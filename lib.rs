# ! [doc = "Peripheral access API for MIK32 microcontrollers (generated using svd2rust v0.35.0 ( ))\n\nYou can find an overview of the generated API [here].\n\nAPI features to be included in the [next]
svd2rust release can be generated by cloning the svd2rust [repository], checking out the above commit, and running `cargo doc --open`.\n\n[here]: https://docs.rs/svd2rust/0.35.0/svd2rust/#peripheral-api\n[next]: https://github.com/rust-embedded/svd2rust/blob/master/CHANGELOG.md#unreleased\n[repository]: https://github.com/rust-embedded/svd2rust"]
# ! [allow (non_camel_case_types)]
# ! [allow (non_snake_case)]
# ! [no_std]
use core :: ops :: Deref ; use core :: marker :: PhantomData ; # [allow (unused_imports)]
use generic :: * ; # [doc = r"Common register and bit access and modify traits"]
pub mod generic { use core :: marker ; # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)"]
pub trait RawReg : Copy + Default + From < bool > + core :: ops :: BitOr < Output = Self > + core :: ops :: BitAnd < Output = Self > + core :: ops :: BitOrAssign + core :: ops :: BitAndAssign + core :: ops :: Not < Output = Self > + core :: ops :: Shl < u8 , Output = Self > { # [doc = " Mask for bits of width `WI`"]
fn mask < const WI : u8 > () -> Self ; # [doc = " Mask for bits of width 1"]
fn one () -> Self ; } macro_rules ! raw_reg { ($ U : ty , $ size : literal , $ mask : ident) => { impl RawReg for $ U { # [inline (always)]
fn mask < const WI : u8 > () -> Self { $ mask ::< WI > () } # [inline (always)]
fn one () -> Self { 1 } } const fn $ mask < const WI : u8 > () -> $ U { <$ U >:: MAX >> ($ size - WI) } impl FieldSpec for $ U { type Ux = $ U ; } } ; } raw_reg ! (u8 , 8 , mask_u8) ; raw_reg ! (u16 , 16 , mask_u16) ; raw_reg ! (u32 , 32 , mask_u32) ; raw_reg ! (u64 , 64 , mask_u64) ; # [doc = " Raw register type"]
pub trait RegisterSpec { # [doc = " Raw register type (`u8`, `u16`, `u32`, ...)."]
type Ux : RawReg ; } # [doc = " Raw field type"]
pub trait FieldSpec : Sized { # [doc = " Raw field type (`u8`, `u16`, `u32`, ...)."]
type Ux : Copy + core :: fmt :: Debug + PartialEq + From < Self > ; } # [doc = " Marker for fields with fixed values"]
pub trait IsEnum : FieldSpec { } # [doc = " Trait implemented by readable registers to enable the `read` method."]
# [doc = ""]
# [doc = " Registers marked with `Writable` can be also be `modify`'ed."]
pub trait Readable : RegisterSpec { } # [doc = " Trait implemented by writeable registers."]
# [doc = ""]
# [doc = " This enables the  `write`, `write_with_zero` and `reset` methods."]
# [doc = ""]
# [doc = " Registers marked with `Readable` can be also be `modify`'ed."]
pub trait Writable : RegisterSpec { # [doc = " Is it safe to write any bits to register"]
type Safety ; # [doc = " Specifies the register bits that are not changed if you pass `1` and are changed if you pass `0`"]
const ZERO_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; # [doc = " Specifies the register bits that are not changed if you pass `0` and are changed if you pass `1`"]
const ONE_TO_MODIFY_FIELDS_BITMAP : Self :: Ux ; } # [doc = " Reset value of the register."]
# [doc = ""]
# [doc = " This value is the initial value for the `write` method. It can also be directly written to the"]
# [doc = " register by using the `reset` method."]
pub trait Resettable : RegisterSpec { # [doc = " Reset value of the register."]
const RESET_VALUE : Self :: Ux ; # [doc = " Reset value of the register."]
# [inline (always)]
fn reset_value () -> Self :: Ux { Self :: RESET_VALUE } } # [doc (hidden)]
pub mod raw { use super :: { marker , BitM , FieldSpec , RegisterSpec , Unsafe , Writable } ; pub struct R < REG : RegisterSpec > { pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct W < REG : RegisterSpec > { # [doc = "Writable bits"]
pub (crate) bits : REG :: Ux , pub (super) _reg : marker :: PhantomData < REG > , } pub struct FieldReader < FI = u8 > where FI : FieldSpec , { pub (crate) bits : FI :: Ux , _reg : marker :: PhantomData < FI > , } impl < FI : FieldSpec > FieldReader < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) const fn new (bits : FI :: Ux) -> Self { Self { bits , _reg : marker :: PhantomData , } } } pub struct BitReader < FI = bool > { pub (crate) bits : bool , _reg : marker :: PhantomData < FI > , } impl < FI > BitReader < FI > { # [doc = " Creates a new instance of the reader."]
# [allow (unused)]
# [inline (always)]
pub (crate) const fn new (bits : bool) -> Self { Self { bits , _reg : marker :: PhantomData , } } } # [must_use = "after creating `FieldWriter` you need to call field value setting method"]
pub struct FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > where REG : Writable + RegisterSpec , FI : FieldSpec , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , Safety) > , } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } } # [must_use = "after creating `BitWriter` you need to call bit setting method"]
pub struct BitWriter < 'a , REG , FI = bool , M = BitM > where REG : Writable + RegisterSpec , bool : From < FI > , { pub (crate) w : & 'a mut W < REG > , pub (crate) o : u8 , _field : marker :: PhantomData < (FI , M) > , } impl < 'a , REG , FI , M > BitWriter < 'a , REG , FI , M > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Creates a new instance of the writer"]
# [allow (unused)]
# [inline (always)]
pub (crate) fn new (w : & 'a mut W < REG > , o : u8) -> Self { Self { w , o , _field : marker :: PhantomData , } } } } # [doc = " Register reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of registers. Also used as a closure argument in the `modify`"]
# [doc = " method."]
pub type R < REG > = raw :: R < REG > ; impl < REG : RegisterSpec > R < REG > { # [doc = " Reads raw bits from register."]
# [inline (always)]
pub const fn bits (& self) -> REG :: Ux { self . bits } } impl < REG : RegisterSpec , FI > PartialEq < FI > for R < REG > where REG :: Ux : PartialEq , FI : Copy , REG :: Ux : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& REG :: Ux :: from (* other)) } } # [doc = " Register writer."]
# [doc = ""]
# [doc = " Used as an argument to the closures in the `write` and `modify` methods of the register."]
pub type W < REG > = raw :: W < REG > ; impl < REG : Writable > W < REG > { # [doc = " Writes raw bits to the register."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } impl < REG > W < REG > where REG : Writable < Safety = Safe > { # [doc = " Writes raw bits to the register."]
# [inline (always)]
pub fn set (& mut self , bits : REG :: Ux) -> & mut Self { self . bits = bits ; self } } # [doc = " Field reader."]
# [doc = ""]
# [doc = " Result of the `read` methods of fields."]
pub type FieldReader < FI = u8 > = raw :: FieldReader < FI > ; # [doc = " Bit-wise field reader"]
pub type BitReader < FI = bool > = raw :: BitReader < FI > ; impl < FI : FieldSpec > FieldReader < FI > { # [doc = " Reads raw bits from field."]
# [inline (always)]
pub const fn bits (& self) -> FI :: Ux { self . bits } } impl < FI : FieldSpec > core :: fmt :: Debug for FieldReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } } impl < FI > PartialEq < FI > for FieldReader < FI > where FI : FieldSpec + Copy , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& FI :: Ux :: from (* other)) } } impl < FI > PartialEq < FI > for BitReader < FI > where FI : Copy , bool : From < FI > , { # [inline (always)]
fn eq (& self , other : & FI) -> bool { self . bits . eq (& bool :: from (* other)) } } impl < FI > BitReader < FI > { # [doc = " Value of the field as raw bits."]
# [inline (always)]
pub const fn bit (& self) -> bool { self . bits } # [doc = " Returns `true` if the bit is clear (0)."]
# [inline (always)]
pub const fn bit_is_clear (& self) -> bool { ! self . bit () } # [doc = " Returns `true` if the bit is set (1)."]
# [inline (always)]
pub const fn bit_is_set (& self) -> bool { self . bit () } } impl < FI > core :: fmt :: Debug for BitReader < FI > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . bits , f) } } # [doc = " Marker for register/field writers which can take any value of specified width"]
pub struct Safe ; # [doc = " You should check that value is allowed to pass to register/field writer marked with this"]
pub struct Unsafe ; # [doc = " Marker for field writers are safe to write in specified inclusive range"]
pub struct Range < const MIN : u64 , const MAX : u64 > ; # [doc = " Marker for field writers are safe to write in specified inclusive range"]
pub struct RangeFrom < const MIN : u64 > ; # [doc = " Marker for field writers are safe to write in specified inclusive range"]
pub struct RangeTo < const MAX : u64 > ; # [doc = " Write field Proxy"]
pub type FieldWriter < 'a , REG , const WI : u8 , FI = u8 , Safety = Unsafe > = raw :: FieldWriter < 'a , REG , WI , FI , Safety > ; impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , { # [doc = " Field width"]
pub const WIDTH : u8 = WI ; # [doc = " Field width"]
# [inline (always)]
pub const fn width (& self) -> u8 { WI } # [doc = " Field offset"]
# [inline (always)]
pub const fn offset (& self) -> u8 { self . o } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Passing incorrect value can cause undefined behaviour. See reference manual"]
# [inline (always)]
pub unsafe fn bits (self , value : FI :: Ux) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: mask :: < WI > () << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: mask :: < WI > ()) << self . o ; self . w } } impl < 'a , REG , const WI : u8 , FI > FieldWriter < 'a , REG , WI , FI , Safe > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , Range < MIN , MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN && value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MIN : u64 > FieldWriter < 'a , REG , WI , FI , RangeFrom < MIN > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value >= MIN) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , const MAX : u64 > FieldWriter < 'a , REG , WI , FI , RangeTo < MAX > > where REG : Writable + RegisterSpec , FI : FieldSpec , REG :: Ux : From < FI :: Ux > , u64 : From < FI :: Ux > , { # [doc = " Writes raw bits to the field"]
# [inline (always)]
pub fn set (self , value : FI :: Ux) -> & 'a mut W < REG > { { let value = u64 :: from (value) ; assert ! (value <= MAX) ; } unsafe { self . bits (value) } } } impl < 'a , REG , const WI : u8 , FI , Safety > FieldWriter < 'a , REG , WI , FI , Safety > where REG : Writable + RegisterSpec , FI : IsEnum , REG :: Ux : From < FI :: Ux > , { # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> & 'a mut W < REG > { unsafe { self . bits (FI :: Ux :: from (variant)) } } } macro_rules ! bit_proxy { ($ writer : ident , $ mwv : ident) => { # [doc (hidden)]
pub struct $ mwv ; # [doc = " Bit-wise write field proxy"]
pub type $ writer <'a , REG , FI = bool > = raw :: BitWriter <'a , REG , FI , $ mwv >; impl <'a , REG , FI > $ writer <'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI >, { # [doc = " Field width"]
pub const WIDTH : u8 = 1 ; # [doc = " Field width"]
# [inline (always)]
pub const fn width (& self) -> u8 { Self :: WIDTH } # [doc = " Field offset"]
# [inline (always)]
pub const fn offset (& self) -> u8 { self . o } # [doc = " Writes bit to the field"]
# [inline (always)]
pub fn bit (self , value : bool) -> &'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w . bits |= (REG :: Ux :: from (value) & REG :: Ux :: one ()) << self . o ; self . w } # [doc = " Writes `variant` to the field"]
# [inline (always)]
pub fn variant (self , variant : FI) -> &'a mut W < REG > { self . bit (bool :: from (variant)) } } } ; } bit_proxy ! (BitWriter , BitM) ; bit_proxy ! (BitWriter1S , Bit1S) ; bit_proxy ! (BitWriter0C , Bit0C) ; bit_proxy ! (BitWriter1C , Bit1C) ; bit_proxy ! (BitWriter0S , Bit0S) ; bit_proxy ! (BitWriter1T , Bit1T) ; bit_proxy ! (BitWriter0T , Bit0T) ; impl < 'a , REG , FI > BitWriter < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Sets the field bit"]
# [inline (always)]
pub fn set_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = " Clears the field bit"]
# [inline (always)]
pub fn clear_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1C < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Clears the field bit by passing one"]
# [inline (always)]
pub fn clear_bit_by_one (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0S < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Sets the field bit by passing zero"]
# [inline (always)]
pub fn set_bit_by_zero (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } impl < 'a , REG , FI > BitWriter1T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing one"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits |= REG :: Ux :: one () << self . o ; self . w } } impl < 'a , REG , FI > BitWriter0T < 'a , REG , FI > where REG : Writable + RegisterSpec , bool : From < FI > , { # [doc = "Toggle the field bit by passing zero"]
# [inline (always)]
pub fn toggle_bit (self) -> & 'a mut W < REG > { self . w . bits &= ! (REG :: Ux :: one () << self . o) ; self . w } } # [doc = " This structure provides volatile access to registers."]
# [repr (transparent)]
pub struct Reg < REG : RegisterSpec > { register : vcell :: VolatileCell < REG :: Ux > , _marker : marker :: PhantomData < REG > , } unsafe impl < REG : RegisterSpec > Send for Reg < REG > where REG :: Ux : Send { } impl < REG : RegisterSpec > Reg < REG > { # [doc = " Returns the underlying memory address of register."]
# [doc = ""]
# [doc = " ```ignore"]
# [doc = " let reg_ptr = periph.reg.as_ptr();"]
# [doc = " ```"]
# [inline (always)]
pub fn as_ptr (& self) -> * mut REG :: Ux { self . register . as_ptr () } } impl < REG : Readable > Reg < REG > { # [doc = " Reads the contents of a `Readable` register."]
# [doc = ""]
# [doc = " You can read the raw contents of a register by using `bits`:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.read().bits();"]
# [doc = " ```"]
# [doc = " or get the content of a particular field of a register:"]
# [doc = " ```ignore"]
# [doc = " let reader = periph.reg.read();"]
# [doc = " let bits = reader.field1().bits();"]
# [doc = " let flag = reader.field2().bit_is_set();"]
# [doc = " ```"]
# [inline (always)]
pub fn read (& self) -> R < REG > { R { bits : self . register . get () , _reg : marker :: PhantomData , } } } impl < REG : Resettable + Writable > Reg < REG > { # [doc = " Writes the reset value to `Writable` register."]
# [doc = ""]
# [doc = " Resets the register to its initial state."]
# [inline (always)]
pub fn reset (& self) { self . register . set (REG :: RESET_VALUE) } # [doc = " Writes bits to a `Writable` register."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| unsafe { w.bits(rawbits) });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [inline (always)]
pub fn write < F > (& self , f : F) -> REG :: Ux where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { let value = f (& mut W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , }) . bits ; self . register . set (value) ; value } # [doc = " Writes bits to a `Writable` register and produce a value."]
# [doc = ""]
# [doc = " You can write raw bits into a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write_and(|w| unsafe { w.bits(rawbits); });"]
# [doc = " ```"]
# [doc = " or write only the fields you need:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write_and(|w| {"]
# [doc = "     w.field1().bits(newfield1bits)"]
# [doc = "         .field2().set_bit()"]
# [doc = "         .field3().variant(VARIANT);"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.write_and(|w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT);"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " In the latter case, other fields will be set to their reset value."]
# [doc = ""]
# [doc = " Values can be returned from the closure:"]
# [doc = " ```ignore"]
# [doc = " let state = periph.reg.write_and(|w| State::set(w.field1()));"]
# [doc = " ```"]
# [inline (always)]
pub fn from_write < F , T > (& self , f : F) -> T where F : FnOnce (& mut W < REG >) -> T , { let mut writer = W { bits : REG :: RESET_VALUE & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ; let result = f (& mut writer) ; self . register . set (writer . bits) ; result } } impl < REG : Writable > Reg < REG > { # [doc = " Writes 0 to a `Writable` register."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn write_with_zero < F > (& self , f : F) -> REG :: Ux where F : FnOnce (& mut W < REG >) -> & mut W < REG > , { let value = f (& mut W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , }) . bits ; self . register . set (value) ; value } # [doc = " Writes 0 to a `Writable` register and produces a value."]
# [doc = ""]
# [doc = " Similar to `write`, but unused bits will contain 0."]
# [doc = ""]
# [doc = " # Safety"]
# [doc = ""]
# [doc = " Unsafe to use with registers which don't allow to write 0."]
# [inline (always)]
pub unsafe fn from_write_with_zero < F , T > (& self , f : F) -> T where F : FnOnce (& mut W < REG >) -> T , { let mut writer = W { bits : REG :: Ux :: default () , _reg : marker :: PhantomData , } ; let result = f (& mut writer) ; self . register . set (writer . bits) ; result } } impl < REG : Readable + Writable > Reg < REG > { # [doc = " Modifies the contents of the register by reading and then writing it."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|r, w| unsafe { w.bits("]
# [doc = "    r.bits() | 3"]
# [doc = " ) });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| w"]
# [doc = "     .field1().bits(newfield1bits)"]
# [doc = "     .field2().set_bit()"]
# [doc = "     .field3().variant(VARIANT)"]
# [doc = " );"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT)"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn modify < F > (& self , f : F) -> REG :: Ux where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> & 'w mut W < REG > , { let bits = self . register . get () ; let value = f (& R { bits , _reg : marker :: PhantomData , } , & mut W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ,) . bits ; self . register . set (value) ; value } # [doc = " Modifies the contents of the register by reading and then writing it"]
# [doc = " and produces a value."]
# [doc = ""]
# [doc = " E.g. to do a read-modify-write sequence to change parts of a register:"]
# [doc = " ```ignore"]
# [doc = " let bits = periph.reg.modify(|r, w| {"]
# [doc = "     let new_bits = r.bits() | 3;"]
# [doc = "     unsafe {"]
# [doc = "         w.bits(new_bits);"]
# [doc = "     }"]
# [doc = ""]
# [doc = "     new_bits"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " or"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits)"]
# [doc = "         .field2().set_bit()"]
# [doc = "         .field3().variant(VARIANT);"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " or an alternative way of saying the same:"]
# [doc = " ```ignore"]
# [doc = " periph.reg.modify(|_, w| {"]
# [doc = "     w.field1().bits(newfield1bits);"]
# [doc = "     w.field2().set_bit();"]
# [doc = "     w.field3().variant(VARIANT);"]
# [doc = " });"]
# [doc = " ```"]
# [doc = " Other fields will have the value they had before the call to `modify`."]
# [inline (always)]
pub fn from_modify < F , T > (& self , f : F) -> T where for < 'w > F : FnOnce (& R < REG > , & 'w mut W < REG >) -> T , { let bits = self . register . get () ; let mut writer = W { bits : bits & ! REG :: ONE_TO_MODIFY_FIELDS_BITMAP | REG :: ZERO_TO_MODIFY_FIELDS_BITMAP , _reg : marker :: PhantomData , } ; let result = f (& R { bits , _reg : marker :: PhantomData , } , & mut writer ,) ; self . register . set (writer . bits) ; result } } impl < REG : Readable > core :: fmt :: Debug for crate :: generic :: Reg < REG > where R < REG > : core :: fmt :: Debug , { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { core :: fmt :: Debug :: fmt (& self . read () , f) } } } # [cfg (feature = "rt")]
extern "C" { } # [doc (hidden)]
# [repr (C)]
pub union Vector { pub _handler : unsafe extern "C" fn () , pub _reserved : usize , } # [cfg (feature = "rt")]
# [doc (hidden)]
# [no_mangle]
pub static __EXTERNAL_INTERRUPTS : [Vector ; 0]
= []
; # [doc = "Прямой доступ к памяти"]
pub struct Dma { _marker : PhantomData < * const () > } unsafe impl Send for Dma { } impl Dma { # [doc = r"Pointer to the register block"]
pub const PTR : * const dma :: RegisterBlock = 0x0004_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const dma :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Dma { type Target = dma :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Dma { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dma") . finish () } } # [doc = "Прямой доступ к памяти"]
pub mod dma { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { ch1_dst : Ch1Dst , ch1_src : Ch1Src , ch1_len : Ch1Len , ch1_cfg : Ch1Cfg , ch2_dst : Ch2Dst , ch2_src : Ch2Src , ch2_len : Ch2Len , ch2_cfg : Ch2Cfg , ch3_dst : Ch3Dst , ch3_src : Ch3Src , ch3_len : Ch3Len , ch3_cfg : Ch3Cfg , ch4_dst : Ch4Dst , ch4_src : Ch4Src , ch4_len : Ch4Len , ch4_cfg : Ch4Cfg , _reserved_16_config : [u8 ; 0x04]
, } impl RegisterBlock { # [doc = "0x00 - Регистр адреса назначения канала 1"]
# [inline (always)]
pub const fn ch1_dst (& self) -> & Ch1Dst { & self . ch1_dst } # [doc = "0x04 - Регистр адреса источника канала 1"]
# [inline (always)]
pub const fn ch1_src (& self) -> & Ch1Src { & self . ch1_src } # [doc = "0x08 - Регистр размера передаваемых данных канала 1"]
# [inline (always)]
pub const fn ch1_len (& self) -> & Ch1Len { & self . ch1_len } # [doc = "0x0c - Регистр управления и конфигурации канала 1"]
# [inline (always)]
pub const fn ch1_cfg (& self) -> & Ch1Cfg { & self . ch1_cfg } # [doc = "0x10 - Регистр адреса назначения канала 2"]
# [inline (always)]
pub const fn ch2_dst (& self) -> & Ch2Dst { & self . ch2_dst } # [doc = "0x14 - Регистр адреса источника канала 2"]
# [inline (always)]
pub const fn ch2_src (& self) -> & Ch2Src { & self . ch2_src } # [doc = "0x18 - Регистр размера передаваемых данных канала 2"]
# [inline (always)]
pub const fn ch2_len (& self) -> & Ch2Len { & self . ch2_len } # [doc = "0x1c - Регистр управления и конфигурации канала 2"]
# [inline (always)]
pub const fn ch2_cfg (& self) -> & Ch2Cfg { & self . ch2_cfg } # [doc = "0x20 - Регистр адреса назначения канала 3"]
# [inline (always)]
pub const fn ch3_dst (& self) -> & Ch3Dst { & self . ch3_dst } # [doc = "0x24 - Регистр адреса источника канала 3"]
# [inline (always)]
pub const fn ch3_src (& self) -> & Ch3Src { & self . ch3_src } # [doc = "0x28 - Регистр размера передаваемых данных канала 3"]
# [inline (always)]
pub const fn ch3_len (& self) -> & Ch3Len { & self . ch3_len } # [doc = "0x2c - Регистр управления и конфигурации канала 3"]
# [inline (always)]
pub const fn ch3_cfg (& self) -> & Ch3Cfg { & self . ch3_cfg } # [doc = "0x30 - Регистр адреса назначения канала 4"]
# [inline (always)]
pub const fn ch4_dst (& self) -> & Ch4Dst { & self . ch4_dst } # [doc = "0x34 - Регистр адреса источника канала 4"]
# [inline (always)]
pub const fn ch4_src (& self) -> & Ch4Src { & self . ch4_src } # [doc = "0x38 - Регистр размера передаваемых данных канала 4"]
# [inline (always)]
pub const fn ch4_len (& self) -> & Ch4Len { & self . ch4_len } # [doc = "0x3c - Регистр управления и конфигурации канала 4"]
# [inline (always)]
pub const fn ch4_cfg (& self) -> & Ch4Cfg { & self . ch4_cfg } # [doc = "0x40 - Регистр прерываний и настройки контроллера"]
# [inline (always)]
pub const fn status (& self) -> & Status { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (64) . cast () } } # [doc = "0x40 - Регистр прерываний и настройки контроллера"]
# [inline (always)]
pub const fn config (& self) -> & Config { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (64) . cast () } } } # [doc = "CH1_DST (rw) register accessor: Регистр адреса назначения канала 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_dst::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_dst::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch1_dst`]
module"]
# [doc (alias = "CH1_DST")]
pub type Ch1Dst = crate :: Reg < ch1_dst :: Ch1DstSpec > ; # [doc = "Регистр адреса назначения канала 1"]
pub mod ch1_dst { # [doc = "Register `CH1_DST` reader"]
pub type R = crate :: R < Ch1DstSpec > ; # [doc = "Register `CH1_DST` writer"]
pub type W = crate :: W < Ch1DstSpec > ; # [doc = "Field `Dst` reader - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
pub type DstR = crate :: FieldReader < u32 > ; # [doc = "Field `Dst` writer - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
pub type DstW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
# [inline (always)]
pub fn dst (& self) -> DstR { DstR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
# [inline (always)]
pub fn dst (& mut self) -> DstW < Ch1DstSpec > { DstW :: new (self , 0) } } # [doc = "Регистр адреса назначения канала 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_dst::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_dst::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch1DstSpec ; impl crate :: RegisterSpec for Ch1DstSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch1_dst::R`](R) reader structure"]
impl crate :: Readable for Ch1DstSpec { } # [doc = "`write(|w| ..)` method takes [`ch1_dst::W`](W) writer structure"]
impl crate :: Writable for Ch1DstSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH1_DST to value 0"]
impl crate :: Resettable for Ch1DstSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH1_SRC (rw) register accessor: Регистр адреса источника канала 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_src::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_src::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch1_src`]
module"]
# [doc (alias = "CH1_SRC")]
pub type Ch1Src = crate :: Reg < ch1_src :: Ch1SrcSpec > ; # [doc = "Регистр адреса источника канала 1"]
pub mod ch1_src { # [doc = "Register `CH1_SRC` reader"]
pub type R = crate :: R < Ch1SrcSpec > ; # [doc = "Register `CH1_SRC` writer"]
pub type W = crate :: W < Ch1SrcSpec > ; # [doc = "Field `Src` reader - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
pub type SrcR = crate :: FieldReader < u32 > ; # [doc = "Field `Src` writer - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
pub type SrcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
# [inline (always)]
pub fn src (& self) -> SrcR { SrcR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
# [inline (always)]
pub fn src (& mut self) -> SrcW < Ch1SrcSpec > { SrcW :: new (self , 0) } } # [doc = "Регистр адреса источника канала 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_src::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_src::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch1SrcSpec ; impl crate :: RegisterSpec for Ch1SrcSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch1_src::R`](R) reader structure"]
impl crate :: Readable for Ch1SrcSpec { } # [doc = "`write(|w| ..)` method takes [`ch1_src::W`](W) writer structure"]
impl crate :: Writable for Ch1SrcSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH1_SRC to value 0"]
impl crate :: Resettable for Ch1SrcSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH1_LEN (rw) register accessor: Регистр размера передаваемых данных канала 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch1_len`]
module"]
# [doc (alias = "CH1_LEN")]
pub type Ch1Len = crate :: Reg < ch1_len :: Ch1LenSpec > ; # [doc = "Регистр размера передаваемых данных канала 1"]
pub mod ch1_len { # [doc = "Register `CH1_LEN` reader"]
pub type R = crate :: R < Ch1LenSpec > ; # [doc = "Register `CH1_LEN` writer"]
pub type W = crate :: W < Ch1LenSpec > ; # [doc = "Field `Data_Len` reader - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
pub type DataLenR = crate :: FieldReader < u32 > ; # [doc = "Field `Data_Len` writer - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
pub type DataLenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
# [inline (always)]
pub fn data_len (& self) -> DataLenR { DataLenR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
# [inline (always)]
pub fn data_len (& mut self) -> DataLenW < Ch1LenSpec > { DataLenW :: new (self , 0) } } # [doc = "Регистр размера передаваемых данных канала 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch1LenSpec ; impl crate :: RegisterSpec for Ch1LenSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch1_len::R`](R) reader structure"]
impl crate :: Readable for Ch1LenSpec { } # [doc = "`write(|w| ..)` method takes [`ch1_len::W`](W) writer structure"]
impl crate :: Writable for Ch1LenSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH1_LEN to value 0"]
impl crate :: Resettable for Ch1LenSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH1_CFG (rw) register accessor: Регистр управления и конфигурации канала 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch1_cfg`]
module"]
# [doc (alias = "CH1_CFG")]
pub type Ch1Cfg = crate :: Reg < ch1_cfg :: Ch1CfgSpec > ; # [doc = "Регистр управления и конфигурации канала 1"]
pub mod ch1_cfg { # [doc = "Register `CH1_CFG` reader"]
pub type R = crate :: R < Ch1CfgSpec > ; # [doc = "Register `CH1_CFG` writer"]
pub type W = crate :: W < Ch1CfgSpec > ; # [doc = "Разрешение работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Enable { # [doc = "0: Принудительная остановка"]
Stop = 0 , # [doc = "1: Инициализация работы канала"]
Start = 1 , } impl From < Enable > for bool { # [inline (always)]
fn from (variant : Enable) -> Self { variant as u8 != 0 } } # [doc = "Field `ENABLE` reader - Разрешение работы канала"]
pub type EnableR = crate :: BitReader < Enable > ; impl EnableR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Enable { match self . bits { false => Enable :: Stop , true => Enable :: Start , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == Enable :: Stop } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_start (& self) -> bool { * self == Enable :: Start } } # [doc = "Field `ENABLE` writer - Разрешение работы канала"]
pub type EnableW < 'a , REG > = crate :: BitWriter < 'a , REG , Enable > ; impl < 'a , REG > EnableW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn stop (self) -> & 'a mut crate :: W < REG > { self . variant (Enable :: Stop) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn start (self) -> & 'a mut crate :: W < REG > { self . variant (Enable :: Start) } } # [doc = "Приоритет канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Prior { # [doc = "0: Принудительная остановка"]
Low = 0 , # [doc = "1: Инициализация работы канала"]
Medium = 1 , # [doc = "2: Инициализация работы канала"]
High = 2 , # [doc = "3: Инициализация работы канала"]
VeryHigh = 3 , } impl From < Prior > for u8 { # [inline (always)]
fn from (variant : Prior) -> Self { variant as _ } } impl crate :: FieldSpec for Prior { type Ux = u8 ; } impl crate :: IsEnum for Prior { } # [doc = "Field `PRIOR` reader - Приоритет канала"]
pub type PriorR = crate :: FieldReader < Prior > ; impl PriorR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Prior { match self . bits { 0 => Prior :: Low , 1 => Prior :: Medium , 2 => Prior :: High , 3 => Prior :: VeryHigh , _ => unreachable ! () , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == Prior :: Low } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_medium (& self) -> bool { * self == Prior :: Medium } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == Prior :: High } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_very_high (& self) -> bool { * self == Prior :: VeryHigh } } # [doc = "Field `PRIOR` writer - Приоритет канала"]
pub type PriorW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Prior , crate :: Safe > ; impl < 'a , REG > PriorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn low (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: Low) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn medium (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: Medium) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn high (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: High) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn very_high (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: VeryHigh) } } # [doc = "Режим адреса источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadMode { # [doc = "0: Принудительная остановка"]
Periphery = 0 , # [doc = "1: Инициализация работы канала"]
Memory = 1 , } impl From < ReadMode > for bool { # [inline (always)]
fn from (variant : ReadMode) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_MODE` reader - Режим адреса источника"]
pub type ReadModeR = crate :: BitReader < ReadMode > ; impl ReadModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadMode { match self . bits { false => ReadMode :: Periphery , true => ReadMode :: Memory , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_periphery (& self) -> bool { * self == ReadMode :: Periphery } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_memory (& self) -> bool { * self == ReadMode :: Memory } } # [doc = "Field `READ_MODE` writer - Режим адреса источника"]
pub type ReadModeW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadMode > ; impl < 'a , REG > ReadModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn periphery (self) -> & 'a mut crate :: W < REG > { self . variant (ReadMode :: Periphery) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn memory (self) -> & 'a mut crate :: W < REG > { self . variant (ReadMode :: Memory) } } # [doc = "Режим адреса назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteMode { # [doc = "0: Принудительная остановка"]
Periphery = 0 , # [doc = "1: Инициализация работы канала"]
Memory = 1 , } impl From < WriteMode > for bool { # [inline (always)]
fn from (variant : WriteMode) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_MODE` reader - Режим адреса назначения"]
pub type WriteModeR = crate :: BitReader < WriteMode > ; impl WriteModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteMode { match self . bits { false => WriteMode :: Periphery , true => WriteMode :: Memory , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_periphery (& self) -> bool { * self == WriteMode :: Periphery } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_memory (& self) -> bool { * self == WriteMode :: Memory } } # [doc = "Field `WRITE_MODE` writer - Режим адреса назначения"]
pub type WriteModeW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteMode > ; impl < 'a , REG > WriteModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn periphery (self) -> & 'a mut crate :: W < REG > { self . variant (WriteMode :: Periphery) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn memory (self) -> & 'a mut crate :: W < REG > { self . variant (WriteMode :: Memory) } } # [doc = "Инкремент адреса источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadIncrement { # [doc = "0: Нет инкремента"]
NoIncrement = 0 , # [doc = "1: Есть инкремент"]
Increment = 1 , } impl From < ReadIncrement > for bool { # [inline (always)]
fn from (variant : ReadIncrement) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_INCREMENT` reader - Инкремент адреса источника"]
pub type ReadIncrementR = crate :: BitReader < ReadIncrement > ; impl ReadIncrementR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadIncrement { match self . bits { false => ReadIncrement :: NoIncrement , true => ReadIncrement :: Increment , } } # [doc = "Нет инкремента"]
# [inline (always)]
pub fn is_no_increment (& self) -> bool { * self == ReadIncrement :: NoIncrement } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn is_increment (& self) -> bool { * self == ReadIncrement :: Increment } } # [doc = "Field `READ_INCREMENT` writer - Инкремент адреса источника"]
pub type ReadIncrementW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadIncrement > ; impl < 'a , REG > ReadIncrementW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Нет инкремента"]
# [inline (always)]
pub fn no_increment (self) -> & 'a mut crate :: W < REG > { self . variant (ReadIncrement :: NoIncrement) } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn increment (self) -> & 'a mut crate :: W < REG > { self . variant (ReadIncrement :: Increment) } } # [doc = "Инкремент адреса назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteIncrement { # [doc = "0: Нет инкремента"]
NoIncrement = 0 , # [doc = "1: Есть инкремент"]
Increment = 1 , } impl From < WriteIncrement > for bool { # [inline (always)]
fn from (variant : WriteIncrement) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_INCREMENT` reader - Инкремент адреса назначения"]
pub type WriteIncrementR = crate :: BitReader < WriteIncrement > ; impl WriteIncrementR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteIncrement { match self . bits { false => WriteIncrement :: NoIncrement , true => WriteIncrement :: Increment , } } # [doc = "Нет инкремента"]
# [inline (always)]
pub fn is_no_increment (& self) -> bool { * self == WriteIncrement :: NoIncrement } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn is_increment (& self) -> bool { * self == WriteIncrement :: Increment } } # [doc = "Field `WRITE_INCREMENT` writer - Инкремент адреса назначения"]
pub type WriteIncrementW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteIncrement > ; impl < 'a , REG > WriteIncrementW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Нет инкремента"]
# [inline (always)]
pub fn no_increment (self) -> & 'a mut crate :: W < REG > { self . variant (WriteIncrement :: NoIncrement) } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn increment (self) -> & 'a mut crate :: W < REG > { self . variant (WriteIncrement :: Increment) } } # [doc = "Разрядность адреса источника. Должно быть кратно data_len\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ReadSize { # [doc = "0: Байт"]
Byte = 0 , # [doc = "1: Полуслово"]
_2byte = 1 , # [doc = "2: Слово"]
_4byte = 2 , } impl From < ReadSize > for u8 { # [inline (always)]
fn from (variant : ReadSize) -> Self { variant as _ } } impl crate :: FieldSpec for ReadSize { type Ux = u8 ; } impl crate :: IsEnum for ReadSize { } # [doc = "Field `READ_SIZE` reader - Разрядность адреса источника. Должно быть кратно data_len"]
pub type ReadSizeR = crate :: FieldReader < ReadSize > ; impl ReadSizeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < ReadSize > { match self . bits { 0 => Some (ReadSize :: Byte) , 1 => Some (ReadSize :: _2byte) , 2 => Some (ReadSize :: _4byte) , _ => None , } } # [doc = "Байт"]
# [inline (always)]
pub fn is_byte (& self) -> bool { * self == ReadSize :: Byte } # [doc = "Полуслово"]
# [inline (always)]
pub fn is_2byte (& self) -> bool { * self == ReadSize :: _2byte } # [doc = "Слово"]
# [inline (always)]
pub fn is_4byte (& self) -> bool { * self == ReadSize :: _4byte } } # [doc = "Field `READ_SIZE` writer - Разрядность адреса источника. Должно быть кратно data_len"]
pub type ReadSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , ReadSize > ; impl < 'a , REG > ReadSizeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Байт"]
# [inline (always)]
pub fn byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: Byte) } # [doc = "Полуслово"]
# [inline (always)]
pub fn _2byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: _2byte) } # [doc = "Слово"]
# [inline (always)]
pub fn _4byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: _4byte) } } # [doc = "Разрядность адреса назначения. Должно быть кратно LEN\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WriteSize { # [doc = "0: Байт"]
Byte = 0 , # [doc = "1: Полуслово"]
_2byte = 1 , # [doc = "2: Слово"]
_4byte = 2 , } impl From < WriteSize > for u8 { # [inline (always)]
fn from (variant : WriteSize) -> Self { variant as _ } } impl crate :: FieldSpec for WriteSize { type Ux = u8 ; } impl crate :: IsEnum for WriteSize { } # [doc = "Field `WRITE_SIZE` reader - Разрядность адреса назначения. Должно быть кратно LEN"]
pub type WriteSizeR = crate :: FieldReader < WriteSize > ; impl WriteSizeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < WriteSize > { match self . bits { 0 => Some (WriteSize :: Byte) , 1 => Some (WriteSize :: _2byte) , 2 => Some (WriteSize :: _4byte) , _ => None , } } # [doc = "Байт"]
# [inline (always)]
pub fn is_byte (& self) -> bool { * self == WriteSize :: Byte } # [doc = "Полуслово"]
# [inline (always)]
pub fn is_2byte (& self) -> bool { * self == WriteSize :: _2byte } # [doc = "Слово"]
# [inline (always)]
pub fn is_4byte (& self) -> bool { * self == WriteSize :: _4byte } } # [doc = "Field `WRITE_SIZE` writer - Разрядность адреса назначения. Должно быть кратно LEN"]
pub type WriteSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , WriteSize > ; impl < 'a , REG > WriteSizeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Байт"]
# [inline (always)]
pub fn byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: Byte) } # [doc = "Полуслово"]
# [inline (always)]
pub fn _2byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: _2byte) } # [doc = "Слово"]
# [inline (always)]
pub fn _4byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: _4byte) } } # [doc = "Field `READ_BURST_SIZE` reader - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
pub type ReadBurstSizeR = crate :: FieldReader ; # [doc = "Field `READ_BURST_SIZE` writer - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
pub type ReadBurstSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `WRITE_BURST_SIZE` reader - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
pub type WriteBurstSizeR = crate :: FieldReader ; # [doc = "Field `WRITE_BURST_SIZE` writer - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
pub type WriteBurstSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Выбор периферийной линии источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ReadRequest { # [doc = "0: Линия запросов от USART_0"]
Usart0 = 0 , # [doc = "1: Линия запросов от USART_1"]
Usart1 = 1 , # [doc = "2: Линия запросов от крипто-блока"]
Crypto = 2 , # [doc = "3: Линия запросов от SPI_0"]
Spi0 = 3 , # [doc = "4: Линия запросов от SPI_1"]
Spi1 = 4 , # [doc = "5: Линия запросов от I2C_0"]
I2c0 = 5 , # [doc = "6: Линия запросов от I2C_1"]
I2c1 = 6 , # [doc = "7: Линия запросов от SPIFI"]
Spifi = 7 , # [doc = "8: Линия запросов от Timer32_1"]
Timer32_1 = 8 , # [doc = "9: Линия запросов от Timer32_2"]
Timer32_2 = 9 , # [doc = "10: Линия запросов от DAC0"]
Dac0 = 10 , # [doc = "11: Линия запросов от DAC1"]
Dac1 = 11 , # [doc = "12: Линия запросов от Timer32_0"]
Timer32_0 = 12 , } impl From < ReadRequest > for u8 { # [inline (always)]
fn from (variant : ReadRequest) -> Self { variant as _ } } impl crate :: FieldSpec for ReadRequest { type Ux = u8 ; } impl crate :: IsEnum for ReadRequest { } # [doc = "Field `READ_REQUEST` reader - Выбор периферийной линии источника"]
pub type ReadRequestR = crate :: FieldReader < ReadRequest > ; impl ReadRequestR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < ReadRequest > { match self . bits { 0 => Some (ReadRequest :: Usart0) , 1 => Some (ReadRequest :: Usart1) , 2 => Some (ReadRequest :: Crypto) , 3 => Some (ReadRequest :: Spi0) , 4 => Some (ReadRequest :: Spi1) , 5 => Some (ReadRequest :: I2c0) , 6 => Some (ReadRequest :: I2c1) , 7 => Some (ReadRequest :: Spifi) , 8 => Some (ReadRequest :: Timer32_1) , 9 => Some (ReadRequest :: Timer32_2) , 10 => Some (ReadRequest :: Dac0) , 11 => Some (ReadRequest :: Dac1) , 12 => Some (ReadRequest :: Timer32_0) , _ => None , } } # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn is_usart_0 (& self) -> bool { * self == ReadRequest :: Usart0 } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn is_usart_1 (& self) -> bool { * self == ReadRequest :: Usart1 } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn is_crypto (& self) -> bool { * self == ReadRequest :: Crypto } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn is_spi_0 (& self) -> bool { * self == ReadRequest :: Spi0 } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn is_spi_1 (& self) -> bool { * self == ReadRequest :: Spi1 } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn is_i2c_0 (& self) -> bool { * self == ReadRequest :: I2c0 } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn is_i2c_1 (& self) -> bool { * self == ReadRequest :: I2c1 } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn is_spifi (& self) -> bool { * self == ReadRequest :: Spifi } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn is_timer32_1 (& self) -> bool { * self == ReadRequest :: Timer32_1 } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn is_timer32_2 (& self) -> bool { * self == ReadRequest :: Timer32_2 } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn is_dac0 (& self) -> bool { * self == ReadRequest :: Dac0 } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn is_dac1 (& self) -> bool { * self == ReadRequest :: Dac1 } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn is_timer32_0 (& self) -> bool { * self == ReadRequest :: Timer32_0 } } # [doc = "Field `READ_REQUEST` writer - Выбор периферийной линии источника"]
pub type ReadRequestW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , ReadRequest > ; impl < 'a , REG > ReadRequestW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn usart_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Usart0) } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn usart_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Usart1) } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn crypto (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Crypto) } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn spi_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spi0) } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn spi_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spi1) } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn i2c_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: I2c0) } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn i2c_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: I2c1) } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn spifi (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spifi) } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn timer32_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_1) } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn timer32_2 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_2) } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn dac0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Dac0) } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn dac1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Dac1) } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn timer32_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_0) } } # [doc = "Выбор периферийной линии назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WriteRequest { # [doc = "0: Линия запросов от USART_0"]
Usart0 = 0 , # [doc = "1: Линия запросов от USART_1"]
Usart1 = 1 , # [doc = "2: Линия запросов от крипто-блока"]
Crypto = 2 , # [doc = "3: Линия запросов от SPI_0"]
Spi0 = 3 , # [doc = "4: Линия запросов от SPI_1"]
Spi1 = 4 , # [doc = "5: Линия запросов от I2C_0"]
I2c0 = 5 , # [doc = "6: Линия запросов от I2C_1"]
I2c1 = 6 , # [doc = "7: Линия запросов от SPIFI"]
Spifi = 7 , # [doc = "8: Линия запросов от Timer32_1"]
Timer32_1 = 8 , # [doc = "9: Линия запросов от Timer32_2"]
Timer32_2 = 9 , # [doc = "10: Линия запросов от DAC0"]
Dac0 = 10 , # [doc = "11: Линия запросов от DAC1"]
Dac1 = 11 , # [doc = "12: Линия запросов от Timer32_0"]
Timer32_0 = 12 , } impl From < WriteRequest > for u8 { # [inline (always)]
fn from (variant : WriteRequest) -> Self { variant as _ } } impl crate :: FieldSpec for WriteRequest { type Ux = u8 ; } impl crate :: IsEnum for WriteRequest { } # [doc = "Field `WRITE_REQUEST` reader - Выбор периферийной линии назначения"]
pub type WriteRequestR = crate :: FieldReader < WriteRequest > ; impl WriteRequestR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < WriteRequest > { match self . bits { 0 => Some (WriteRequest :: Usart0) , 1 => Some (WriteRequest :: Usart1) , 2 => Some (WriteRequest :: Crypto) , 3 => Some (WriteRequest :: Spi0) , 4 => Some (WriteRequest :: Spi1) , 5 => Some (WriteRequest :: I2c0) , 6 => Some (WriteRequest :: I2c1) , 7 => Some (WriteRequest :: Spifi) , 8 => Some (WriteRequest :: Timer32_1) , 9 => Some (WriteRequest :: Timer32_2) , 10 => Some (WriteRequest :: Dac0) , 11 => Some (WriteRequest :: Dac1) , 12 => Some (WriteRequest :: Timer32_0) , _ => None , } } # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn is_usart_0 (& self) -> bool { * self == WriteRequest :: Usart0 } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn is_usart_1 (& self) -> bool { * self == WriteRequest :: Usart1 } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn is_crypto (& self) -> bool { * self == WriteRequest :: Crypto } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn is_spi_0 (& self) -> bool { * self == WriteRequest :: Spi0 } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn is_spi_1 (& self) -> bool { * self == WriteRequest :: Spi1 } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn is_i2c_0 (& self) -> bool { * self == WriteRequest :: I2c0 } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn is_i2c_1 (& self) -> bool { * self == WriteRequest :: I2c1 } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn is_spifi (& self) -> bool { * self == WriteRequest :: Spifi } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn is_timer32_1 (& self) -> bool { * self == WriteRequest :: Timer32_1 } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn is_timer32_2 (& self) -> bool { * self == WriteRequest :: Timer32_2 } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn is_dac0 (& self) -> bool { * self == WriteRequest :: Dac0 } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn is_dac1 (& self) -> bool { * self == WriteRequest :: Dac1 } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn is_timer32_0 (& self) -> bool { * self == WriteRequest :: Timer32_0 } } # [doc = "Field `WRITE_REQUEST` writer - Выбор периферийной линии назначения"]
pub type WriteRequestW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , WriteRequest > ; impl < 'a , REG > WriteRequestW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn usart_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Usart0) } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn usart_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Usart1) } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn crypto (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Crypto) } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn spi_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spi0) } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn spi_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spi1) } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn i2c_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: I2c0) } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn i2c_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: I2c1) } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn spifi (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spifi) } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn timer32_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_1) } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn timer32_2 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_2) } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn dac0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Dac0) } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn dac1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Dac1) } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn timer32_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_0) } } # [doc = "Разрешение работы логики с откликом для адресата источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadAckEn { # [doc = "0: Запрещено"]
Disable = 0 , # [doc = "1: Разрешено"]
Enable = 1 , } impl From < ReadAckEn > for bool { # [inline (always)]
fn from (variant : ReadAckEn) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_ACK_EN` reader - Разрешение работы логики с откликом для адресата источника"]
pub type ReadAckEnR = crate :: BitReader < ReadAckEn > ; impl ReadAckEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadAckEn { match self . bits { false => ReadAckEn :: Disable , true => ReadAckEn :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == ReadAckEn :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == ReadAckEn :: Enable } } # [doc = "Field `READ_ACK_EN` writer - Разрешение работы логики с откликом для адресата источника"]
pub type ReadAckEnW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadAckEn > ; impl < 'a , REG > ReadAckEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (ReadAckEn :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (ReadAckEn :: Enable) } } # [doc = "Разрешение работы логики с откликом для адресата назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteAckEn { # [doc = "0: Запрещено"]
Disable = 0 , # [doc = "1: Разрешено"]
Enable = 1 , } impl From < WriteAckEn > for bool { # [inline (always)]
fn from (variant : WriteAckEn) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_ACK_EN` reader - Разрешение работы логики с откликом для адресата назначения"]
pub type WriteAckEnR = crate :: BitReader < WriteAckEn > ; impl WriteAckEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteAckEn { match self . bits { false => WriteAckEn :: Disable , true => WriteAckEn :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WriteAckEn :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WriteAckEn :: Enable } } # [doc = "Field `WRITE_ACK_EN` writer - Разрешение работы логики с откликом для адресата назначения"]
pub type WriteAckEnW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteAckEn > ; impl < 'a , REG > WriteAckEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WriteAckEn :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WriteAckEn :: Enable) } } # [doc = "Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum IrqEn { # [doc = "0: Прерывание не формируется"]
Disable = 0 , # [doc = "1: Прерывание формируется"]
Enable = 1 , } impl From < IrqEn > for bool { # [inline (always)]
fn from (variant : IrqEn) -> Self { variant as u8 != 0 } } # [doc = "Field `IRQ_EN` reader - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
pub type IrqEnR = crate :: BitReader < IrqEn > ; impl IrqEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> IrqEn { match self . bits { false => IrqEn :: Disable , true => IrqEn :: Enable , } } # [doc = "Прерывание не формируется"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == IrqEn :: Disable } # [doc = "Прерывание формируется"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == IrqEn :: Enable } } # [doc = "Field `IRQ_EN` writer - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
pub type IrqEnW < 'a , REG > = crate :: BitWriter < 'a , REG , IrqEn > ; impl < 'a , REG > IrqEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание не формируется"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (IrqEn :: Disable) } # [doc = "Прерывание формируется"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (IrqEn :: Enable) } } impl R { # [doc = "Bit 0 - Разрешение работы канала"]
# [inline (always)]
pub fn enable (& self) -> EnableR { EnableR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Приоритет канала"]
# [inline (always)]
pub fn prior (& self) -> PriorR { PriorR :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bit 3 - Режим адреса источника"]
# [inline (always)]
pub fn read_mode (& self) -> ReadModeR { ReadModeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Режим адреса назначения"]
# [inline (always)]
pub fn write_mode (& self) -> WriteModeR { WriteModeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Инкремент адреса источника"]
# [inline (always)]
pub fn read_increment (& self) -> ReadIncrementR { ReadIncrementR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 5 - Инкремент адреса назначения"]
# [inline (always)]
pub fn write_increment (& self) -> WriteIncrementR { WriteIncrementR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 7:8 - Разрядность адреса источника. Должно быть кратно data_len"]
# [inline (always)]
pub fn read_size (& self) -> ReadSizeR { ReadSizeR :: new (((self . bits >> 7) & 3) as u8) } # [doc = "Bits 9:10 - Разрядность адреса назначения. Должно быть кратно LEN"]
# [inline (always)]
pub fn write_size (& self) -> WriteSizeR { WriteSizeR :: new (((self . bits >> 9) & 3) as u8) } # [doc = "Bits 11:13 - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
# [inline (always)]
pub fn read_burst_size (& self) -> ReadBurstSizeR { ReadBurstSizeR :: new (((self . bits >> 11) & 7) as u8) } # [doc = "Bits 14:16 - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
# [inline (always)]
pub fn write_burst_size (& self) -> WriteBurstSizeR { WriteBurstSizeR :: new (((self . bits >> 14) & 7) as u8) } # [doc = "Bits 17:20 - Выбор периферийной линии источника"]
# [inline (always)]
pub fn read_request (& self) -> ReadRequestR { ReadRequestR :: new (((self . bits >> 17) & 0x0f) as u8) } # [doc = "Bits 21:24 - Выбор периферийной линии назначения"]
# [inline (always)]
pub fn write_request (& self) -> WriteRequestR { WriteRequestR :: new (((self . bits >> 21) & 0x0f) as u8) } # [doc = "Bit 25 - Разрешение работы логики с откликом для адресата источника"]
# [inline (always)]
pub fn read_ack_en (& self) -> ReadAckEnR { ReadAckEnR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Разрешение работы логики с откликом для адресата назначения"]
# [inline (always)]
pub fn write_ack_en (& self) -> WriteAckEnR { WriteAckEnR :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
# [inline (always)]
pub fn irq_en (& self) -> IrqEnR { IrqEnR :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bit 0 - Разрешение работы канала"]
# [inline (always)]
pub fn enable (& mut self) -> EnableW < Ch1CfgSpec > { EnableW :: new (self , 0) } # [doc = "Bits 1:2 - Приоритет канала"]
# [inline (always)]
pub fn prior (& mut self) -> PriorW < Ch1CfgSpec > { PriorW :: new (self , 1) } # [doc = "Bit 3 - Режим адреса источника"]
# [inline (always)]
pub fn read_mode (& mut self) -> ReadModeW < Ch1CfgSpec > { ReadModeW :: new (self , 3) } # [doc = "Bit 4 - Режим адреса назначения"]
# [inline (always)]
pub fn write_mode (& mut self) -> WriteModeW < Ch1CfgSpec > { WriteModeW :: new (self , 4) } # [doc = "Bit 5 - Инкремент адреса источника"]
# [inline (always)]
pub fn read_increment (& mut self) -> ReadIncrementW < Ch1CfgSpec > { ReadIncrementW :: new (self , 5) } # [doc = "Bit 5 - Инкремент адреса назначения"]
# [inline (always)]
pub fn write_increment (& mut self) -> WriteIncrementW < Ch1CfgSpec > { WriteIncrementW :: new (self , 5) } # [doc = "Bits 7:8 - Разрядность адреса источника. Должно быть кратно data_len"]
# [inline (always)]
pub fn read_size (& mut self) -> ReadSizeW < Ch1CfgSpec > { ReadSizeW :: new (self , 7) } # [doc = "Bits 9:10 - Разрядность адреса назначения. Должно быть кратно LEN"]
# [inline (always)]
pub fn write_size (& mut self) -> WriteSizeW < Ch1CfgSpec > { WriteSizeW :: new (self , 9) } # [doc = "Bits 11:13 - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
# [inline (always)]
pub fn read_burst_size (& mut self) -> ReadBurstSizeW < Ch1CfgSpec > { ReadBurstSizeW :: new (self , 11) } # [doc = "Bits 14:16 - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
# [inline (always)]
pub fn write_burst_size (& mut self) -> WriteBurstSizeW < Ch1CfgSpec > { WriteBurstSizeW :: new (self , 14) } # [doc = "Bits 17:20 - Выбор периферийной линии источника"]
# [inline (always)]
pub fn read_request (& mut self) -> ReadRequestW < Ch1CfgSpec > { ReadRequestW :: new (self , 17) } # [doc = "Bits 21:24 - Выбор периферийной линии назначения"]
# [inline (always)]
pub fn write_request (& mut self) -> WriteRequestW < Ch1CfgSpec > { WriteRequestW :: new (self , 21) } # [doc = "Bit 25 - Разрешение работы логики с откликом для адресата источника"]
# [inline (always)]
pub fn read_ack_en (& mut self) -> ReadAckEnW < Ch1CfgSpec > { ReadAckEnW :: new (self , 25) } # [doc = "Bit 26 - Разрешение работы логики с откликом для адресата назначения"]
# [inline (always)]
pub fn write_ack_en (& mut self) -> WriteAckEnW < Ch1CfgSpec > { WriteAckEnW :: new (self , 26) } # [doc = "Bit 27 - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
# [inline (always)]
pub fn irq_en (& mut self) -> IrqEnW < Ch1CfgSpec > { IrqEnW :: new (self , 27) } } # [doc = "Регистр управления и конфигурации канала 1\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch1CfgSpec ; impl crate :: RegisterSpec for Ch1CfgSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch1_cfg::R`](R) reader structure"]
impl crate :: Readable for Ch1CfgSpec { } # [doc = "`write(|w| ..)` method takes [`ch1_cfg::W`](W) writer structure"]
impl crate :: Writable for Ch1CfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH1_CFG to value 0"]
impl crate :: Resettable for Ch1CfgSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH2_DST (rw) register accessor: Регистр адреса назначения канала 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_dst::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_dst::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch2_dst`]
module"]
# [doc (alias = "CH2_DST")]
pub type Ch2Dst = crate :: Reg < ch2_dst :: Ch2DstSpec > ; # [doc = "Регистр адреса назначения канала 2"]
pub mod ch2_dst { # [doc = "Register `CH2_DST` reader"]
pub type R = crate :: R < Ch2DstSpec > ; # [doc = "Register `CH2_DST` writer"]
pub type W = crate :: W < Ch2DstSpec > ; # [doc = "Field `Dst` reader - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
pub type DstR = crate :: FieldReader < u32 > ; # [doc = "Field `Dst` writer - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
pub type DstW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
# [inline (always)]
pub fn dst (& self) -> DstR { DstR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
# [inline (always)]
pub fn dst (& mut self) -> DstW < Ch2DstSpec > { DstW :: new (self , 0) } } # [doc = "Регистр адреса назначения канала 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_dst::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_dst::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch2DstSpec ; impl crate :: RegisterSpec for Ch2DstSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch2_dst::R`](R) reader structure"]
impl crate :: Readable for Ch2DstSpec { } # [doc = "`write(|w| ..)` method takes [`ch2_dst::W`](W) writer structure"]
impl crate :: Writable for Ch2DstSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH2_DST to value 0"]
impl crate :: Resettable for Ch2DstSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH2_SRC (rw) register accessor: Регистр адреса источника канала 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_src::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_src::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch2_src`]
module"]
# [doc (alias = "CH2_SRC")]
pub type Ch2Src = crate :: Reg < ch2_src :: Ch2SrcSpec > ; # [doc = "Регистр адреса источника канала 2"]
pub mod ch2_src { # [doc = "Register `CH2_SRC` reader"]
pub type R = crate :: R < Ch2SrcSpec > ; # [doc = "Register `CH2_SRC` writer"]
pub type W = crate :: W < Ch2SrcSpec > ; # [doc = "Field `Src` reader - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
pub type SrcR = crate :: FieldReader < u32 > ; # [doc = "Field `Src` writer - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
pub type SrcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
# [inline (always)]
pub fn src (& self) -> SrcR { SrcR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
# [inline (always)]
pub fn src (& mut self) -> SrcW < Ch2SrcSpec > { SrcW :: new (self , 0) } } # [doc = "Регистр адреса источника канала 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_src::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_src::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch2SrcSpec ; impl crate :: RegisterSpec for Ch2SrcSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch2_src::R`](R) reader structure"]
impl crate :: Readable for Ch2SrcSpec { } # [doc = "`write(|w| ..)` method takes [`ch2_src::W`](W) writer structure"]
impl crate :: Writable for Ch2SrcSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH2_SRC to value 0"]
impl crate :: Resettable for Ch2SrcSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH2_LEN (rw) register accessor: Регистр размера передаваемых данных канала 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch2_len`]
module"]
# [doc (alias = "CH2_LEN")]
pub type Ch2Len = crate :: Reg < ch2_len :: Ch2LenSpec > ; # [doc = "Регистр размера передаваемых данных канала 2"]
pub mod ch2_len { # [doc = "Register `CH2_LEN` reader"]
pub type R = crate :: R < Ch2LenSpec > ; # [doc = "Register `CH2_LEN` writer"]
pub type W = crate :: W < Ch2LenSpec > ; # [doc = "Field `Data_Len` reader - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
pub type DataLenR = crate :: FieldReader < u32 > ; # [doc = "Field `Data_Len` writer - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
pub type DataLenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
# [inline (always)]
pub fn data_len (& self) -> DataLenR { DataLenR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
# [inline (always)]
pub fn data_len (& mut self) -> DataLenW < Ch2LenSpec > { DataLenW :: new (self , 0) } } # [doc = "Регистр размера передаваемых данных канала 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch2LenSpec ; impl crate :: RegisterSpec for Ch2LenSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch2_len::R`](R) reader structure"]
impl crate :: Readable for Ch2LenSpec { } # [doc = "`write(|w| ..)` method takes [`ch2_len::W`](W) writer structure"]
impl crate :: Writable for Ch2LenSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH2_LEN to value 0"]
impl crate :: Resettable for Ch2LenSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH2_CFG (rw) register accessor: Регистр управления и конфигурации канала 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch2_cfg`]
module"]
# [doc (alias = "CH2_CFG")]
pub type Ch2Cfg = crate :: Reg < ch2_cfg :: Ch2CfgSpec > ; # [doc = "Регистр управления и конфигурации канала 2"]
pub mod ch2_cfg { # [doc = "Register `CH2_CFG` reader"]
pub type R = crate :: R < Ch2CfgSpec > ; # [doc = "Register `CH2_CFG` writer"]
pub type W = crate :: W < Ch2CfgSpec > ; # [doc = "Разрешение работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Enable { # [doc = "0: Принудительная остановка"]
Stop = 0 , # [doc = "1: Инициализация работы канала"]
Start = 1 , } impl From < Enable > for bool { # [inline (always)]
fn from (variant : Enable) -> Self { variant as u8 != 0 } } # [doc = "Field `ENABLE` reader - Разрешение работы канала"]
pub type EnableR = crate :: BitReader < Enable > ; impl EnableR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Enable { match self . bits { false => Enable :: Stop , true => Enable :: Start , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == Enable :: Stop } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_start (& self) -> bool { * self == Enable :: Start } } # [doc = "Field `ENABLE` writer - Разрешение работы канала"]
pub type EnableW < 'a , REG > = crate :: BitWriter < 'a , REG , Enable > ; impl < 'a , REG > EnableW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn stop (self) -> & 'a mut crate :: W < REG > { self . variant (Enable :: Stop) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn start (self) -> & 'a mut crate :: W < REG > { self . variant (Enable :: Start) } } # [doc = "Приоритет канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Prior { # [doc = "0: Принудительная остановка"]
Low = 0 , # [doc = "1: Инициализация работы канала"]
Medium = 1 , # [doc = "2: Инициализация работы канала"]
High = 2 , # [doc = "3: Инициализация работы канала"]
VeryHigh = 3 , } impl From < Prior > for u8 { # [inline (always)]
fn from (variant : Prior) -> Self { variant as _ } } impl crate :: FieldSpec for Prior { type Ux = u8 ; } impl crate :: IsEnum for Prior { } # [doc = "Field `PRIOR` reader - Приоритет канала"]
pub type PriorR = crate :: FieldReader < Prior > ; impl PriorR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Prior { match self . bits { 0 => Prior :: Low , 1 => Prior :: Medium , 2 => Prior :: High , 3 => Prior :: VeryHigh , _ => unreachable ! () , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == Prior :: Low } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_medium (& self) -> bool { * self == Prior :: Medium } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == Prior :: High } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_very_high (& self) -> bool { * self == Prior :: VeryHigh } } # [doc = "Field `PRIOR` writer - Приоритет канала"]
pub type PriorW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Prior , crate :: Safe > ; impl < 'a , REG > PriorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn low (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: Low) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn medium (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: Medium) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn high (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: High) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn very_high (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: VeryHigh) } } # [doc = "Режим адреса источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadMode { # [doc = "0: Принудительная остановка"]
Periphery = 0 , # [doc = "1: Инициализация работы канала"]
Memory = 1 , } impl From < ReadMode > for bool { # [inline (always)]
fn from (variant : ReadMode) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_MODE` reader - Режим адреса источника"]
pub type ReadModeR = crate :: BitReader < ReadMode > ; impl ReadModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadMode { match self . bits { false => ReadMode :: Periphery , true => ReadMode :: Memory , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_periphery (& self) -> bool { * self == ReadMode :: Periphery } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_memory (& self) -> bool { * self == ReadMode :: Memory } } # [doc = "Field `READ_MODE` writer - Режим адреса источника"]
pub type ReadModeW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadMode > ; impl < 'a , REG > ReadModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn periphery (self) -> & 'a mut crate :: W < REG > { self . variant (ReadMode :: Periphery) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn memory (self) -> & 'a mut crate :: W < REG > { self . variant (ReadMode :: Memory) } } # [doc = "Режим адреса назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteMode { # [doc = "0: Принудительная остановка"]
Periphery = 0 , # [doc = "1: Инициализация работы канала"]
Memory = 1 , } impl From < WriteMode > for bool { # [inline (always)]
fn from (variant : WriteMode) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_MODE` reader - Режим адреса назначения"]
pub type WriteModeR = crate :: BitReader < WriteMode > ; impl WriteModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteMode { match self . bits { false => WriteMode :: Periphery , true => WriteMode :: Memory , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_periphery (& self) -> bool { * self == WriteMode :: Periphery } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_memory (& self) -> bool { * self == WriteMode :: Memory } } # [doc = "Field `WRITE_MODE` writer - Режим адреса назначения"]
pub type WriteModeW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteMode > ; impl < 'a , REG > WriteModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn periphery (self) -> & 'a mut crate :: W < REG > { self . variant (WriteMode :: Periphery) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn memory (self) -> & 'a mut crate :: W < REG > { self . variant (WriteMode :: Memory) } } # [doc = "Инкремент адреса источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadIncrement { # [doc = "0: Нет инкремента"]
NoIncrement = 0 , # [doc = "1: Есть инкремент"]
Increment = 1 , } impl From < ReadIncrement > for bool { # [inline (always)]
fn from (variant : ReadIncrement) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_INCREMENT` reader - Инкремент адреса источника"]
pub type ReadIncrementR = crate :: BitReader < ReadIncrement > ; impl ReadIncrementR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadIncrement { match self . bits { false => ReadIncrement :: NoIncrement , true => ReadIncrement :: Increment , } } # [doc = "Нет инкремента"]
# [inline (always)]
pub fn is_no_increment (& self) -> bool { * self == ReadIncrement :: NoIncrement } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn is_increment (& self) -> bool { * self == ReadIncrement :: Increment } } # [doc = "Field `READ_INCREMENT` writer - Инкремент адреса источника"]
pub type ReadIncrementW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadIncrement > ; impl < 'a , REG > ReadIncrementW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Нет инкремента"]
# [inline (always)]
pub fn no_increment (self) -> & 'a mut crate :: W < REG > { self . variant (ReadIncrement :: NoIncrement) } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn increment (self) -> & 'a mut crate :: W < REG > { self . variant (ReadIncrement :: Increment) } } # [doc = "Инкремент адреса назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteIncrement { # [doc = "0: Нет инкремента"]
NoIncrement = 0 , # [doc = "1: Есть инкремент"]
Increment = 1 , } impl From < WriteIncrement > for bool { # [inline (always)]
fn from (variant : WriteIncrement) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_INCREMENT` reader - Инкремент адреса назначения"]
pub type WriteIncrementR = crate :: BitReader < WriteIncrement > ; impl WriteIncrementR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteIncrement { match self . bits { false => WriteIncrement :: NoIncrement , true => WriteIncrement :: Increment , } } # [doc = "Нет инкремента"]
# [inline (always)]
pub fn is_no_increment (& self) -> bool { * self == WriteIncrement :: NoIncrement } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn is_increment (& self) -> bool { * self == WriteIncrement :: Increment } } # [doc = "Field `WRITE_INCREMENT` writer - Инкремент адреса назначения"]
pub type WriteIncrementW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteIncrement > ; impl < 'a , REG > WriteIncrementW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Нет инкремента"]
# [inline (always)]
pub fn no_increment (self) -> & 'a mut crate :: W < REG > { self . variant (WriteIncrement :: NoIncrement) } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn increment (self) -> & 'a mut crate :: W < REG > { self . variant (WriteIncrement :: Increment) } } # [doc = "Разрядность адреса источника. Должно быть кратно data_len\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ReadSize { # [doc = "0: Байт"]
Byte = 0 , # [doc = "1: Полуслово"]
_2byte = 1 , # [doc = "2: Слово"]
_4byte = 2 , } impl From < ReadSize > for u8 { # [inline (always)]
fn from (variant : ReadSize) -> Self { variant as _ } } impl crate :: FieldSpec for ReadSize { type Ux = u8 ; } impl crate :: IsEnum for ReadSize { } # [doc = "Field `READ_SIZE` reader - Разрядность адреса источника. Должно быть кратно data_len"]
pub type ReadSizeR = crate :: FieldReader < ReadSize > ; impl ReadSizeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < ReadSize > { match self . bits { 0 => Some (ReadSize :: Byte) , 1 => Some (ReadSize :: _2byte) , 2 => Some (ReadSize :: _4byte) , _ => None , } } # [doc = "Байт"]
# [inline (always)]
pub fn is_byte (& self) -> bool { * self == ReadSize :: Byte } # [doc = "Полуслово"]
# [inline (always)]
pub fn is_2byte (& self) -> bool { * self == ReadSize :: _2byte } # [doc = "Слово"]
# [inline (always)]
pub fn is_4byte (& self) -> bool { * self == ReadSize :: _4byte } } # [doc = "Field `READ_SIZE` writer - Разрядность адреса источника. Должно быть кратно data_len"]
pub type ReadSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , ReadSize > ; impl < 'a , REG > ReadSizeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Байт"]
# [inline (always)]
pub fn byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: Byte) } # [doc = "Полуслово"]
# [inline (always)]
pub fn _2byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: _2byte) } # [doc = "Слово"]
# [inline (always)]
pub fn _4byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: _4byte) } } # [doc = "Разрядность адреса назначения. Должно быть кратно LEN\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WriteSize { # [doc = "0: Байт"]
Byte = 0 , # [doc = "1: Полуслово"]
_2byte = 1 , # [doc = "2: Слово"]
_4byte = 2 , } impl From < WriteSize > for u8 { # [inline (always)]
fn from (variant : WriteSize) -> Self { variant as _ } } impl crate :: FieldSpec for WriteSize { type Ux = u8 ; } impl crate :: IsEnum for WriteSize { } # [doc = "Field `WRITE_SIZE` reader - Разрядность адреса назначения. Должно быть кратно LEN"]
pub type WriteSizeR = crate :: FieldReader < WriteSize > ; impl WriteSizeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < WriteSize > { match self . bits { 0 => Some (WriteSize :: Byte) , 1 => Some (WriteSize :: _2byte) , 2 => Some (WriteSize :: _4byte) , _ => None , } } # [doc = "Байт"]
# [inline (always)]
pub fn is_byte (& self) -> bool { * self == WriteSize :: Byte } # [doc = "Полуслово"]
# [inline (always)]
pub fn is_2byte (& self) -> bool { * self == WriteSize :: _2byte } # [doc = "Слово"]
# [inline (always)]
pub fn is_4byte (& self) -> bool { * self == WriteSize :: _4byte } } # [doc = "Field `WRITE_SIZE` writer - Разрядность адреса назначения. Должно быть кратно LEN"]
pub type WriteSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , WriteSize > ; impl < 'a , REG > WriteSizeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Байт"]
# [inline (always)]
pub fn byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: Byte) } # [doc = "Полуслово"]
# [inline (always)]
pub fn _2byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: _2byte) } # [doc = "Слово"]
# [inline (always)]
pub fn _4byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: _4byte) } } # [doc = "Field `READ_BURST_SIZE` reader - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
pub type ReadBurstSizeR = crate :: FieldReader ; # [doc = "Field `READ_BURST_SIZE` writer - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
pub type ReadBurstSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `WRITE_BURST_SIZE` reader - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
pub type WriteBurstSizeR = crate :: FieldReader ; # [doc = "Field `WRITE_BURST_SIZE` writer - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
pub type WriteBurstSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Выбор периферийной линии источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ReadRequest { # [doc = "0: Линия запросов от USART_0"]
Usart0 = 0 , # [doc = "1: Линия запросов от USART_1"]
Usart1 = 1 , # [doc = "2: Линия запросов от крипто-блока"]
Crypto = 2 , # [doc = "3: Линия запросов от SPI_0"]
Spi0 = 3 , # [doc = "4: Линия запросов от SPI_1"]
Spi1 = 4 , # [doc = "5: Линия запросов от I2C_0"]
I2c0 = 5 , # [doc = "6: Линия запросов от I2C_1"]
I2c1 = 6 , # [doc = "7: Линия запросов от SPIFI"]
Spifi = 7 , # [doc = "8: Линия запросов от Timer32_1"]
Timer32_1 = 8 , # [doc = "9: Линия запросов от Timer32_2"]
Timer32_2 = 9 , # [doc = "10: Линия запросов от DAC0"]
Dac0 = 10 , # [doc = "11: Линия запросов от DAC1"]
Dac1 = 11 , # [doc = "12: Линия запросов от Timer32_0"]
Timer32_0 = 12 , } impl From < ReadRequest > for u8 { # [inline (always)]
fn from (variant : ReadRequest) -> Self { variant as _ } } impl crate :: FieldSpec for ReadRequest { type Ux = u8 ; } impl crate :: IsEnum for ReadRequest { } # [doc = "Field `READ_REQUEST` reader - Выбор периферийной линии источника"]
pub type ReadRequestR = crate :: FieldReader < ReadRequest > ; impl ReadRequestR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < ReadRequest > { match self . bits { 0 => Some (ReadRequest :: Usart0) , 1 => Some (ReadRequest :: Usart1) , 2 => Some (ReadRequest :: Crypto) , 3 => Some (ReadRequest :: Spi0) , 4 => Some (ReadRequest :: Spi1) , 5 => Some (ReadRequest :: I2c0) , 6 => Some (ReadRequest :: I2c1) , 7 => Some (ReadRequest :: Spifi) , 8 => Some (ReadRequest :: Timer32_1) , 9 => Some (ReadRequest :: Timer32_2) , 10 => Some (ReadRequest :: Dac0) , 11 => Some (ReadRequest :: Dac1) , 12 => Some (ReadRequest :: Timer32_0) , _ => None , } } # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn is_usart_0 (& self) -> bool { * self == ReadRequest :: Usart0 } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn is_usart_1 (& self) -> bool { * self == ReadRequest :: Usart1 } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn is_crypto (& self) -> bool { * self == ReadRequest :: Crypto } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn is_spi_0 (& self) -> bool { * self == ReadRequest :: Spi0 } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn is_spi_1 (& self) -> bool { * self == ReadRequest :: Spi1 } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn is_i2c_0 (& self) -> bool { * self == ReadRequest :: I2c0 } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn is_i2c_1 (& self) -> bool { * self == ReadRequest :: I2c1 } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn is_spifi (& self) -> bool { * self == ReadRequest :: Spifi } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn is_timer32_1 (& self) -> bool { * self == ReadRequest :: Timer32_1 } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn is_timer32_2 (& self) -> bool { * self == ReadRequest :: Timer32_2 } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn is_dac0 (& self) -> bool { * self == ReadRequest :: Dac0 } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn is_dac1 (& self) -> bool { * self == ReadRequest :: Dac1 } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn is_timer32_0 (& self) -> bool { * self == ReadRequest :: Timer32_0 } } # [doc = "Field `READ_REQUEST` writer - Выбор периферийной линии источника"]
pub type ReadRequestW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , ReadRequest > ; impl < 'a , REG > ReadRequestW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn usart_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Usart0) } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn usart_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Usart1) } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn crypto (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Crypto) } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn spi_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spi0) } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn spi_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spi1) } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn i2c_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: I2c0) } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn i2c_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: I2c1) } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn spifi (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spifi) } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn timer32_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_1) } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn timer32_2 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_2) } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn dac0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Dac0) } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn dac1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Dac1) } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn timer32_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_0) } } # [doc = "Выбор периферийной линии назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WriteRequest { # [doc = "0: Линия запросов от USART_0"]
Usart0 = 0 , # [doc = "1: Линия запросов от USART_1"]
Usart1 = 1 , # [doc = "2: Линия запросов от крипто-блока"]
Crypto = 2 , # [doc = "3: Линия запросов от SPI_0"]
Spi0 = 3 , # [doc = "4: Линия запросов от SPI_1"]
Spi1 = 4 , # [doc = "5: Линия запросов от I2C_0"]
I2c0 = 5 , # [doc = "6: Линия запросов от I2C_1"]
I2c1 = 6 , # [doc = "7: Линия запросов от SPIFI"]
Spifi = 7 , # [doc = "8: Линия запросов от Timer32_1"]
Timer32_1 = 8 , # [doc = "9: Линия запросов от Timer32_2"]
Timer32_2 = 9 , # [doc = "10: Линия запросов от DAC0"]
Dac0 = 10 , # [doc = "11: Линия запросов от DAC1"]
Dac1 = 11 , # [doc = "12: Линия запросов от Timer32_0"]
Timer32_0 = 12 , } impl From < WriteRequest > for u8 { # [inline (always)]
fn from (variant : WriteRequest) -> Self { variant as _ } } impl crate :: FieldSpec for WriteRequest { type Ux = u8 ; } impl crate :: IsEnum for WriteRequest { } # [doc = "Field `WRITE_REQUEST` reader - Выбор периферийной линии назначения"]
pub type WriteRequestR = crate :: FieldReader < WriteRequest > ; impl WriteRequestR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < WriteRequest > { match self . bits { 0 => Some (WriteRequest :: Usart0) , 1 => Some (WriteRequest :: Usart1) , 2 => Some (WriteRequest :: Crypto) , 3 => Some (WriteRequest :: Spi0) , 4 => Some (WriteRequest :: Spi1) , 5 => Some (WriteRequest :: I2c0) , 6 => Some (WriteRequest :: I2c1) , 7 => Some (WriteRequest :: Spifi) , 8 => Some (WriteRequest :: Timer32_1) , 9 => Some (WriteRequest :: Timer32_2) , 10 => Some (WriteRequest :: Dac0) , 11 => Some (WriteRequest :: Dac1) , 12 => Some (WriteRequest :: Timer32_0) , _ => None , } } # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn is_usart_0 (& self) -> bool { * self == WriteRequest :: Usart0 } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn is_usart_1 (& self) -> bool { * self == WriteRequest :: Usart1 } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn is_crypto (& self) -> bool { * self == WriteRequest :: Crypto } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn is_spi_0 (& self) -> bool { * self == WriteRequest :: Spi0 } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn is_spi_1 (& self) -> bool { * self == WriteRequest :: Spi1 } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn is_i2c_0 (& self) -> bool { * self == WriteRequest :: I2c0 } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn is_i2c_1 (& self) -> bool { * self == WriteRequest :: I2c1 } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn is_spifi (& self) -> bool { * self == WriteRequest :: Spifi } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn is_timer32_1 (& self) -> bool { * self == WriteRequest :: Timer32_1 } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn is_timer32_2 (& self) -> bool { * self == WriteRequest :: Timer32_2 } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn is_dac0 (& self) -> bool { * self == WriteRequest :: Dac0 } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn is_dac1 (& self) -> bool { * self == WriteRequest :: Dac1 } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn is_timer32_0 (& self) -> bool { * self == WriteRequest :: Timer32_0 } } # [doc = "Field `WRITE_REQUEST` writer - Выбор периферийной линии назначения"]
pub type WriteRequestW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , WriteRequest > ; impl < 'a , REG > WriteRequestW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn usart_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Usart0) } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn usart_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Usart1) } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn crypto (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Crypto) } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn spi_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spi0) } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn spi_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spi1) } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn i2c_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: I2c0) } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn i2c_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: I2c1) } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn spifi (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spifi) } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn timer32_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_1) } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn timer32_2 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_2) } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn dac0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Dac0) } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn dac1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Dac1) } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn timer32_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_0) } } # [doc = "Разрешение работы логики с откликом для адресата источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadAckEn { # [doc = "0: Запрещено"]
Disable = 0 , # [doc = "1: Разрешено"]
Enable = 1 , } impl From < ReadAckEn > for bool { # [inline (always)]
fn from (variant : ReadAckEn) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_ACK_EN` reader - Разрешение работы логики с откликом для адресата источника"]
pub type ReadAckEnR = crate :: BitReader < ReadAckEn > ; impl ReadAckEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadAckEn { match self . bits { false => ReadAckEn :: Disable , true => ReadAckEn :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == ReadAckEn :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == ReadAckEn :: Enable } } # [doc = "Field `READ_ACK_EN` writer - Разрешение работы логики с откликом для адресата источника"]
pub type ReadAckEnW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadAckEn > ; impl < 'a , REG > ReadAckEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (ReadAckEn :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (ReadAckEn :: Enable) } } # [doc = "Разрешение работы логики с откликом для адресата назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteAckEn { # [doc = "0: Запрещено"]
Disable = 0 , # [doc = "1: Разрешено"]
Enable = 1 , } impl From < WriteAckEn > for bool { # [inline (always)]
fn from (variant : WriteAckEn) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_ACK_EN` reader - Разрешение работы логики с откликом для адресата назначения"]
pub type WriteAckEnR = crate :: BitReader < WriteAckEn > ; impl WriteAckEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteAckEn { match self . bits { false => WriteAckEn :: Disable , true => WriteAckEn :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WriteAckEn :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WriteAckEn :: Enable } } # [doc = "Field `WRITE_ACK_EN` writer - Разрешение работы логики с откликом для адресата назначения"]
pub type WriteAckEnW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteAckEn > ; impl < 'a , REG > WriteAckEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WriteAckEn :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WriteAckEn :: Enable) } } # [doc = "Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum IrqEn { # [doc = "0: Прерывание не формируется"]
Disable = 0 , # [doc = "1: Прерывание формируется"]
Enable = 1 , } impl From < IrqEn > for bool { # [inline (always)]
fn from (variant : IrqEn) -> Self { variant as u8 != 0 } } # [doc = "Field `IRQ_EN` reader - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
pub type IrqEnR = crate :: BitReader < IrqEn > ; impl IrqEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> IrqEn { match self . bits { false => IrqEn :: Disable , true => IrqEn :: Enable , } } # [doc = "Прерывание не формируется"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == IrqEn :: Disable } # [doc = "Прерывание формируется"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == IrqEn :: Enable } } # [doc = "Field `IRQ_EN` writer - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
pub type IrqEnW < 'a , REG > = crate :: BitWriter < 'a , REG , IrqEn > ; impl < 'a , REG > IrqEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание не формируется"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (IrqEn :: Disable) } # [doc = "Прерывание формируется"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (IrqEn :: Enable) } } impl R { # [doc = "Bit 0 - Разрешение работы канала"]
# [inline (always)]
pub fn enable (& self) -> EnableR { EnableR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Приоритет канала"]
# [inline (always)]
pub fn prior (& self) -> PriorR { PriorR :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bit 3 - Режим адреса источника"]
# [inline (always)]
pub fn read_mode (& self) -> ReadModeR { ReadModeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Режим адреса назначения"]
# [inline (always)]
pub fn write_mode (& self) -> WriteModeR { WriteModeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Инкремент адреса источника"]
# [inline (always)]
pub fn read_increment (& self) -> ReadIncrementR { ReadIncrementR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 5 - Инкремент адреса назначения"]
# [inline (always)]
pub fn write_increment (& self) -> WriteIncrementR { WriteIncrementR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 7:8 - Разрядность адреса источника. Должно быть кратно data_len"]
# [inline (always)]
pub fn read_size (& self) -> ReadSizeR { ReadSizeR :: new (((self . bits >> 7) & 3) as u8) } # [doc = "Bits 9:10 - Разрядность адреса назначения. Должно быть кратно LEN"]
# [inline (always)]
pub fn write_size (& self) -> WriteSizeR { WriteSizeR :: new (((self . bits >> 9) & 3) as u8) } # [doc = "Bits 11:13 - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
# [inline (always)]
pub fn read_burst_size (& self) -> ReadBurstSizeR { ReadBurstSizeR :: new (((self . bits >> 11) & 7) as u8) } # [doc = "Bits 14:16 - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
# [inline (always)]
pub fn write_burst_size (& self) -> WriteBurstSizeR { WriteBurstSizeR :: new (((self . bits >> 14) & 7) as u8) } # [doc = "Bits 17:20 - Выбор периферийной линии источника"]
# [inline (always)]
pub fn read_request (& self) -> ReadRequestR { ReadRequestR :: new (((self . bits >> 17) & 0x0f) as u8) } # [doc = "Bits 21:24 - Выбор периферийной линии назначения"]
# [inline (always)]
pub fn write_request (& self) -> WriteRequestR { WriteRequestR :: new (((self . bits >> 21) & 0x0f) as u8) } # [doc = "Bit 25 - Разрешение работы логики с откликом для адресата источника"]
# [inline (always)]
pub fn read_ack_en (& self) -> ReadAckEnR { ReadAckEnR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Разрешение работы логики с откликом для адресата назначения"]
# [inline (always)]
pub fn write_ack_en (& self) -> WriteAckEnR { WriteAckEnR :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
# [inline (always)]
pub fn irq_en (& self) -> IrqEnR { IrqEnR :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bit 0 - Разрешение работы канала"]
# [inline (always)]
pub fn enable (& mut self) -> EnableW < Ch2CfgSpec > { EnableW :: new (self , 0) } # [doc = "Bits 1:2 - Приоритет канала"]
# [inline (always)]
pub fn prior (& mut self) -> PriorW < Ch2CfgSpec > { PriorW :: new (self , 1) } # [doc = "Bit 3 - Режим адреса источника"]
# [inline (always)]
pub fn read_mode (& mut self) -> ReadModeW < Ch2CfgSpec > { ReadModeW :: new (self , 3) } # [doc = "Bit 4 - Режим адреса назначения"]
# [inline (always)]
pub fn write_mode (& mut self) -> WriteModeW < Ch2CfgSpec > { WriteModeW :: new (self , 4) } # [doc = "Bit 5 - Инкремент адреса источника"]
# [inline (always)]
pub fn read_increment (& mut self) -> ReadIncrementW < Ch2CfgSpec > { ReadIncrementW :: new (self , 5) } # [doc = "Bit 5 - Инкремент адреса назначения"]
# [inline (always)]
pub fn write_increment (& mut self) -> WriteIncrementW < Ch2CfgSpec > { WriteIncrementW :: new (self , 5) } # [doc = "Bits 7:8 - Разрядность адреса источника. Должно быть кратно data_len"]
# [inline (always)]
pub fn read_size (& mut self) -> ReadSizeW < Ch2CfgSpec > { ReadSizeW :: new (self , 7) } # [doc = "Bits 9:10 - Разрядность адреса назначения. Должно быть кратно LEN"]
# [inline (always)]
pub fn write_size (& mut self) -> WriteSizeW < Ch2CfgSpec > { WriteSizeW :: new (self , 9) } # [doc = "Bits 11:13 - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
# [inline (always)]
pub fn read_burst_size (& mut self) -> ReadBurstSizeW < Ch2CfgSpec > { ReadBurstSizeW :: new (self , 11) } # [doc = "Bits 14:16 - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
# [inline (always)]
pub fn write_burst_size (& mut self) -> WriteBurstSizeW < Ch2CfgSpec > { WriteBurstSizeW :: new (self , 14) } # [doc = "Bits 17:20 - Выбор периферийной линии источника"]
# [inline (always)]
pub fn read_request (& mut self) -> ReadRequestW < Ch2CfgSpec > { ReadRequestW :: new (self , 17) } # [doc = "Bits 21:24 - Выбор периферийной линии назначения"]
# [inline (always)]
pub fn write_request (& mut self) -> WriteRequestW < Ch2CfgSpec > { WriteRequestW :: new (self , 21) } # [doc = "Bit 25 - Разрешение работы логики с откликом для адресата источника"]
# [inline (always)]
pub fn read_ack_en (& mut self) -> ReadAckEnW < Ch2CfgSpec > { ReadAckEnW :: new (self , 25) } # [doc = "Bit 26 - Разрешение работы логики с откликом для адресата назначения"]
# [inline (always)]
pub fn write_ack_en (& mut self) -> WriteAckEnW < Ch2CfgSpec > { WriteAckEnW :: new (self , 26) } # [doc = "Bit 27 - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
# [inline (always)]
pub fn irq_en (& mut self) -> IrqEnW < Ch2CfgSpec > { IrqEnW :: new (self , 27) } } # [doc = "Регистр управления и конфигурации канала 2\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch2CfgSpec ; impl crate :: RegisterSpec for Ch2CfgSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch2_cfg::R`](R) reader structure"]
impl crate :: Readable for Ch2CfgSpec { } # [doc = "`write(|w| ..)` method takes [`ch2_cfg::W`](W) writer structure"]
impl crate :: Writable for Ch2CfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH2_CFG to value 0"]
impl crate :: Resettable for Ch2CfgSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH3_DST (rw) register accessor: Регистр адреса назначения канала 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_dst::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_dst::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch3_dst`]
module"]
# [doc (alias = "CH3_DST")]
pub type Ch3Dst = crate :: Reg < ch3_dst :: Ch3DstSpec > ; # [doc = "Регистр адреса назначения канала 3"]
pub mod ch3_dst { # [doc = "Register `CH3_DST` reader"]
pub type R = crate :: R < Ch3DstSpec > ; # [doc = "Register `CH3_DST` writer"]
pub type W = crate :: W < Ch3DstSpec > ; # [doc = "Field `Dst` reader - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
pub type DstR = crate :: FieldReader < u32 > ; # [doc = "Field `Dst` writer - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
pub type DstW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
# [inline (always)]
pub fn dst (& self) -> DstR { DstR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
# [inline (always)]
pub fn dst (& mut self) -> DstW < Ch3DstSpec > { DstW :: new (self , 0) } } # [doc = "Регистр адреса назначения канала 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_dst::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_dst::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch3DstSpec ; impl crate :: RegisterSpec for Ch3DstSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch3_dst::R`](R) reader structure"]
impl crate :: Readable for Ch3DstSpec { } # [doc = "`write(|w| ..)` method takes [`ch3_dst::W`](W) writer structure"]
impl crate :: Writable for Ch3DstSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH3_DST to value 0"]
impl crate :: Resettable for Ch3DstSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH3_SRC (rw) register accessor: Регистр адреса источника канала 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_src::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_src::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch3_src`]
module"]
# [doc (alias = "CH3_SRC")]
pub type Ch3Src = crate :: Reg < ch3_src :: Ch3SrcSpec > ; # [doc = "Регистр адреса источника канала 3"]
pub mod ch3_src { # [doc = "Register `CH3_SRC` reader"]
pub type R = crate :: R < Ch3SrcSpec > ; # [doc = "Register `CH3_SRC` writer"]
pub type W = crate :: W < Ch3SrcSpec > ; # [doc = "Field `Src` reader - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
pub type SrcR = crate :: FieldReader < u32 > ; # [doc = "Field `Src` writer - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
pub type SrcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
# [inline (always)]
pub fn src (& self) -> SrcR { SrcR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
# [inline (always)]
pub fn src (& mut self) -> SrcW < Ch3SrcSpec > { SrcW :: new (self , 0) } } # [doc = "Регистр адреса источника канала 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_src::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_src::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch3SrcSpec ; impl crate :: RegisterSpec for Ch3SrcSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch3_src::R`](R) reader structure"]
impl crate :: Readable for Ch3SrcSpec { } # [doc = "`write(|w| ..)` method takes [`ch3_src::W`](W) writer structure"]
impl crate :: Writable for Ch3SrcSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH3_SRC to value 0"]
impl crate :: Resettable for Ch3SrcSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH3_LEN (rw) register accessor: Регистр размера передаваемых данных канала 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch3_len`]
module"]
# [doc (alias = "CH3_LEN")]
pub type Ch3Len = crate :: Reg < ch3_len :: Ch3LenSpec > ; # [doc = "Регистр размера передаваемых данных канала 3"]
pub mod ch3_len { # [doc = "Register `CH3_LEN` reader"]
pub type R = crate :: R < Ch3LenSpec > ; # [doc = "Register `CH3_LEN` writer"]
pub type W = crate :: W < Ch3LenSpec > ; # [doc = "Field `Data_Len` reader - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
pub type DataLenR = crate :: FieldReader < u32 > ; # [doc = "Field `Data_Len` writer - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
pub type DataLenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
# [inline (always)]
pub fn data_len (& self) -> DataLenR { DataLenR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
# [inline (always)]
pub fn data_len (& mut self) -> DataLenW < Ch3LenSpec > { DataLenW :: new (self , 0) } } # [doc = "Регистр размера передаваемых данных канала 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch3LenSpec ; impl crate :: RegisterSpec for Ch3LenSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch3_len::R`](R) reader structure"]
impl crate :: Readable for Ch3LenSpec { } # [doc = "`write(|w| ..)` method takes [`ch3_len::W`](W) writer structure"]
impl crate :: Writable for Ch3LenSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH3_LEN to value 0"]
impl crate :: Resettable for Ch3LenSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH3_CFG (rw) register accessor: Регистр управления и конфигурации канала 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch3_cfg`]
module"]
# [doc (alias = "CH3_CFG")]
pub type Ch3Cfg = crate :: Reg < ch3_cfg :: Ch3CfgSpec > ; # [doc = "Регистр управления и конфигурации канала 3"]
pub mod ch3_cfg { # [doc = "Register `CH3_CFG` reader"]
pub type R = crate :: R < Ch3CfgSpec > ; # [doc = "Register `CH3_CFG` writer"]
pub type W = crate :: W < Ch3CfgSpec > ; # [doc = "Разрешение работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Enable { # [doc = "0: Принудительная остановка"]
Stop = 0 , # [doc = "1: Инициализация работы канала"]
Start = 1 , } impl From < Enable > for bool { # [inline (always)]
fn from (variant : Enable) -> Self { variant as u8 != 0 } } # [doc = "Field `ENABLE` reader - Разрешение работы канала"]
pub type EnableR = crate :: BitReader < Enable > ; impl EnableR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Enable { match self . bits { false => Enable :: Stop , true => Enable :: Start , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == Enable :: Stop } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_start (& self) -> bool { * self == Enable :: Start } } # [doc = "Field `ENABLE` writer - Разрешение работы канала"]
pub type EnableW < 'a , REG > = crate :: BitWriter < 'a , REG , Enable > ; impl < 'a , REG > EnableW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn stop (self) -> & 'a mut crate :: W < REG > { self . variant (Enable :: Stop) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn start (self) -> & 'a mut crate :: W < REG > { self . variant (Enable :: Start) } } # [doc = "Приоритет канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Prior { # [doc = "0: Принудительная остановка"]
Low = 0 , # [doc = "1: Инициализация работы канала"]
Medium = 1 , # [doc = "2: Инициализация работы канала"]
High = 2 , # [doc = "3: Инициализация работы канала"]
VeryHigh = 3 , } impl From < Prior > for u8 { # [inline (always)]
fn from (variant : Prior) -> Self { variant as _ } } impl crate :: FieldSpec for Prior { type Ux = u8 ; } impl crate :: IsEnum for Prior { } # [doc = "Field `PRIOR` reader - Приоритет канала"]
pub type PriorR = crate :: FieldReader < Prior > ; impl PriorR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Prior { match self . bits { 0 => Prior :: Low , 1 => Prior :: Medium , 2 => Prior :: High , 3 => Prior :: VeryHigh , _ => unreachable ! () , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == Prior :: Low } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_medium (& self) -> bool { * self == Prior :: Medium } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == Prior :: High } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_very_high (& self) -> bool { * self == Prior :: VeryHigh } } # [doc = "Field `PRIOR` writer - Приоритет канала"]
pub type PriorW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Prior , crate :: Safe > ; impl < 'a , REG > PriorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn low (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: Low) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn medium (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: Medium) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn high (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: High) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn very_high (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: VeryHigh) } } # [doc = "Режим адреса источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadMode { # [doc = "0: Принудительная остановка"]
Periphery = 0 , # [doc = "1: Инициализация работы канала"]
Memory = 1 , } impl From < ReadMode > for bool { # [inline (always)]
fn from (variant : ReadMode) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_MODE` reader - Режим адреса источника"]
pub type ReadModeR = crate :: BitReader < ReadMode > ; impl ReadModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadMode { match self . bits { false => ReadMode :: Periphery , true => ReadMode :: Memory , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_periphery (& self) -> bool { * self == ReadMode :: Periphery } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_memory (& self) -> bool { * self == ReadMode :: Memory } } # [doc = "Field `READ_MODE` writer - Режим адреса источника"]
pub type ReadModeW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadMode > ; impl < 'a , REG > ReadModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn periphery (self) -> & 'a mut crate :: W < REG > { self . variant (ReadMode :: Periphery) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn memory (self) -> & 'a mut crate :: W < REG > { self . variant (ReadMode :: Memory) } } # [doc = "Режим адреса назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteMode { # [doc = "0: Принудительная остановка"]
Periphery = 0 , # [doc = "1: Инициализация работы канала"]
Memory = 1 , } impl From < WriteMode > for bool { # [inline (always)]
fn from (variant : WriteMode) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_MODE` reader - Режим адреса назначения"]
pub type WriteModeR = crate :: BitReader < WriteMode > ; impl WriteModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteMode { match self . bits { false => WriteMode :: Periphery , true => WriteMode :: Memory , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_periphery (& self) -> bool { * self == WriteMode :: Periphery } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_memory (& self) -> bool { * self == WriteMode :: Memory } } # [doc = "Field `WRITE_MODE` writer - Режим адреса назначения"]
pub type WriteModeW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteMode > ; impl < 'a , REG > WriteModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn periphery (self) -> & 'a mut crate :: W < REG > { self . variant (WriteMode :: Periphery) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn memory (self) -> & 'a mut crate :: W < REG > { self . variant (WriteMode :: Memory) } } # [doc = "Инкремент адреса источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadIncrement { # [doc = "0: Нет инкремента"]
NoIncrement = 0 , # [doc = "1: Есть инкремент"]
Increment = 1 , } impl From < ReadIncrement > for bool { # [inline (always)]
fn from (variant : ReadIncrement) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_INCREMENT` reader - Инкремент адреса источника"]
pub type ReadIncrementR = crate :: BitReader < ReadIncrement > ; impl ReadIncrementR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadIncrement { match self . bits { false => ReadIncrement :: NoIncrement , true => ReadIncrement :: Increment , } } # [doc = "Нет инкремента"]
# [inline (always)]
pub fn is_no_increment (& self) -> bool { * self == ReadIncrement :: NoIncrement } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn is_increment (& self) -> bool { * self == ReadIncrement :: Increment } } # [doc = "Field `READ_INCREMENT` writer - Инкремент адреса источника"]
pub type ReadIncrementW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadIncrement > ; impl < 'a , REG > ReadIncrementW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Нет инкремента"]
# [inline (always)]
pub fn no_increment (self) -> & 'a mut crate :: W < REG > { self . variant (ReadIncrement :: NoIncrement) } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn increment (self) -> & 'a mut crate :: W < REG > { self . variant (ReadIncrement :: Increment) } } # [doc = "Инкремент адреса назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteIncrement { # [doc = "0: Нет инкремента"]
NoIncrement = 0 , # [doc = "1: Есть инкремент"]
Increment = 1 , } impl From < WriteIncrement > for bool { # [inline (always)]
fn from (variant : WriteIncrement) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_INCREMENT` reader - Инкремент адреса назначения"]
pub type WriteIncrementR = crate :: BitReader < WriteIncrement > ; impl WriteIncrementR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteIncrement { match self . bits { false => WriteIncrement :: NoIncrement , true => WriteIncrement :: Increment , } } # [doc = "Нет инкремента"]
# [inline (always)]
pub fn is_no_increment (& self) -> bool { * self == WriteIncrement :: NoIncrement } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn is_increment (& self) -> bool { * self == WriteIncrement :: Increment } } # [doc = "Field `WRITE_INCREMENT` writer - Инкремент адреса назначения"]
pub type WriteIncrementW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteIncrement > ; impl < 'a , REG > WriteIncrementW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Нет инкремента"]
# [inline (always)]
pub fn no_increment (self) -> & 'a mut crate :: W < REG > { self . variant (WriteIncrement :: NoIncrement) } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn increment (self) -> & 'a mut crate :: W < REG > { self . variant (WriteIncrement :: Increment) } } # [doc = "Разрядность адреса источника. Должно быть кратно data_len\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ReadSize { # [doc = "0: Байт"]
Byte = 0 , # [doc = "1: Полуслово"]
_2byte = 1 , # [doc = "2: Слово"]
_4byte = 2 , } impl From < ReadSize > for u8 { # [inline (always)]
fn from (variant : ReadSize) -> Self { variant as _ } } impl crate :: FieldSpec for ReadSize { type Ux = u8 ; } impl crate :: IsEnum for ReadSize { } # [doc = "Field `READ_SIZE` reader - Разрядность адреса источника. Должно быть кратно data_len"]
pub type ReadSizeR = crate :: FieldReader < ReadSize > ; impl ReadSizeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < ReadSize > { match self . bits { 0 => Some (ReadSize :: Byte) , 1 => Some (ReadSize :: _2byte) , 2 => Some (ReadSize :: _4byte) , _ => None , } } # [doc = "Байт"]
# [inline (always)]
pub fn is_byte (& self) -> bool { * self == ReadSize :: Byte } # [doc = "Полуслово"]
# [inline (always)]
pub fn is_2byte (& self) -> bool { * self == ReadSize :: _2byte } # [doc = "Слово"]
# [inline (always)]
pub fn is_4byte (& self) -> bool { * self == ReadSize :: _4byte } } # [doc = "Field `READ_SIZE` writer - Разрядность адреса источника. Должно быть кратно data_len"]
pub type ReadSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , ReadSize > ; impl < 'a , REG > ReadSizeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Байт"]
# [inline (always)]
pub fn byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: Byte) } # [doc = "Полуслово"]
# [inline (always)]
pub fn _2byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: _2byte) } # [doc = "Слово"]
# [inline (always)]
pub fn _4byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: _4byte) } } # [doc = "Разрядность адреса назначения. Должно быть кратно LEN\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WriteSize { # [doc = "0: Байт"]
Byte = 0 , # [doc = "1: Полуслово"]
_2byte = 1 , # [doc = "2: Слово"]
_4byte = 2 , } impl From < WriteSize > for u8 { # [inline (always)]
fn from (variant : WriteSize) -> Self { variant as _ } } impl crate :: FieldSpec for WriteSize { type Ux = u8 ; } impl crate :: IsEnum for WriteSize { } # [doc = "Field `WRITE_SIZE` reader - Разрядность адреса назначения. Должно быть кратно LEN"]
pub type WriteSizeR = crate :: FieldReader < WriteSize > ; impl WriteSizeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < WriteSize > { match self . bits { 0 => Some (WriteSize :: Byte) , 1 => Some (WriteSize :: _2byte) , 2 => Some (WriteSize :: _4byte) , _ => None , } } # [doc = "Байт"]
# [inline (always)]
pub fn is_byte (& self) -> bool { * self == WriteSize :: Byte } # [doc = "Полуслово"]
# [inline (always)]
pub fn is_2byte (& self) -> bool { * self == WriteSize :: _2byte } # [doc = "Слово"]
# [inline (always)]
pub fn is_4byte (& self) -> bool { * self == WriteSize :: _4byte } } # [doc = "Field `WRITE_SIZE` writer - Разрядность адреса назначения. Должно быть кратно LEN"]
pub type WriteSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , WriteSize > ; impl < 'a , REG > WriteSizeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Байт"]
# [inline (always)]
pub fn byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: Byte) } # [doc = "Полуслово"]
# [inline (always)]
pub fn _2byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: _2byte) } # [doc = "Слово"]
# [inline (always)]
pub fn _4byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: _4byte) } } # [doc = "Field `READ_BURST_SIZE` reader - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
pub type ReadBurstSizeR = crate :: FieldReader ; # [doc = "Field `READ_BURST_SIZE` writer - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
pub type ReadBurstSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `WRITE_BURST_SIZE` reader - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
pub type WriteBurstSizeR = crate :: FieldReader ; # [doc = "Field `WRITE_BURST_SIZE` writer - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
pub type WriteBurstSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Выбор периферийной линии источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ReadRequest { # [doc = "0: Линия запросов от USART_0"]
Usart0 = 0 , # [doc = "1: Линия запросов от USART_1"]
Usart1 = 1 , # [doc = "2: Линия запросов от крипто-блока"]
Crypto = 2 , # [doc = "3: Линия запросов от SPI_0"]
Spi0 = 3 , # [doc = "4: Линия запросов от SPI_1"]
Spi1 = 4 , # [doc = "5: Линия запросов от I2C_0"]
I2c0 = 5 , # [doc = "6: Линия запросов от I2C_1"]
I2c1 = 6 , # [doc = "7: Линия запросов от SPIFI"]
Spifi = 7 , # [doc = "8: Линия запросов от Timer32_1"]
Timer32_1 = 8 , # [doc = "9: Линия запросов от Timer32_2"]
Timer32_2 = 9 , # [doc = "10: Линия запросов от DAC0"]
Dac0 = 10 , # [doc = "11: Линия запросов от DAC1"]
Dac1 = 11 , # [doc = "12: Линия запросов от Timer32_0"]
Timer32_0 = 12 , } impl From < ReadRequest > for u8 { # [inline (always)]
fn from (variant : ReadRequest) -> Self { variant as _ } } impl crate :: FieldSpec for ReadRequest { type Ux = u8 ; } impl crate :: IsEnum for ReadRequest { } # [doc = "Field `READ_REQUEST` reader - Выбор периферийной линии источника"]
pub type ReadRequestR = crate :: FieldReader < ReadRequest > ; impl ReadRequestR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < ReadRequest > { match self . bits { 0 => Some (ReadRequest :: Usart0) , 1 => Some (ReadRequest :: Usart1) , 2 => Some (ReadRequest :: Crypto) , 3 => Some (ReadRequest :: Spi0) , 4 => Some (ReadRequest :: Spi1) , 5 => Some (ReadRequest :: I2c0) , 6 => Some (ReadRequest :: I2c1) , 7 => Some (ReadRequest :: Spifi) , 8 => Some (ReadRequest :: Timer32_1) , 9 => Some (ReadRequest :: Timer32_2) , 10 => Some (ReadRequest :: Dac0) , 11 => Some (ReadRequest :: Dac1) , 12 => Some (ReadRequest :: Timer32_0) , _ => None , } } # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn is_usart_0 (& self) -> bool { * self == ReadRequest :: Usart0 } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn is_usart_1 (& self) -> bool { * self == ReadRequest :: Usart1 } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn is_crypto (& self) -> bool { * self == ReadRequest :: Crypto } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn is_spi_0 (& self) -> bool { * self == ReadRequest :: Spi0 } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn is_spi_1 (& self) -> bool { * self == ReadRequest :: Spi1 } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn is_i2c_0 (& self) -> bool { * self == ReadRequest :: I2c0 } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn is_i2c_1 (& self) -> bool { * self == ReadRequest :: I2c1 } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn is_spifi (& self) -> bool { * self == ReadRequest :: Spifi } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn is_timer32_1 (& self) -> bool { * self == ReadRequest :: Timer32_1 } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn is_timer32_2 (& self) -> bool { * self == ReadRequest :: Timer32_2 } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn is_dac0 (& self) -> bool { * self == ReadRequest :: Dac0 } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn is_dac1 (& self) -> bool { * self == ReadRequest :: Dac1 } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn is_timer32_0 (& self) -> bool { * self == ReadRequest :: Timer32_0 } } # [doc = "Field `READ_REQUEST` writer - Выбор периферийной линии источника"]
pub type ReadRequestW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , ReadRequest > ; impl < 'a , REG > ReadRequestW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn usart_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Usart0) } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn usart_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Usart1) } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn crypto (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Crypto) } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn spi_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spi0) } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn spi_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spi1) } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn i2c_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: I2c0) } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn i2c_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: I2c1) } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn spifi (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spifi) } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn timer32_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_1) } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn timer32_2 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_2) } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn dac0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Dac0) } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn dac1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Dac1) } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn timer32_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_0) } } # [doc = "Выбор периферийной линии назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WriteRequest { # [doc = "0: Линия запросов от USART_0"]
Usart0 = 0 , # [doc = "1: Линия запросов от USART_1"]
Usart1 = 1 , # [doc = "2: Линия запросов от крипто-блока"]
Crypto = 2 , # [doc = "3: Линия запросов от SPI_0"]
Spi0 = 3 , # [doc = "4: Линия запросов от SPI_1"]
Spi1 = 4 , # [doc = "5: Линия запросов от I2C_0"]
I2c0 = 5 , # [doc = "6: Линия запросов от I2C_1"]
I2c1 = 6 , # [doc = "7: Линия запросов от SPIFI"]
Spifi = 7 , # [doc = "8: Линия запросов от Timer32_1"]
Timer32_1 = 8 , # [doc = "9: Линия запросов от Timer32_2"]
Timer32_2 = 9 , # [doc = "10: Линия запросов от DAC0"]
Dac0 = 10 , # [doc = "11: Линия запросов от DAC1"]
Dac1 = 11 , # [doc = "12: Линия запросов от Timer32_0"]
Timer32_0 = 12 , } impl From < WriteRequest > for u8 { # [inline (always)]
fn from (variant : WriteRequest) -> Self { variant as _ } } impl crate :: FieldSpec for WriteRequest { type Ux = u8 ; } impl crate :: IsEnum for WriteRequest { } # [doc = "Field `WRITE_REQUEST` reader - Выбор периферийной линии назначения"]
pub type WriteRequestR = crate :: FieldReader < WriteRequest > ; impl WriteRequestR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < WriteRequest > { match self . bits { 0 => Some (WriteRequest :: Usart0) , 1 => Some (WriteRequest :: Usart1) , 2 => Some (WriteRequest :: Crypto) , 3 => Some (WriteRequest :: Spi0) , 4 => Some (WriteRequest :: Spi1) , 5 => Some (WriteRequest :: I2c0) , 6 => Some (WriteRequest :: I2c1) , 7 => Some (WriteRequest :: Spifi) , 8 => Some (WriteRequest :: Timer32_1) , 9 => Some (WriteRequest :: Timer32_2) , 10 => Some (WriteRequest :: Dac0) , 11 => Some (WriteRequest :: Dac1) , 12 => Some (WriteRequest :: Timer32_0) , _ => None , } } # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn is_usart_0 (& self) -> bool { * self == WriteRequest :: Usart0 } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn is_usart_1 (& self) -> bool { * self == WriteRequest :: Usart1 } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn is_crypto (& self) -> bool { * self == WriteRequest :: Crypto } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn is_spi_0 (& self) -> bool { * self == WriteRequest :: Spi0 } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn is_spi_1 (& self) -> bool { * self == WriteRequest :: Spi1 } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn is_i2c_0 (& self) -> bool { * self == WriteRequest :: I2c0 } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn is_i2c_1 (& self) -> bool { * self == WriteRequest :: I2c1 } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn is_spifi (& self) -> bool { * self == WriteRequest :: Spifi } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn is_timer32_1 (& self) -> bool { * self == WriteRequest :: Timer32_1 } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn is_timer32_2 (& self) -> bool { * self == WriteRequest :: Timer32_2 } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn is_dac0 (& self) -> bool { * self == WriteRequest :: Dac0 } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn is_dac1 (& self) -> bool { * self == WriteRequest :: Dac1 } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn is_timer32_0 (& self) -> bool { * self == WriteRequest :: Timer32_0 } } # [doc = "Field `WRITE_REQUEST` writer - Выбор периферийной линии назначения"]
pub type WriteRequestW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , WriteRequest > ; impl < 'a , REG > WriteRequestW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn usart_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Usart0) } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn usart_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Usart1) } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn crypto (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Crypto) } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn spi_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spi0) } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn spi_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spi1) } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn i2c_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: I2c0) } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn i2c_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: I2c1) } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn spifi (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spifi) } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn timer32_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_1) } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn timer32_2 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_2) } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn dac0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Dac0) } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn dac1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Dac1) } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn timer32_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_0) } } # [doc = "Разрешение работы логики с откликом для адресата источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadAckEn { # [doc = "0: Запрещено"]
Disable = 0 , # [doc = "1: Разрешено"]
Enable = 1 , } impl From < ReadAckEn > for bool { # [inline (always)]
fn from (variant : ReadAckEn) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_ACK_EN` reader - Разрешение работы логики с откликом для адресата источника"]
pub type ReadAckEnR = crate :: BitReader < ReadAckEn > ; impl ReadAckEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadAckEn { match self . bits { false => ReadAckEn :: Disable , true => ReadAckEn :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == ReadAckEn :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == ReadAckEn :: Enable } } # [doc = "Field `READ_ACK_EN` writer - Разрешение работы логики с откликом для адресата источника"]
pub type ReadAckEnW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadAckEn > ; impl < 'a , REG > ReadAckEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (ReadAckEn :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (ReadAckEn :: Enable) } } # [doc = "Разрешение работы логики с откликом для адресата назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteAckEn { # [doc = "0: Запрещено"]
Disable = 0 , # [doc = "1: Разрешено"]
Enable = 1 , } impl From < WriteAckEn > for bool { # [inline (always)]
fn from (variant : WriteAckEn) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_ACK_EN` reader - Разрешение работы логики с откликом для адресата назначения"]
pub type WriteAckEnR = crate :: BitReader < WriteAckEn > ; impl WriteAckEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteAckEn { match self . bits { false => WriteAckEn :: Disable , true => WriteAckEn :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WriteAckEn :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WriteAckEn :: Enable } } # [doc = "Field `WRITE_ACK_EN` writer - Разрешение работы логики с откликом для адресата назначения"]
pub type WriteAckEnW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteAckEn > ; impl < 'a , REG > WriteAckEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WriteAckEn :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WriteAckEn :: Enable) } } # [doc = "Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum IrqEn { # [doc = "0: Прерывание не формируется"]
Disable = 0 , # [doc = "1: Прерывание формируется"]
Enable = 1 , } impl From < IrqEn > for bool { # [inline (always)]
fn from (variant : IrqEn) -> Self { variant as u8 != 0 } } # [doc = "Field `IRQ_EN` reader - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
pub type IrqEnR = crate :: BitReader < IrqEn > ; impl IrqEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> IrqEn { match self . bits { false => IrqEn :: Disable , true => IrqEn :: Enable , } } # [doc = "Прерывание не формируется"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == IrqEn :: Disable } # [doc = "Прерывание формируется"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == IrqEn :: Enable } } # [doc = "Field `IRQ_EN` writer - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
pub type IrqEnW < 'a , REG > = crate :: BitWriter < 'a , REG , IrqEn > ; impl < 'a , REG > IrqEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание не формируется"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (IrqEn :: Disable) } # [doc = "Прерывание формируется"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (IrqEn :: Enable) } } impl R { # [doc = "Bit 0 - Разрешение работы канала"]
# [inline (always)]
pub fn enable (& self) -> EnableR { EnableR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Приоритет канала"]
# [inline (always)]
pub fn prior (& self) -> PriorR { PriorR :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bit 3 - Режим адреса источника"]
# [inline (always)]
pub fn read_mode (& self) -> ReadModeR { ReadModeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Режим адреса назначения"]
# [inline (always)]
pub fn write_mode (& self) -> WriteModeR { WriteModeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Инкремент адреса источника"]
# [inline (always)]
pub fn read_increment (& self) -> ReadIncrementR { ReadIncrementR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 5 - Инкремент адреса назначения"]
# [inline (always)]
pub fn write_increment (& self) -> WriteIncrementR { WriteIncrementR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 7:8 - Разрядность адреса источника. Должно быть кратно data_len"]
# [inline (always)]
pub fn read_size (& self) -> ReadSizeR { ReadSizeR :: new (((self . bits >> 7) & 3) as u8) } # [doc = "Bits 9:10 - Разрядность адреса назначения. Должно быть кратно LEN"]
# [inline (always)]
pub fn write_size (& self) -> WriteSizeR { WriteSizeR :: new (((self . bits >> 9) & 3) as u8) } # [doc = "Bits 11:13 - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
# [inline (always)]
pub fn read_burst_size (& self) -> ReadBurstSizeR { ReadBurstSizeR :: new (((self . bits >> 11) & 7) as u8) } # [doc = "Bits 14:16 - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
# [inline (always)]
pub fn write_burst_size (& self) -> WriteBurstSizeR { WriteBurstSizeR :: new (((self . bits >> 14) & 7) as u8) } # [doc = "Bits 17:20 - Выбор периферийной линии источника"]
# [inline (always)]
pub fn read_request (& self) -> ReadRequestR { ReadRequestR :: new (((self . bits >> 17) & 0x0f) as u8) } # [doc = "Bits 21:24 - Выбор периферийной линии назначения"]
# [inline (always)]
pub fn write_request (& self) -> WriteRequestR { WriteRequestR :: new (((self . bits >> 21) & 0x0f) as u8) } # [doc = "Bit 25 - Разрешение работы логики с откликом для адресата источника"]
# [inline (always)]
pub fn read_ack_en (& self) -> ReadAckEnR { ReadAckEnR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Разрешение работы логики с откликом для адресата назначения"]
# [inline (always)]
pub fn write_ack_en (& self) -> WriteAckEnR { WriteAckEnR :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
# [inline (always)]
pub fn irq_en (& self) -> IrqEnR { IrqEnR :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bit 0 - Разрешение работы канала"]
# [inline (always)]
pub fn enable (& mut self) -> EnableW < Ch3CfgSpec > { EnableW :: new (self , 0) } # [doc = "Bits 1:2 - Приоритет канала"]
# [inline (always)]
pub fn prior (& mut self) -> PriorW < Ch3CfgSpec > { PriorW :: new (self , 1) } # [doc = "Bit 3 - Режим адреса источника"]
# [inline (always)]
pub fn read_mode (& mut self) -> ReadModeW < Ch3CfgSpec > { ReadModeW :: new (self , 3) } # [doc = "Bit 4 - Режим адреса назначения"]
# [inline (always)]
pub fn write_mode (& mut self) -> WriteModeW < Ch3CfgSpec > { WriteModeW :: new (self , 4) } # [doc = "Bit 5 - Инкремент адреса источника"]
# [inline (always)]
pub fn read_increment (& mut self) -> ReadIncrementW < Ch3CfgSpec > { ReadIncrementW :: new (self , 5) } # [doc = "Bit 5 - Инкремент адреса назначения"]
# [inline (always)]
pub fn write_increment (& mut self) -> WriteIncrementW < Ch3CfgSpec > { WriteIncrementW :: new (self , 5) } # [doc = "Bits 7:8 - Разрядность адреса источника. Должно быть кратно data_len"]
# [inline (always)]
pub fn read_size (& mut self) -> ReadSizeW < Ch3CfgSpec > { ReadSizeW :: new (self , 7) } # [doc = "Bits 9:10 - Разрядность адреса назначения. Должно быть кратно LEN"]
# [inline (always)]
pub fn write_size (& mut self) -> WriteSizeW < Ch3CfgSpec > { WriteSizeW :: new (self , 9) } # [doc = "Bits 11:13 - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
# [inline (always)]
pub fn read_burst_size (& mut self) -> ReadBurstSizeW < Ch3CfgSpec > { ReadBurstSizeW :: new (self , 11) } # [doc = "Bits 14:16 - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
# [inline (always)]
pub fn write_burst_size (& mut self) -> WriteBurstSizeW < Ch3CfgSpec > { WriteBurstSizeW :: new (self , 14) } # [doc = "Bits 17:20 - Выбор периферийной линии источника"]
# [inline (always)]
pub fn read_request (& mut self) -> ReadRequestW < Ch3CfgSpec > { ReadRequestW :: new (self , 17) } # [doc = "Bits 21:24 - Выбор периферийной линии назначения"]
# [inline (always)]
pub fn write_request (& mut self) -> WriteRequestW < Ch3CfgSpec > { WriteRequestW :: new (self , 21) } # [doc = "Bit 25 - Разрешение работы логики с откликом для адресата источника"]
# [inline (always)]
pub fn read_ack_en (& mut self) -> ReadAckEnW < Ch3CfgSpec > { ReadAckEnW :: new (self , 25) } # [doc = "Bit 26 - Разрешение работы логики с откликом для адресата назначения"]
# [inline (always)]
pub fn write_ack_en (& mut self) -> WriteAckEnW < Ch3CfgSpec > { WriteAckEnW :: new (self , 26) } # [doc = "Bit 27 - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
# [inline (always)]
pub fn irq_en (& mut self) -> IrqEnW < Ch3CfgSpec > { IrqEnW :: new (self , 27) } } # [doc = "Регистр управления и конфигурации канала 3\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch3CfgSpec ; impl crate :: RegisterSpec for Ch3CfgSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch3_cfg::R`](R) reader structure"]
impl crate :: Readable for Ch3CfgSpec { } # [doc = "`write(|w| ..)` method takes [`ch3_cfg::W`](W) writer structure"]
impl crate :: Writable for Ch3CfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH3_CFG to value 0"]
impl crate :: Resettable for Ch3CfgSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH4_DST (rw) register accessor: Регистр адреса назначения канала 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_dst::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_dst::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch4_dst`]
module"]
# [doc (alias = "CH4_DST")]
pub type Ch4Dst = crate :: Reg < ch4_dst :: Ch4DstSpec > ; # [doc = "Регистр адреса назначения канала 4"]
pub mod ch4_dst { # [doc = "Register `CH4_DST` reader"]
pub type R = crate :: R < Ch4DstSpec > ; # [doc = "Register `CH4_DST` writer"]
pub type W = crate :: W < Ch4DstSpec > ; # [doc = "Field `Dst` reader - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
pub type DstR = crate :: FieldReader < u32 > ; # [doc = "Field `Dst` writer - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
pub type DstW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
# [inline (always)]
pub fn dst (& self) -> DstR { DstR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Адрес назначения. В режиме чтения текущего статуса (Current_valuе=1) возвращает последнюю переданную подзадачу контроллера канала. В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса"]
# [inline (always)]
pub fn dst (& mut self) -> DstW < Ch4DstSpec > { DstW :: new (self , 0) } } # [doc = "Регистр адреса назначения канала 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_dst::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_dst::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch4DstSpec ; impl crate :: RegisterSpec for Ch4DstSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch4_dst::R`](R) reader structure"]
impl crate :: Readable for Ch4DstSpec { } # [doc = "`write(|w| ..)` method takes [`ch4_dst::W`](W) writer structure"]
impl crate :: Writable for Ch4DstSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH4_DST to value 0"]
impl crate :: Resettable for Ch4DstSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH4_SRC (rw) register accessor: Регистр адреса источника канала 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_src::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_src::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch4_src`]
module"]
# [doc (alias = "CH4_SRC")]
pub type Ch4Src = crate :: Reg < ch4_src :: Ch4SrcSpec > ; # [doc = "Регистр адреса источника канала 4"]
pub mod ch4_src { # [doc = "Register `CH4_SRC` reader"]
pub type R = crate :: R < Ch4SrcSpec > ; # [doc = "Register `CH4_SRC` writer"]
pub type W = crate :: W < Ch4SrcSpec > ; # [doc = "Field `Src` reader - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
pub type SrcR = crate :: FieldReader < u32 > ; # [doc = "Field `Src` writer - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
pub type SrcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
# [inline (always)]
pub fn src (& self) -> SrcR { SrcR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Адрес источника В режиме чтения текущего статуса (Current_valuе=1) возвращает текущую подзадачу контроллера канала. Указатель на адрес блока, который обрабатывается вычисляется как: Current_ch_read_task - 2^READ_BURST_SIZE В случае ошибки записи содержит указатель на текущий адрес мастер-интерфейса, вернувшего HRESP=1"]
# [inline (always)]
pub fn src (& mut self) -> SrcW < Ch4SrcSpec > { SrcW :: new (self , 0) } } # [doc = "Регистр адреса источника канала 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_src::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_src::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch4SrcSpec ; impl crate :: RegisterSpec for Ch4SrcSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch4_src::R`](R) reader structure"]
impl crate :: Readable for Ch4SrcSpec { } # [doc = "`write(|w| ..)` method takes [`ch4_src::W`](W) writer structure"]
impl crate :: Writable for Ch4SrcSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH4_SRC to value 0"]
impl crate :: Resettable for Ch4SrcSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH4_LEN (rw) register accessor: Регистр размера передаваемых данных канала 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_len::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_len::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch4_len`]
module"]
# [doc (alias = "CH4_LEN")]
pub type Ch4Len = crate :: Reg < ch4_len :: Ch4LenSpec > ; # [doc = "Регистр размера передаваемых данных канала 4"]
pub mod ch4_len { # [doc = "Register `CH4_LEN` reader"]
pub type R = crate :: R < Ch4LenSpec > ; # [doc = "Register `CH4_LEN` writer"]
pub type W = crate :: W < Ch4LenSpec > ; # [doc = "Field `Data_Len` reader - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
pub type DataLenR = crate :: FieldReader < u32 > ; # [doc = "Field `Data_Len` writer - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
pub type DataLenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
# [inline (always)]
pub fn data_len (& self) -> DataLenR { DataLenR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Количество байт пересылки рассчитывается как LEN +1 В режиме чтения текущего статуса (Current_valuе=1) возвращает счётчик байт подзадач контроллера. Счётчик байт подзадач обновляется только по подзадачам записи. Кол-во байт в блоках, которые удалось записать вычисляется как: If (state==write): LEN - 2^WRITE_BURST_SIZE If (state==read): Current byte len"]
# [inline (always)]
pub fn data_len (& mut self) -> DataLenW < Ch4LenSpec > { DataLenW :: new (self , 0) } } # [doc = "Регистр размера передаваемых данных канала 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_len::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_len::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch4LenSpec ; impl crate :: RegisterSpec for Ch4LenSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch4_len::R`](R) reader structure"]
impl crate :: Readable for Ch4LenSpec { } # [doc = "`write(|w| ..)` method takes [`ch4_len::W`](W) writer structure"]
impl crate :: Writable for Ch4LenSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH4_LEN to value 0"]
impl crate :: Resettable for Ch4LenSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH4_CFG (rw) register accessor: Регистр управления и конфигурации канала 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch4_cfg`]
module"]
# [doc (alias = "CH4_CFG")]
pub type Ch4Cfg = crate :: Reg < ch4_cfg :: Ch4CfgSpec > ; # [doc = "Регистр управления и конфигурации канала 4"]
pub mod ch4_cfg { # [doc = "Register `CH4_CFG` reader"]
pub type R = crate :: R < Ch4CfgSpec > ; # [doc = "Register `CH4_CFG` writer"]
pub type W = crate :: W < Ch4CfgSpec > ; # [doc = "Разрешение работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Enable { # [doc = "0: Принудительная остановка"]
Stop = 0 , # [doc = "1: Инициализация работы канала"]
Start = 1 , } impl From < Enable > for bool { # [inline (always)]
fn from (variant : Enable) -> Self { variant as u8 != 0 } } # [doc = "Field `ENABLE` reader - Разрешение работы канала"]
pub type EnableR = crate :: BitReader < Enable > ; impl EnableR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Enable { match self . bits { false => Enable :: Stop , true => Enable :: Start , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == Enable :: Stop } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_start (& self) -> bool { * self == Enable :: Start } } # [doc = "Field `ENABLE` writer - Разрешение работы канала"]
pub type EnableW < 'a , REG > = crate :: BitWriter < 'a , REG , Enable > ; impl < 'a , REG > EnableW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn stop (self) -> & 'a mut crate :: W < REG > { self . variant (Enable :: Stop) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn start (self) -> & 'a mut crate :: W < REG > { self . variant (Enable :: Start) } } # [doc = "Приоритет канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Prior { # [doc = "0: Принудительная остановка"]
Low = 0 , # [doc = "1: Инициализация работы канала"]
Medium = 1 , # [doc = "2: Инициализация работы канала"]
High = 2 , # [doc = "3: Инициализация работы канала"]
VeryHigh = 3 , } impl From < Prior > for u8 { # [inline (always)]
fn from (variant : Prior) -> Self { variant as _ } } impl crate :: FieldSpec for Prior { type Ux = u8 ; } impl crate :: IsEnum for Prior { } # [doc = "Field `PRIOR` reader - Приоритет канала"]
pub type PriorR = crate :: FieldReader < Prior > ; impl PriorR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Prior { match self . bits { 0 => Prior :: Low , 1 => Prior :: Medium , 2 => Prior :: High , 3 => Prior :: VeryHigh , _ => unreachable ! () , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == Prior :: Low } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_medium (& self) -> bool { * self == Prior :: Medium } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == Prior :: High } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_very_high (& self) -> bool { * self == Prior :: VeryHigh } } # [doc = "Field `PRIOR` writer - Приоритет канала"]
pub type PriorW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Prior , crate :: Safe > ; impl < 'a , REG > PriorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn low (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: Low) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn medium (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: Medium) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn high (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: High) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn very_high (self) -> & 'a mut crate :: W < REG > { self . variant (Prior :: VeryHigh) } } # [doc = "Режим адреса источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadMode { # [doc = "0: Принудительная остановка"]
Periphery = 0 , # [doc = "1: Инициализация работы канала"]
Memory = 1 , } impl From < ReadMode > for bool { # [inline (always)]
fn from (variant : ReadMode) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_MODE` reader - Режим адреса источника"]
pub type ReadModeR = crate :: BitReader < ReadMode > ; impl ReadModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadMode { match self . bits { false => ReadMode :: Periphery , true => ReadMode :: Memory , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_periphery (& self) -> bool { * self == ReadMode :: Periphery } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_memory (& self) -> bool { * self == ReadMode :: Memory } } # [doc = "Field `READ_MODE` writer - Режим адреса источника"]
pub type ReadModeW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadMode > ; impl < 'a , REG > ReadModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn periphery (self) -> & 'a mut crate :: W < REG > { self . variant (ReadMode :: Periphery) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn memory (self) -> & 'a mut crate :: W < REG > { self . variant (ReadMode :: Memory) } } # [doc = "Режим адреса назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteMode { # [doc = "0: Принудительная остановка"]
Periphery = 0 , # [doc = "1: Инициализация работы канала"]
Memory = 1 , } impl From < WriteMode > for bool { # [inline (always)]
fn from (variant : WriteMode) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_MODE` reader - Режим адреса назначения"]
pub type WriteModeR = crate :: BitReader < WriteMode > ; impl WriteModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteMode { match self . bits { false => WriteMode :: Periphery , true => WriteMode :: Memory , } } # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn is_periphery (& self) -> bool { * self == WriteMode :: Periphery } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn is_memory (& self) -> bool { * self == WriteMode :: Memory } } # [doc = "Field `WRITE_MODE` writer - Режим адреса назначения"]
pub type WriteModeW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteMode > ; impl < 'a , REG > WriteModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Принудительная остановка"]
# [inline (always)]
pub fn periphery (self) -> & 'a mut crate :: W < REG > { self . variant (WriteMode :: Periphery) } # [doc = "Инициализация работы канала"]
# [inline (always)]
pub fn memory (self) -> & 'a mut crate :: W < REG > { self . variant (WriteMode :: Memory) } } # [doc = "Инкремент адреса источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadIncrement { # [doc = "0: Нет инкремента"]
NoIncrement = 0 , # [doc = "1: Есть инкремент"]
Increment = 1 , } impl From < ReadIncrement > for bool { # [inline (always)]
fn from (variant : ReadIncrement) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_INCREMENT` reader - Инкремент адреса источника"]
pub type ReadIncrementR = crate :: BitReader < ReadIncrement > ; impl ReadIncrementR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadIncrement { match self . bits { false => ReadIncrement :: NoIncrement , true => ReadIncrement :: Increment , } } # [doc = "Нет инкремента"]
# [inline (always)]
pub fn is_no_increment (& self) -> bool { * self == ReadIncrement :: NoIncrement } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn is_increment (& self) -> bool { * self == ReadIncrement :: Increment } } # [doc = "Field `READ_INCREMENT` writer - Инкремент адреса источника"]
pub type ReadIncrementW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadIncrement > ; impl < 'a , REG > ReadIncrementW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Нет инкремента"]
# [inline (always)]
pub fn no_increment (self) -> & 'a mut crate :: W < REG > { self . variant (ReadIncrement :: NoIncrement) } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn increment (self) -> & 'a mut crate :: W < REG > { self . variant (ReadIncrement :: Increment) } } # [doc = "Инкремент адреса назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteIncrement { # [doc = "0: Нет инкремента"]
NoIncrement = 0 , # [doc = "1: Есть инкремент"]
Increment = 1 , } impl From < WriteIncrement > for bool { # [inline (always)]
fn from (variant : WriteIncrement) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_INCREMENT` reader - Инкремент адреса назначения"]
pub type WriteIncrementR = crate :: BitReader < WriteIncrement > ; impl WriteIncrementR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteIncrement { match self . bits { false => WriteIncrement :: NoIncrement , true => WriteIncrement :: Increment , } } # [doc = "Нет инкремента"]
# [inline (always)]
pub fn is_no_increment (& self) -> bool { * self == WriteIncrement :: NoIncrement } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn is_increment (& self) -> bool { * self == WriteIncrement :: Increment } } # [doc = "Field `WRITE_INCREMENT` writer - Инкремент адреса назначения"]
pub type WriteIncrementW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteIncrement > ; impl < 'a , REG > WriteIncrementW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Нет инкремента"]
# [inline (always)]
pub fn no_increment (self) -> & 'a mut crate :: W < REG > { self . variant (WriteIncrement :: NoIncrement) } # [doc = "Есть инкремент"]
# [inline (always)]
pub fn increment (self) -> & 'a mut crate :: W < REG > { self . variant (WriteIncrement :: Increment) } } # [doc = "Разрядность адреса источника. Должно быть кратно data_len\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ReadSize { # [doc = "0: Байт"]
Byte = 0 , # [doc = "1: Полуслово"]
_2byte = 1 , # [doc = "2: Слово"]
_4byte = 2 , } impl From < ReadSize > for u8 { # [inline (always)]
fn from (variant : ReadSize) -> Self { variant as _ } } impl crate :: FieldSpec for ReadSize { type Ux = u8 ; } impl crate :: IsEnum for ReadSize { } # [doc = "Field `READ_SIZE` reader - Разрядность адреса источника. Должно быть кратно data_len"]
pub type ReadSizeR = crate :: FieldReader < ReadSize > ; impl ReadSizeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < ReadSize > { match self . bits { 0 => Some (ReadSize :: Byte) , 1 => Some (ReadSize :: _2byte) , 2 => Some (ReadSize :: _4byte) , _ => None , } } # [doc = "Байт"]
# [inline (always)]
pub fn is_byte (& self) -> bool { * self == ReadSize :: Byte } # [doc = "Полуслово"]
# [inline (always)]
pub fn is_2byte (& self) -> bool { * self == ReadSize :: _2byte } # [doc = "Слово"]
# [inline (always)]
pub fn is_4byte (& self) -> bool { * self == ReadSize :: _4byte } } # [doc = "Field `READ_SIZE` writer - Разрядность адреса источника. Должно быть кратно data_len"]
pub type ReadSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , ReadSize > ; impl < 'a , REG > ReadSizeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Байт"]
# [inline (always)]
pub fn byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: Byte) } # [doc = "Полуслово"]
# [inline (always)]
pub fn _2byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: _2byte) } # [doc = "Слово"]
# [inline (always)]
pub fn _4byte (self) -> & 'a mut crate :: W < REG > { self . variant (ReadSize :: _4byte) } } # [doc = "Разрядность адреса назначения. Должно быть кратно LEN\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WriteSize { # [doc = "0: Байт"]
Byte = 0 , # [doc = "1: Полуслово"]
_2byte = 1 , # [doc = "2: Слово"]
_4byte = 2 , } impl From < WriteSize > for u8 { # [inline (always)]
fn from (variant : WriteSize) -> Self { variant as _ } } impl crate :: FieldSpec for WriteSize { type Ux = u8 ; } impl crate :: IsEnum for WriteSize { } # [doc = "Field `WRITE_SIZE` reader - Разрядность адреса назначения. Должно быть кратно LEN"]
pub type WriteSizeR = crate :: FieldReader < WriteSize > ; impl WriteSizeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < WriteSize > { match self . bits { 0 => Some (WriteSize :: Byte) , 1 => Some (WriteSize :: _2byte) , 2 => Some (WriteSize :: _4byte) , _ => None , } } # [doc = "Байт"]
# [inline (always)]
pub fn is_byte (& self) -> bool { * self == WriteSize :: Byte } # [doc = "Полуслово"]
# [inline (always)]
pub fn is_2byte (& self) -> bool { * self == WriteSize :: _2byte } # [doc = "Слово"]
# [inline (always)]
pub fn is_4byte (& self) -> bool { * self == WriteSize :: _4byte } } # [doc = "Field `WRITE_SIZE` writer - Разрядность адреса назначения. Должно быть кратно LEN"]
pub type WriteSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , WriteSize > ; impl < 'a , REG > WriteSizeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Байт"]
# [inline (always)]
pub fn byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: Byte) } # [doc = "Полуслово"]
# [inline (always)]
pub fn _2byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: _2byte) } # [doc = "Слово"]
# [inline (always)]
pub fn _4byte (self) -> & 'a mut crate :: W < REG > { self . variant (WriteSize :: _4byte) } } # [doc = "Field `READ_BURST_SIZE` reader - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
pub type ReadBurstSizeR = crate :: FieldReader ; # [doc = "Field `READ_BURST_SIZE` writer - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
pub type ReadBurstSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `WRITE_BURST_SIZE` reader - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
pub type WriteBurstSizeR = crate :: FieldReader ; # [doc = "Field `WRITE_BURST_SIZE` writer - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
pub type WriteBurstSizeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Выбор периферийной линии источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ReadRequest { # [doc = "0: Линия запросов от USART_0"]
Usart0 = 0 , # [doc = "1: Линия запросов от USART_1"]
Usart1 = 1 , # [doc = "2: Линия запросов от крипто-блока"]
Crypto = 2 , # [doc = "3: Линия запросов от SPI_0"]
Spi0 = 3 , # [doc = "4: Линия запросов от SPI_1"]
Spi1 = 4 , # [doc = "5: Линия запросов от I2C_0"]
I2c0 = 5 , # [doc = "6: Линия запросов от I2C_1"]
I2c1 = 6 , # [doc = "7: Линия запросов от SPIFI"]
Spifi = 7 , # [doc = "8: Линия запросов от Timer32_1"]
Timer32_1 = 8 , # [doc = "9: Линия запросов от Timer32_2"]
Timer32_2 = 9 , # [doc = "10: Линия запросов от DAC0"]
Dac0 = 10 , # [doc = "11: Линия запросов от DAC1"]
Dac1 = 11 , # [doc = "12: Линия запросов от Timer32_0"]
Timer32_0 = 12 , } impl From < ReadRequest > for u8 { # [inline (always)]
fn from (variant : ReadRequest) -> Self { variant as _ } } impl crate :: FieldSpec for ReadRequest { type Ux = u8 ; } impl crate :: IsEnum for ReadRequest { } # [doc = "Field `READ_REQUEST` reader - Выбор периферийной линии источника"]
pub type ReadRequestR = crate :: FieldReader < ReadRequest > ; impl ReadRequestR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < ReadRequest > { match self . bits { 0 => Some (ReadRequest :: Usart0) , 1 => Some (ReadRequest :: Usart1) , 2 => Some (ReadRequest :: Crypto) , 3 => Some (ReadRequest :: Spi0) , 4 => Some (ReadRequest :: Spi1) , 5 => Some (ReadRequest :: I2c0) , 6 => Some (ReadRequest :: I2c1) , 7 => Some (ReadRequest :: Spifi) , 8 => Some (ReadRequest :: Timer32_1) , 9 => Some (ReadRequest :: Timer32_2) , 10 => Some (ReadRequest :: Dac0) , 11 => Some (ReadRequest :: Dac1) , 12 => Some (ReadRequest :: Timer32_0) , _ => None , } } # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn is_usart_0 (& self) -> bool { * self == ReadRequest :: Usart0 } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn is_usart_1 (& self) -> bool { * self == ReadRequest :: Usart1 } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn is_crypto (& self) -> bool { * self == ReadRequest :: Crypto } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn is_spi_0 (& self) -> bool { * self == ReadRequest :: Spi0 } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn is_spi_1 (& self) -> bool { * self == ReadRequest :: Spi1 } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn is_i2c_0 (& self) -> bool { * self == ReadRequest :: I2c0 } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn is_i2c_1 (& self) -> bool { * self == ReadRequest :: I2c1 } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn is_spifi (& self) -> bool { * self == ReadRequest :: Spifi } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn is_timer32_1 (& self) -> bool { * self == ReadRequest :: Timer32_1 } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn is_timer32_2 (& self) -> bool { * self == ReadRequest :: Timer32_2 } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn is_dac0 (& self) -> bool { * self == ReadRequest :: Dac0 } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn is_dac1 (& self) -> bool { * self == ReadRequest :: Dac1 } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn is_timer32_0 (& self) -> bool { * self == ReadRequest :: Timer32_0 } } # [doc = "Field `READ_REQUEST` writer - Выбор периферийной линии источника"]
pub type ReadRequestW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , ReadRequest > ; impl < 'a , REG > ReadRequestW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn usart_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Usart0) } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn usart_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Usart1) } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn crypto (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Crypto) } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn spi_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spi0) } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn spi_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spi1) } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn i2c_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: I2c0) } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn i2c_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: I2c1) } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn spifi (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Spifi) } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn timer32_1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_1) } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn timer32_2 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_2) } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn dac0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Dac0) } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn dac1 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Dac1) } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn timer32_0 (self) -> & 'a mut crate :: W < REG > { self . variant (ReadRequest :: Timer32_0) } } # [doc = "Выбор периферийной линии назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WriteRequest { # [doc = "0: Линия запросов от USART_0"]
Usart0 = 0 , # [doc = "1: Линия запросов от USART_1"]
Usart1 = 1 , # [doc = "2: Линия запросов от крипто-блока"]
Crypto = 2 , # [doc = "3: Линия запросов от SPI_0"]
Spi0 = 3 , # [doc = "4: Линия запросов от SPI_1"]
Spi1 = 4 , # [doc = "5: Линия запросов от I2C_0"]
I2c0 = 5 , # [doc = "6: Линия запросов от I2C_1"]
I2c1 = 6 , # [doc = "7: Линия запросов от SPIFI"]
Spifi = 7 , # [doc = "8: Линия запросов от Timer32_1"]
Timer32_1 = 8 , # [doc = "9: Линия запросов от Timer32_2"]
Timer32_2 = 9 , # [doc = "10: Линия запросов от DAC0"]
Dac0 = 10 , # [doc = "11: Линия запросов от DAC1"]
Dac1 = 11 , # [doc = "12: Линия запросов от Timer32_0"]
Timer32_0 = 12 , } impl From < WriteRequest > for u8 { # [inline (always)]
fn from (variant : WriteRequest) -> Self { variant as _ } } impl crate :: FieldSpec for WriteRequest { type Ux = u8 ; } impl crate :: IsEnum for WriteRequest { } # [doc = "Field `WRITE_REQUEST` reader - Выбор периферийной линии назначения"]
pub type WriteRequestR = crate :: FieldReader < WriteRequest > ; impl WriteRequestR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < WriteRequest > { match self . bits { 0 => Some (WriteRequest :: Usart0) , 1 => Some (WriteRequest :: Usart1) , 2 => Some (WriteRequest :: Crypto) , 3 => Some (WriteRequest :: Spi0) , 4 => Some (WriteRequest :: Spi1) , 5 => Some (WriteRequest :: I2c0) , 6 => Some (WriteRequest :: I2c1) , 7 => Some (WriteRequest :: Spifi) , 8 => Some (WriteRequest :: Timer32_1) , 9 => Some (WriteRequest :: Timer32_2) , 10 => Some (WriteRequest :: Dac0) , 11 => Some (WriteRequest :: Dac1) , 12 => Some (WriteRequest :: Timer32_0) , _ => None , } } # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn is_usart_0 (& self) -> bool { * self == WriteRequest :: Usart0 } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn is_usart_1 (& self) -> bool { * self == WriteRequest :: Usart1 } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn is_crypto (& self) -> bool { * self == WriteRequest :: Crypto } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn is_spi_0 (& self) -> bool { * self == WriteRequest :: Spi0 } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn is_spi_1 (& self) -> bool { * self == WriteRequest :: Spi1 } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn is_i2c_0 (& self) -> bool { * self == WriteRequest :: I2c0 } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn is_i2c_1 (& self) -> bool { * self == WriteRequest :: I2c1 } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn is_spifi (& self) -> bool { * self == WriteRequest :: Spifi } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn is_timer32_1 (& self) -> bool { * self == WriteRequest :: Timer32_1 } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn is_timer32_2 (& self) -> bool { * self == WriteRequest :: Timer32_2 } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn is_dac0 (& self) -> bool { * self == WriteRequest :: Dac0 } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn is_dac1 (& self) -> bool { * self == WriteRequest :: Dac1 } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn is_timer32_0 (& self) -> bool { * self == WriteRequest :: Timer32_0 } } # [doc = "Field `WRITE_REQUEST` writer - Выбор периферийной линии назначения"]
pub type WriteRequestW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , WriteRequest > ; impl < 'a , REG > WriteRequestW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Линия запросов от USART_0"]
# [inline (always)]
pub fn usart_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Usart0) } # [doc = "Линия запросов от USART_1"]
# [inline (always)]
pub fn usart_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Usart1) } # [doc = "Линия запросов от крипто-блока"]
# [inline (always)]
pub fn crypto (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Crypto) } # [doc = "Линия запросов от SPI_0"]
# [inline (always)]
pub fn spi_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spi0) } # [doc = "Линия запросов от SPI_1"]
# [inline (always)]
pub fn spi_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spi1) } # [doc = "Линия запросов от I2C_0"]
# [inline (always)]
pub fn i2c_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: I2c0) } # [doc = "Линия запросов от I2C_1"]
# [inline (always)]
pub fn i2c_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: I2c1) } # [doc = "Линия запросов от SPIFI"]
# [inline (always)]
pub fn spifi (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Spifi) } # [doc = "Линия запросов от Timer32_1"]
# [inline (always)]
pub fn timer32_1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_1) } # [doc = "Линия запросов от Timer32_2"]
# [inline (always)]
pub fn timer32_2 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_2) } # [doc = "Линия запросов от DAC0"]
# [inline (always)]
pub fn dac0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Dac0) } # [doc = "Линия запросов от DAC1"]
# [inline (always)]
pub fn dac1 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Dac1) } # [doc = "Линия запросов от Timer32_0"]
# [inline (always)]
pub fn timer32_0 (self) -> & 'a mut crate :: W < REG > { self . variant (WriteRequest :: Timer32_0) } } # [doc = "Разрешение работы логики с откликом для адресата источника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadAckEn { # [doc = "0: Запрещено"]
Disable = 0 , # [doc = "1: Разрешено"]
Enable = 1 , } impl From < ReadAckEn > for bool { # [inline (always)]
fn from (variant : ReadAckEn) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_ACK_EN` reader - Разрешение работы логики с откликом для адресата источника"]
pub type ReadAckEnR = crate :: BitReader < ReadAckEn > ; impl ReadAckEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadAckEn { match self . bits { false => ReadAckEn :: Disable , true => ReadAckEn :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == ReadAckEn :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == ReadAckEn :: Enable } } # [doc = "Field `READ_ACK_EN` writer - Разрешение работы логики с откликом для адресата источника"]
pub type ReadAckEnW < 'a , REG > = crate :: BitWriter < 'a , REG , ReadAckEn > ; impl < 'a , REG > ReadAckEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (ReadAckEn :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (ReadAckEn :: Enable) } } # [doc = "Разрешение работы логики с откликом для адресата назначения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteAckEn { # [doc = "0: Запрещено"]
Disable = 0 , # [doc = "1: Разрешено"]
Enable = 1 , } impl From < WriteAckEn > for bool { # [inline (always)]
fn from (variant : WriteAckEn) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_ACK_EN` reader - Разрешение работы логики с откликом для адресата назначения"]
pub type WriteAckEnR = crate :: BitReader < WriteAckEn > ; impl WriteAckEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteAckEn { match self . bits { false => WriteAckEn :: Disable , true => WriteAckEn :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WriteAckEn :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WriteAckEn :: Enable } } # [doc = "Field `WRITE_ACK_EN` writer - Разрешение работы логики с откликом для адресата назначения"]
pub type WriteAckEnW < 'a , REG > = crate :: BitWriter < 'a , REG , WriteAckEn > ; impl < 'a , REG > WriteAckEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WriteAckEn :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WriteAckEn :: Enable) } } # [doc = "Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum IrqEn { # [doc = "0: Прерывание не формируется"]
Disable = 0 , # [doc = "1: Прерывание формируется"]
Enable = 1 , } impl From < IrqEn > for bool { # [inline (always)]
fn from (variant : IrqEn) -> Self { variant as u8 != 0 } } # [doc = "Field `IRQ_EN` reader - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
pub type IrqEnR = crate :: BitReader < IrqEn > ; impl IrqEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> IrqEn { match self . bits { false => IrqEn :: Disable , true => IrqEn :: Enable , } } # [doc = "Прерывание не формируется"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == IrqEn :: Disable } # [doc = "Прерывание формируется"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == IrqEn :: Enable } } # [doc = "Field `IRQ_EN` writer - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
pub type IrqEnW < 'a , REG > = crate :: BitWriter < 'a , REG , IrqEn > ; impl < 'a , REG > IrqEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание не формируется"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (IrqEn :: Disable) } # [doc = "Прерывание формируется"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (IrqEn :: Enable) } } impl R { # [doc = "Bit 0 - Разрешение работы канала"]
# [inline (always)]
pub fn enable (& self) -> EnableR { EnableR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Приоритет канала"]
# [inline (always)]
pub fn prior (& self) -> PriorR { PriorR :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bit 3 - Режим адреса источника"]
# [inline (always)]
pub fn read_mode (& self) -> ReadModeR { ReadModeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Режим адреса назначения"]
# [inline (always)]
pub fn write_mode (& self) -> WriteModeR { WriteModeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Инкремент адреса источника"]
# [inline (always)]
pub fn read_increment (& self) -> ReadIncrementR { ReadIncrementR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 5 - Инкремент адреса назначения"]
# [inline (always)]
pub fn write_increment (& self) -> WriteIncrementR { WriteIncrementR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 7:8 - Разрядность адреса источника. Должно быть кратно data_len"]
# [inline (always)]
pub fn read_size (& self) -> ReadSizeR { ReadSizeR :: new (((self . bits >> 7) & 3) as u8) } # [doc = "Bits 9:10 - Разрядность адреса назначения. Должно быть кратно LEN"]
# [inline (always)]
pub fn write_size (& self) -> WriteSizeR { WriteSizeR :: new (((self . bits >> 9) & 3) as u8) } # [doc = "Bits 11:13 - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
# [inline (always)]
pub fn read_burst_size (& self) -> ReadBurstSizeR { ReadBurstSizeR :: new (((self . bits >> 11) & 7) as u8) } # [doc = "Bits 14:16 - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
# [inline (always)]
pub fn write_burst_size (& self) -> WriteBurstSizeR { WriteBurstSizeR :: new (((self . bits >> 14) & 7) as u8) } # [doc = "Bits 17:20 - Выбор периферийной линии источника"]
# [inline (always)]
pub fn read_request (& self) -> ReadRequestR { ReadRequestR :: new (((self . bits >> 17) & 0x0f) as u8) } # [doc = "Bits 21:24 - Выбор периферийной линии назначения"]
# [inline (always)]
pub fn write_request (& self) -> WriteRequestR { WriteRequestR :: new (((self . bits >> 21) & 0x0f) as u8) } # [doc = "Bit 25 - Разрешение работы логики с откликом для адресата источника"]
# [inline (always)]
pub fn read_ack_en (& self) -> ReadAckEnR { ReadAckEnR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Разрешение работы логики с откликом для адресата назначения"]
# [inline (always)]
pub fn write_ack_en (& self) -> WriteAckEnR { WriteAckEnR :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
# [inline (always)]
pub fn irq_en (& self) -> IrqEnR { IrqEnR :: new (((self . bits >> 27) & 1) != 0) } } impl W { # [doc = "Bit 0 - Разрешение работы канала"]
# [inline (always)]
pub fn enable (& mut self) -> EnableW < Ch4CfgSpec > { EnableW :: new (self , 0) } # [doc = "Bits 1:2 - Приоритет канала"]
# [inline (always)]
pub fn prior (& mut self) -> PriorW < Ch4CfgSpec > { PriorW :: new (self , 1) } # [doc = "Bit 3 - Режим адреса источника"]
# [inline (always)]
pub fn read_mode (& mut self) -> ReadModeW < Ch4CfgSpec > { ReadModeW :: new (self , 3) } # [doc = "Bit 4 - Режим адреса назначения"]
# [inline (always)]
pub fn write_mode (& mut self) -> WriteModeW < Ch4CfgSpec > { WriteModeW :: new (self , 4) } # [doc = "Bit 5 - Инкремент адреса источника"]
# [inline (always)]
pub fn read_increment (& mut self) -> ReadIncrementW < Ch4CfgSpec > { ReadIncrementW :: new (self , 5) } # [doc = "Bit 5 - Инкремент адреса назначения"]
# [inline (always)]
pub fn write_increment (& mut self) -> WriteIncrementW < Ch4CfgSpec > { WriteIncrementW :: new (self , 5) } # [doc = "Bits 7:8 - Разрядность адреса источника. Должно быть кратно data_len"]
# [inline (always)]
pub fn read_size (& mut self) -> ReadSizeW < Ch4CfgSpec > { ReadSizeW :: new (self , 7) } # [doc = "Bits 9:10 - Разрядность адреса назначения. Должно быть кратно LEN"]
# [inline (always)]
pub fn write_size (& mut self) -> WriteSizeW < Ch4CfgSpec > { WriteSizeW :: new (self , 9) } # [doc = "Bits 11:13 - Количество байт в пакете. Определяется как 2^read_block_size. Должно быть кратно read_size."]
# [inline (always)]
pub fn read_burst_size (& mut self) -> ReadBurstSizeW < Ch4CfgSpec > { ReadBurstSizeW :: new (self , 11) } # [doc = "Bits 14:16 - Количество байт в пакете. Определяется как 2^write_block_size. Должно быть кратно write_size."]
# [inline (always)]
pub fn write_burst_size (& mut self) -> WriteBurstSizeW < Ch4CfgSpec > { WriteBurstSizeW :: new (self , 14) } # [doc = "Bits 17:20 - Выбор периферийной линии источника"]
# [inline (always)]
pub fn read_request (& mut self) -> ReadRequestW < Ch4CfgSpec > { ReadRequestW :: new (self , 17) } # [doc = "Bits 21:24 - Выбор периферийной линии назначения"]
# [inline (always)]
pub fn write_request (& mut self) -> WriteRequestW < Ch4CfgSpec > { WriteRequestW :: new (self , 21) } # [doc = "Bit 25 - Разрешение работы логики с откликом для адресата источника"]
# [inline (always)]
pub fn read_ack_en (& mut self) -> ReadAckEnW < Ch4CfgSpec > { ReadAckEnW :: new (self , 25) } # [doc = "Bit 26 - Разрешение работы логики с откликом для адресата назначения"]
# [inline (always)]
pub fn write_ack_en (& mut self) -> WriteAckEnW < Ch4CfgSpec > { WriteAckEnW :: new (self , 26) } # [doc = "Bit 27 - Разрешение формирования пре-рывания по завершении работы канала: 0 – прерывание не формируется; 1 – прерывание формируется"]
# [inline (always)]
pub fn irq_en (& mut self) -> IrqEnW < Ch4CfgSpec > { IrqEnW :: new (self , 27) } } # [doc = "Регистр управления и конфигурации канала 4\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch4CfgSpec ; impl crate :: RegisterSpec for Ch4CfgSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch4_cfg::R`](R) reader structure"]
impl crate :: Readable for Ch4CfgSpec { } # [doc = "`write(|w| ..)` method takes [`ch4_cfg::W`](W) writer structure"]
impl crate :: Writable for Ch4CfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH4_CFG to value 0"]
impl crate :: Resettable for Ch4CfgSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONFIG (w) register accessor: Регистр прерываний и настройки контроллера\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@config`]
module"]
# [doc (alias = "CONFIG")]
pub type Config = crate :: Reg < config :: ConfigSpec > ; # [doc = "Регистр прерываний и настройки контроллера"]
pub mod config { # [doc = "Register `CONFIG` writer"]
pub type W = crate :: W < ConfigSpec > ; # [doc = "Field `CLEAR_LOCAL_IRQ` writer - Очистка локального прерывания"]
pub type ClearLocalIrqW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `CLEAR_GLOBAL_IRQ` writer - Очистка глобального прерывания: «1» – снятие запроса на прерывание"]
pub type ClearGlobalIrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `CLEAR_ERROR_IRQ` writer - Очистка прерывания ошибки: «1» – снятие запроса на прерывание"]
pub type ClearErrorIrqW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Разрешение формирования глобального прерывания\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum GlobalIrqEna { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < GlobalIrqEna > for bool { # [inline (always)]
fn from (variant : GlobalIrqEna) -> Self { variant as u8 != 0 } } # [doc = "Field `GLOBAL_IRQ_ENA` writer - Разрешение формирования глобального прерывания"]
pub type GlobalIrqEnaW < 'a , REG > = crate :: BitWriter < 'a , REG , GlobalIrqEna > ; impl < 'a , REG > GlobalIrqEnaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (GlobalIrqEna :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (GlobalIrqEna :: Enable) } } # [doc = "Разрешение формирования прерывания при ошибке\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ErrorIrqEna { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < ErrorIrqEna > for bool { # [inline (always)]
fn from (variant : ErrorIrqEna) -> Self { variant as u8 != 0 } } # [doc = "Field `ERROR_IRQ_ENA` writer - Разрешение формирования прерывания при ошибке"]
pub type ErrorIrqEnaW < 'a , REG > = crate :: BitWriter < 'a , REG , ErrorIrqEna > ; impl < 'a , REG > ErrorIrqEnaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (ErrorIrqEna :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (ErrorIrqEna :: Enable) } } # [doc = "Разрешение чтения текущего статуса канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CurrentValue { # [doc = "0: Разрешено (текущие значения)"]
Disable = 0 , # [doc = "1: Запрещено (значения при настройке)"]
Enable = 1 , } impl From < CurrentValue > for bool { # [inline (always)]
fn from (variant : CurrentValue) -> Self { variant as u8 != 0 } } # [doc = "Field `CURRENT_VALUE` writer - Разрешение чтения текущего статуса канала"]
pub type CurrentValueW < 'a , REG > = crate :: BitWriter < 'a , REG , CurrentValue > ; impl < 'a , REG > CurrentValueW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Разрешено (текущие значения)"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (CurrentValue :: Disable) } # [doc = "Запрещено (значения при настройке)"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (CurrentValue :: Enable) } } impl W { # [doc = "Bits 0:3 - Очистка локального прерывания"]
# [inline (always)]
pub fn clear_local_irq (& mut self) -> ClearLocalIrqW < ConfigSpec > { ClearLocalIrqW :: new (self , 0) } # [doc = "Bit 4 - Очистка глобального прерывания: «1» – снятие запроса на прерывание"]
# [inline (always)]
pub fn clear_global_irq (& mut self) -> ClearGlobalIrqW < ConfigSpec > { ClearGlobalIrqW :: new (self , 4) } # [doc = "Bit 5 - Очистка прерывания ошибки: «1» – снятие запроса на прерывание"]
# [inline (always)]
pub fn clear_error_irq (& mut self) -> ClearErrorIrqW < ConfigSpec > { ClearErrorIrqW :: new (self , 5) } # [doc = "Bit 6 - Разрешение формирования глобального прерывания"]
# [inline (always)]
pub fn global_irq_ena (& mut self) -> GlobalIrqEnaW < ConfigSpec > { GlobalIrqEnaW :: new (self , 6) } # [doc = "Bit 7 - Разрешение формирования прерывания при ошибке"]
# [inline (always)]
pub fn error_irq_ena (& mut self) -> ErrorIrqEnaW < ConfigSpec > { ErrorIrqEnaW :: new (self , 7) } # [doc = "Bit 8 - Разрешение чтения текущего статуса канала"]
# [inline (always)]
pub fn current_value (& mut self) -> CurrentValueW < ConfigSpec > { CurrentValueW :: new (self , 8) } } # [doc = "Регистр прерываний и настройки контроллера\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ConfigSpec ; impl crate :: RegisterSpec for ConfigSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`config::W`](W) writer structure"]
impl crate :: Writable for ConfigSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONFIG to value 0"]
impl crate :: Resettable for ConfigSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "STATUS (r) register accessor: Регистр прерываний и настройки контроллера\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@status`]
module"]
# [doc (alias = "STATUS")]
pub type Status = crate :: Reg < status :: StatusSpec > ; # [doc = "Регистр прерываний и настройки контроллера"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub type R = crate :: R < StatusSpec > ; # [doc = "Field `CHANNEL_READY` reader - Статус состояния каналов: «1» - готов к работе; «0» - занят В режиме чтения текущего статуса (Current_valuе=1) возвращает: \\[0\\]
- состояния ошибки при чтении (0 – ошибки не было; 1 – была зафиксирована ошибка шины при чтении) \\[1\\]
- состояния ошибки при записи (0 – ошибки не было; 1 – была зафиксирована ошибка шины при записи) \\[3:2\\]
состояния статуса контроллера канала (2’b01 – канал в состоянии чтения; 2’b10 – канала в состоянии записи)"]
pub type ChannelReadyR = crate :: FieldReader ; # [doc = "Field `CHANNEL1_IRQ` reader - Статус прерываний: «1» - есть прерывания; «0» - нет прерываний"]
pub type Channel1IrqR = crate :: BitReader ; # [doc = "Field `CHANNEL2_IRQ` reader - Статус прерываний: «1» - есть прерывания; «0» - нет прерываний"]
pub type Channel2IrqR = crate :: BitReader ; # [doc = "Field `CHANNEL3_IRQ` reader - Статус прерываний: «1» - есть прерывания; «0» - нет прерываний"]
pub type Channel3IrqR = crate :: BitReader ; # [doc = "Field `CHANNEL4_IRQ` reader - Статус прерываний: «1» - есть прерывания; «0» - нет прерываний"]
pub type Channel4IrqR = crate :: BitReader ; # [doc = "Field `CHANNEL1_BUS_ERROR` reader - Статус состояния каналов при ошибках на шине: «1» - есть ошибка; «0» - нет ошибки"]
pub type Channel1BusErrorR = crate :: BitReader ; # [doc = "Field `CHANNEL2_BUS_ERROR` reader - Статус состояния каналов при ошибках на шине: «1» - есть ошибка; «0» - нет ошибки"]
pub type Channel2BusErrorR = crate :: BitReader ; # [doc = "Field `CHANNEL3_BUS_ERROR` reader - Статус состояния каналов при ошибках на шине: «1» - есть ошибка; «0» - нет ошибки"]
pub type Channel3BusErrorR = crate :: BitReader ; # [doc = "Field `CHANNEL4_BUS_ERROR` reader - Статус состояния каналов при ошибках на шине: «1» - есть ошибка; «0» - нет ошибки"]
pub type Channel4BusErrorR = crate :: BitReader ; impl R { # [doc = "Bits 0:3 - Статус состояния каналов: «1» - готов к работе; «0» - занят В режиме чтения текущего статуса (Current_valuе=1) возвращает: \\[0\\]
- состояния ошибки при чтении (0 – ошибки не было; 1 – была зафиксирована ошибка шины при чтении) \\[1\\]
- состояния ошибки при записи (0 – ошибки не было; 1 – была зафиксирована ошибка шины при записи) \\[3:2\\]
состояния статуса контроллера канала (2’b01 – канал в состоянии чтения; 2’b10 – канала в состоянии записи)"]
# [inline (always)]
pub fn channel_ready (& self) -> ChannelReadyR { ChannelReadyR :: new ((self . bits & 0x0f) as u8) } # [doc = "Bit 4 - Статус прерываний: «1» - есть прерывания; «0» - нет прерываний"]
# [inline (always)]
pub fn channel1_irq (& self) -> Channel1IrqR { Channel1IrqR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Статус прерываний: «1» - есть прерывания; «0» - нет прерываний"]
# [inline (always)]
pub fn channel2_irq (& self) -> Channel2IrqR { Channel2IrqR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Статус прерываний: «1» - есть прерывания; «0» - нет прерываний"]
# [inline (always)]
pub fn channel3_irq (& self) -> Channel3IrqR { Channel3IrqR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Статус прерываний: «1» - есть прерывания; «0» - нет прерываний"]
# [inline (always)]
pub fn channel4_irq (& self) -> Channel4IrqR { Channel4IrqR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Статус состояния каналов при ошибках на шине: «1» - есть ошибка; «0» - нет ошибки"]
# [inline (always)]
pub fn channel1_bus_error (& self) -> Channel1BusErrorR { Channel1BusErrorR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Статус состояния каналов при ошибках на шине: «1» - есть ошибка; «0» - нет ошибки"]
# [inline (always)]
pub fn channel2_bus_error (& self) -> Channel2BusErrorR { Channel2BusErrorR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Статус состояния каналов при ошибках на шине: «1» - есть ошибка; «0» - нет ошибки"]
# [inline (always)]
pub fn channel3_bus_error (& self) -> Channel3BusErrorR { Channel3BusErrorR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Статус состояния каналов при ошибках на шине: «1» - есть ошибка; «0» - нет ошибки"]
# [inline (always)]
pub fn channel4_bus_error (& self) -> Channel4BusErrorR { Channel4BusErrorR :: new (((self . bits >> 11) & 1) != 0) } } # [doc = "Регистр прерываний и настройки контроллера\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StatusSpec ; impl crate :: RegisterSpec for StatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`status::R`](R) reader structure"]
impl crate :: Readable for StatusSpec { } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for StatusSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Блок управления питанием и тактированием"]
pub struct Pm { _marker : PhantomData < * const () > } unsafe impl Send for Pm { } impl Pm { # [doc = r"Pointer to the register block"]
pub const PTR : * const pm :: RegisterBlock = 0x0005_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pm :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Pm { type Target = pm :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Pm { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Pm") . finish () } } # [doc = "Блок управления питанием и тактированием"]
pub mod pm { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { div_ahb : DivAhb , div_apb_m : DivApbM , div_apb_p : DivApbP , clk_ahb_set : ClkAhbSet , clk_ahb_clear : ClkAhbClear , clk_apb_m_set : ClkApbMSet , clk_apb_m_clear : ClkApbMClear , clk_apb_p_set : ClkApbPSet , clk_apb_p_clear : ClkApbPClear , ahb_mux : AhbMux , wdt_clk_mux : WdtClkMux , cpu_rtc_clk_mux : CpuRtcClkMux , timer_cfg : TimerCfg , freq_mask : FreqMask , freq_status : FreqStatus , sleep_mode : SleepMode , } impl RegisterBlock { # [doc = "0x00 - Задает значение делителя шины AHB. Частота шины AHB (FAHB) рассчитывается, как FSYS/( DIV_AHB+1)"]
# [inline (always)]
pub const fn div_ahb (& self) -> & DivAhb { & self . div_ahb } # [doc = "0x04 - Задает значение делителя шины APB_M. Частота шины APB_M (FAPM_M) рассчитывается, как FAPB/( Div_APM_M+1)"]
# [inline (always)]
pub const fn div_apb_m (& self) -> & DivApbM { & self . div_apb_m } # [doc = "0x08 - Задает значение делителя шины APB_P. Частота шины APB_P (FAPM_P) рассчитывается, как FAPB/( Div_APM_P+1)"]
# [inline (always)]
pub const fn div_apb_p (& self) -> & DivApbP { & self . div_apb_p } # [doc = "0x0c - Регистр включения тактированием устройств на шине AHB"]
# [inline (always)]
pub const fn clk_ahb_set (& self) -> & ClkAhbSet { & self . clk_ahb_set } # [doc = "0x10 - Регистр выключения тактированием устройств на шине AHB. Каждому биту соответствует устройство, аналогично CLK_AHB_SET"]
# [inline (always)]
pub const fn clk_ahb_clear (& self) -> & ClkAhbClear { & self . clk_ahb_clear } # [doc = "0x14 - Регистр включения тактированием устройств на шине APB_M. Каждому биту соответствует устройство"]
# [inline (always)]
pub const fn clk_apb_m_set (& self) -> & ClkApbMSet { & self . clk_apb_m_set } # [doc = "0x18 - Регистр выключения тактированием устройств на шине APB_M. Каждому биту соответствует устройство, аналогично Clk_APB_M_Set"]
# [inline (always)]
pub const fn clk_apb_m_clear (& self) -> & ClkApbMClear { & self . clk_apb_m_clear } # [doc = "0x1c - Регистр включения тактированием устройств на шине APB_P. Каждому биту соответствует одно устройство"]
# [inline (always)]
pub const fn clk_apb_p_set (& self) -> & ClkApbPSet { & self . clk_apb_p_set } # [doc = "0x20 - Регистр выключения тактированием устройств на шине APB_P. Каждому биту соответствует устройство, аналогично CLK_APB_P_SET"]
# [inline (always)]
pub const fn clk_apb_p_clear (& self) -> & ClkApbPClear { & self . clk_apb_p_clear } # [doc = "0x24 - Настройка источника тактирования системы"]
# [inline (always)]
pub const fn ahb_mux (& self) -> & AhbMux { & self . ahb_mux } # [doc = "0x28 - Выбор источника тактирования сторожевого таймера: 0 – внешний OSC32M; 1 – внутренний HSI32M; 2 – внешний OSC32K; 3 – внутренний LSI32К;"]
# [inline (always)]
pub const fn wdt_clk_mux (& self) -> & WdtClkMux { & self . wdt_clk_mux } # [doc = "0x2c - Выбор источника тактирования RTC для системного таймера в составе ядра"]
# [inline (always)]
pub const fn cpu_rtc_clk_mux (& self) -> & CpuRtcClkMux { & self . cpu_rtc_clk_mux } # [doc = "0x30 - Выбор источника тактирования для таймеров"]
# [inline (always)]
pub const fn timer_cfg (& self) -> & TimerCfg { & self . timer_cfg } # [doc = "0x34 - Настройки прерываний монитора частоты"]
# [inline (always)]
pub const fn freq_mask (& self) -> & FreqMask { & self . freq_mask } # [doc = "0x38 - Статус монитора частоты"]
# [inline (always)]
pub const fn freq_status (& self) -> & FreqStatus { & self . freq_status } # [doc = "0x3c - Переход в спящий режим осуществляется записью в данный регистр. При записи отключается тактирование ядра. В зависимости от записываемого значения отключается тактирование модулей"]
# [inline (always)]
pub const fn sleep_mode (& self) -> & SleepMode { & self . sleep_mode } } # [doc = "DIV_AHB (rw) register accessor: Задает значение делителя шины AHB. Частота шины AHB (FAHB) рассчитывается, как FSYS/( DIV_AHB+1)\n\nYou can [`read`](crate::Reg::read) this register and get [`div_ahb::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div_ahb::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div_ahb`]
module"]
# [doc (alias = "DIV_AHB")]
pub type DivAhb = crate :: Reg < div_ahb :: DivAhbSpec > ; # [doc = "Задает значение делителя шины AHB. Частота шины AHB (FAHB) рассчитывается, как FSYS/( DIV_AHB+1)"]
pub mod div_ahb { # [doc = "Register `DIV_AHB` reader"]
pub type R = crate :: R < DivAhbSpec > ; # [doc = "Register `DIV_AHB` writer"]
pub type W = crate :: W < DivAhbSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Задает значение делителя шины AHB. Частота шины AHB (FAHB) рассчитывается, как FSYS/( DIV_AHB+1)\n\nYou can [`read`](crate::Reg::read) this register and get [`div_ahb::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div_ahb::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DivAhbSpec ; impl crate :: RegisterSpec for DivAhbSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`div_ahb::R`](R) reader structure"]
impl crate :: Readable for DivAhbSpec { } # [doc = "`write(|w| ..)` method takes [`div_ahb::W`](W) writer structure"]
impl crate :: Writable for DivAhbSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DIV_AHB to value 0"]
impl crate :: Resettable for DivAhbSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DIV_APB_M (rw) register accessor: Задает значение делителя шины APB_M. Частота шины APB_M (FAPM_M) рассчитывается, как FAPB/( Div_APM_M+1)\n\nYou can [`read`](crate::Reg::read) this register and get [`div_apb_m::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div_apb_m::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div_apb_m`]
module"]
# [doc (alias = "DIV_APB_M")]
pub type DivApbM = crate :: Reg < div_apb_m :: DivApbMSpec > ; # [doc = "Задает значение делителя шины APB_M. Частота шины APB_M (FAPM_M) рассчитывается, как FAPB/( Div_APM_M+1)"]
pub mod div_apb_m { # [doc = "Register `DIV_APB_M` reader"]
pub type R = crate :: R < DivApbMSpec > ; # [doc = "Register `DIV_APB_M` writer"]
pub type W = crate :: W < DivApbMSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Задает значение делителя шины APB_M. Частота шины APB_M (FAPM_M) рассчитывается, как FAPB/( Div_APM_M+1)\n\nYou can [`read`](crate::Reg::read) this register and get [`div_apb_m::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div_apb_m::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DivApbMSpec ; impl crate :: RegisterSpec for DivApbMSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`div_apb_m::R`](R) reader structure"]
impl crate :: Readable for DivApbMSpec { } # [doc = "`write(|w| ..)` method takes [`div_apb_m::W`](W) writer structure"]
impl crate :: Writable for DivApbMSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DIV_APB_M to value 0"]
impl crate :: Resettable for DivApbMSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DIV_APB_P (rw) register accessor: Задает значение делителя шины APB_P. Частота шины APB_P (FAPM_P) рассчитывается, как FAPB/( Div_APM_P+1)\n\nYou can [`read`](crate::Reg::read) this register and get [`div_apb_p::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div_apb_p::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@div_apb_p`]
module"]
# [doc (alias = "DIV_APB_P")]
pub type DivApbP = crate :: Reg < div_apb_p :: DivApbPSpec > ; # [doc = "Задает значение делителя шины APB_P. Частота шины APB_P (FAPM_P) рассчитывается, как FAPB/( Div_APM_P+1)"]
pub mod div_apb_p { # [doc = "Register `DIV_APB_P` reader"]
pub type R = crate :: R < DivApbPSpec > ; # [doc = "Register `DIV_APB_P` writer"]
pub type W = crate :: W < DivApbPSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Задает значение делителя шины APB_P. Частота шины APB_P (FAPM_P) рассчитывается, как FAPB/( Div_APM_P+1)\n\nYou can [`read`](crate::Reg::read) this register and get [`div_apb_p::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`div_apb_p::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DivApbPSpec ; impl crate :: RegisterSpec for DivApbPSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`div_apb_p::R`](R) reader structure"]
impl crate :: Readable for DivApbPSpec { } # [doc = "`write(|w| ..)` method takes [`div_apb_p::W`](W) writer structure"]
impl crate :: Writable for DivApbPSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DIV_APB_P to value 0"]
impl crate :: Resettable for DivApbPSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CLK_AHB_SET (rw) register accessor: Регистр включения тактированием устройств на шине AHB\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_ahb_set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_ahb_set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_ahb_set`]
module"]
# [doc (alias = "CLK_AHB_SET")]
pub type ClkAhbSet = crate :: Reg < clk_ahb_set :: ClkAhbSetSpec > ; # [doc = "Регистр включения тактированием устройств на шине AHB"]
pub mod clk_ahb_set { # [doc = "Register `CLK_AHB_SET` reader"]
pub type R = crate :: R < ClkAhbSetSpec > ; # [doc = "Register `CLK_AHB_SET` writer"]
pub type W = crate :: W < ClkAhbSetSpec > ; # [doc = "Ядро\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Core { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Core > for bool { # [inline (always)]
fn from (variant : Core) -> Self { variant as u8 != 0 } } # [doc = "Field `Core` reader - Ядро"]
pub type CoreR = crate :: BitReader < Core > ; impl CoreR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Core { match self . bits { false => Core :: Disable , true => Core :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Core :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Core :: Enable } } # [doc = "Field `Core` writer - Ядро"]
pub type CoreW < 'a , REG > = crate :: BitWriter < 'a , REG , Core > ; impl < 'a , REG > CoreW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Core :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Core :: Enable) } } # [doc = "EEPROM\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Eeprom { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Eeprom > for bool { # [inline (always)]
fn from (variant : Eeprom) -> Self { variant as u8 != 0 } } # [doc = "Field `EEPROM` reader - EEPROM"]
pub type EepromR = crate :: BitReader < Eeprom > ; impl EepromR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Eeprom { match self . bits { false => Eeprom :: Disable , true => Eeprom :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Eeprom :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Eeprom :: Enable } } # [doc = "Field `EEPROM` writer - EEPROM"]
pub type EepromW < 'a , REG > = crate :: BitWriter < 'a , REG , Eeprom > ; impl < 'a , REG > EepromW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Eeprom :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Eeprom :: Enable) } } # [doc = "RAM\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ram { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Ram > for bool { # [inline (always)]
fn from (variant : Ram) -> Self { variant as u8 != 0 } } # [doc = "Field `RAM` reader - RAM"]
pub type RamR = crate :: BitReader < Ram > ; impl RamR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ram { match self . bits { false => Ram :: Disable , true => Ram :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Ram :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Ram :: Enable } } # [doc = "Field `RAM` writer - RAM"]
pub type RamW < 'a , REG > = crate :: BitWriter < 'a , REG , Ram > ; impl < 'a , REG > RamW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Ram :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Ram :: Enable) } } # [doc = "SPIFI\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spifi { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Spifi > for bool { # [inline (always)]
fn from (variant : Spifi) -> Self { variant as u8 != 0 } } # [doc = "Field `SPIFI` reader - SPIFI"]
pub type SpifiR = crate :: BitReader < Spifi > ; impl SpifiR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spifi { match self . bits { false => Spifi :: Disable , true => Spifi :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spifi :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spifi :: Enable } } # [doc = "Field `SPIFI` writer - SPIFI"]
pub type SpifiW < 'a , REG > = crate :: BitWriter < 'a , REG , Spifi > ; impl < 'a , REG > SpifiW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spifi :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spifi :: Enable) } } # [doc = "TCB\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Tcb { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Tcb > for bool { # [inline (always)]
fn from (variant : Tcb) -> Self { variant as u8 != 0 } } # [doc = "Field `TCB` reader - TCB"]
pub type TcbR = crate :: BitReader < Tcb > ; impl TcbR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Tcb { match self . bits { false => Tcb :: Disable , true => Tcb :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Tcb :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Tcb :: Enable } } # [doc = "Field `TCB` writer - TCB"]
pub type TcbW < 'a , REG > = crate :: BitWriter < 'a , REG , Tcb > ; impl < 'a , REG > TcbW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Tcb :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Tcb :: Enable) } } # [doc = "DMA\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dma { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Dma > for bool { # [inline (always)]
fn from (variant : Dma) -> Self { variant as u8 != 0 } } # [doc = "Field `DMA` reader - DMA"]
pub type DmaR = crate :: BitReader < Dma > ; impl DmaR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dma { match self . bits { false => Dma :: Disable , true => Dma :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dma :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dma :: Enable } } # [doc = "Field `DMA` writer - DMA"]
pub type DmaW < 'a , REG > = crate :: BitWriter < 'a , REG , Dma > ; impl < 'a , REG > DmaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Enable) } } # [doc = "Crypto\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Crypto { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Crypto > for bool { # [inline (always)]
fn from (variant : Crypto) -> Self { variant as u8 != 0 } } # [doc = "Field `Crypto` reader - Crypto"]
pub type CryptoR = crate :: BitReader < Crypto > ; impl CryptoR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Crypto { match self . bits { false => Crypto :: Disable , true => Crypto :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Crypto :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Crypto :: Enable } } # [doc = "Field `Crypto` writer - Crypto"]
pub type CryptoW < 'a , REG > = crate :: BitWriter < 'a , REG , Crypto > ; impl < 'a , REG > CryptoW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Crypto :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Crypto :: Enable) } } # [doc = "CRC32\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Crc32 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Crc32 > for bool { # [inline (always)]
fn from (variant : Crc32) -> Self { variant as u8 != 0 } } # [doc = "Field `CRC32` reader - CRC32"]
pub type Crc32R = crate :: BitReader < Crc32 > ; impl Crc32R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Crc32 { match self . bits { false => Crc32 :: Disable , true => Crc32 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Crc32 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Crc32 :: Enable } } # [doc = "Field `CRC32` writer - CRC32"]
pub type Crc32W < 'a , REG > = crate :: BitWriter < 'a , REG , Crc32 > ; impl < 'a , REG > Crc32W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Crc32 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Crc32 :: Enable) } } impl R { # [doc = "Bit 0 - Ядро"]
# [inline (always)]
pub fn core (& self) -> CoreR { CoreR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - EEPROM"]
# [inline (always)]
pub fn eeprom (& self) -> EepromR { EepromR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - RAM"]
# [inline (always)]
pub fn ram (& self) -> RamR { RamR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - SPIFI"]
# [inline (always)]
pub fn spifi (& self) -> SpifiR { SpifiR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - TCB"]
# [inline (always)]
pub fn tcb (& self) -> TcbR { TcbR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DMA"]
# [inline (always)]
pub fn dma (& self) -> DmaR { DmaR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Crypto"]
# [inline (always)]
pub fn crypto (& self) -> CryptoR { CryptoR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - CRC32"]
# [inline (always)]
pub fn crc32 (& self) -> Crc32R { Crc32R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Ядро"]
# [inline (always)]
pub fn core (& mut self) -> CoreW < ClkAhbSetSpec > { CoreW :: new (self , 0) } # [doc = "Bit 1 - EEPROM"]
# [inline (always)]
pub fn eeprom (& mut self) -> EepromW < ClkAhbSetSpec > { EepromW :: new (self , 1) } # [doc = "Bit 2 - RAM"]
# [inline (always)]
pub fn ram (& mut self) -> RamW < ClkAhbSetSpec > { RamW :: new (self , 2) } # [doc = "Bit 3 - SPIFI"]
# [inline (always)]
pub fn spifi (& mut self) -> SpifiW < ClkAhbSetSpec > { SpifiW :: new (self , 3) } # [doc = "Bit 4 - TCB"]
# [inline (always)]
pub fn tcb (& mut self) -> TcbW < ClkAhbSetSpec > { TcbW :: new (self , 4) } # [doc = "Bit 5 - DMA"]
# [inline (always)]
pub fn dma (& mut self) -> DmaW < ClkAhbSetSpec > { DmaW :: new (self , 5) } # [doc = "Bit 6 - Crypto"]
# [inline (always)]
pub fn crypto (& mut self) -> CryptoW < ClkAhbSetSpec > { CryptoW :: new (self , 6) } # [doc = "Bit 7 - CRC32"]
# [inline (always)]
pub fn crc32 (& mut self) -> Crc32W < ClkAhbSetSpec > { Crc32W :: new (self , 7) } } # [doc = "Регистр включения тактированием устройств на шине AHB\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_ahb_set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_ahb_set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClkAhbSetSpec ; impl crate :: RegisterSpec for ClkAhbSetSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`clk_ahb_set::R`](R) reader structure"]
impl crate :: Readable for ClkAhbSetSpec { } # [doc = "`write(|w| ..)` method takes [`clk_ahb_set::W`](W) writer structure"]
impl crate :: Writable for ClkAhbSetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLK_AHB_SET to value 0x1f"]
impl crate :: Resettable for ClkAhbSetSpec { const RESET_VALUE : u32 = 0x1f ; } } # [doc = "CLK_AHB_CLEAR (rw) register accessor: Регистр выключения тактированием устройств на шине AHB. Каждому биту соответствует устройство, аналогично CLK_AHB_SET\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_ahb_clear::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_ahb_clear::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_ahb_clear`]
module"]
# [doc (alias = "CLK_AHB_CLEAR")]
pub type ClkAhbClear = crate :: Reg < clk_ahb_clear :: ClkAhbClearSpec > ; # [doc = "Регистр выключения тактированием устройств на шине AHB. Каждому биту соответствует устройство, аналогично CLK_AHB_SET"]
pub mod clk_ahb_clear { # [doc = "Register `CLK_AHB_CLEAR` reader"]
pub type R = crate :: R < ClkAhbClearSpec > ; # [doc = "Register `CLK_AHB_CLEAR` writer"]
pub type W = crate :: W < ClkAhbClearSpec > ; # [doc = "Ядро\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Core { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Core > for bool { # [inline (always)]
fn from (variant : Core) -> Self { variant as u8 != 0 } } # [doc = "Field `Core` reader - Ядро"]
pub type CoreR = crate :: BitReader < Core > ; impl CoreR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Core { match self . bits { false => Core :: Disable , true => Core :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Core :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Core :: Enable } } # [doc = "Ядро\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CoreWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < CoreWO > for bool { # [inline (always)]
fn from (variant : CoreWO) -> Self { variant as u8 != 0 } } # [doc = "Field `Core` writer - Ядро"]
pub type CoreW < 'a , REG > = crate :: BitWriter < 'a , REG , CoreWO > ; impl < 'a , REG > CoreW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (CoreWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (CoreWO :: Enable) } } # [doc = "EEPROM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Eeprom { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Eeprom > for bool { # [inline (always)]
fn from (variant : Eeprom) -> Self { variant as u8 != 0 } } # [doc = "Field `EEPROM` reader - EEPROM"]
pub type EepromR = crate :: BitReader < Eeprom > ; impl EepromR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Eeprom { match self . bits { false => Eeprom :: Disable , true => Eeprom :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Eeprom :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Eeprom :: Enable } } # [doc = "EEPROM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EepromWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < EepromWO > for bool { # [inline (always)]
fn from (variant : EepromWO) -> Self { variant as u8 != 0 } } # [doc = "Field `EEPROM` writer - EEPROM"]
pub type EepromW < 'a , REG > = crate :: BitWriter < 'a , REG , EepromWO > ; impl < 'a , REG > EepromW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (EepromWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (EepromWO :: Enable) } } # [doc = "RAM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ram { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Ram > for bool { # [inline (always)]
fn from (variant : Ram) -> Self { variant as u8 != 0 } } # [doc = "Field `RAM` reader - RAM"]
pub type RamR = crate :: BitReader < Ram > ; impl RamR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ram { match self . bits { false => Ram :: Disable , true => Ram :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Ram :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Ram :: Enable } } # [doc = "RAM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RamWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < RamWO > for bool { # [inline (always)]
fn from (variant : RamWO) -> Self { variant as u8 != 0 } } # [doc = "Field `RAM` writer - RAM"]
pub type RamW < 'a , REG > = crate :: BitWriter < 'a , REG , RamWO > ; impl < 'a , REG > RamW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (RamWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (RamWO :: Enable) } } # [doc = "SPIFI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spifi { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Spifi > for bool { # [inline (always)]
fn from (variant : Spifi) -> Self { variant as u8 != 0 } } # [doc = "Field `SPIFI` reader - SPIFI"]
pub type SpifiR = crate :: BitReader < Spifi > ; impl SpifiR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spifi { match self . bits { false => Spifi :: Disable , true => Spifi :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spifi :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spifi :: Enable } } # [doc = "SPIFI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SpifiWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < SpifiWO > for bool { # [inline (always)]
fn from (variant : SpifiWO) -> Self { variant as u8 != 0 } } # [doc = "Field `SPIFI` writer - SPIFI"]
pub type SpifiW < 'a , REG > = crate :: BitWriter < 'a , REG , SpifiWO > ; impl < 'a , REG > SpifiW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (SpifiWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (SpifiWO :: Enable) } } # [doc = "TCB\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Tcb { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Tcb > for bool { # [inline (always)]
fn from (variant : Tcb) -> Self { variant as u8 != 0 } } # [doc = "Field `TCB` reader - TCB"]
pub type TcbR = crate :: BitReader < Tcb > ; impl TcbR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Tcb { match self . bits { false => Tcb :: Disable , true => Tcb :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Tcb :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Tcb :: Enable } } # [doc = "TCB\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TcbWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < TcbWO > for bool { # [inline (always)]
fn from (variant : TcbWO) -> Self { variant as u8 != 0 } } # [doc = "Field `TCB` writer - TCB"]
pub type TcbW < 'a , REG > = crate :: BitWriter < 'a , REG , TcbWO > ; impl < 'a , REG > TcbW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (TcbWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (TcbWO :: Enable) } } # [doc = "DMA\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dma { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Dma > for bool { # [inline (always)]
fn from (variant : Dma) -> Self { variant as u8 != 0 } } # [doc = "Field `DMA` reader - DMA"]
pub type DmaR = crate :: BitReader < Dma > ; impl DmaR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dma { match self . bits { false => Dma :: Disable , true => Dma :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dma :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dma :: Enable } } # [doc = "DMA\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum DmaWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < DmaWO > for bool { # [inline (always)]
fn from (variant : DmaWO) -> Self { variant as u8 != 0 } } # [doc = "Field `DMA` writer - DMA"]
pub type DmaW < 'a , REG > = crate :: BitWriter < 'a , REG , DmaWO > ; impl < 'a , REG > DmaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (DmaWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (DmaWO :: Enable) } } # [doc = "Crypto\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Crypto { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Crypto > for bool { # [inline (always)]
fn from (variant : Crypto) -> Self { variant as u8 != 0 } } # [doc = "Field `Crypto` reader - Crypto"]
pub type CryptoR = crate :: BitReader < Crypto > ; impl CryptoR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Crypto { match self . bits { false => Crypto :: Disable , true => Crypto :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Crypto :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Crypto :: Enable } } # [doc = "Crypto\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CryptoWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < CryptoWO > for bool { # [inline (always)]
fn from (variant : CryptoWO) -> Self { variant as u8 != 0 } } # [doc = "Field `Crypto` writer - Crypto"]
pub type CryptoW < 'a , REG > = crate :: BitWriter < 'a , REG , CryptoWO > ; impl < 'a , REG > CryptoW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (CryptoWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (CryptoWO :: Enable) } } # [doc = "CRC32\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Crc32 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Crc32 > for bool { # [inline (always)]
fn from (variant : Crc32) -> Self { variant as u8 != 0 } } # [doc = "Field `CRC32` reader - CRC32"]
pub type Crc32R = crate :: BitReader < Crc32 > ; impl Crc32R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Crc32 { match self . bits { false => Crc32 :: Disable , true => Crc32 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Crc32 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Crc32 :: Enable } } # [doc = "CRC32\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Crc32WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Crc32WO > for bool { # [inline (always)]
fn from (variant : Crc32WO) -> Self { variant as u8 != 0 } } # [doc = "Field `CRC32` writer - CRC32"]
pub type Crc32W < 'a , REG > = crate :: BitWriter < 'a , REG , Crc32WO > ; impl < 'a , REG > Crc32W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Crc32WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Crc32WO :: Enable) } } impl R { # [doc = "Bit 0 - Ядро"]
# [inline (always)]
pub fn core (& self) -> CoreR { CoreR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - EEPROM"]
# [inline (always)]
pub fn eeprom (& self) -> EepromR { EepromR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - RAM"]
# [inline (always)]
pub fn ram (& self) -> RamR { RamR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - SPIFI"]
# [inline (always)]
pub fn spifi (& self) -> SpifiR { SpifiR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - TCB"]
# [inline (always)]
pub fn tcb (& self) -> TcbR { TcbR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - DMA"]
# [inline (always)]
pub fn dma (& self) -> DmaR { DmaR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Crypto"]
# [inline (always)]
pub fn crypto (& self) -> CryptoR { CryptoR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - CRC32"]
# [inline (always)]
pub fn crc32 (& self) -> Crc32R { Crc32R :: new (((self . bits >> 7) & 1) != 0) } } impl W { # [doc = "Bit 0 - Ядро"]
# [inline (always)]
pub fn core (& mut self) -> CoreW < ClkAhbClearSpec > { CoreW :: new (self , 0) } # [doc = "Bit 1 - EEPROM"]
# [inline (always)]
pub fn eeprom (& mut self) -> EepromW < ClkAhbClearSpec > { EepromW :: new (self , 1) } # [doc = "Bit 2 - RAM"]
# [inline (always)]
pub fn ram (& mut self) -> RamW < ClkAhbClearSpec > { RamW :: new (self , 2) } # [doc = "Bit 3 - SPIFI"]
# [inline (always)]
pub fn spifi (& mut self) -> SpifiW < ClkAhbClearSpec > { SpifiW :: new (self , 3) } # [doc = "Bit 4 - TCB"]
# [inline (always)]
pub fn tcb (& mut self) -> TcbW < ClkAhbClearSpec > { TcbW :: new (self , 4) } # [doc = "Bit 5 - DMA"]
# [inline (always)]
pub fn dma (& mut self) -> DmaW < ClkAhbClearSpec > { DmaW :: new (self , 5) } # [doc = "Bit 6 - Crypto"]
# [inline (always)]
pub fn crypto (& mut self) -> CryptoW < ClkAhbClearSpec > { CryptoW :: new (self , 6) } # [doc = "Bit 7 - CRC32"]
# [inline (always)]
pub fn crc32 (& mut self) -> Crc32W < ClkAhbClearSpec > { Crc32W :: new (self , 7) } } # [doc = "Регистр выключения тактированием устройств на шине AHB. Каждому биту соответствует устройство, аналогично CLK_AHB_SET\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_ahb_clear::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_ahb_clear::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClkAhbClearSpec ; impl crate :: RegisterSpec for ClkAhbClearSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`clk_ahb_clear::R`](R) reader structure"]
impl crate :: Readable for ClkAhbClearSpec { } # [doc = "`write(|w| ..)` method takes [`clk_ahb_clear::W`](W) writer structure"]
impl crate :: Writable for ClkAhbClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLK_AHB_CLEAR to value 0"]
impl crate :: Resettable for ClkAhbClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CLK_APB_M_SET (rw) register accessor: Регистр включения тактированием устройств на шине APB_M. Каждому биту соответствует устройство\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_apb_m_set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_apb_m_set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_apb_m_set`]
module"]
# [doc (alias = "CLK_APB_M_SET")]
pub type ClkApbMSet = crate :: Reg < clk_apb_m_set :: ClkApbMSetSpec > ; # [doc = "Регистр включения тактированием устройств на шине APB_M. Каждому биту соответствует устройство"]
pub mod clk_apb_m_set { # [doc = "Register `CLK_APB_M_SET` reader"]
pub type R = crate :: R < ClkApbMSetSpec > ; # [doc = "Register `CLK_APB_M_SET` writer"]
pub type W = crate :: W < ClkApbMSetSpec > ; # [doc = "Блок управления питанием (PM - Power Monitor)\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pm { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Pm > for bool { # [inline (always)]
fn from (variant : Pm) -> Self { variant as u8 != 0 } } # [doc = "Field `PM` reader - Блок управления питанием (PM - Power Monitor)"]
pub type PmR = crate :: BitReader < Pm > ; impl PmR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pm { match self . bits { false => Pm :: Disable , true => Pm :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Pm :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Pm :: Enable } } # [doc = "Field `PM` writer - Блок управления питанием (PM - Power Monitor)"]
pub type PmW < 'a , REG > = crate :: BitWriter < 'a , REG , Pm > ; impl < 'a , REG > PmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Pm :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Pm :: Enable) } } # [doc = "Контроллер прерываний\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Epic { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Epic > for bool { # [inline (always)]
fn from (variant : Epic) -> Self { variant as u8 != 0 } } # [doc = "Field `EPIC` reader - Контроллер прерываний"]
pub type EpicR = crate :: BitReader < Epic > ; impl EpicR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Epic { match self . bits { false => Epic :: Disable , true => Epic :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Epic :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Epic :: Enable } } # [doc = "Field `EPIC` writer - Контроллер прерываний"]
pub type EpicW < 'a , REG > = crate :: BitWriter < 'a , REG , Epic > ; impl < 'a , REG > EpicW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Epic :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Epic :: Enable) } } # [doc = "Таймер32_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer32_0 > for bool { # [inline (always)]
fn from (variant : Timer32_0) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_0` reader - Таймер32_0"]
pub type Timer32_0R = crate :: BitReader < Timer32_0 > ; impl Timer32_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_0 { match self . bits { false => Timer32_0 :: Disable , true => Timer32_0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_0 :: Enable } } # [doc = "Field `Timer32_0` writer - Таймер32_0"]
pub type Timer32_0W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer32_0 > ; impl < 'a , REG > Timer32_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_0 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_0 :: Enable) } } # [doc = "Контроллер выводов\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PadConfig { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < PadConfig > for bool { # [inline (always)]
fn from (variant : PadConfig) -> Self { variant as u8 != 0 } } # [doc = "Field `Pad_config` reader - Контроллер выводов"]
pub type PadConfigR = crate :: BitReader < PadConfig > ; impl PadConfigR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PadConfig { match self . bits { false => PadConfig :: Disable , true => PadConfig :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PadConfig :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PadConfig :: Enable } } # [doc = "Field `Pad_config` writer - Контроллер выводов"]
pub type PadConfigW < 'a , REG > = crate :: BitWriter < 'a , REG , PadConfig > ; impl < 'a , REG > PadConfigW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PadConfig :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PadConfig :: Enable) } } # [doc = "Сторожевой таймер шины\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WdtBus { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < WdtBus > for bool { # [inline (always)]
fn from (variant : WdtBus) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT_BUS` reader - Сторожевой таймер шины"]
pub type WdtBusR = crate :: BitReader < WdtBus > ; impl WdtBusR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WdtBus { match self . bits { false => WdtBus :: Disable , true => WdtBus :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WdtBus :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WdtBus :: Enable } } # [doc = "Field `WDT_BUS` writer - Сторожевой таймер шины"]
pub type WdtBusW < 'a , REG > = crate :: BitWriter < 'a , REG , WdtBus > ; impl < 'a , REG > WdtBusW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBus :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBus :: Enable) } } # [doc = "OTP\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Otp { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Otp > for bool { # [inline (always)]
fn from (variant : Otp) -> Self { variant as u8 != 0 } } # [doc = "Field `OTP` reader - OTP"]
pub type OtpR = crate :: BitReader < Otp > ; impl OtpR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Otp { match self . bits { false => Otp :: Disable , true => Otp :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Otp :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Otp :: Enable } } # [doc = "Field `OTP` writer - OTP"]
pub type OtpW < 'a , REG > = crate :: BitWriter < 'a , REG , Otp > ; impl < 'a , REG > OtpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Otp :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Otp :: Enable) } } # [doc = "Монитор питания системного домена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pvd { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Pvd > for bool { # [inline (always)]
fn from (variant : Pvd) -> Self { variant as u8 != 0 } } # [doc = "Field `PVD` reader - Монитор питания системного домена"]
pub type PvdR = crate :: BitReader < Pvd > ; impl PvdR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pvd { match self . bits { false => Pvd :: Disable , true => Pvd :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Pvd :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Pvd :: Enable } } # [doc = "Field `PVD` writer - Монитор питания системного домена"]
pub type PvdW < 'a , REG > = crate :: BitWriter < 'a , REG , Pvd > ; impl < 'a , REG > PvdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Pvd :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Pvd :: Enable) } } # [doc = "Блок WakeUp (WU) батарейного домена\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wu { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Wu > for bool { # [inline (always)]
fn from (variant : Wu) -> Self { variant as u8 != 0 } } # [doc = "Field `WU` reader - Блок WakeUp (WU) батарейного домена"]
pub type WuR = crate :: BitReader < Wu > ; impl WuR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wu { match self . bits { false => Wu :: Disable , true => Wu :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Wu :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Wu :: Enable } } # [doc = "Field `WU` writer - Блок WakeUp (WU) батарейного домена"]
pub type WuW < 'a , REG > = crate :: BitWriter < 'a , REG , Wu > ; impl < 'a , REG > WuW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Wu :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Wu :: Enable) } } # [doc = "RTC батарейного домена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rtc { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Rtc > for bool { # [inline (always)]
fn from (variant : Rtc) -> Self { variant as u8 != 0 } } # [doc = "Field `RTC` reader - RTC батарейного домена"]
pub type RtcR = crate :: BitReader < Rtc > ; impl RtcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rtc { match self . bits { false => Rtc :: Disable , true => Rtc :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Rtc :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Rtc :: Enable } } # [doc = "Field `RTC` writer - RTC батарейного домена"]
pub type RtcW < 'a , REG > = crate :: BitWriter < 'a , REG , Rtc > ; impl < 'a , REG > RtcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Rtc :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Rtc :: Enable) } } impl R { # [doc = "Bit 0 - Блок управления питанием (PM - Power Monitor)"]
# [inline (always)]
pub fn pm (& self) -> PmR { PmR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Контроллер прерываний"]
# [inline (always)]
pub fn epic (& self) -> EpicR { EpicR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Таймер32_0"]
# [inline (always)]
pub fn timer32_0 (& self) -> Timer32_0R { Timer32_0R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Контроллер выводов"]
# [inline (always)]
pub fn pad_config (& self) -> PadConfigR { PadConfigR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Сторожевой таймер шины"]
# [inline (always)]
pub fn wdt_bus (& self) -> WdtBusR { WdtBusR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - OTP"]
# [inline (always)]
pub fn otp (& self) -> OtpR { OtpR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Монитор питания системного домена"]
# [inline (always)]
pub fn pvd (& self) -> PvdR { PvdR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Блок WakeUp (WU) батарейного домена"]
# [inline (always)]
pub fn wu (& self) -> WuR { WuR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - RTC батарейного домена"]
# [inline (always)]
pub fn rtc (& self) -> RtcR { RtcR :: new (((self . bits >> 8) & 1) != 0) } } impl W { # [doc = "Bit 0 - Блок управления питанием (PM - Power Monitor)"]
# [inline (always)]
pub fn pm (& mut self) -> PmW < ClkApbMSetSpec > { PmW :: new (self , 0) } # [doc = "Bit 1 - Контроллер прерываний"]
# [inline (always)]
pub fn epic (& mut self) -> EpicW < ClkApbMSetSpec > { EpicW :: new (self , 1) } # [doc = "Bit 2 - Таймер32_0"]
# [inline (always)]
pub fn timer32_0 (& mut self) -> Timer32_0W < ClkApbMSetSpec > { Timer32_0W :: new (self , 2) } # [doc = "Bit 3 - Контроллер выводов"]
# [inline (always)]
pub fn pad_config (& mut self) -> PadConfigW < ClkApbMSetSpec > { PadConfigW :: new (self , 3) } # [doc = "Bit 4 - Сторожевой таймер шины"]
# [inline (always)]
pub fn wdt_bus (& mut self) -> WdtBusW < ClkApbMSetSpec > { WdtBusW :: new (self , 4) } # [doc = "Bit 5 - OTP"]
# [inline (always)]
pub fn otp (& mut self) -> OtpW < ClkApbMSetSpec > { OtpW :: new (self , 5) } # [doc = "Bit 6 - Монитор питания системного домена"]
# [inline (always)]
pub fn pvd (& mut self) -> PvdW < ClkApbMSetSpec > { PvdW :: new (self , 6) } # [doc = "Bit 7 - Блок WakeUp (WU) батарейного домена"]
# [inline (always)]
pub fn wu (& mut self) -> WuW < ClkApbMSetSpec > { WuW :: new (self , 7) } # [doc = "Bit 8 - RTC батарейного домена"]
# [inline (always)]
pub fn rtc (& mut self) -> RtcW < ClkApbMSetSpec > { RtcW :: new (self , 8) } } # [doc = "Регистр включения тактированием устройств на шине APB_M. Каждому биту соответствует устройство\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_apb_m_set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_apb_m_set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClkApbMSetSpec ; impl crate :: RegisterSpec for ClkApbMSetSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`clk_apb_m_set::R`](R) reader structure"]
impl crate :: Readable for ClkApbMSetSpec { } # [doc = "`write(|w| ..)` method takes [`clk_apb_m_set::W`](W) writer structure"]
impl crate :: Writable for ClkApbMSetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLK_APB_M_SET to value 0x89"]
impl crate :: Resettable for ClkApbMSetSpec { const RESET_VALUE : u32 = 0x89 ; } } # [doc = "CLK_APB_M_CLEAR (rw) register accessor: Регистр выключения тактированием устройств на шине APB_M. Каждому биту соответствует устройство, аналогично Clk_APB_M_Set\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_apb_m_clear::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_apb_m_clear::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_apb_m_clear`]
module"]
# [doc (alias = "CLK_APB_M_CLEAR")]
pub type ClkApbMClear = crate :: Reg < clk_apb_m_clear :: ClkApbMClearSpec > ; # [doc = "Регистр выключения тактированием устройств на шине APB_M. Каждому биту соответствует устройство, аналогично Clk_APB_M_Set"]
pub mod clk_apb_m_clear { # [doc = "Register `CLK_APB_M_CLEAR` reader"]
pub type R = crate :: R < ClkApbMClearSpec > ; # [doc = "Register `CLK_APB_M_CLEAR` writer"]
pub type W = crate :: W < ClkApbMClearSpec > ; # [doc = "Блок управления питанием (PM - Power Monitor)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pm { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Pm > for bool { # [inline (always)]
fn from (variant : Pm) -> Self { variant as u8 != 0 } } # [doc = "Field `PM` reader - Блок управления питанием (PM - Power Monitor)"]
pub type PmR = crate :: BitReader < Pm > ; impl PmR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pm { match self . bits { false => Pm :: Disable , true => Pm :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Pm :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Pm :: Enable } } # [doc = "Блок управления питанием (PM - Power Monitor)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PmWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < PmWO > for bool { # [inline (always)]
fn from (variant : PmWO) -> Self { variant as u8 != 0 } } # [doc = "Field `PM` writer - Блок управления питанием (PM - Power Monitor)"]
pub type PmW < 'a , REG > = crate :: BitWriter < 'a , REG , PmWO > ; impl < 'a , REG > PmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PmWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PmWO :: Enable) } } # [doc = "Контроллер прерываний\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Epic { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Epic > for bool { # [inline (always)]
fn from (variant : Epic) -> Self { variant as u8 != 0 } } # [doc = "Field `EPIC` reader - Контроллер прерываний"]
pub type EpicR = crate :: BitReader < Epic > ; impl EpicR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Epic { match self . bits { false => Epic :: Disable , true => Epic :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Epic :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Epic :: Enable } } # [doc = "Контроллер прерываний\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EpicWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < EpicWO > for bool { # [inline (always)]
fn from (variant : EpicWO) -> Self { variant as u8 != 0 } } # [doc = "Field `EPIC` writer - Контроллер прерываний"]
pub type EpicW < 'a , REG > = crate :: BitWriter < 'a , REG , EpicWO > ; impl < 'a , REG > EpicW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (EpicWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (EpicWO :: Enable) } } # [doc = "Таймер32_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer32_0 > for bool { # [inline (always)]
fn from (variant : Timer32_0) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_0` reader - Таймер32_0"]
pub type Timer32_0R = crate :: BitReader < Timer32_0 > ; impl Timer32_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_0 { match self . bits { false => Timer32_0 :: Disable , true => Timer32_0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_0 :: Enable } } # [doc = "Таймер32_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_0WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Timer32_0WO > for bool { # [inline (always)]
fn from (variant : Timer32_0WO) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_0` writer - Таймер32_0"]
pub type Timer32_0W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer32_0WO > ; impl < 'a , REG > Timer32_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_0WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_0WO :: Enable) } } # [doc = "Контроллер выводов\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PadConfig { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < PadConfig > for bool { # [inline (always)]
fn from (variant : PadConfig) -> Self { variant as u8 != 0 } } # [doc = "Field `Pad_config` reader - Контроллер выводов"]
pub type PadConfigR = crate :: BitReader < PadConfig > ; impl PadConfigR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PadConfig { match self . bits { false => PadConfig :: Disable , true => PadConfig :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PadConfig :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PadConfig :: Enable } } # [doc = "Контроллер выводов\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PadConfigWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < PadConfigWO > for bool { # [inline (always)]
fn from (variant : PadConfigWO) -> Self { variant as u8 != 0 } } # [doc = "Field `Pad_config` writer - Контроллер выводов"]
pub type PadConfigW < 'a , REG > = crate :: BitWriter < 'a , REG , PadConfigWO > ; impl < 'a , REG > PadConfigW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PadConfigWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PadConfigWO :: Enable) } } # [doc = "Сторожевой таймер шины\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WdtBus { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < WdtBus > for bool { # [inline (always)]
fn from (variant : WdtBus) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT_BUS` reader - Сторожевой таймер шины"]
pub type WdtBusR = crate :: BitReader < WdtBus > ; impl WdtBusR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WdtBus { match self . bits { false => WdtBus :: Disable , true => WdtBus :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WdtBus :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WdtBus :: Enable } } # [doc = "Сторожевой таймер шины\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WdtBusWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < WdtBusWO > for bool { # [inline (always)]
fn from (variant : WdtBusWO) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT_BUS` writer - Сторожевой таймер шины"]
pub type WdtBusW < 'a , REG > = crate :: BitWriter < 'a , REG , WdtBusWO > ; impl < 'a , REG > WdtBusW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusWO :: Enable) } } # [doc = "OTP\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Otp { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Otp > for bool { # [inline (always)]
fn from (variant : Otp) -> Self { variant as u8 != 0 } } # [doc = "Field `OTP` reader - OTP"]
pub type OtpR = crate :: BitReader < Otp > ; impl OtpR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Otp { match self . bits { false => Otp :: Disable , true => Otp :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Otp :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Otp :: Enable } } # [doc = "OTP\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum OtpWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < OtpWO > for bool { # [inline (always)]
fn from (variant : OtpWO) -> Self { variant as u8 != 0 } } # [doc = "Field `OTP` writer - OTP"]
pub type OtpW < 'a , REG > = crate :: BitWriter < 'a , REG , OtpWO > ; impl < 'a , REG > OtpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (OtpWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (OtpWO :: Enable) } } # [doc = "Монитор питания системного домена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pvd { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Pvd > for bool { # [inline (always)]
fn from (variant : Pvd) -> Self { variant as u8 != 0 } } # [doc = "Field `PVD` reader - Монитор питания системного домена"]
pub type PvdR = crate :: BitReader < Pvd > ; impl PvdR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pvd { match self . bits { false => Pvd :: Disable , true => Pvd :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Pvd :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Pvd :: Enable } } # [doc = "Монитор питания системного домена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PvdWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < PvdWO > for bool { # [inline (always)]
fn from (variant : PvdWO) -> Self { variant as u8 != 0 } } # [doc = "Field `PVD` writer - Монитор питания системного домена"]
pub type PvdW < 'a , REG > = crate :: BitWriter < 'a , REG , PvdWO > ; impl < 'a , REG > PvdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdWO :: Enable) } } # [doc = "Блок WakeUp (WU) батарейного домена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wu { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Wu > for bool { # [inline (always)]
fn from (variant : Wu) -> Self { variant as u8 != 0 } } # [doc = "Field `WU` reader - Блок WakeUp (WU) батарейного домена"]
pub type WuR = crate :: BitReader < Wu > ; impl WuR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wu { match self . bits { false => Wu :: Disable , true => Wu :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Wu :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Wu :: Enable } } # [doc = "Блок WakeUp (WU) батарейного домена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WuWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < WuWO > for bool { # [inline (always)]
fn from (variant : WuWO) -> Self { variant as u8 != 0 } } # [doc = "Field `WU` writer - Блок WakeUp (WU) батарейного домена"]
pub type WuW < 'a , REG > = crate :: BitWriter < 'a , REG , WuWO > ; impl < 'a , REG > WuW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WuWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WuWO :: Enable) } } # [doc = "RTC батарейного домена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rtc { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Rtc > for bool { # [inline (always)]
fn from (variant : Rtc) -> Self { variant as u8 != 0 } } # [doc = "Field `RTC` reader - RTC батарейного домена"]
pub type RtcR = crate :: BitReader < Rtc > ; impl RtcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rtc { match self . bits { false => Rtc :: Disable , true => Rtc :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Rtc :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Rtc :: Enable } } # [doc = "RTC батарейного домена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RtcWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < RtcWO > for bool { # [inline (always)]
fn from (variant : RtcWO) -> Self { variant as u8 != 0 } } # [doc = "Field `RTC` writer - RTC батарейного домена"]
pub type RtcW < 'a , REG > = crate :: BitWriter < 'a , REG , RtcWO > ; impl < 'a , REG > RtcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (RtcWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (RtcWO :: Enable) } } impl R { # [doc = "Bit 0 - Блок управления питанием (PM - Power Monitor)"]
# [inline (always)]
pub fn pm (& self) -> PmR { PmR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Контроллер прерываний"]
# [inline (always)]
pub fn epic (& self) -> EpicR { EpicR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Таймер32_0"]
# [inline (always)]
pub fn timer32_0 (& self) -> Timer32_0R { Timer32_0R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Контроллер выводов"]
# [inline (always)]
pub fn pad_config (& self) -> PadConfigR { PadConfigR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Сторожевой таймер шины"]
# [inline (always)]
pub fn wdt_bus (& self) -> WdtBusR { WdtBusR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - OTP"]
# [inline (always)]
pub fn otp (& self) -> OtpR { OtpR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Монитор питания системного домена"]
# [inline (always)]
pub fn pvd (& self) -> PvdR { PvdR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Блок WakeUp (WU) батарейного домена"]
# [inline (always)]
pub fn wu (& self) -> WuR { WuR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - RTC батарейного домена"]
# [inline (always)]
pub fn rtc (& self) -> RtcR { RtcR :: new (((self . bits >> 8) & 1) != 0) } } impl W { # [doc = "Bit 0 - Блок управления питанием (PM - Power Monitor)"]
# [inline (always)]
pub fn pm (& mut self) -> PmW < ClkApbMClearSpec > { PmW :: new (self , 0) } # [doc = "Bit 1 - Контроллер прерываний"]
# [inline (always)]
pub fn epic (& mut self) -> EpicW < ClkApbMClearSpec > { EpicW :: new (self , 1) } # [doc = "Bit 2 - Таймер32_0"]
# [inline (always)]
pub fn timer32_0 (& mut self) -> Timer32_0W < ClkApbMClearSpec > { Timer32_0W :: new (self , 2) } # [doc = "Bit 3 - Контроллер выводов"]
# [inline (always)]
pub fn pad_config (& mut self) -> PadConfigW < ClkApbMClearSpec > { PadConfigW :: new (self , 3) } # [doc = "Bit 4 - Сторожевой таймер шины"]
# [inline (always)]
pub fn wdt_bus (& mut self) -> WdtBusW < ClkApbMClearSpec > { WdtBusW :: new (self , 4) } # [doc = "Bit 5 - OTP"]
# [inline (always)]
pub fn otp (& mut self) -> OtpW < ClkApbMClearSpec > { OtpW :: new (self , 5) } # [doc = "Bit 6 - Монитор питания системного домена"]
# [inline (always)]
pub fn pvd (& mut self) -> PvdW < ClkApbMClearSpec > { PvdW :: new (self , 6) } # [doc = "Bit 7 - Блок WakeUp (WU) батарейного домена"]
# [inline (always)]
pub fn wu (& mut self) -> WuW < ClkApbMClearSpec > { WuW :: new (self , 7) } # [doc = "Bit 8 - RTC батарейного домена"]
# [inline (always)]
pub fn rtc (& mut self) -> RtcW < ClkApbMClearSpec > { RtcW :: new (self , 8) } } # [doc = "Регистр выключения тактированием устройств на шине APB_M. Каждому биту соответствует устройство, аналогично Clk_APB_M_Set\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_apb_m_clear::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_apb_m_clear::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClkApbMClearSpec ; impl crate :: RegisterSpec for ClkApbMClearSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`clk_apb_m_clear::R`](R) reader structure"]
impl crate :: Readable for ClkApbMClearSpec { } # [doc = "`write(|w| ..)` method takes [`clk_apb_m_clear::W`](W) writer structure"]
impl crate :: Writable for ClkApbMClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLK_APB_M_CLEAR to value 0"]
impl crate :: Resettable for ClkApbMClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CLK_APB_P_SET (rw) register accessor: Регистр включения тактированием устройств на шине APB_P. Каждому биту соответствует одно устройство\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_apb_p_set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_apb_p_set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_apb_p_set`]
module"]
# [doc (alias = "CLK_APB_P_SET")]
pub type ClkApbPSet = crate :: Reg < clk_apb_p_set :: ClkApbPSetSpec > ; # [doc = "Регистр включения тактированием устройств на шине APB_P. Каждому биту соответствует одно устройство"]
pub mod clk_apb_p_set { # [doc = "Register `CLK_APB_P_SET` reader"]
pub type R = crate :: R < ClkApbPSetSpec > ; # [doc = "Register `CLK_APB_P_SET` writer"]
pub type W = crate :: W < ClkApbPSetSpec > ; # [doc = "Сторожевой таймер\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wdt { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Wdt > for bool { # [inline (always)]
fn from (variant : Wdt) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT` reader - Сторожевой таймер"]
pub type WdtR = crate :: BitReader < Wdt > ; impl WdtR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wdt { match self . bits { false => Wdt :: Disable , true => Wdt :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Wdt :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Wdt :: Enable } } # [doc = "Field `WDT` writer - Сторожевой таймер"]
pub type WdtW < 'a , REG > = crate :: BitWriter < 'a , REG , Wdt > ; impl < 'a , REG > WdtW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Wdt :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Wdt :: Enable) } } # [doc = "UART_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Uart0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Uart0 > for bool { # [inline (always)]
fn from (variant : Uart0) -> Self { variant as u8 != 0 } } # [doc = "Field `UART_0` reader - UART_0"]
pub type Uart0R = crate :: BitReader < Uart0 > ; impl Uart0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Uart0 { match self . bits { false => Uart0 :: Disable , true => Uart0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Uart0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Uart0 :: Enable } } # [doc = "Field `UART_0` writer - UART_0"]
pub type Uart0W < 'a , REG > = crate :: BitWriter < 'a , REG , Uart0 > ; impl < 'a , REG > Uart0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Uart0 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Uart0 :: Enable) } } # [doc = "UART_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Uart1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Uart1 > for bool { # [inline (always)]
fn from (variant : Uart1) -> Self { variant as u8 != 0 } } # [doc = "Field `UART_1` reader - UART_1"]
pub type Uart1R = crate :: BitReader < Uart1 > ; impl Uart1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Uart1 { match self . bits { false => Uart1 :: Disable , true => Uart1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Uart1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Uart1 :: Enable } } # [doc = "Field `UART_1` writer - UART_1"]
pub type Uart1W < 'a , REG > = crate :: BitWriter < 'a , REG , Uart1 > ; impl < 'a , REG > Uart1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Uart1 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Uart1 :: Enable) } } # [doc = "Timer16_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer16_0 > for bool { # [inline (always)]
fn from (variant : Timer16_0) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_0` reader - Timer16_0"]
pub type Timer16_0R = crate :: BitReader < Timer16_0 > ; impl Timer16_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_0 { match self . bits { false => Timer16_0 :: Disable , true => Timer16_0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_0 :: Enable } } # [doc = "Field `Timer16_0` writer - Timer16_0"]
pub type Timer16_0W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer16_0 > ; impl < 'a , REG > Timer16_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_0 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_0 :: Enable) } } # [doc = "Timer16_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer16_1 > for bool { # [inline (always)]
fn from (variant : Timer16_1) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_1` reader - Timer16_1"]
pub type Timer16_1R = crate :: BitReader < Timer16_1 > ; impl Timer16_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_1 { match self . bits { false => Timer16_1 :: Disable , true => Timer16_1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_1 :: Enable } } # [doc = "Field `Timer16_1` writer - Timer16_1"]
pub type Timer16_1W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer16_1 > ; impl < 'a , REG > Timer16_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_1 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_1 :: Enable) } } # [doc = "Timer16_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_2 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer16_2 > for bool { # [inline (always)]
fn from (variant : Timer16_2) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_2` reader - Timer16_2"]
pub type Timer16_2R = crate :: BitReader < Timer16_2 > ; impl Timer16_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_2 { match self . bits { false => Timer16_2 :: Disable , true => Timer16_2 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_2 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_2 :: Enable } } # [doc = "Field `Timer16_2` writer - Timer16_2"]
pub type Timer16_2W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer16_2 > ; impl < 'a , REG > Timer16_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_2 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_2 :: Enable) } } # [doc = "Timer32_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer32_1 > for bool { # [inline (always)]
fn from (variant : Timer32_1) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_1` reader - Timer32_1"]
pub type Timer32_1R = crate :: BitReader < Timer32_1 > ; impl Timer32_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_1 { match self . bits { false => Timer32_1 :: Disable , true => Timer32_1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_1 :: Enable } } # [doc = "Field `Timer32_1` writer - Timer32_1"]
pub type Timer32_1W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer32_1 > ; impl < 'a , REG > Timer32_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_1 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_1 :: Enable) } } # [doc = "Timer32_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_2 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer32_2 > for bool { # [inline (always)]
fn from (variant : Timer32_2) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_2` reader - Timer32_2"]
pub type Timer32_2R = crate :: BitReader < Timer32_2 > ; impl Timer32_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_2 { match self . bits { false => Timer32_2 :: Disable , true => Timer32_2 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_2 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_2 :: Enable } } # [doc = "Field `Timer32_2` writer - Timer32_2"]
pub type Timer32_2W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer32_2 > ; impl < 'a , REG > Timer32_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_2 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_2 :: Enable) } } # [doc = "SPI_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spi0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Spi0 > for bool { # [inline (always)]
fn from (variant : Spi0) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_0` reader - SPI_0"]
pub type Spi0R = crate :: BitReader < Spi0 > ; impl Spi0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spi0 { match self . bits { false => Spi0 :: Disable , true => Spi0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spi0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spi0 :: Enable } } # [doc = "Field `SPI_0` writer - SPI_0"]
pub type Spi0W < 'a , REG > = crate :: BitWriter < 'a , REG , Spi0 > ; impl < 'a , REG > Spi0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi0 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi0 :: Enable) } } # [doc = "SPI_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spi1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Spi1 > for bool { # [inline (always)]
fn from (variant : Spi1) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_1` reader - SPI_1"]
pub type Spi1R = crate :: BitReader < Spi1 > ; impl Spi1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spi1 { match self . bits { false => Spi1 :: Disable , true => Spi1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spi1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spi1 :: Enable } } # [doc = "Field `SPI_1` writer - SPI_1"]
pub type Spi1W < 'a , REG > = crate :: BitWriter < 'a , REG , Spi1 > ; impl < 'a , REG > Spi1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi1 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi1 :: Enable) } } # [doc = "I2C_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum I2c0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < I2c0 > for bool { # [inline (always)]
fn from (variant : I2c0) -> Self { variant as u8 != 0 } } # [doc = "Field `I2C_0` reader - I2C_0"]
pub type I2c0R = crate :: BitReader < I2c0 > ; impl I2c0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> I2c0 { match self . bits { false => I2c0 :: Disable , true => I2c0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == I2c0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == I2c0 :: Enable } } # [doc = "Field `I2C_0` writer - I2C_0"]
pub type I2c0W < 'a , REG > = crate :: BitWriter < 'a , REG , I2c0 > ; impl < 'a , REG > I2c0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c0 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c0 :: Enable) } } # [doc = "I2C_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum I2c1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < I2c1 > for bool { # [inline (always)]
fn from (variant : I2c1) -> Self { variant as u8 != 0 } } # [doc = "Field `I2C_1` reader - I2C_1"]
pub type I2c1R = crate :: BitReader < I2c1 > ; impl I2c1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> I2c1 { match self . bits { false => I2c1 :: Disable , true => I2c1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == I2c1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == I2c1 :: Enable } } # [doc = "Field `I2C_1` writer - I2C_1"]
pub type I2c1W < 'a , REG > = crate :: BitWriter < 'a , REG , I2c1 > ; impl < 'a , REG > I2c1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c1 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c1 :: Enable) } } # [doc = "GPIO_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gpio0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Gpio0 > for bool { # [inline (always)]
fn from (variant : Gpio0) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_0` reader - GPIO_0"]
pub type Gpio0R = crate :: BitReader < Gpio0 > ; impl Gpio0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Gpio0 { match self . bits { false => Gpio0 :: Disable , true => Gpio0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Gpio0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Gpio0 :: Enable } } # [doc = "Field `GPIO_0` writer - GPIO_0"]
pub type Gpio0W < 'a , REG > = crate :: BitWriter < 'a , REG , Gpio0 > ; impl < 'a , REG > Gpio0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio0 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio0 :: Enable) } } # [doc = "GPIO_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gpio1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Gpio1 > for bool { # [inline (always)]
fn from (variant : Gpio1) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_1` reader - GPIO_1"]
pub type Gpio1R = crate :: BitReader < Gpio1 > ; impl Gpio1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Gpio1 { match self . bits { false => Gpio1 :: Disable , true => Gpio1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Gpio1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Gpio1 :: Enable } } # [doc = "Field `GPIO_1` writer - GPIO_1"]
pub type Gpio1W < 'a , REG > = crate :: BitWriter < 'a , REG , Gpio1 > ; impl < 'a , REG > Gpio1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio1 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio1 :: Enable) } } # [doc = "GPIO_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gpio2 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Gpio2 > for bool { # [inline (always)]
fn from (variant : Gpio2) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_2` reader - GPIO_2"]
pub type Gpio2R = crate :: BitReader < Gpio2 > ; impl Gpio2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Gpio2 { match self . bits { false => Gpio2 :: Disable , true => Gpio2 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Gpio2 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Gpio2 :: Enable } } # [doc = "Field `GPIO_2` writer - GPIO_2"]
pub type Gpio2W < 'a , REG > = crate :: BitWriter < 'a , REG , Gpio2 > ; impl < 'a , REG > Gpio2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio2 :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio2 :: Enable) } } # [doc = "Регистры аналоговых блоков\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum AnalogRegs { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < AnalogRegs > for bool { # [inline (always)]
fn from (variant : AnalogRegs) -> Self { variant as u8 != 0 } } # [doc = "Field `Analog_regs` reader - Регистры аналоговых блоков"]
pub type AnalogRegsR = crate :: BitReader < AnalogRegs > ; impl AnalogRegsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> AnalogRegs { match self . bits { false => AnalogRegs :: Disable , true => AnalogRegs :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == AnalogRegs :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == AnalogRegs :: Enable } } # [doc = "Field `Analog_regs` writer - Регистры аналоговых блоков"]
pub type AnalogRegsW < 'a , REG > = crate :: BitWriter < 'a , REG , AnalogRegs > ; impl < 'a , REG > AnalogRegsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (AnalogRegs :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (AnalogRegs :: Enable) } } # [doc = "Схема формирования прерываний GPIO\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum GpioIrq { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < GpioIrq > for bool { # [inline (always)]
fn from (variant : GpioIrq) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_IRQ` reader - Схема формирования прерываний GPIO"]
pub type GpioIrqR = crate :: BitReader < GpioIrq > ; impl GpioIrqR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> GpioIrq { match self . bits { false => GpioIrq :: Disable , true => GpioIrq :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == GpioIrq :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == GpioIrq :: Enable } } # [doc = "Field `GPIO_IRQ` writer - Схема формирования прерываний GPIO"]
pub type GpioIrqW < 'a , REG > = crate :: BitWriter < 'a , REG , GpioIrq > ; impl < 'a , REG > GpioIrqW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (GpioIrq :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (GpioIrq :: Enable) } } impl R { # [doc = "Bit 0 - Сторожевой таймер"]
# [inline (always)]
pub fn wdt (& self) -> WdtR { WdtR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - UART_0"]
# [inline (always)]
pub fn uart_0 (& self) -> Uart0R { Uart0R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - UART_1"]
# [inline (always)]
pub fn uart_1 (& self) -> Uart1R { Uart1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& self) -> Timer16_0R { Timer16_0R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& self) -> Timer16_1R { Timer16_1R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& self) -> Timer16_2R { Timer16_2R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& self) -> Timer32_1R { Timer32_1R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& self) -> Timer32_2R { Timer32_2R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - SPI_0"]
# [inline (always)]
pub fn spi_0 (& self) -> Spi0R { Spi0R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - SPI_1"]
# [inline (always)]
pub fn spi_1 (& self) -> Spi1R { Spi1R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - I2C_0"]
# [inline (always)]
pub fn i2c_0 (& self) -> I2c0R { I2c0R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - I2C_1"]
# [inline (always)]
pub fn i2c_1 (& self) -> I2c1R { I2c1R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - GPIO_0"]
# [inline (always)]
pub fn gpio_0 (& self) -> Gpio0R { Gpio0R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - GPIO_1"]
# [inline (always)]
pub fn gpio_1 (& self) -> Gpio1R { Gpio1R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - GPIO_2"]
# [inline (always)]
pub fn gpio_2 (& self) -> Gpio2R { Gpio2R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Регистры аналоговых блоков"]
# [inline (always)]
pub fn analog_regs (& self) -> AnalogRegsR { AnalogRegsR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 15 - Схема формирования прерываний GPIO"]
# [inline (always)]
pub fn gpio_irq (& self) -> GpioIrqR { GpioIrqR :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - Сторожевой таймер"]
# [inline (always)]
pub fn wdt (& mut self) -> WdtW < ClkApbPSetSpec > { WdtW :: new (self , 0) } # [doc = "Bit 1 - UART_0"]
# [inline (always)]
pub fn uart_0 (& mut self) -> Uart0W < ClkApbPSetSpec > { Uart0W :: new (self , 1) } # [doc = "Bit 2 - UART_1"]
# [inline (always)]
pub fn uart_1 (& mut self) -> Uart1W < ClkApbPSetSpec > { Uart1W :: new (self , 2) } # [doc = "Bit 3 - Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& mut self) -> Timer16_0W < ClkApbPSetSpec > { Timer16_0W :: new (self , 3) } # [doc = "Bit 4 - Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& mut self) -> Timer16_1W < ClkApbPSetSpec > { Timer16_1W :: new (self , 4) } # [doc = "Bit 5 - Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& mut self) -> Timer16_2W < ClkApbPSetSpec > { Timer16_2W :: new (self , 5) } # [doc = "Bit 6 - Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& mut self) -> Timer32_1W < ClkApbPSetSpec > { Timer32_1W :: new (self , 6) } # [doc = "Bit 7 - Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& mut self) -> Timer32_2W < ClkApbPSetSpec > { Timer32_2W :: new (self , 7) } # [doc = "Bit 8 - SPI_0"]
# [inline (always)]
pub fn spi_0 (& mut self) -> Spi0W < ClkApbPSetSpec > { Spi0W :: new (self , 8) } # [doc = "Bit 9 - SPI_1"]
# [inline (always)]
pub fn spi_1 (& mut self) -> Spi1W < ClkApbPSetSpec > { Spi1W :: new (self , 9) } # [doc = "Bit 10 - I2C_0"]
# [inline (always)]
pub fn i2c_0 (& mut self) -> I2c0W < ClkApbPSetSpec > { I2c0W :: new (self , 10) } # [doc = "Bit 11 - I2C_1"]
# [inline (always)]
pub fn i2c_1 (& mut self) -> I2c1W < ClkApbPSetSpec > { I2c1W :: new (self , 11) } # [doc = "Bit 12 - GPIO_0"]
# [inline (always)]
pub fn gpio_0 (& mut self) -> Gpio0W < ClkApbPSetSpec > { Gpio0W :: new (self , 12) } # [doc = "Bit 13 - GPIO_1"]
# [inline (always)]
pub fn gpio_1 (& mut self) -> Gpio1W < ClkApbPSetSpec > { Gpio1W :: new (self , 13) } # [doc = "Bit 14 - GPIO_2"]
# [inline (always)]
pub fn gpio_2 (& mut self) -> Gpio2W < ClkApbPSetSpec > { Gpio2W :: new (self , 14) } # [doc = "Bit 15 - Регистры аналоговых блоков"]
# [inline (always)]
pub fn analog_regs (& mut self) -> AnalogRegsW < ClkApbPSetSpec > { AnalogRegsW :: new (self , 15) } # [doc = "Bit 15 - Схема формирования прерываний GPIO"]
# [inline (always)]
pub fn gpio_irq (& mut self) -> GpioIrqW < ClkApbPSetSpec > { GpioIrqW :: new (self , 15) } } # [doc = "Регистр включения тактированием устройств на шине APB_P. Каждому биту соответствует одно устройство\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_apb_p_set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_apb_p_set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClkApbPSetSpec ; impl crate :: RegisterSpec for ClkApbPSetSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`clk_apb_p_set::R`](R) reader structure"]
impl crate :: Readable for ClkApbPSetSpec { } # [doc = "`write(|w| ..)` method takes [`clk_apb_p_set::W`](W) writer structure"]
impl crate :: Writable for ClkApbPSetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLK_APB_P_SET to value 0"]
impl crate :: Resettable for ClkApbPSetSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CLK_APB_P_CLEAR (rw) register accessor: Регистр выключения тактированием устройств на шине APB_P. Каждому биту соответствует устройство, аналогично CLK_APB_P_SET\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_apb_p_clear::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_apb_p_clear::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clk_apb_p_clear`]
module"]
# [doc (alias = "CLK_APB_P_CLEAR")]
pub type ClkApbPClear = crate :: Reg < clk_apb_p_clear :: ClkApbPClearSpec > ; # [doc = "Регистр выключения тактированием устройств на шине APB_P. Каждому биту соответствует устройство, аналогично CLK_APB_P_SET"]
pub mod clk_apb_p_clear { # [doc = "Register `CLK_APB_P_CLEAR` reader"]
pub type R = crate :: R < ClkApbPClearSpec > ; # [doc = "Register `CLK_APB_P_CLEAR` writer"]
pub type W = crate :: W < ClkApbPClearSpec > ; # [doc = "Сторожевой таймер\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wdt { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Wdt > for bool { # [inline (always)]
fn from (variant : Wdt) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT` reader - Сторожевой таймер"]
pub type WdtR = crate :: BitReader < Wdt > ; impl WdtR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wdt { match self . bits { false => Wdt :: Disable , true => Wdt :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Wdt :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Wdt :: Enable } } # [doc = "Сторожевой таймер\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WdtWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < WdtWO > for bool { # [inline (always)]
fn from (variant : WdtWO) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT` writer - Сторожевой таймер"]
pub type WdtW < 'a , REG > = crate :: BitWriter < 'a , REG , WdtWO > ; impl < 'a , REG > WdtW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtWO :: Enable) } } # [doc = "UART_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Uart0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Uart0 > for bool { # [inline (always)]
fn from (variant : Uart0) -> Self { variant as u8 != 0 } } # [doc = "Field `UART_0` reader - UART_0"]
pub type Uart0R = crate :: BitReader < Uart0 > ; impl Uart0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Uart0 { match self . bits { false => Uart0 :: Disable , true => Uart0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Uart0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Uart0 :: Enable } } # [doc = "UART_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Uart0WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Uart0WO > for bool { # [inline (always)]
fn from (variant : Uart0WO) -> Self { variant as u8 != 0 } } # [doc = "Field `UART_0` writer - UART_0"]
pub type Uart0W < 'a , REG > = crate :: BitWriter < 'a , REG , Uart0WO > ; impl < 'a , REG > Uart0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Uart0WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Uart0WO :: Enable) } } # [doc = "UART_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Uart1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Uart1 > for bool { # [inline (always)]
fn from (variant : Uart1) -> Self { variant as u8 != 0 } } # [doc = "Field `UART_1` reader - UART_1"]
pub type Uart1R = crate :: BitReader < Uart1 > ; impl Uart1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Uart1 { match self . bits { false => Uart1 :: Disable , true => Uart1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Uart1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Uart1 :: Enable } } # [doc = "UART_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Uart1WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Uart1WO > for bool { # [inline (always)]
fn from (variant : Uart1WO) -> Self { variant as u8 != 0 } } # [doc = "Field `UART_1` writer - UART_1"]
pub type Uart1W < 'a , REG > = crate :: BitWriter < 'a , REG , Uart1WO > ; impl < 'a , REG > Uart1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Uart1WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Uart1WO :: Enable) } } # [doc = "Timer16_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer16_0 > for bool { # [inline (always)]
fn from (variant : Timer16_0) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_0` reader - Timer16_0"]
pub type Timer16_0R = crate :: BitReader < Timer16_0 > ; impl Timer16_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_0 { match self . bits { false => Timer16_0 :: Disable , true => Timer16_0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_0 :: Enable } } # [doc = "Timer16_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_0WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Timer16_0WO > for bool { # [inline (always)]
fn from (variant : Timer16_0WO) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_0` writer - Timer16_0"]
pub type Timer16_0W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer16_0WO > ; impl < 'a , REG > Timer16_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_0WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_0WO :: Enable) } } # [doc = "Timer16_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer16_1 > for bool { # [inline (always)]
fn from (variant : Timer16_1) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_1` reader - Timer16_1"]
pub type Timer16_1R = crate :: BitReader < Timer16_1 > ; impl Timer16_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_1 { match self . bits { false => Timer16_1 :: Disable , true => Timer16_1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_1 :: Enable } } # [doc = "Timer16_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_1WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Timer16_1WO > for bool { # [inline (always)]
fn from (variant : Timer16_1WO) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_1` writer - Timer16_1"]
pub type Timer16_1W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer16_1WO > ; impl < 'a , REG > Timer16_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_1WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_1WO :: Enable) } } # [doc = "Timer16_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_2 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer16_2 > for bool { # [inline (always)]
fn from (variant : Timer16_2) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_2` reader - Timer16_2"]
pub type Timer16_2R = crate :: BitReader < Timer16_2 > ; impl Timer16_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_2 { match self . bits { false => Timer16_2 :: Disable , true => Timer16_2 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_2 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_2 :: Enable } } # [doc = "Timer16_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_2WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Timer16_2WO > for bool { # [inline (always)]
fn from (variant : Timer16_2WO) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_2` writer - Timer16_2"]
pub type Timer16_2W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer16_2WO > ; impl < 'a , REG > Timer16_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_2WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_2WO :: Enable) } } # [doc = "Timer32_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer32_1 > for bool { # [inline (always)]
fn from (variant : Timer32_1) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_1` reader - Timer32_1"]
pub type Timer32_1R = crate :: BitReader < Timer32_1 > ; impl Timer32_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_1 { match self . bits { false => Timer32_1 :: Disable , true => Timer32_1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_1 :: Enable } } # [doc = "Timer32_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_1WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Timer32_1WO > for bool { # [inline (always)]
fn from (variant : Timer32_1WO) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_1` writer - Timer32_1"]
pub type Timer32_1W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer32_1WO > ; impl < 'a , REG > Timer32_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_1WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_1WO :: Enable) } } # [doc = "Timer32_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_2 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Timer32_2 > for bool { # [inline (always)]
fn from (variant : Timer32_2) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_2` reader - Timer32_2"]
pub type Timer32_2R = crate :: BitReader < Timer32_2 > ; impl Timer32_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_2 { match self . bits { false => Timer32_2 :: Disable , true => Timer32_2 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_2 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_2 :: Enable } } # [doc = "Timer32_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_2WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Timer32_2WO > for bool { # [inline (always)]
fn from (variant : Timer32_2WO) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_2` writer - Timer32_2"]
pub type Timer32_2W < 'a , REG > = crate :: BitWriter < 'a , REG , Timer32_2WO > ; impl < 'a , REG > Timer32_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_2WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_2WO :: Enable) } } # [doc = "SPI_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spi0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Spi0 > for bool { # [inline (always)]
fn from (variant : Spi0) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_0` reader - SPI_0"]
pub type Spi0R = crate :: BitReader < Spi0 > ; impl Spi0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spi0 { match self . bits { false => Spi0 :: Disable , true => Spi0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spi0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spi0 :: Enable } } # [doc = "SPI_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spi0WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Spi0WO > for bool { # [inline (always)]
fn from (variant : Spi0WO) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_0` writer - SPI_0"]
pub type Spi0W < 'a , REG > = crate :: BitWriter < 'a , REG , Spi0WO > ; impl < 'a , REG > Spi0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi0WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi0WO :: Enable) } } # [doc = "SPI_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spi1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Spi1 > for bool { # [inline (always)]
fn from (variant : Spi1) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_1` reader - SPI_1"]
pub type Spi1R = crate :: BitReader < Spi1 > ; impl Spi1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spi1 { match self . bits { false => Spi1 :: Disable , true => Spi1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spi1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spi1 :: Enable } } # [doc = "SPI_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spi1WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Spi1WO > for bool { # [inline (always)]
fn from (variant : Spi1WO) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_1` writer - SPI_1"]
pub type Spi1W < 'a , REG > = crate :: BitWriter < 'a , REG , Spi1WO > ; impl < 'a , REG > Spi1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi1WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi1WO :: Enable) } } # [doc = "I2C_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum I2c0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < I2c0 > for bool { # [inline (always)]
fn from (variant : I2c0) -> Self { variant as u8 != 0 } } # [doc = "Field `I2C_0` reader - I2C_0"]
pub type I2c0R = crate :: BitReader < I2c0 > ; impl I2c0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> I2c0 { match self . bits { false => I2c0 :: Disable , true => I2c0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == I2c0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == I2c0 :: Enable } } # [doc = "I2C_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum I2c0WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < I2c0WO > for bool { # [inline (always)]
fn from (variant : I2c0WO) -> Self { variant as u8 != 0 } } # [doc = "Field `I2C_0` writer - I2C_0"]
pub type I2c0W < 'a , REG > = crate :: BitWriter < 'a , REG , I2c0WO > ; impl < 'a , REG > I2c0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c0WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c0WO :: Enable) } } # [doc = "I2C_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum I2c1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < I2c1 > for bool { # [inline (always)]
fn from (variant : I2c1) -> Self { variant as u8 != 0 } } # [doc = "Field `I2C_1` reader - I2C_1"]
pub type I2c1R = crate :: BitReader < I2c1 > ; impl I2c1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> I2c1 { match self . bits { false => I2c1 :: Disable , true => I2c1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == I2c1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == I2c1 :: Enable } } # [doc = "I2C_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum I2c1WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < I2c1WO > for bool { # [inline (always)]
fn from (variant : I2c1WO) -> Self { variant as u8 != 0 } } # [doc = "Field `I2C_1` writer - I2C_1"]
pub type I2c1W < 'a , REG > = crate :: BitWriter < 'a , REG , I2c1WO > ; impl < 'a , REG > I2c1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c1WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c1WO :: Enable) } } # [doc = "GPIO_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gpio0 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Gpio0 > for bool { # [inline (always)]
fn from (variant : Gpio0) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_0` reader - GPIO_0"]
pub type Gpio0R = crate :: BitReader < Gpio0 > ; impl Gpio0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Gpio0 { match self . bits { false => Gpio0 :: Disable , true => Gpio0 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Gpio0 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Gpio0 :: Enable } } # [doc = "GPIO_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gpio0WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Gpio0WO > for bool { # [inline (always)]
fn from (variant : Gpio0WO) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_0` writer - GPIO_0"]
pub type Gpio0W < 'a , REG > = crate :: BitWriter < 'a , REG , Gpio0WO > ; impl < 'a , REG > Gpio0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio0WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio0WO :: Enable) } } # [doc = "GPIO_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gpio1 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Gpio1 > for bool { # [inline (always)]
fn from (variant : Gpio1) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_1` reader - GPIO_1"]
pub type Gpio1R = crate :: BitReader < Gpio1 > ; impl Gpio1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Gpio1 { match self . bits { false => Gpio1 :: Disable , true => Gpio1 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Gpio1 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Gpio1 :: Enable } } # [doc = "GPIO_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gpio1WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Gpio1WO > for bool { # [inline (always)]
fn from (variant : Gpio1WO) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_1` writer - GPIO_1"]
pub type Gpio1W < 'a , REG > = crate :: BitWriter < 'a , REG , Gpio1WO > ; impl < 'a , REG > Gpio1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio1WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio1WO :: Enable) } } # [doc = "GPIO_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gpio2 { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < Gpio2 > for bool { # [inline (always)]
fn from (variant : Gpio2) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_2` reader - GPIO_2"]
pub type Gpio2R = crate :: BitReader < Gpio2 > ; impl Gpio2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Gpio2 { match self . bits { false => Gpio2 :: Disable , true => Gpio2 :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Gpio2 :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Gpio2 :: Enable } } # [doc = "GPIO_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gpio2WO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < Gpio2WO > for bool { # [inline (always)]
fn from (variant : Gpio2WO) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_2` writer - GPIO_2"]
pub type Gpio2W < 'a , REG > = crate :: BitWriter < 'a , REG , Gpio2WO > ; impl < 'a , REG > Gpio2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio2WO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio2WO :: Enable) } } # [doc = "Регистры аналоговых блоков\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum AnalogRegs { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < AnalogRegs > for bool { # [inline (always)]
fn from (variant : AnalogRegs) -> Self { variant as u8 != 0 } } # [doc = "Field `Analog_regs` reader - Регистры аналоговых блоков"]
pub type AnalogRegsR = crate :: BitReader < AnalogRegs > ; impl AnalogRegsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> AnalogRegs { match self . bits { false => AnalogRegs :: Disable , true => AnalogRegs :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == AnalogRegs :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == AnalogRegs :: Enable } } # [doc = "Регистры аналоговых блоков\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum AnalogRegsWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < AnalogRegsWO > for bool { # [inline (always)]
fn from (variant : AnalogRegsWO) -> Self { variant as u8 != 0 } } # [doc = "Field `Analog_regs` writer - Регистры аналоговых блоков"]
pub type AnalogRegsW < 'a , REG > = crate :: BitWriter < 'a , REG , AnalogRegsWO > ; impl < 'a , REG > AnalogRegsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (AnalogRegsWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (AnalogRegsWO :: Enable) } } # [doc = "Схема формирования прерываний GPIO\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum GpioIrq { # [doc = "0: Тактирование выключено"]
Disable = 0 , # [doc = "1: Тактирование включено"]
Enable = 1 , } impl From < GpioIrq > for bool { # [inline (always)]
fn from (variant : GpioIrq) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_IRQ` reader - Схема формирования прерываний GPIO"]
pub type GpioIrqR = crate :: BitReader < GpioIrq > ; impl GpioIrqR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> GpioIrq { match self . bits { false => GpioIrq :: Disable , true => GpioIrq :: Enable , } } # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == GpioIrq :: Disable } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == GpioIrq :: Enable } } # [doc = "Схема формирования прерываний GPIO\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum GpioIrqWO { # [doc = "1: Тактирование выключено"]
Disable = 1 , # [doc = "0: Тактирование включено"]
Enable = 0 , } impl From < GpioIrqWO > for bool { # [inline (always)]
fn from (variant : GpioIrqWO) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO_IRQ` writer - Схема формирования прерываний GPIO"]
pub type GpioIrqW < 'a , REG > = crate :: BitWriter < 'a , REG , GpioIrqWO > ; impl < 'a , REG > GpioIrqW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (GpioIrqWO :: Disable) } # [doc = "Тактирование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (GpioIrqWO :: Enable) } } impl R { # [doc = "Bit 0 - Сторожевой таймер"]
# [inline (always)]
pub fn wdt (& self) -> WdtR { WdtR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - UART_0"]
# [inline (always)]
pub fn uart_0 (& self) -> Uart0R { Uart0R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - UART_1"]
# [inline (always)]
pub fn uart_1 (& self) -> Uart1R { Uart1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& self) -> Timer16_0R { Timer16_0R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& self) -> Timer16_1R { Timer16_1R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& self) -> Timer16_2R { Timer16_2R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& self) -> Timer32_1R { Timer32_1R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& self) -> Timer32_2R { Timer32_2R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - SPI_0"]
# [inline (always)]
pub fn spi_0 (& self) -> Spi0R { Spi0R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - SPI_1"]
# [inline (always)]
pub fn spi_1 (& self) -> Spi1R { Spi1R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - I2C_0"]
# [inline (always)]
pub fn i2c_0 (& self) -> I2c0R { I2c0R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - I2C_1"]
# [inline (always)]
pub fn i2c_1 (& self) -> I2c1R { I2c1R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - GPIO_0"]
# [inline (always)]
pub fn gpio_0 (& self) -> Gpio0R { Gpio0R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - GPIO_1"]
# [inline (always)]
pub fn gpio_1 (& self) -> Gpio1R { Gpio1R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - GPIO_2"]
# [inline (always)]
pub fn gpio_2 (& self) -> Gpio2R { Gpio2R :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Регистры аналоговых блоков"]
# [inline (always)]
pub fn analog_regs (& self) -> AnalogRegsR { AnalogRegsR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 15 - Схема формирования прерываний GPIO"]
# [inline (always)]
pub fn gpio_irq (& self) -> GpioIrqR { GpioIrqR :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bit 0 - Сторожевой таймер"]
# [inline (always)]
pub fn wdt (& mut self) -> WdtW < ClkApbPClearSpec > { WdtW :: new (self , 0) } # [doc = "Bit 1 - UART_0"]
# [inline (always)]
pub fn uart_0 (& mut self) -> Uart0W < ClkApbPClearSpec > { Uart0W :: new (self , 1) } # [doc = "Bit 2 - UART_1"]
# [inline (always)]
pub fn uart_1 (& mut self) -> Uart1W < ClkApbPClearSpec > { Uart1W :: new (self , 2) } # [doc = "Bit 3 - Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& mut self) -> Timer16_0W < ClkApbPClearSpec > { Timer16_0W :: new (self , 3) } # [doc = "Bit 4 - Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& mut self) -> Timer16_1W < ClkApbPClearSpec > { Timer16_1W :: new (self , 4) } # [doc = "Bit 5 - Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& mut self) -> Timer16_2W < ClkApbPClearSpec > { Timer16_2W :: new (self , 5) } # [doc = "Bit 6 - Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& mut self) -> Timer32_1W < ClkApbPClearSpec > { Timer32_1W :: new (self , 6) } # [doc = "Bit 7 - Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& mut self) -> Timer32_2W < ClkApbPClearSpec > { Timer32_2W :: new (self , 7) } # [doc = "Bit 8 - SPI_0"]
# [inline (always)]
pub fn spi_0 (& mut self) -> Spi0W < ClkApbPClearSpec > { Spi0W :: new (self , 8) } # [doc = "Bit 9 - SPI_1"]
# [inline (always)]
pub fn spi_1 (& mut self) -> Spi1W < ClkApbPClearSpec > { Spi1W :: new (self , 9) } # [doc = "Bit 10 - I2C_0"]
# [inline (always)]
pub fn i2c_0 (& mut self) -> I2c0W < ClkApbPClearSpec > { I2c0W :: new (self , 10) } # [doc = "Bit 11 - I2C_1"]
# [inline (always)]
pub fn i2c_1 (& mut self) -> I2c1W < ClkApbPClearSpec > { I2c1W :: new (self , 11) } # [doc = "Bit 12 - GPIO_0"]
# [inline (always)]
pub fn gpio_0 (& mut self) -> Gpio0W < ClkApbPClearSpec > { Gpio0W :: new (self , 12) } # [doc = "Bit 13 - GPIO_1"]
# [inline (always)]
pub fn gpio_1 (& mut self) -> Gpio1W < ClkApbPClearSpec > { Gpio1W :: new (self , 13) } # [doc = "Bit 14 - GPIO_2"]
# [inline (always)]
pub fn gpio_2 (& mut self) -> Gpio2W < ClkApbPClearSpec > { Gpio2W :: new (self , 14) } # [doc = "Bit 15 - Регистры аналоговых блоков"]
# [inline (always)]
pub fn analog_regs (& mut self) -> AnalogRegsW < ClkApbPClearSpec > { AnalogRegsW :: new (self , 15) } # [doc = "Bit 15 - Схема формирования прерываний GPIO"]
# [inline (always)]
pub fn gpio_irq (& mut self) -> GpioIrqW < ClkApbPClearSpec > { GpioIrqW :: new (self , 15) } } # [doc = "Регистр выключения тактированием устройств на шине APB_P. Каждому биту соответствует устройство, аналогично CLK_APB_P_SET\n\nYou can [`read`](crate::Reg::read) this register and get [`clk_apb_p_clear::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clk_apb_p_clear::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClkApbPClearSpec ; impl crate :: RegisterSpec for ClkApbPClearSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`clk_apb_p_clear::R`](R) reader structure"]
impl crate :: Readable for ClkApbPClearSpec { } # [doc = "`write(|w| ..)` method takes [`clk_apb_p_clear::W`](W) writer structure"]
impl crate :: Writable for ClkApbPClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLK_APB_P_CLEAR to value 0"]
impl crate :: Resettable for ClkApbPClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "AHB_MUX (rw) register accessor: Настройка источника тактирования системы\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb_mux::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb_mux::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ahb_mux`]
module"]
# [doc (alias = "AHB_MUX")]
pub type AhbMux = crate :: Reg < ahb_mux :: AhbMuxSpec > ; # [doc = "Настройка источника тактирования системы"]
pub mod ahb_mux { # [doc = "Register `AHB_MUX` reader"]
pub type R = crate :: R < AhbMuxSpec > ; # [doc = "Register `AHB_MUX` writer"]
pub type W = crate :: W < AhbMuxSpec > ; # [doc = "Источника тактирования системы\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum AhbClkMux { # [doc = "0: Внешний OSC32M"]
Osc32m = 0 , # [doc = "1: Внутренний HSI32M"]
Hsi32m = 1 , # [doc = "2: Внешний OSC32K"]
Osc32k = 2 , # [doc = "3: Внутренний LSI32К"]
Lsi32k = 3 , } impl From < AhbClkMux > for u8 { # [inline (always)]
fn from (variant : AhbClkMux) -> Self { variant as _ } } impl crate :: FieldSpec for AhbClkMux { type Ux = u8 ; } impl crate :: IsEnum for AhbClkMux { } # [doc = "Field `AHB_CLK_MUX` reader - Источника тактирования системы"]
pub type AhbClkMuxR = crate :: FieldReader < AhbClkMux > ; impl AhbClkMuxR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> AhbClkMux { match self . bits { 0 => AhbClkMux :: Osc32m , 1 => AhbClkMux :: Hsi32m , 2 => AhbClkMux :: Osc32k , 3 => AhbClkMux :: Lsi32k , _ => unreachable ! () , } } # [doc = "Внешний OSC32M"]
# [inline (always)]
pub fn is_osc32m (& self) -> bool { * self == AhbClkMux :: Osc32m } # [doc = "Внутренний HSI32M"]
# [inline (always)]
pub fn is_hsi32m (& self) -> bool { * self == AhbClkMux :: Hsi32m } # [doc = "Внешний OSC32K"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == AhbClkMux :: Osc32k } # [doc = "Внутренний LSI32К"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == AhbClkMux :: Lsi32k } } # [doc = "Field `AHB_CLK_MUX` writer - Источника тактирования системы"]
pub type AhbClkMuxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , AhbClkMux , crate :: Safe > ; impl < 'a , REG > AhbClkMuxW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Внешний OSC32M"]
# [inline (always)]
pub fn osc32m (self) -> & 'a mut crate :: W < REG > { self . variant (AhbClkMux :: Osc32m) } # [doc = "Внутренний HSI32M"]
# [inline (always)]
pub fn hsi32m (self) -> & 'a mut crate :: W < REG > { self . variant (AhbClkMux :: Hsi32m) } # [doc = "Внешний OSC32K"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (AhbClkMux :: Osc32k) } # [doc = "Внутренний LSI32К"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (AhbClkMux :: Lsi32k) } } # [doc = "Запрет на принудительное переключение с выбранного источника тактирования при пропадании тактирования\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ForceMux { # [doc = "0: Разрешение автоматической смены частоты"]
Unfixed = 0 , # [doc = "1: Запрет автоматической смены частоты"]
Fixed = 1 , } impl From < ForceMux > for bool { # [inline (always)]
fn from (variant : ForceMux) -> Self { variant as u8 != 0 } } # [doc = "Field `FORCE_MUX` reader - Запрет на принудительное переключение с выбранного источника тактирования при пропадании тактирования"]
pub type ForceMuxR = crate :: BitReader < ForceMux > ; impl ForceMuxR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ForceMux { match self . bits { false => ForceMux :: Unfixed , true => ForceMux :: Fixed , } } # [doc = "Разрешение автоматической смены частоты"]
# [inline (always)]
pub fn is_unfixed (& self) -> bool { * self == ForceMux :: Unfixed } # [doc = "Запрет автоматической смены частоты"]
# [inline (always)]
pub fn is_fixed (& self) -> bool { * self == ForceMux :: Fixed } } # [doc = "Field `FORCE_MUX` writer - Запрет на принудительное переключение с выбранного источника тактирования при пропадании тактирования"]
pub type ForceMuxW < 'a , REG > = crate :: BitWriter < 'a , REG , ForceMux > ; impl < 'a , REG > ForceMuxW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Разрешение автоматической смены частоты"]
# [inline (always)]
pub fn unfixed (self) -> & 'a mut crate :: W < REG > { self . variant (ForceMux :: Unfixed) } # [doc = "Запрет автоматической смены частоты"]
# [inline (always)]
pub fn fixed (self) -> & 'a mut crate :: W < REG > { self . variant (ForceMux :: Fixed) } } impl R { # [doc = "Bits 0:1 - Источника тактирования системы"]
# [inline (always)]
pub fn ahb_clk_mux (& self) -> AhbClkMuxR { AhbClkMuxR :: new ((self . bits & 3) as u8) } # [doc = "Bit 2 - Запрет на принудительное переключение с выбранного источника тактирования при пропадании тактирования"]
# [inline (always)]
pub fn force_mux (& self) -> ForceMuxR { ForceMuxR :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bits 0:1 - Источника тактирования системы"]
# [inline (always)]
pub fn ahb_clk_mux (& mut self) -> AhbClkMuxW < AhbMuxSpec > { AhbClkMuxW :: new (self , 0) } # [doc = "Bit 2 - Запрет на принудительное переключение с выбранного источника тактирования при пропадании тактирования"]
# [inline (always)]
pub fn force_mux (& mut self) -> ForceMuxW < AhbMuxSpec > { ForceMuxW :: new (self , 2) } } # [doc = "Настройка источника тактирования системы\n\nYou can [`read`](crate::Reg::read) this register and get [`ahb_mux::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ahb_mux::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AhbMuxSpec ; impl crate :: RegisterSpec for AhbMuxSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ahb_mux::R`](R) reader structure"]
impl crate :: Readable for AhbMuxSpec { } # [doc = "`write(|w| ..)` method takes [`ahb_mux::W`](W) writer structure"]
impl crate :: Writable for AhbMuxSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets AHB_MUX to value 0"]
impl crate :: Resettable for AhbMuxSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "WDT_CLK_MUX (rw) register accessor: Выбор источника тактирования сторожевого таймера: 0 – внешний OSC32M; 1 – внутренний HSI32M; 2 – внешний OSC32K; 3 – внутренний LSI32К;\n\nYou can [`read`](crate::Reg::read) this register and get [`wdt_clk_mux::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wdt_clk_mux::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@wdt_clk_mux`]
module"]
# [doc (alias = "WDT_CLK_MUX")]
pub type WdtClkMux = crate :: Reg < wdt_clk_mux :: WdtClkMuxSpec > ; # [doc = "Выбор источника тактирования сторожевого таймера: 0 – внешний OSC32M; 1 – внутренний HSI32M; 2 – внешний OSC32K; 3 – внутренний LSI32К;"]
pub mod wdt_clk_mux { # [doc = "Register `WDT_CLK_MUX` reader"]
pub type R = crate :: R < WdtClkMuxSpec > ; # [doc = "Register `WDT_CLK_MUX` writer"]
pub type W = crate :: W < WdtClkMuxSpec > ; # [doc = "Выбор источника тактирования сторожевого таймера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum WdtClkMux { # [doc = "0: Внешний OSC32M"]
Osc32m = 0 , # [doc = "1: Внутренний HSI32M"]
Hsi32m = 1 , # [doc = "2: Внешний OSC32K"]
Osc32k = 2 , # [doc = "3: Внутренний LSI32К"]
Lsi32k = 3 , } impl From < WdtClkMux > for u8 { # [inline (always)]
fn from (variant : WdtClkMux) -> Self { variant as _ } } impl crate :: FieldSpec for WdtClkMux { type Ux = u8 ; } impl crate :: IsEnum for WdtClkMux { } # [doc = "Field `WDT_CLK_MUX` reader - Выбор источника тактирования сторожевого таймера"]
pub type WdtClkMuxR = crate :: FieldReader < WdtClkMux > ; impl WdtClkMuxR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WdtClkMux { match self . bits { 0 => WdtClkMux :: Osc32m , 1 => WdtClkMux :: Hsi32m , 2 => WdtClkMux :: Osc32k , 3 => WdtClkMux :: Lsi32k , _ => unreachable ! () , } } # [doc = "Внешний OSC32M"]
# [inline (always)]
pub fn is_osc32m (& self) -> bool { * self == WdtClkMux :: Osc32m } # [doc = "Внутренний HSI32M"]
# [inline (always)]
pub fn is_hsi32m (& self) -> bool { * self == WdtClkMux :: Hsi32m } # [doc = "Внешний OSC32K"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == WdtClkMux :: Osc32k } # [doc = "Внутренний LSI32К"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == WdtClkMux :: Lsi32k } } # [doc = "Field `WDT_CLK_MUX` writer - Выбор источника тактирования сторожевого таймера"]
pub type WdtClkMuxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , WdtClkMux , crate :: Safe > ; impl < 'a , REG > WdtClkMuxW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Внешний OSC32M"]
# [inline (always)]
pub fn osc32m (self) -> & 'a mut crate :: W < REG > { self . variant (WdtClkMux :: Osc32m) } # [doc = "Внутренний HSI32M"]
# [inline (always)]
pub fn hsi32m (self) -> & 'a mut crate :: W < REG > { self . variant (WdtClkMux :: Hsi32m) } # [doc = "Внешний OSC32K"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (WdtClkMux :: Osc32k) } # [doc = "Внутренний LSI32К"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (WdtClkMux :: Lsi32k) } } impl R { # [doc = "Bits 0:1 - Выбор источника тактирования сторожевого таймера"]
# [inline (always)]
pub fn wdt_clk_mux (& self) -> WdtClkMuxR { WdtClkMuxR :: new ((self . bits & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Выбор источника тактирования сторожевого таймера"]
# [inline (always)]
pub fn wdt_clk_mux (& mut self) -> WdtClkMuxW < WdtClkMuxSpec > { WdtClkMuxW :: new (self , 0) } } # [doc = "Выбор источника тактирования сторожевого таймера: 0 – внешний OSC32M; 1 – внутренний HSI32M; 2 – внешний OSC32K; 3 – внутренний LSI32К;\n\nYou can [`read`](crate::Reg::read) this register and get [`wdt_clk_mux::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`wdt_clk_mux::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct WdtClkMuxSpec ; impl crate :: RegisterSpec for WdtClkMuxSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`wdt_clk_mux::R`](R) reader structure"]
impl crate :: Readable for WdtClkMuxSpec { } # [doc = "`write(|w| ..)` method takes [`wdt_clk_mux::W`](W) writer structure"]
impl crate :: Writable for WdtClkMuxSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets WDT_CLK_MUX to value 0"]
impl crate :: Resettable for WdtClkMuxSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CPU_RTC_CLK_MUX (rw) register accessor: Выбор источника тактирования RTC для системного таймера в составе ядра\n\nYou can [`read`](crate::Reg::read) this register and get [`cpu_rtc_clk_mux::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpu_rtc_clk_mux::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cpu_rtc_clk_mux`]
module"]
# [doc (alias = "CPU_RTC_CLK_MUX")]
pub type CpuRtcClkMux = crate :: Reg < cpu_rtc_clk_mux :: CpuRtcClkMuxSpec > ; # [doc = "Выбор источника тактирования RTC для системного таймера в составе ядра"]
pub mod cpu_rtc_clk_mux { # [doc = "Register `CPU_RTC_CLK_MUX` reader"]
pub type R = crate :: R < CpuRtcClkMuxSpec > ; # [doc = "Register `CPU_RTC_CLK_MUX` writer"]
pub type W = crate :: W < CpuRtcClkMuxSpec > ; # [doc = "Выбор источника тактирования сторожевого таймера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CpuRtcClkMux { # [doc = "0: Внешний OSC32K"]
Osc32k = 0 , # [doc = "1: Внутренний LSI32К"]
Lsi32k = 1 , } impl From < CpuRtcClkMux > for bool { # [inline (always)]
fn from (variant : CpuRtcClkMux) -> Self { variant as u8 != 0 } } # [doc = "Field `CPU_RTC_CLK_MUX` reader - Выбор источника тактирования сторожевого таймера"]
pub type CpuRtcClkMuxR = crate :: BitReader < CpuRtcClkMux > ; impl CpuRtcClkMuxR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> CpuRtcClkMux { match self . bits { false => CpuRtcClkMux :: Osc32k , true => CpuRtcClkMux :: Lsi32k , } } # [doc = "Внешний OSC32K"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == CpuRtcClkMux :: Osc32k } # [doc = "Внутренний LSI32К"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == CpuRtcClkMux :: Lsi32k } } # [doc = "Field `CPU_RTC_CLK_MUX` writer - Выбор источника тактирования сторожевого таймера"]
pub type CpuRtcClkMuxW < 'a , REG > = crate :: BitWriter < 'a , REG , CpuRtcClkMux > ; impl < 'a , REG > CpuRtcClkMuxW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Внешний OSC32K"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (CpuRtcClkMux :: Osc32k) } # [doc = "Внутренний LSI32К"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (CpuRtcClkMux :: Lsi32k) } } impl R { # [doc = "Bit 0 - Выбор источника тактирования сторожевого таймера"]
# [inline (always)]
pub fn cpu_rtc_clk_mux (& self) -> CpuRtcClkMuxR { CpuRtcClkMuxR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Выбор источника тактирования сторожевого таймера"]
# [inline (always)]
pub fn cpu_rtc_clk_mux (& mut self) -> CpuRtcClkMuxW < CpuRtcClkMuxSpec > { CpuRtcClkMuxW :: new (self , 0) } } # [doc = "Выбор источника тактирования RTC для системного таймера в составе ядра\n\nYou can [`read`](crate::Reg::read) this register and get [`cpu_rtc_clk_mux::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cpu_rtc_clk_mux::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CpuRtcClkMuxSpec ; impl crate :: RegisterSpec for CpuRtcClkMuxSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cpu_rtc_clk_mux::R`](R) reader structure"]
impl crate :: Readable for CpuRtcClkMuxSpec { } # [doc = "`write(|w| ..)` method takes [`cpu_rtc_clk_mux::W`](W) writer structure"]
impl crate :: Writable for CpuRtcClkMuxSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CPU_RTC_CLK_MUX to value 0"]
impl crate :: Resettable for CpuRtcClkMuxSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TIMER_CFG (rw) register accessor: Выбор источника тактирования для таймеров\n\nYou can [`read`](crate::Reg::read) this register and get [`timer_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timer_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@timer_cfg`]
module"]
# [doc (alias = "TIMER_CFG")]
pub type TimerCfg = crate :: Reg < timer_cfg :: TimerCfgSpec > ; # [doc = "Выбор источника тактирования для таймеров"]
pub mod timer_cfg { # [doc = "Register `TIMER_CFG` reader"]
pub type R = crate :: R < TimerCfgSpec > ; # [doc = "Register `TIMER_CFG` writer"]
pub type W = crate :: W < TimerCfgSpec > ; # [doc = "Выбор синхронного тактового сигнала для входа TIM1 Timer32_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum MuxTim32_0Tim1 { # [doc = "0: Системная частота (sys_clk)"]
SysClk = 0 , # [doc = "1: Частота шины AHB (hclk)"]
Hclk = 1 , } impl From < MuxTim32_0Tim1 > for bool { # [inline (always)]
fn from (variant : MuxTim32_0Tim1) -> Self { variant as u8 != 0 } } # [doc = "Field `MUX_TIM32_0_TIM1` reader - Выбор синхронного тактового сигнала для входа TIM1 Timer32_0"]
pub type MuxTim32_0Tim1R = crate :: BitReader < MuxTim32_0Tim1 > ; impl MuxTim32_0Tim1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> MuxTim32_0Tim1 { match self . bits { false => MuxTim32_0Tim1 :: SysClk , true => MuxTim32_0Tim1 :: Hclk , } } # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn is_sys_clk (& self) -> bool { * self == MuxTim32_0Tim1 :: SysClk } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn is_hclk (& self) -> bool { * self == MuxTim32_0Tim1 :: Hclk } } # [doc = "Field `MUX_TIM32_0_TIM1` writer - Выбор синхронного тактового сигнала для входа TIM1 Timer32_0"]
pub type MuxTim32_0Tim1W < 'a , REG > = crate :: BitWriter < 'a , REG , MuxTim32_0Tim1 > ; impl < 'a , REG > MuxTim32_0Tim1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn sys_clk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_0Tim1 :: SysClk) } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn hclk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_0Tim1 :: Hclk) } } # [doc = "Выбор асинхронного тактового сигнала для входа TIM2 Timer32_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum MuxTim32_0Tim2 { # [doc = "0: OSC32K"]
Osc32k = 0 , # [doc = "1: LSI32K"]
Lsi32k = 1 , } impl From < MuxTim32_0Tim2 > for bool { # [inline (always)]
fn from (variant : MuxTim32_0Tim2) -> Self { variant as u8 != 0 } } # [doc = "Field `MUX_TIM32_0_TIM2` reader - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_0"]
pub type MuxTim32_0Tim2R = crate :: BitReader < MuxTim32_0Tim2 > ; impl MuxTim32_0Tim2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> MuxTim32_0Tim2 { match self . bits { false => MuxTim32_0Tim2 :: Osc32k , true => MuxTim32_0Tim2 :: Lsi32k , } } # [doc = "OSC32K"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == MuxTim32_0Tim2 :: Osc32k } # [doc = "LSI32K"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == MuxTim32_0Tim2 :: Lsi32k } } # [doc = "Field `MUX_TIM32_0_TIM2` writer - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_0"]
pub type MuxTim32_0Tim2W < 'a , REG > = crate :: BitWriter < 'a , REG , MuxTim32_0Tim2 > ; impl < 'a , REG > MuxTim32_0Tim2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "OSC32K"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_0Tim2 :: Osc32k) } # [doc = "LSI32K"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_0Tim2 :: Lsi32k) } } # [doc = "Выбор синхронного тактового сигнала для входа TIM1 Timer32_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum MuxTim32_1Tim1 { # [doc = "0: Системная частота (sys_clk)"]
SysClk = 0 , # [doc = "1: Частота шины AHB (hclk)"]
Hclk = 1 , } impl From < MuxTim32_1Tim1 > for bool { # [inline (always)]
fn from (variant : MuxTim32_1Tim1) -> Self { variant as u8 != 0 } } # [doc = "Field `MUX_TIM32_1_TIM1` reader - Выбор синхронного тактового сигнала для входа TIM1 Timer32_1"]
pub type MuxTim32_1Tim1R = crate :: BitReader < MuxTim32_1Tim1 > ; impl MuxTim32_1Tim1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> MuxTim32_1Tim1 { match self . bits { false => MuxTim32_1Tim1 :: SysClk , true => MuxTim32_1Tim1 :: Hclk , } } # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn is_sys_clk (& self) -> bool { * self == MuxTim32_1Tim1 :: SysClk } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn is_hclk (& self) -> bool { * self == MuxTim32_1Tim1 :: Hclk } } # [doc = "Field `MUX_TIM32_1_TIM1` writer - Выбор синхронного тактового сигнала для входа TIM1 Timer32_1"]
pub type MuxTim32_1Tim1W < 'a , REG > = crate :: BitWriter < 'a , REG , MuxTim32_1Tim1 > ; impl < 'a , REG > MuxTim32_1Tim1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn sys_clk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_1Tim1 :: SysClk) } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn hclk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_1Tim1 :: Hclk) } } # [doc = "Выбор асинхронного тактового сигнала для входа TIM2 Timer32_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum MuxTim32_1Tim2 { # [doc = "0: OSC32K"]
Osc32k = 0 , # [doc = "1: LSI32K"]
Lsi32k = 1 , } impl From < MuxTim32_1Tim2 > for bool { # [inline (always)]
fn from (variant : MuxTim32_1Tim2) -> Self { variant as u8 != 0 } } # [doc = "Field `MUX_TIM32_1_TIM2` reader - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_1"]
pub type MuxTim32_1Tim2R = crate :: BitReader < MuxTim32_1Tim2 > ; impl MuxTim32_1Tim2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> MuxTim32_1Tim2 { match self . bits { false => MuxTim32_1Tim2 :: Osc32k , true => MuxTim32_1Tim2 :: Lsi32k , } } # [doc = "OSC32K"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == MuxTim32_1Tim2 :: Osc32k } # [doc = "LSI32K"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == MuxTim32_1Tim2 :: Lsi32k } } # [doc = "Field `MUX_TIM32_1_TIM2` writer - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_1"]
pub type MuxTim32_1Tim2W < 'a , REG > = crate :: BitWriter < 'a , REG , MuxTim32_1Tim2 > ; impl < 'a , REG > MuxTim32_1Tim2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "OSC32K"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_1Tim2 :: Osc32k) } # [doc = "LSI32K"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_1Tim2 :: Lsi32k) } } # [doc = "Выбор синхронного тактового сигнала для входа TIM1 Timer32_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum MuxTim32_2Tim1 { # [doc = "0: Системная частота (sys_clk)"]
SysClk = 0 , # [doc = "1: Частота шины AHB (hclk)"]
Hclk = 1 , } impl From < MuxTim32_2Tim1 > for bool { # [inline (always)]
fn from (variant : MuxTim32_2Tim1) -> Self { variant as u8 != 0 } } # [doc = "Field `MUX_TIM32_2_TIM1` reader - Выбор синхронного тактового сигнала для входа TIM1 Timer32_2"]
pub type MuxTim32_2Tim1R = crate :: BitReader < MuxTim32_2Tim1 > ; impl MuxTim32_2Tim1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> MuxTim32_2Tim1 { match self . bits { false => MuxTim32_2Tim1 :: SysClk , true => MuxTim32_2Tim1 :: Hclk , } } # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn is_sys_clk (& self) -> bool { * self == MuxTim32_2Tim1 :: SysClk } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn is_hclk (& self) -> bool { * self == MuxTim32_2Tim1 :: Hclk } } # [doc = "Field `MUX_TIM32_2_TIM1` writer - Выбор синхронного тактового сигнала для входа TIM1 Timer32_2"]
pub type MuxTim32_2Tim1W < 'a , REG > = crate :: BitWriter < 'a , REG , MuxTim32_2Tim1 > ; impl < 'a , REG > MuxTim32_2Tim1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn sys_clk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_2Tim1 :: SysClk) } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn hclk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_2Tim1 :: Hclk) } } # [doc = "Выбор асинхронного тактового сигнала для входа TIM2 Timer32_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum MuxTim32_2Tim2 { # [doc = "0: OSC32K"]
Osc32k = 0 , # [doc = "1: LSI32K"]
Lsi32k = 1 , } impl From < MuxTim32_2Tim2 > for bool { # [inline (always)]
fn from (variant : MuxTim32_2Tim2) -> Self { variant as u8 != 0 } } # [doc = "Field `MUX_TIM32_2_TIM2` reader - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_2"]
pub type MuxTim32_2Tim2R = crate :: BitReader < MuxTim32_2Tim2 > ; impl MuxTim32_2Tim2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> MuxTim32_2Tim2 { match self . bits { false => MuxTim32_2Tim2 :: Osc32k , true => MuxTim32_2Tim2 :: Lsi32k , } } # [doc = "OSC32K"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == MuxTim32_2Tim2 :: Osc32k } # [doc = "LSI32K"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == MuxTim32_2Tim2 :: Lsi32k } } # [doc = "Field `MUX_TIM32_2_TIM2` writer - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_2"]
pub type MuxTim32_2Tim2W < 'a , REG > = crate :: BitWriter < 'a , REG , MuxTim32_2Tim2 > ; impl < 'a , REG > MuxTim32_2Tim2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "OSC32K"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_2Tim2 :: Osc32k) } # [doc = "LSI32K"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim32_2Tim2 :: Lsi32k) } } # [doc = "Выбор тактового сигнала для Timer16_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MuxTim16_0 { # [doc = "0: Системная частота (sys_clk)"]
SysClk = 0 , # [doc = "1: Частота шины AHB (hclk)"]
Hclk = 1 , # [doc = "2: Частота внешнего осциллятора OSC32М"]
Osc32m = 2 , # [doc = "3: Частота встроенного осциллятора HSI32M"]
Hsi32m = 3 , # [doc = "4: частота внешнего осциллятора OSC32К"]
Osc32k = 4 , # [doc = "5: Частота встроенного осциллятора LSI32K"]
Lsi32k = 5 , } impl From < MuxTim16_0 > for u8 { # [inline (always)]
fn from (variant : MuxTim16_0) -> Self { variant as _ } } impl crate :: FieldSpec for MuxTim16_0 { type Ux = u8 ; } impl crate :: IsEnum for MuxTim16_0 { } # [doc = "Field `MUX_TIM16_0` reader - Выбор тактового сигнала для Timer16_0"]
pub type MuxTim16_0R = crate :: FieldReader < MuxTim16_0 > ; impl MuxTim16_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < MuxTim16_0 > { match self . bits { 0 => Some (MuxTim16_0 :: SysClk) , 1 => Some (MuxTim16_0 :: Hclk) , 2 => Some (MuxTim16_0 :: Osc32m) , 3 => Some (MuxTim16_0 :: Hsi32m) , 4 => Some (MuxTim16_0 :: Osc32k) , 5 => Some (MuxTim16_0 :: Lsi32k) , _ => None , } } # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn is_sys_clk (& self) -> bool { * self == MuxTim16_0 :: SysClk } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn is_hclk (& self) -> bool { * self == MuxTim16_0 :: Hclk } # [doc = "Частота внешнего осциллятора OSC32М"]
# [inline (always)]
pub fn is_osc32m (& self) -> bool { * self == MuxTim16_0 :: Osc32m } # [doc = "Частота встроенного осциллятора HSI32M"]
# [inline (always)]
pub fn is_hsi32m (& self) -> bool { * self == MuxTim16_0 :: Hsi32m } # [doc = "частота внешнего осциллятора OSC32К"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == MuxTim16_0 :: Osc32k } # [doc = "Частота встроенного осциллятора LSI32K"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == MuxTim16_0 :: Lsi32k } } # [doc = "Field `MUX_TIM16_0` writer - Выбор тактового сигнала для Timer16_0"]
pub type MuxTim16_0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , MuxTim16_0 > ; impl < 'a , REG > MuxTim16_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn sys_clk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_0 :: SysClk) } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn hclk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_0 :: Hclk) } # [doc = "Частота внешнего осциллятора OSC32М"]
# [inline (always)]
pub fn osc32m (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_0 :: Osc32m) } # [doc = "Частота встроенного осциллятора HSI32M"]
# [inline (always)]
pub fn hsi32m (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_0 :: Hsi32m) } # [doc = "частота внешнего осциллятора OSC32К"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_0 :: Osc32k) } # [doc = "Частота встроенного осциллятора LSI32K"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_0 :: Lsi32k) } } # [doc = "Выбор тактового сигнала для Timer16_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MuxTim16_1 { # [doc = "0: Системная частота (sys_clk)"]
SysClk = 0 , # [doc = "1: Частота шины AHB (hclk)"]
Hclk = 1 , # [doc = "2: Частота внешнего осциллятора OSC32М"]
Osc32m = 2 , # [doc = "3: Частота встроенного осциллятора HSI32M"]
Hsi32m = 3 , # [doc = "4: частота внешнего осциллятора OSC32К"]
Osc32k = 4 , # [doc = "5: Частота встроенного осциллятора LSI32K"]
Lsi32k = 5 , } impl From < MuxTim16_1 > for u8 { # [inline (always)]
fn from (variant : MuxTim16_1) -> Self { variant as _ } } impl crate :: FieldSpec for MuxTim16_1 { type Ux = u8 ; } impl crate :: IsEnum for MuxTim16_1 { } # [doc = "Field `MUX_TIM16_1` reader - Выбор тактового сигнала для Timer16_1"]
pub type MuxTim16_1R = crate :: FieldReader < MuxTim16_1 > ; impl MuxTim16_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < MuxTim16_1 > { match self . bits { 0 => Some (MuxTim16_1 :: SysClk) , 1 => Some (MuxTim16_1 :: Hclk) , 2 => Some (MuxTim16_1 :: Osc32m) , 3 => Some (MuxTim16_1 :: Hsi32m) , 4 => Some (MuxTim16_1 :: Osc32k) , 5 => Some (MuxTim16_1 :: Lsi32k) , _ => None , } } # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn is_sys_clk (& self) -> bool { * self == MuxTim16_1 :: SysClk } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn is_hclk (& self) -> bool { * self == MuxTim16_1 :: Hclk } # [doc = "Частота внешнего осциллятора OSC32М"]
# [inline (always)]
pub fn is_osc32m (& self) -> bool { * self == MuxTim16_1 :: Osc32m } # [doc = "Частота встроенного осциллятора HSI32M"]
# [inline (always)]
pub fn is_hsi32m (& self) -> bool { * self == MuxTim16_1 :: Hsi32m } # [doc = "частота внешнего осциллятора OSC32К"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == MuxTim16_1 :: Osc32k } # [doc = "Частота встроенного осциллятора LSI32K"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == MuxTim16_1 :: Lsi32k } } # [doc = "Field `MUX_TIM16_1` writer - Выбор тактового сигнала для Timer16_1"]
pub type MuxTim16_1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , MuxTim16_1 > ; impl < 'a , REG > MuxTim16_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn sys_clk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_1 :: SysClk) } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn hclk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_1 :: Hclk) } # [doc = "Частота внешнего осциллятора OSC32М"]
# [inline (always)]
pub fn osc32m (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_1 :: Osc32m) } # [doc = "Частота встроенного осциллятора HSI32M"]
# [inline (always)]
pub fn hsi32m (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_1 :: Hsi32m) } # [doc = "частота внешнего осциллятора OSC32К"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_1 :: Osc32k) } # [doc = "Частота встроенного осциллятора LSI32K"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_1 :: Lsi32k) } } # [doc = "Выбор тактового сигнала для Timer16_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum MuxTim16_2 { # [doc = "0: Системная частота (sys_clk)"]
SysClk = 0 , # [doc = "1: Частота шины AHB (hclk)"]
Hclk = 1 , # [doc = "2: Частота внешнего осциллятора OSC32М"]
Osc32m = 2 , # [doc = "3: Частота встроенного осциллятора HSI32M"]
Hsi32m = 3 , # [doc = "4: частота внешнего осциллятора OSC32К"]
Osc32k = 4 , # [doc = "5: Частота встроенного осциллятора LSI32K"]
Lsi32k = 5 , } impl From < MuxTim16_2 > for u8 { # [inline (always)]
fn from (variant : MuxTim16_2) -> Self { variant as _ } } impl crate :: FieldSpec for MuxTim16_2 { type Ux = u8 ; } impl crate :: IsEnum for MuxTim16_2 { } # [doc = "Field `MUX_TIM16_2` reader - Выбор тактового сигнала для Timer16_2"]
pub type MuxTim16_2R = crate :: FieldReader < MuxTim16_2 > ; impl MuxTim16_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < MuxTim16_2 > { match self . bits { 0 => Some (MuxTim16_2 :: SysClk) , 1 => Some (MuxTim16_2 :: Hclk) , 2 => Some (MuxTim16_2 :: Osc32m) , 3 => Some (MuxTim16_2 :: Hsi32m) , 4 => Some (MuxTim16_2 :: Osc32k) , 5 => Some (MuxTim16_2 :: Lsi32k) , _ => None , } } # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn is_sys_clk (& self) -> bool { * self == MuxTim16_2 :: SysClk } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn is_hclk (& self) -> bool { * self == MuxTim16_2 :: Hclk } # [doc = "Частота внешнего осциллятора OSC32М"]
# [inline (always)]
pub fn is_osc32m (& self) -> bool { * self == MuxTim16_2 :: Osc32m } # [doc = "Частота встроенного осциллятора HSI32M"]
# [inline (always)]
pub fn is_hsi32m (& self) -> bool { * self == MuxTim16_2 :: Hsi32m } # [doc = "частота внешнего осциллятора OSC32К"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == MuxTim16_2 :: Osc32k } # [doc = "Частота встроенного осциллятора LSI32K"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == MuxTim16_2 :: Lsi32k } } # [doc = "Field `MUX_TIM16_2` writer - Выбор тактового сигнала для Timer16_2"]
pub type MuxTim16_2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , MuxTim16_2 > ; impl < 'a , REG > MuxTim16_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Системная частота (sys_clk)"]
# [inline (always)]
pub fn sys_clk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_2 :: SysClk) } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn hclk (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_2 :: Hclk) } # [doc = "Частота внешнего осциллятора OSC32М"]
# [inline (always)]
pub fn osc32m (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_2 :: Osc32m) } # [doc = "Частота встроенного осциллятора HSI32M"]
# [inline (always)]
pub fn hsi32m (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_2 :: Hsi32m) } # [doc = "частота внешнего осциллятора OSC32К"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_2 :: Osc32k) } # [doc = "Частота встроенного осциллятора LSI32K"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (MuxTim16_2 :: Lsi32k) } } impl R { # [doc = "Bit 0 - Выбор синхронного тактового сигнала для входа TIM1 Timer32_0"]
# [inline (always)]
pub fn mux_tim32_0_tim1 (& self) -> MuxTim32_0Tim1R { MuxTim32_0Tim1R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_0"]
# [inline (always)]
pub fn mux_tim32_0_tim2 (& self) -> MuxTim32_0Tim2R { MuxTim32_0Tim2R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 3 - Выбор синхронного тактового сигнала для входа TIM1 Timer32_1"]
# [inline (always)]
pub fn mux_tim32_1_tim1 (& self) -> MuxTim32_1Tim1R { MuxTim32_1Tim1R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_1"]
# [inline (always)]
pub fn mux_tim32_1_tim2 (& self) -> MuxTim32_1Tim2R { MuxTim32_1Tim2R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 6 - Выбор синхронного тактового сигнала для входа TIM1 Timer32_2"]
# [inline (always)]
pub fn mux_tim32_2_tim1 (& self) -> MuxTim32_2Tim1R { MuxTim32_2Tim1R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_2"]
# [inline (always)]
pub fn mux_tim32_2_tim2 (& self) -> MuxTim32_2Tim2R { MuxTim32_2Tim2R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 9:11 - Выбор тактового сигнала для Timer16_0"]
# [inline (always)]
pub fn mux_tim16_0 (& self) -> MuxTim16_0R { MuxTim16_0R :: new (((self . bits >> 9) & 7) as u8) } # [doc = "Bits 12:14 - Выбор тактового сигнала для Timer16_1"]
# [inline (always)]
pub fn mux_tim16_1 (& self) -> MuxTim16_1R { MuxTim16_1R :: new (((self . bits >> 12) & 7) as u8) } # [doc = "Bits 15:17 - Выбор тактового сигнала для Timer16_2"]
# [inline (always)]
pub fn mux_tim16_2 (& self) -> MuxTim16_2R { MuxTim16_2R :: new (((self . bits >> 15) & 7) as u8) } } impl W { # [doc = "Bit 0 - Выбор синхронного тактового сигнала для входа TIM1 Timer32_0"]
# [inline (always)]
pub fn mux_tim32_0_tim1 (& mut self) -> MuxTim32_0Tim1W < TimerCfgSpec > { MuxTim32_0Tim1W :: new (self , 0) } # [doc = "Bit 1 - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_0"]
# [inline (always)]
pub fn mux_tim32_0_tim2 (& mut self) -> MuxTim32_0Tim2W < TimerCfgSpec > { MuxTim32_0Tim2W :: new (self , 1) } # [doc = "Bit 3 - Выбор синхронного тактового сигнала для входа TIM1 Timer32_1"]
# [inline (always)]
pub fn mux_tim32_1_tim1 (& mut self) -> MuxTim32_1Tim1W < TimerCfgSpec > { MuxTim32_1Tim1W :: new (self , 3) } # [doc = "Bit 4 - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_1"]
# [inline (always)]
pub fn mux_tim32_1_tim2 (& mut self) -> MuxTim32_1Tim2W < TimerCfgSpec > { MuxTim32_1Tim2W :: new (self , 4) } # [doc = "Bit 6 - Выбор синхронного тактового сигнала для входа TIM1 Timer32_2"]
# [inline (always)]
pub fn mux_tim32_2_tim1 (& mut self) -> MuxTim32_2Tim1W < TimerCfgSpec > { MuxTim32_2Tim1W :: new (self , 6) } # [doc = "Bit 7 - Выбор асинхронного тактового сигнала для входа TIM2 Timer32_2"]
# [inline (always)]
pub fn mux_tim32_2_tim2 (& mut self) -> MuxTim32_2Tim2W < TimerCfgSpec > { MuxTim32_2Tim2W :: new (self , 7) } # [doc = "Bits 9:11 - Выбор тактового сигнала для Timer16_0"]
# [inline (always)]
pub fn mux_tim16_0 (& mut self) -> MuxTim16_0W < TimerCfgSpec > { MuxTim16_0W :: new (self , 9) } # [doc = "Bits 12:14 - Выбор тактового сигнала для Timer16_1"]
# [inline (always)]
pub fn mux_tim16_1 (& mut self) -> MuxTim16_1W < TimerCfgSpec > { MuxTim16_1W :: new (self , 12) } # [doc = "Bits 15:17 - Выбор тактового сигнала для Timer16_2"]
# [inline (always)]
pub fn mux_tim16_2 (& mut self) -> MuxTim16_2W < TimerCfgSpec > { MuxTim16_2W :: new (self , 15) } } # [doc = "Выбор источника тактирования для таймеров\n\nYou can [`read`](crate::Reg::read) this register and get [`timer_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timer_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TimerCfgSpec ; impl crate :: RegisterSpec for TimerCfgSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`timer_cfg::R`](R) reader structure"]
impl crate :: Readable for TimerCfgSpec { } # [doc = "`write(|w| ..)` method takes [`timer_cfg::W`](W) writer structure"]
impl crate :: Writable for TimerCfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TIMER_CFG to value 0"]
impl crate :: Resettable for TimerCfgSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "FREQ_MASK (rw) register accessor: Настройки прерываний монитора частоты\n\nYou can [`read`](crate::Reg::read) this register and get [`freq_mask::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`freq_mask::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@freq_mask`]
module"]
# [doc (alias = "FREQ_MASK")]
pub type FreqMask = crate :: Reg < freq_mask :: FreqMaskSpec > ; # [doc = "Настройки прерываний монитора частоты"]
pub mod freq_mask { # [doc = "Register `FREQ_MASK` reader"]
pub type R = crate :: R < FreqMaskSpec > ; # [doc = "Register `FREQ_MASK` writer"]
pub type W = crate :: W < FreqMaskSpec > ; # [doc = "Разрешение прерывания при пропадании частоты LSI32K\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum MaskLsi32k { # [doc = "0: Запретить прерывание"]
Disable = 0 , # [doc = "1: Разрешить прерывание"]
Enable = 1 , } impl From < MaskLsi32k > for bool { # [inline (always)]
fn from (variant : MaskLsi32k) -> Self { variant as u8 != 0 } } # [doc = "Field `MASK_LSI32K` reader - Разрешение прерывания при пропадании частоты LSI32K"]
pub type MaskLsi32kR = crate :: BitReader < MaskLsi32k > ; impl MaskLsi32kR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> MaskLsi32k { match self . bits { false => MaskLsi32k :: Disable , true => MaskLsi32k :: Enable , } } # [doc = "Запретить прерывание"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == MaskLsi32k :: Disable } # [doc = "Разрешить прерывание"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == MaskLsi32k :: Enable } } # [doc = "Field `MASK_LSI32K` writer - Разрешение прерывания при пропадании частоты LSI32K"]
pub type MaskLsi32kW < 'a , REG > = crate :: BitWriter < 'a , REG , MaskLsi32k > ; impl < 'a , REG > MaskLsi32kW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запретить прерывание"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (MaskLsi32k :: Disable) } # [doc = "Разрешить прерывание"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (MaskLsi32k :: Enable) } } # [doc = "Разрешение прерывания при пропадании частоты внешнего осциллятора 32 кГц\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum MaskOsc32k { # [doc = "0: Запретить прерывание"]
Disable = 0 , # [doc = "1: Разрешить прерывание"]
Enable = 1 , } impl From < MaskOsc32k > for bool { # [inline (always)]
fn from (variant : MaskOsc32k) -> Self { variant as u8 != 0 } } # [doc = "Field `MASK_OSC32K` reader - Разрешение прерывания при пропадании частоты внешнего осциллятора 32 кГц"]
pub type MaskOsc32kR = crate :: BitReader < MaskOsc32k > ; impl MaskOsc32kR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> MaskOsc32k { match self . bits { false => MaskOsc32k :: Disable , true => MaskOsc32k :: Enable , } } # [doc = "Запретить прерывание"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == MaskOsc32k :: Disable } # [doc = "Разрешить прерывание"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == MaskOsc32k :: Enable } } # [doc = "Field `MASK_OSC32K` writer - Разрешение прерывания при пропадании частоты внешнего осциллятора 32 кГц"]
pub type MaskOsc32kW < 'a , REG > = crate :: BitWriter < 'a , REG , MaskOsc32k > ; impl < 'a , REG > MaskOsc32kW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запретить прерывание"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (MaskOsc32k :: Disable) } # [doc = "Разрешить прерывание"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (MaskOsc32k :: Enable) } } # [doc = "Разрешение прерывания при пропадании частоты HSI32M\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum MaskHsi32m { # [doc = "0: Запретить прерывание"]
Disable = 0 , # [doc = "1: Разрешить прерывание"]
Enable = 1 , } impl From < MaskHsi32m > for bool { # [inline (always)]
fn from (variant : MaskHsi32m) -> Self { variant as u8 != 0 } } # [doc = "Field `MASK_HSI32M` reader - Разрешение прерывания при пропадании частоты HSI32M"]
pub type MaskHsi32mR = crate :: BitReader < MaskHsi32m > ; impl MaskHsi32mR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> MaskHsi32m { match self . bits { false => MaskHsi32m :: Disable , true => MaskHsi32m :: Enable , } } # [doc = "Запретить прерывание"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == MaskHsi32m :: Disable } # [doc = "Разрешить прерывание"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == MaskHsi32m :: Enable } } # [doc = "Field `MASK_HSI32M` writer - Разрешение прерывания при пропадании частоты HSI32M"]
pub type MaskHsi32mW < 'a , REG > = crate :: BitWriter < 'a , REG , MaskHsi32m > ; impl < 'a , REG > MaskHsi32mW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запретить прерывание"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (MaskHsi32m :: Disable) } # [doc = "Разрешить прерывание"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (MaskHsi32m :: Enable) } } # [doc = "Разрешение прерывания при пропадании частоты внешнего осциллятора 32 МГц\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum MaskOsc32m { # [doc = "0: Запретить прерывание"]
Disable = 0 , # [doc = "1: Разрешить прерывание"]
Enable = 1 , } impl From < MaskOsc32m > for bool { # [inline (always)]
fn from (variant : MaskOsc32m) -> Self { variant as u8 != 0 } } # [doc = "Field `MASK_OSC32M` reader - Разрешение прерывания при пропадании частоты внешнего осциллятора 32 МГц"]
pub type MaskOsc32mR = crate :: BitReader < MaskOsc32m > ; impl MaskOsc32mR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> MaskOsc32m { match self . bits { false => MaskOsc32m :: Disable , true => MaskOsc32m :: Enable , } } # [doc = "Запретить прерывание"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == MaskOsc32m :: Disable } # [doc = "Разрешить прерывание"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == MaskOsc32m :: Enable } } # [doc = "Field `MASK_OSC32M` writer - Разрешение прерывания при пропадании частоты внешнего осциллятора 32 МГц"]
pub type MaskOsc32mW < 'a , REG > = crate :: BitWriter < 'a , REG , MaskOsc32m > ; impl < 'a , REG > MaskOsc32mW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запретить прерывание"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (MaskOsc32m :: Disable) } # [doc = "Разрешить прерывание"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (MaskOsc32m :: Enable) } } impl R { # [doc = "Bit 0 - Разрешение прерывания при пропадании частоты LSI32K"]
# [inline (always)]
pub fn mask_lsi32k (& self) -> MaskLsi32kR { MaskLsi32kR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Разрешение прерывания при пропадании частоты внешнего осциллятора 32 кГц"]
# [inline (always)]
pub fn mask_osc32k (& self) -> MaskOsc32kR { MaskOsc32kR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Разрешение прерывания при пропадании частоты HSI32M"]
# [inline (always)]
pub fn mask_hsi32m (& self) -> MaskHsi32mR { MaskHsi32mR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Разрешение прерывания при пропадании частоты внешнего осциллятора 32 МГц"]
# [inline (always)]
pub fn mask_osc32m (& self) -> MaskOsc32mR { MaskOsc32mR :: new (((self . bits >> 3) & 1) != 0) } } impl W { # [doc = "Bit 0 - Разрешение прерывания при пропадании частоты LSI32K"]
# [inline (always)]
pub fn mask_lsi32k (& mut self) -> MaskLsi32kW < FreqMaskSpec > { MaskLsi32kW :: new (self , 0) } # [doc = "Bit 1 - Разрешение прерывания при пропадании частоты внешнего осциллятора 32 кГц"]
# [inline (always)]
pub fn mask_osc32k (& mut self) -> MaskOsc32kW < FreqMaskSpec > { MaskOsc32kW :: new (self , 1) } # [doc = "Bit 2 - Разрешение прерывания при пропадании частоты HSI32M"]
# [inline (always)]
pub fn mask_hsi32m (& mut self) -> MaskHsi32mW < FreqMaskSpec > { MaskHsi32mW :: new (self , 2) } # [doc = "Bit 3 - Разрешение прерывания при пропадании частоты внешнего осциллятора 32 МГц"]
# [inline (always)]
pub fn mask_osc32m (& mut self) -> MaskOsc32mW < FreqMaskSpec > { MaskOsc32mW :: new (self , 3) } } # [doc = "Настройки прерываний монитора частоты\n\nYou can [`read`](crate::Reg::read) this register and get [`freq_mask::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`freq_mask::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct FreqMaskSpec ; impl crate :: RegisterSpec for FreqMaskSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`freq_mask::R`](R) reader structure"]
impl crate :: Readable for FreqMaskSpec { } # [doc = "`write(|w| ..)` method takes [`freq_mask::W`](W) writer structure"]
impl crate :: Writable for FreqMaskSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets FREQ_MASK to value 0"]
impl crate :: Resettable for FreqMaskSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "FREQ_STATUS (rw) register accessor: Статус монитора частоты\n\nYou can [`read`](crate::Reg::read) this register and get [`freq_status::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`freq_status::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@freq_status`]
module"]
# [doc (alias = "FREQ_STATUS")]
pub type FreqStatus = crate :: Reg < freq_status :: FreqStatusSpec > ; # [doc = "Статус монитора частоты"]
pub mod freq_status { # [doc = "Register `FREQ_STATUS` reader"]
pub type R = crate :: R < FreqStatusSpec > ; # [doc = "Register `FREQ_STATUS` writer"]
pub type W = crate :: W < FreqStatusSpec > ; # [doc = "Field `MASK_LSI32K` reader - Статус частоты LSI32K"]
pub type MaskLsi32kR = crate :: BitReader ; # [doc = "Field `MASK_OSC32K` reader - Статус частоты внешнего осциллятора 32 кГц OSC32K"]
pub type MaskOsc32kR = crate :: BitReader ; # [doc = "Field `MASK_HSI32M` reader - Статус частоты HSI32M"]
pub type MaskHsi32mR = crate :: BitReader ; # [doc = "Field `MASK_OSC32M` reader - Статус частоты внешнего осциллятора 32 МГц OSC32M"]
pub type MaskOsc32mR = crate :: BitReader ; impl R { # [doc = "Bit 0 - Статус частоты LSI32K"]
# [inline (always)]
pub fn mask_lsi32k (& self) -> MaskLsi32kR { MaskLsi32kR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Статус частоты внешнего осциллятора 32 кГц OSC32K"]
# [inline (always)]
pub fn mask_osc32k (& self) -> MaskOsc32kR { MaskOsc32kR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Статус частоты HSI32M"]
# [inline (always)]
pub fn mask_hsi32m (& self) -> MaskHsi32mR { MaskHsi32mR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Статус частоты внешнего осциллятора 32 МГц OSC32M"]
# [inline (always)]
pub fn mask_osc32m (& self) -> MaskOsc32mR { MaskOsc32mR :: new (((self . bits >> 3) & 1) != 0) } } impl W { } # [doc = "Статус монитора частоты\n\nYou can [`read`](crate::Reg::read) this register and get [`freq_status::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`freq_status::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct FreqStatusSpec ; impl crate :: RegisterSpec for FreqStatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`freq_status::R`](R) reader structure"]
impl crate :: Readable for FreqStatusSpec { } # [doc = "`write(|w| ..)` method takes [`freq_status::W`](W) writer structure"]
impl crate :: Writable for FreqStatusSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets FREQ_STATUS to value 0"]
impl crate :: Resettable for FreqStatusSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SLEEP_MODE (rw) register accessor: Переход в спящий режим осуществляется записью в данный регистр. При записи отключается тактирование ядра. В зависимости от записываемого значения отключается тактирование модулей\n\nYou can [`read`](crate::Reg::read) this register and get [`sleep_mode::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sleep_mode::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sleep_mode`]
module"]
# [doc (alias = "SLEEP_MODE")]
pub type SleepMode = crate :: Reg < sleep_mode :: SleepModeSpec > ; # [doc = "Переход в спящий режим осуществляется записью в данный регистр. При записи отключается тактирование ядра. В зависимости от записываемого значения отключается тактирование модулей"]
pub mod sleep_mode { # [doc = "Register `SLEEP_MODE` reader"]
pub type R = crate :: R < SleepModeSpec > ; # [doc = "Register `SLEEP_MODE` writer"]
pub type W = crate :: W < SleepModeSpec > ; # [doc = "Field `EEPROM` reader - Отключение тактирования EEPROM"]
pub type EepromR = crate :: BitReader ; # [doc = "Field `RAM` reader - Отключение тактирования ОЗУ"]
pub type RamR = crate :: BitReader ; # [doc = "Field `SPIFI` reader - Отключение тактирования контроллера SPIFI"]
pub type SpifiR = crate :: BitReader ; impl R { # [doc = "Bit 0 - Отключение тактирования EEPROM"]
# [inline (always)]
pub fn eeprom (& self) -> EepromR { EepromR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Отключение тактирования ОЗУ"]
# [inline (always)]
pub fn ram (& self) -> RamR { RamR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Отключение тактирования контроллера SPIFI"]
# [inline (always)]
pub fn spifi (& self) -> SpifiR { SpifiR :: new (((self . bits >> 2) & 1) != 0) } } impl W { } # [doc = "Переход в спящий режим осуществляется записью в данный регистр. При записи отключается тактирование ядра. В зависимости от записываемого значения отключается тактирование модулей\n\nYou can [`read`](crate::Reg::read) this register and get [`sleep_mode::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sleep_mode::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SleepModeSpec ; impl crate :: RegisterSpec for SleepModeSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sleep_mode::R`](R) reader structure"]
impl crate :: Readable for SleepModeSpec { } # [doc = "`write(|w| ..)` method takes [`sleep_mode::W`](W) writer structure"]
impl crate :: Writable for SleepModeSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SLEEP_MODE to value 0"]
impl crate :: Resettable for SleepModeSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Программируемый контроллер прерываний"]
pub struct Epic { _marker : PhantomData < * const () > } unsafe impl Send for Epic { } impl Epic { # [doc = r"Pointer to the register block"]
pub const PTR : * const epic :: RegisterBlock = 0x0005_0400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const epic :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Epic { type Target = epic :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Epic { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Epic") . finish () } } # [doc = "Программируемый контроллер прерываний"]
pub mod epic { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { mask_edge_set : MaskEdgeSet , mask_edge_clear : MaskEdgeClear , mask_level_set : MaskLevelSet , mask_level_clear : MaskLevelClear , _reserved4 : [u8 ; 0x08]
, clear : Clear , status : Status , raw_status : RawStatus , } impl RegisterBlock { # [doc = "0x00 - При чтении – текущее состоянии масок прерываний по фронту. При записи, «1» разрешает прерывание по фронту соответствующего источника прерываний."]
# [inline (always)]
pub const fn mask_edge_set (& self) -> & MaskEdgeSet { & self . mask_edge_set } # [doc = "0x04 - Установка маски прерываний по фронту"]
# [inline (always)]
pub const fn mask_edge_clear (& self) -> & MaskEdgeClear { & self . mask_edge_clear } # [doc = "0x08 - Установка маски прерываний по уровню"]
# [inline (always)]
pub const fn mask_level_set (& self) -> & MaskLevelSet { & self . mask_level_set } # [doc = "0x0c - Сброс маски прерываний по уровню"]
# [inline (always)]
pub const fn mask_level_clear (& self) -> & MaskLevelClear { & self . mask_level_clear } # [doc = "0x18 - Сброс флагов в статусе прерываний"]
# [inline (always)]
pub const fn clear (& self) -> & Clear { & self . clear } # [doc = "0x1c - Сброс прерываний"]
# [inline (always)]
pub const fn status (& self) -> & Status { & self . status } # [doc = "0x20 - Текущее состоянии линий прерываний"]
# [inline (always)]
pub const fn raw_status (& self) -> & RawStatus { & self . raw_status } } # [doc = "MASK_EDGE_SET (rw) register accessor: При чтении – текущее состоянии масок прерываний по фронту. При записи, «1» разрешает прерывание по фронту соответствующего источника прерываний.\n\nYou can [`read`](crate::Reg::read) this register and get [`mask_edge_set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mask_edge_set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mask_edge_set`]
module"]
# [doc (alias = "MASK_EDGE_SET")]
pub type MaskEdgeSet = crate :: Reg < mask_edge_set :: MaskEdgeSetSpec > ; # [doc = "При чтении – текущее состоянии масок прерываний по фронту. При записи, «1» разрешает прерывание по фронту соответствующего источника прерываний."]
pub mod mask_edge_set { # [doc = "Register `MASK_EDGE_SET` reader"]
pub type R = crate :: R < MaskEdgeSetSpec > ; # [doc = "Register `MASK_EDGE_SET` writer"]
pub type W = crate :: W < MaskEdgeSetSpec > ; # [doc = "Линия прерывания Timer32_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer32_0 > for bool { # [inline (always)]
fn from (variant : Timer32_0) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_0` reader - Линия прерывания Timer32_0"]
pub type Timer32_0R = crate :: BitReader < Timer32_0 > ; impl Timer32_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_0 { match self . bits { false => Timer32_0 :: Disable , true => Timer32_0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_0 :: Enable } } # [doc = "Field `Timer32_0` writer - Линия прерывания Timer32_0"]
pub type Timer32_0W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Timer32_0 > ; impl < 'a , REG > Timer32_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_0 :: Enable) } } # [doc = "Линия прерывания USART_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Usart0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Usart0 > for bool { # [inline (always)]
fn from (variant : Usart0) -> Self { variant as u8 != 0 } } # [doc = "Field `USART_0` reader - Линия прерывания USART_0"]
pub type Usart0R = crate :: BitReader < Usart0 > ; impl Usart0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Usart0 { match self . bits { false => Usart0 :: Disable , true => Usart0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Usart0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Usart0 :: Enable } } # [doc = "Field `USART_0` writer - Линия прерывания USART_0"]
pub type Usart0W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Usart0 > ; impl < 'a , REG > Usart0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Usart0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Usart0 :: Enable) } } # [doc = "Линия прерывания USART_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Usart1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Usart1 > for bool { # [inline (always)]
fn from (variant : Usart1) -> Self { variant as u8 != 0 } } # [doc = "Field `USART_1` reader - Линия прерывания USART_1"]
pub type Usart1R = crate :: BitReader < Usart1 > ; impl Usart1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Usart1 { match self . bits { false => Usart1 :: Disable , true => Usart1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Usart1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Usart1 :: Enable } } # [doc = "Field `USART_1` writer - Линия прерывания USART_1"]
pub type Usart1W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Usart1 > ; impl < 'a , REG > Usart1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Usart1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Usart1 :: Enable) } } # [doc = "Линия прерывания SPI_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spi0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Spi0 > for bool { # [inline (always)]
fn from (variant : Spi0) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_0` reader - Линия прерывания SPI_0"]
pub type Spi0R = crate :: BitReader < Spi0 > ; impl Spi0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spi0 { match self . bits { false => Spi0 :: Disable , true => Spi0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spi0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spi0 :: Enable } } # [doc = "Field `SPI_0` writer - Линия прерывания SPI_0"]
pub type Spi0W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Spi0 > ; impl < 'a , REG > Spi0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi0 :: Enable) } } # [doc = "Линия прерывания SPI_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spi1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Spi1 > for bool { # [inline (always)]
fn from (variant : Spi1) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_1` reader - Линия прерывания SPI_1"]
pub type Spi1R = crate :: BitReader < Spi1 > ; impl Spi1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spi1 { match self . bits { false => Spi1 :: Disable , true => Spi1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spi1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spi1 :: Enable } } # [doc = "Field `SPI_1` writer - Линия прерывания SPI_1"]
pub type Spi1W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Spi1 > ; impl < 'a , REG > Spi1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi1 :: Enable) } } # [doc = "Линия прерывания GPIO\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gpio { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Gpio > for bool { # [inline (always)]
fn from (variant : Gpio) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO` reader - Линия прерывания GPIO"]
pub type GpioR = crate :: BitReader < Gpio > ; impl GpioR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Gpio { match self . bits { false => Gpio :: Disable , true => Gpio :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Gpio :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Gpio :: Enable } } # [doc = "Field `GPIO` writer - Линия прерывания GPIO"]
pub type GpioW < 'a , REG > = crate :: BitWriter1S < 'a , REG , Gpio > ; impl < 'a , REG > GpioW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio :: Enable) } } # [doc = "Линия прерывания I2C_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum I2c0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < I2c0 > for bool { # [inline (always)]
fn from (variant : I2c0) -> Self { variant as u8 != 0 } } # [doc = "Field `I2C_0` reader - Линия прерывания I2C_0"]
pub type I2c0R = crate :: BitReader < I2c0 > ; impl I2c0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> I2c0 { match self . bits { false => I2c0 :: Disable , true => I2c0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == I2c0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == I2c0 :: Enable } } # [doc = "Field `I2C_0` writer - Линия прерывания I2C_0"]
pub type I2c0W < 'a , REG > = crate :: BitWriter1S < 'a , REG , I2c0 > ; impl < 'a , REG > I2c0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c0 :: Enable) } } # [doc = "Линия прерывания I2C_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum I2c1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < I2c1 > for bool { # [inline (always)]
fn from (variant : I2c1) -> Self { variant as u8 != 0 } } # [doc = "Field `I2C_1` reader - Линия прерывания I2C_1"]
pub type I2c1R = crate :: BitReader < I2c1 > ; impl I2c1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> I2c1 { match self . bits { false => I2c1 :: Disable , true => I2c1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == I2c1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == I2c1 :: Enable } } # [doc = "Field `I2C_1` writer - Линия прерывания I2C_1"]
pub type I2c1W < 'a , REG > = crate :: BitWriter1S < 'a , REG , I2c1 > ; impl < 'a , REG > I2c1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c1 :: Enable) } } # [doc = "Линия прерывания сторожевого таймера (WDT)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wdt { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Wdt > for bool { # [inline (always)]
fn from (variant : Wdt) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT` reader - Линия прерывания сторожевого таймера (WDT)"]
pub type WdtR = crate :: BitReader < Wdt > ; impl WdtR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wdt { match self . bits { false => Wdt :: Disable , true => Wdt :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Wdt :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Wdt :: Enable } } # [doc = "Field `WDT` writer - Линия прерывания сторожевого таймера (WDT)"]
pub type WdtW < 'a , REG > = crate :: BitWriter1S < 'a , REG , Wdt > ; impl < 'a , REG > WdtW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Wdt :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Wdt :: Enable) } } # [doc = "Линия прерывания Timer16_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer16_0 > for bool { # [inline (always)]
fn from (variant : Timer16_0) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_0` reader - Линия прерывания Timer16_0"]
pub type Timer16_0R = crate :: BitReader < Timer16_0 > ; impl Timer16_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_0 { match self . bits { false => Timer16_0 :: Disable , true => Timer16_0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_0 :: Enable } } # [doc = "Field `Timer16_0` writer - Линия прерывания Timer16_0"]
pub type Timer16_0W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Timer16_0 > ; impl < 'a , REG > Timer16_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_0 :: Enable) } } # [doc = "Линия прерывания Timer16_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer16_1 > for bool { # [inline (always)]
fn from (variant : Timer16_1) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_1` reader - Линия прерывания Timer16_1"]
pub type Timer16_1R = crate :: BitReader < Timer16_1 > ; impl Timer16_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_1 { match self . bits { false => Timer16_1 :: Disable , true => Timer16_1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_1 :: Enable } } # [doc = "Field `Timer16_1` writer - Линия прерывания Timer16_1"]
pub type Timer16_1W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Timer16_1 > ; impl < 'a , REG > Timer16_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_1 :: Enable) } } # [doc = "Линия прерывания Timer16_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_2 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer16_2 > for bool { # [inline (always)]
fn from (variant : Timer16_2) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_2` reader - Линия прерывания Timer16_2"]
pub type Timer16_2R = crate :: BitReader < Timer16_2 > ; impl Timer16_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_2 { match self . bits { false => Timer16_2 :: Disable , true => Timer16_2 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_2 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_2 :: Enable } } # [doc = "Field `Timer16_2` writer - Линия прерывания Timer16_2"]
pub type Timer16_2W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Timer16_2 > ; impl < 'a , REG > Timer16_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_2 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_2 :: Enable) } } # [doc = "Линия прерывания Timer32_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer32_1 > for bool { # [inline (always)]
fn from (variant : Timer32_1) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_1` reader - Линия прерывания Timer32_1"]
pub type Timer32_1R = crate :: BitReader < Timer32_1 > ; impl Timer32_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_1 { match self . bits { false => Timer32_1 :: Disable , true => Timer32_1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_1 :: Enable } } # [doc = "Field `Timer32_1` writer - Линия прерывания Timer32_1"]
pub type Timer32_1W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Timer32_1 > ; impl < 'a , REG > Timer32_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_1 :: Enable) } } # [doc = "Линия прерывания Timer32_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_2 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer32_2 > for bool { # [inline (always)]
fn from (variant : Timer32_2) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_2` reader - Линия прерывания Timer32_2"]
pub type Timer32_2R = crate :: BitReader < Timer32_2 > ; impl Timer32_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_2 { match self . bits { false => Timer32_2 :: Disable , true => Timer32_2 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_2 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_2 :: Enable } } # [doc = "Field `Timer32_2` writer - Линия прерывания Timer32_2"]
pub type Timer32_2W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Timer32_2 > ; impl < 'a , REG > Timer32_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_2 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_2 :: Enable) } } # [doc = "Линия прерывания SPIFI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spifi { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Spifi > for bool { # [inline (always)]
fn from (variant : Spifi) -> Self { variant as u8 != 0 } } # [doc = "Field `SPIFI` reader - Линия прерывания SPIFI"]
pub type SpifiR = crate :: BitReader < Spifi > ; impl SpifiR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spifi { match self . bits { false => Spifi :: Disable , true => Spifi :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spifi :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spifi :: Enable } } # [doc = "Field `SPIFI` writer - Линия прерывания SPIFI"]
pub type SpifiW < 'a , REG > = crate :: BitWriter1S < 'a , REG , Spifi > ; impl < 'a , REG > SpifiW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spifi :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spifi :: Enable) } } # [doc = "Линия прерывания RTC\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rtc { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Rtc > for bool { # [inline (always)]
fn from (variant : Rtc) -> Self { variant as u8 != 0 } } # [doc = "Field `RTC` reader - Линия прерывания RTC"]
pub type RtcR = crate :: BitReader < Rtc > ; impl RtcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rtc { match self . bits { false => Rtc :: Disable , true => Rtc :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Rtc :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Rtc :: Enable } } # [doc = "Field `RTC` writer - Линия прерывания RTC"]
pub type RtcW < 'a , REG > = crate :: BitWriter1S < 'a , REG , Rtc > ; impl < 'a , REG > RtcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Rtc :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Rtc :: Enable) } } # [doc = "Линия прерывания EEPROM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Eeprom { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Eeprom > for bool { # [inline (always)]
fn from (variant : Eeprom) -> Self { variant as u8 != 0 } } # [doc = "Field `EEPROM` reader - Линия прерывания EEPROM"]
pub type EepromR = crate :: BitReader < Eeprom > ; impl EepromR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Eeprom { match self . bits { false => Eeprom :: Disable , true => Eeprom :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Eeprom :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Eeprom :: Enable } } # [doc = "Field `EEPROM` writer - Линия прерывания EEPROM"]
pub type EepromW < 'a , REG > = crate :: BitWriter1S < 'a , REG , Eeprom > ; impl < 'a , REG > EepromW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Eeprom :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Eeprom :: Enable) } } # [doc = "Линия прерывания сторожевого таймера шины (периферийные устройства)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WdtBusDom3 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < WdtBusDom3 > for bool { # [inline (always)]
fn from (variant : WdtBusDom3) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT_BUS_DOM3` reader - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
pub type WdtBusDom3R = crate :: BitReader < WdtBusDom3 > ; impl WdtBusDom3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WdtBusDom3 { match self . bits { false => WdtBusDom3 :: Disable , true => WdtBusDom3 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WdtBusDom3 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WdtBusDom3 :: Enable } } # [doc = "Field `WDT_BUS_DOM3` writer - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
pub type WdtBusDom3W < 'a , REG > = crate :: BitWriter1S < 'a , REG , WdtBusDom3 > ; impl < 'a , REG > WdtBusDom3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusDom3 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusDom3 :: Enable) } } # [doc = "Линия прерывания сторожевого таймера шины (SPIFI)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WdtBusSpifi { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < WdtBusSpifi > for bool { # [inline (always)]
fn from (variant : WdtBusSpifi) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT_BUS_SPIFI` reader - Линия прерывания сторожевого таймера шины (SPIFI)"]
pub type WdtBusSpifiR = crate :: BitReader < WdtBusSpifi > ; impl WdtBusSpifiR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WdtBusSpifi { match self . bits { false => WdtBusSpifi :: Disable , true => WdtBusSpifi :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WdtBusSpifi :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WdtBusSpifi :: Enable } } # [doc = "Field `WDT_BUS_SPIFI` writer - Линия прерывания сторожевого таймера шины (SPIFI)"]
pub type WdtBusSpifiW < 'a , REG > = crate :: BitWriter1S < 'a , REG , WdtBusSpifi > ; impl < 'a , REG > WdtBusSpifiW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusSpifi :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusSpifi :: Enable) } } # [doc = "Линия прерывания сторожевого таймера шины (EEPROM)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WdtBusEeprom { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < WdtBusEeprom > for bool { # [inline (always)]
fn from (variant : WdtBusEeprom) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT_BUS_EEPROM` reader - Линия прерывания сторожевого таймера шины (EEPROM)"]
pub type WdtBusEepromR = crate :: BitReader < WdtBusEeprom > ; impl WdtBusEepromR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WdtBusEeprom { match self . bits { false => WdtBusEeprom :: Disable , true => WdtBusEeprom :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WdtBusEeprom :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WdtBusEeprom :: Enable } } # [doc = "Field `WDT_BUS_EEPROM` writer - Линия прерывания сторожевого таймера шины (EEPROM)"]
pub type WdtBusEepromW < 'a , REG > = crate :: BitWriter1S < 'a , REG , WdtBusEeprom > ; impl < 'a , REG > WdtBusEepromW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusEeprom :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusEeprom :: Enable) } } # [doc = "Линия прерывания ПДП\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dma { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Dma > for bool { # [inline (always)]
fn from (variant : Dma) -> Self { variant as u8 != 0 } } # [doc = "Field `DMA` reader - Линия прерывания ПДП"]
pub type DmaR = crate :: BitReader < Dma > ; impl DmaR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dma { match self . bits { false => Dma :: Disable , true => Dma :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dma :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dma :: Enable } } # [doc = "Field `DMA` writer - Линия прерывания ПДП"]
pub type DmaW < 'a , REG > = crate :: BitWriter1S < 'a , REG , Dma > ; impl < 'a , REG > DmaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Enable) } } # [doc = "Линия прерывания монитора частоты\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum FrequencyMonitor { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < FrequencyMonitor > for bool { # [inline (always)]
fn from (variant : FrequencyMonitor) -> Self { variant as u8 != 0 } } # [doc = "Field `Frequency_monitor` reader - Линия прерывания монитора частоты"]
pub type FrequencyMonitorR = crate :: BitReader < FrequencyMonitor > ; impl FrequencyMonitorR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> FrequencyMonitor { match self . bits { false => FrequencyMonitor :: Disable , true => FrequencyMonitor :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == FrequencyMonitor :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == FrequencyMonitor :: Enable } } # [doc = "Field `Frequency_monitor` writer - Линия прерывания монитора частоты"]
pub type FrequencyMonitorW < 'a , REG > = crate :: BitWriter1S < 'a , REG , FrequencyMonitor > ; impl < 'a , REG > FrequencyMonitorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (FrequencyMonitor :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (FrequencyMonitor :: Enable) } } # [doc = "Линия прерывания монитора напряжения AVCC (ниже порога)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PvdAvccUnder { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < PvdAvccUnder > for bool { # [inline (always)]
fn from (variant : PvdAvccUnder) -> Self { variant as u8 != 0 } } # [doc = "Field `PVD_AVCC_under` reader - Линия прерывания монитора напряжения AVCC (ниже порога)"]
pub type PvdAvccUnderR = crate :: BitReader < PvdAvccUnder > ; impl PvdAvccUnderR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PvdAvccUnder { match self . bits { false => PvdAvccUnder :: Disable , true => PvdAvccUnder :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PvdAvccUnder :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PvdAvccUnder :: Enable } } # [doc = "Field `PVD_AVCC_under` writer - Линия прерывания монитора напряжения AVCC (ниже порога)"]
pub type PvdAvccUnderW < 'a , REG > = crate :: BitWriter1S < 'a , REG , PvdAvccUnder > ; impl < 'a , REG > PvdAvccUnderW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdAvccUnder :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdAvccUnder :: Enable) } } # [doc = "Линия прерывания монитора напряжения AVCC (выше порога)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PvdAvccOver { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < PvdAvccOver > for bool { # [inline (always)]
fn from (variant : PvdAvccOver) -> Self { variant as u8 != 0 } } # [doc = "Field `PVD_AVCC_over` reader - Линия прерывания монитора напряжения AVCC (выше порога)"]
pub type PvdAvccOverR = crate :: BitReader < PvdAvccOver > ; impl PvdAvccOverR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PvdAvccOver { match self . bits { false => PvdAvccOver :: Disable , true => PvdAvccOver :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PvdAvccOver :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PvdAvccOver :: Enable } } # [doc = "Field `PVD_AVCC_over` writer - Линия прерывания монитора напряжения AVCC (выше порога)"]
pub type PvdAvccOverW < 'a , REG > = crate :: BitWriter1S < 'a , REG , PvdAvccOver > ; impl < 'a , REG > PvdAvccOverW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdAvccOver :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdAvccOver :: Enable) } } # [doc = "Линия прерывания монитора напряжения VCC (ниже порога)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PvdVccUnder { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < PvdVccUnder > for bool { # [inline (always)]
fn from (variant : PvdVccUnder) -> Self { variant as u8 != 0 } } # [doc = "Field `PVD_VCC_under` reader - Линия прерывания монитора напряжения VCC (ниже порога)"]
pub type PvdVccUnderR = crate :: BitReader < PvdVccUnder > ; impl PvdVccUnderR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PvdVccUnder { match self . bits { false => PvdVccUnder :: Disable , true => PvdVccUnder :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PvdVccUnder :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PvdVccUnder :: Enable } } # [doc = "Field `PVD_VCC_under` writer - Линия прерывания монитора напряжения VCC (ниже порога)"]
pub type PvdVccUnderW < 'a , REG > = crate :: BitWriter1S < 'a , REG , PvdVccUnder > ; impl < 'a , REG > PvdVccUnderW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdVccUnder :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdVccUnder :: Enable) } } # [doc = "Линия прерывания монитора напряжения VCC (выше порога)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PvdVccOver { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < PvdVccOver > for bool { # [inline (always)]
fn from (variant : PvdVccOver) -> Self { variant as u8 != 0 } } # [doc = "Field `PVD_VCC_over` reader - Линия прерывания монитора напряжения VCC (выше порога)"]
pub type PvdVccOverR = crate :: BitReader < PvdVccOver > ; impl PvdVccOverR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PvdVccOver { match self . bits { false => PvdVccOver :: Disable , true => PvdVccOver :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PvdVccOver :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PvdVccOver :: Enable } } # [doc = "Field `PVD_VCC_over` writer - Линия прерывания монитора напряжения VCC (выше порога)"]
pub type PvdVccOverW < 'a , REG > = crate :: BitWriter1S < 'a , REG , PvdVccOver > ; impl < 'a , REG > PvdVccOverW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdVccOver :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdVccOver :: Enable) } } # [doc = "Линия прерывания недостаточного напряжения батареи\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum BatteryNonGood { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < BatteryNonGood > for bool { # [inline (always)]
fn from (variant : BatteryNonGood) -> Self { variant as u8 != 0 } } # [doc = "Field `BATTERY_NON_GOOD` reader - Линия прерывания недостаточного напряжения батареи"]
pub type BatteryNonGoodR = crate :: BitReader < BatteryNonGood > ; impl BatteryNonGoodR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> BatteryNonGood { match self . bits { false => BatteryNonGood :: Disable , true => BatteryNonGood :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == BatteryNonGood :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == BatteryNonGood :: Enable } } # [doc = "Field `BATTERY_NON_GOOD` writer - Линия прерывания недостаточного напряжения батареи"]
pub type BatteryNonGoodW < 'a , REG > = crate :: BitWriter1S < 'a , REG , BatteryNonGood > ; impl < 'a , REG > BatteryNonGoodW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (BatteryNonGood :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (BatteryNonGood :: Enable) } } # [doc = "Линия прерывания BrouwnOut детектора\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Bor { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Bor > for bool { # [inline (always)]
fn from (variant : Bor) -> Self { variant as u8 != 0 } } # [doc = "Field `BOR` reader - Линия прерывания BrouwnOut детектора"]
pub type BorR = crate :: BitReader < Bor > ; impl BorR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Bor { match self . bits { false => Bor :: Disable , true => Bor :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Bor :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Bor :: Enable } } # [doc = "Field `BOR` writer - Линия прерывания BrouwnOut детектора"]
pub type BorW < 'a , REG > = crate :: BitWriter1S < 'a , REG , Bor > ; impl < 'a , REG > BorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Bor :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Bor :: Enable) } } # [doc = "Линия прерывания монитора температуры\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Tsens { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Tsens > for bool { # [inline (always)]
fn from (variant : Tsens) -> Self { variant as u8 != 0 } } # [doc = "Field `TSENS` reader - Линия прерывания монитора температуры"]
pub type TsensR = crate :: BitReader < Tsens > ; impl TsensR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Tsens { match self . bits { false => Tsens :: Disable , true => Tsens :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Tsens :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Tsens :: Enable } } # [doc = "Field `TSENS` writer - Линия прерывания монитора температуры"]
pub type TsensW < 'a , REG > = crate :: BitWriter1S < 'a , REG , Tsens > ; impl < 'a , REG > TsensW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Tsens :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Tsens :: Enable) } } # [doc = "Линия прерывания АЦП\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Adc { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Adc > for bool { # [inline (always)]
fn from (variant : Adc) -> Self { variant as u8 != 0 } } # [doc = "Field `ADC` reader - Линия прерывания АЦП"]
pub type AdcR = crate :: BitReader < Adc > ; impl AdcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Adc { match self . bits { false => Adc :: Disable , true => Adc :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Adc :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Adc :: Enable } } # [doc = "Field `ADC` writer - Линия прерывания АЦП"]
pub type AdcW < 'a , REG > = crate :: BitWriter1S < 'a , REG , Adc > ; impl < 'a , REG > AdcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Adc :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Adc :: Enable) } } # [doc = "Линия прерывания ЦАП0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dac0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Dac0 > for bool { # [inline (always)]
fn from (variant : Dac0) -> Self { variant as u8 != 0 } } # [doc = "Field `DAC0` reader - Линия прерывания ЦАП0"]
pub type Dac0R = crate :: BitReader < Dac0 > ; impl Dac0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dac0 { match self . bits { false => Dac0 :: Disable , true => Dac0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dac0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dac0 :: Enable } } # [doc = "Field `DAC0` writer - Линия прерывания ЦАП0"]
pub type Dac0W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Dac0 > ; impl < 'a , REG > Dac0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dac0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dac0 :: Enable) } } # [doc = "Линия прерывания ЦАП1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dac1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Dac1 > for bool { # [inline (always)]
fn from (variant : Dac1) -> Self { variant as u8 != 0 } } # [doc = "Field `DAC1` reader - Линия прерывания ЦАП1"]
pub type Dac1R = crate :: BitReader < Dac1 > ; impl Dac1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dac1 { match self . bits { false => Dac1 :: Disable , true => Dac1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dac1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dac1 :: Enable } } # [doc = "Field `DAC1` writer - Линия прерывания ЦАП1"]
pub type Dac1W < 'a , REG > = crate :: BitWriter1S < 'a , REG , Dac1 > ; impl < 'a , REG > Dac1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dac1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dac1 :: Enable) } } impl R { # [doc = "Bit 0 - Линия прерывания Timer32_0"]
# [inline (always)]
pub fn timer32_0 (& self) -> Timer32_0R { Timer32_0R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Линия прерывания USART_0"]
# [inline (always)]
pub fn usart_0 (& self) -> Usart0R { Usart0R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Линия прерывания USART_1"]
# [inline (always)]
pub fn usart_1 (& self) -> Usart1R { Usart1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Линия прерывания SPI_0"]
# [inline (always)]
pub fn spi_0 (& self) -> Spi0R { Spi0R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Линия прерывания SPI_1"]
# [inline (always)]
pub fn spi_1 (& self) -> Spi1R { Spi1R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Линия прерывания GPIO"]
# [inline (always)]
pub fn gpio (& self) -> GpioR { GpioR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Линия прерывания I2C_0"]
# [inline (always)]
pub fn i2c_0 (& self) -> I2c0R { I2c0R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Линия прерывания I2C_1"]
# [inline (always)]
pub fn i2c_1 (& self) -> I2c1R { I2c1R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Линия прерывания сторожевого таймера (WDT)"]
# [inline (always)]
pub fn wdt (& self) -> WdtR { WdtR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Линия прерывания Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& self) -> Timer16_0R { Timer16_0R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Линия прерывания Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& self) -> Timer16_1R { Timer16_1R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Линия прерывания Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& self) -> Timer16_2R { Timer16_2R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Линия прерывания Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& self) -> Timer32_1R { Timer32_1R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Линия прерывания Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& self) -> Timer32_2R { Timer32_2R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Линия прерывания SPIFI"]
# [inline (always)]
pub fn spifi (& self) -> SpifiR { SpifiR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Линия прерывания RTC"]
# [inline (always)]
pub fn rtc (& self) -> RtcR { RtcR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Линия прерывания EEPROM"]
# [inline (always)]
pub fn eeprom (& self) -> EepromR { EepromR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
# [inline (always)]
pub fn wdt_bus_dom3 (& self) -> WdtBusDom3R { WdtBusDom3R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Линия прерывания сторожевого таймера шины (SPIFI)"]
# [inline (always)]
pub fn wdt_bus_spifi (& self) -> WdtBusSpifiR { WdtBusSpifiR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Линия прерывания сторожевого таймера шины (EEPROM)"]
# [inline (always)]
pub fn wdt_bus_eeprom (& self) -> WdtBusEepromR { WdtBusEepromR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Линия прерывания ПДП"]
# [inline (always)]
pub fn dma (& self) -> DmaR { DmaR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Линия прерывания монитора частоты"]
# [inline (always)]
pub fn frequency_monitor (& self) -> FrequencyMonitorR { FrequencyMonitorR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Линия прерывания монитора напряжения AVCC (ниже порога)"]
# [inline (always)]
pub fn pvd_avcc_under (& self) -> PvdAvccUnderR { PvdAvccUnderR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Линия прерывания монитора напряжения AVCC (выше порога)"]
# [inline (always)]
pub fn pvd_avcc_over (& self) -> PvdAvccOverR { PvdAvccOverR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 24 - Линия прерывания монитора напряжения VCC (ниже порога)"]
# [inline (always)]
pub fn pvd_vcc_under (& self) -> PvdVccUnderR { PvdVccUnderR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Линия прерывания монитора напряжения VCC (выше порога)"]
# [inline (always)]
pub fn pvd_vcc_over (& self) -> PvdVccOverR { PvdVccOverR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Линия прерывания недостаточного напряжения батареи"]
# [inline (always)]
pub fn battery_non_good (& self) -> BatteryNonGoodR { BatteryNonGoodR :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Линия прерывания BrouwnOut детектора"]
# [inline (always)]
pub fn bor (& self) -> BorR { BorR :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 28 - Линия прерывания монитора температуры"]
# [inline (always)]
pub fn tsens (& self) -> TsensR { TsensR :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Линия прерывания АЦП"]
# [inline (always)]
pub fn adc (& self) -> AdcR { AdcR :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Линия прерывания ЦАП0"]
# [inline (always)]
pub fn dac0 (& self) -> Dac0R { Dac0R :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - Линия прерывания ЦАП1"]
# [inline (always)]
pub fn dac1 (& self) -> Dac1R { Dac1R :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bit 0 - Линия прерывания Timer32_0"]
# [inline (always)]
pub fn timer32_0 (& mut self) -> Timer32_0W < MaskEdgeSetSpec > { Timer32_0W :: new (self , 0) } # [doc = "Bit 1 - Линия прерывания USART_0"]
# [inline (always)]
pub fn usart_0 (& mut self) -> Usart0W < MaskEdgeSetSpec > { Usart0W :: new (self , 1) } # [doc = "Bit 2 - Линия прерывания USART_1"]
# [inline (always)]
pub fn usart_1 (& mut self) -> Usart1W < MaskEdgeSetSpec > { Usart1W :: new (self , 2) } # [doc = "Bit 3 - Линия прерывания SPI_0"]
# [inline (always)]
pub fn spi_0 (& mut self) -> Spi0W < MaskEdgeSetSpec > { Spi0W :: new (self , 3) } # [doc = "Bit 4 - Линия прерывания SPI_1"]
# [inline (always)]
pub fn spi_1 (& mut self) -> Spi1W < MaskEdgeSetSpec > { Spi1W :: new (self , 4) } # [doc = "Bit 5 - Линия прерывания GPIO"]
# [inline (always)]
pub fn gpio (& mut self) -> GpioW < MaskEdgeSetSpec > { GpioW :: new (self , 5) } # [doc = "Bit 6 - Линия прерывания I2C_0"]
# [inline (always)]
pub fn i2c_0 (& mut self) -> I2c0W < MaskEdgeSetSpec > { I2c0W :: new (self , 6) } # [doc = "Bit 7 - Линия прерывания I2C_1"]
# [inline (always)]
pub fn i2c_1 (& mut self) -> I2c1W < MaskEdgeSetSpec > { I2c1W :: new (self , 7) } # [doc = "Bit 8 - Линия прерывания сторожевого таймера (WDT)"]
# [inline (always)]
pub fn wdt (& mut self) -> WdtW < MaskEdgeSetSpec > { WdtW :: new (self , 8) } # [doc = "Bit 9 - Линия прерывания Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& mut self) -> Timer16_0W < MaskEdgeSetSpec > { Timer16_0W :: new (self , 9) } # [doc = "Bit 10 - Линия прерывания Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& mut self) -> Timer16_1W < MaskEdgeSetSpec > { Timer16_1W :: new (self , 10) } # [doc = "Bit 11 - Линия прерывания Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& mut self) -> Timer16_2W < MaskEdgeSetSpec > { Timer16_2W :: new (self , 11) } # [doc = "Bit 12 - Линия прерывания Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& mut self) -> Timer32_1W < MaskEdgeSetSpec > { Timer32_1W :: new (self , 12) } # [doc = "Bit 13 - Линия прерывания Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& mut self) -> Timer32_2W < MaskEdgeSetSpec > { Timer32_2W :: new (self , 13) } # [doc = "Bit 14 - Линия прерывания SPIFI"]
# [inline (always)]
pub fn spifi (& mut self) -> SpifiW < MaskEdgeSetSpec > { SpifiW :: new (self , 14) } # [doc = "Bit 15 - Линия прерывания RTC"]
# [inline (always)]
pub fn rtc (& mut self) -> RtcW < MaskEdgeSetSpec > { RtcW :: new (self , 15) } # [doc = "Bit 16 - Линия прерывания EEPROM"]
# [inline (always)]
pub fn eeprom (& mut self) -> EepromW < MaskEdgeSetSpec > { EepromW :: new (self , 16) } # [doc = "Bit 17 - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
# [inline (always)]
pub fn wdt_bus_dom3 (& mut self) -> WdtBusDom3W < MaskEdgeSetSpec > { WdtBusDom3W :: new (self , 17) } # [doc = "Bit 18 - Линия прерывания сторожевого таймера шины (SPIFI)"]
# [inline (always)]
pub fn wdt_bus_spifi (& mut self) -> WdtBusSpifiW < MaskEdgeSetSpec > { WdtBusSpifiW :: new (self , 18) } # [doc = "Bit 19 - Линия прерывания сторожевого таймера шины (EEPROM)"]
# [inline (always)]
pub fn wdt_bus_eeprom (& mut self) -> WdtBusEepromW < MaskEdgeSetSpec > { WdtBusEepromW :: new (self , 19) } # [doc = "Bit 20 - Линия прерывания ПДП"]
# [inline (always)]
pub fn dma (& mut self) -> DmaW < MaskEdgeSetSpec > { DmaW :: new (self , 20) } # [doc = "Bit 21 - Линия прерывания монитора частоты"]
# [inline (always)]
pub fn frequency_monitor (& mut self) -> FrequencyMonitorW < MaskEdgeSetSpec > { FrequencyMonitorW :: new (self , 21) } # [doc = "Bit 22 - Линия прерывания монитора напряжения AVCC (ниже порога)"]
# [inline (always)]
pub fn pvd_avcc_under (& mut self) -> PvdAvccUnderW < MaskEdgeSetSpec > { PvdAvccUnderW :: new (self , 22) } # [doc = "Bit 23 - Линия прерывания монитора напряжения AVCC (выше порога)"]
# [inline (always)]
pub fn pvd_avcc_over (& mut self) -> PvdAvccOverW < MaskEdgeSetSpec > { PvdAvccOverW :: new (self , 23) } # [doc = "Bit 24 - Линия прерывания монитора напряжения VCC (ниже порога)"]
# [inline (always)]
pub fn pvd_vcc_under (& mut self) -> PvdVccUnderW < MaskEdgeSetSpec > { PvdVccUnderW :: new (self , 24) } # [doc = "Bit 25 - Линия прерывания монитора напряжения VCC (выше порога)"]
# [inline (always)]
pub fn pvd_vcc_over (& mut self) -> PvdVccOverW < MaskEdgeSetSpec > { PvdVccOverW :: new (self , 25) } # [doc = "Bit 26 - Линия прерывания недостаточного напряжения батареи"]
# [inline (always)]
pub fn battery_non_good (& mut self) -> BatteryNonGoodW < MaskEdgeSetSpec > { BatteryNonGoodW :: new (self , 26) } # [doc = "Bit 27 - Линия прерывания BrouwnOut детектора"]
# [inline (always)]
pub fn bor (& mut self) -> BorW < MaskEdgeSetSpec > { BorW :: new (self , 27) } # [doc = "Bit 28 - Линия прерывания монитора температуры"]
# [inline (always)]
pub fn tsens (& mut self) -> TsensW < MaskEdgeSetSpec > { TsensW :: new (self , 28) } # [doc = "Bit 29 - Линия прерывания АЦП"]
# [inline (always)]
pub fn adc (& mut self) -> AdcW < MaskEdgeSetSpec > { AdcW :: new (self , 29) } # [doc = "Bit 30 - Линия прерывания ЦАП0"]
# [inline (always)]
pub fn dac0 (& mut self) -> Dac0W < MaskEdgeSetSpec > { Dac0W :: new (self , 30) } # [doc = "Bit 31 - Линия прерывания ЦАП1"]
# [inline (always)]
pub fn dac1 (& mut self) -> Dac1W < MaskEdgeSetSpec > { Dac1W :: new (self , 31) } } # [doc = "При чтении – текущее состоянии масок прерываний по фронту. При записи, «1» разрешает прерывание по фронту соответствующего источника прерываний.\n\nYou can [`read`](crate::Reg::read) this register and get [`mask_edge_set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mask_edge_set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MaskEdgeSetSpec ; impl crate :: RegisterSpec for MaskEdgeSetSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mask_edge_set::R`](R) reader structure"]
impl crate :: Readable for MaskEdgeSetSpec { } # [doc = "`write(|w| ..)` method takes [`mask_edge_set::W`](W) writer structure"]
impl crate :: Writable for MaskEdgeSetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0xffff_ffff ; } # [doc = "`reset()` method sets MASK_EDGE_SET to value 0"]
impl crate :: Resettable for MaskEdgeSetSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MASK_EDGE_CLEAR (rw) register accessor: Установка маски прерываний по фронту\n\nYou can [`read`](crate::Reg::read) this register and get [`mask_edge_clear::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mask_edge_clear::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mask_edge_clear`]
module"]
# [doc (alias = "MASK_EDGE_CLEAR")]
pub type MaskEdgeClear = crate :: Reg < mask_edge_clear :: MaskEdgeClearSpec > ; # [doc = "Установка маски прерываний по фронту"]
pub mod mask_edge_clear { # [doc = "Register `MASK_EDGE_CLEAR` reader"]
pub type R = crate :: R < MaskEdgeClearSpec > ; # [doc = "Register `MASK_EDGE_CLEAR` writer"]
pub type W = crate :: W < MaskEdgeClearSpec > ; # [doc = "Линия прерывания Timer32_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer32_0 > for bool { # [inline (always)]
fn from (variant : Timer32_0) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_0` reader - Линия прерывания Timer32_0"]
pub type Timer32_0R = crate :: BitReader < Timer32_0 > ; impl Timer32_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_0 { match self . bits { false => Timer32_0 :: Disable , true => Timer32_0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_0 :: Enable } } # [doc = "Field `Timer32_0` writer - Линия прерывания Timer32_0"]
pub type Timer32_0W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Timer32_0 > ; impl < 'a , REG > Timer32_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_0 :: Enable) } } # [doc = "Линия прерывания USART_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Usart0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Usart0 > for bool { # [inline (always)]
fn from (variant : Usart0) -> Self { variant as u8 != 0 } } # [doc = "Field `USART_0` reader - Линия прерывания USART_0"]
pub type Usart0R = crate :: BitReader < Usart0 > ; impl Usart0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Usart0 { match self . bits { false => Usart0 :: Disable , true => Usart0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Usart0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Usart0 :: Enable } } # [doc = "Field `USART_0` writer - Линия прерывания USART_0"]
pub type Usart0W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Usart0 > ; impl < 'a , REG > Usart0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Usart0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Usart0 :: Enable) } } # [doc = "Линия прерывания USART_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Usart1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Usart1 > for bool { # [inline (always)]
fn from (variant : Usart1) -> Self { variant as u8 != 0 } } # [doc = "Field `USART_1` reader - Линия прерывания USART_1"]
pub type Usart1R = crate :: BitReader < Usart1 > ; impl Usart1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Usart1 { match self . bits { false => Usart1 :: Disable , true => Usart1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Usart1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Usart1 :: Enable } } # [doc = "Field `USART_1` writer - Линия прерывания USART_1"]
pub type Usart1W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Usart1 > ; impl < 'a , REG > Usart1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Usart1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Usart1 :: Enable) } } # [doc = "Линия прерывания SPI_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spi0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Spi0 > for bool { # [inline (always)]
fn from (variant : Spi0) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_0` reader - Линия прерывания SPI_0"]
pub type Spi0R = crate :: BitReader < Spi0 > ; impl Spi0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spi0 { match self . bits { false => Spi0 :: Disable , true => Spi0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spi0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spi0 :: Enable } } # [doc = "Field `SPI_0` writer - Линия прерывания SPI_0"]
pub type Spi0W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Spi0 > ; impl < 'a , REG > Spi0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi0 :: Enable) } } # [doc = "Линия прерывания SPI_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spi1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Spi1 > for bool { # [inline (always)]
fn from (variant : Spi1) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_1` reader - Линия прерывания SPI_1"]
pub type Spi1R = crate :: BitReader < Spi1 > ; impl Spi1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spi1 { match self . bits { false => Spi1 :: Disable , true => Spi1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spi1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spi1 :: Enable } } # [doc = "Field `SPI_1` writer - Линия прерывания SPI_1"]
pub type Spi1W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Spi1 > ; impl < 'a , REG > Spi1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spi1 :: Enable) } } # [doc = "Линия прерывания GPIO\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gpio { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Gpio > for bool { # [inline (always)]
fn from (variant : Gpio) -> Self { variant as u8 != 0 } } # [doc = "Field `GPIO` reader - Линия прерывания GPIO"]
pub type GpioR = crate :: BitReader < Gpio > ; impl GpioR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Gpio { match self . bits { false => Gpio :: Disable , true => Gpio :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Gpio :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Gpio :: Enable } } # [doc = "Field `GPIO` writer - Линия прерывания GPIO"]
pub type GpioW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Gpio > ; impl < 'a , REG > GpioW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Gpio :: Enable) } } # [doc = "Линия прерывания I2C_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum I2c0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < I2c0 > for bool { # [inline (always)]
fn from (variant : I2c0) -> Self { variant as u8 != 0 } } # [doc = "Field `I2C_0` reader - Линия прерывания I2C_0"]
pub type I2c0R = crate :: BitReader < I2c0 > ; impl I2c0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> I2c0 { match self . bits { false => I2c0 :: Disable , true => I2c0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == I2c0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == I2c0 :: Enable } } # [doc = "Field `I2C_0` writer - Линия прерывания I2C_0"]
pub type I2c0W < 'a , REG > = crate :: BitWriter1C < 'a , REG , I2c0 > ; impl < 'a , REG > I2c0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c0 :: Enable) } } # [doc = "Линия прерывания I2C_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum I2c1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < I2c1 > for bool { # [inline (always)]
fn from (variant : I2c1) -> Self { variant as u8 != 0 } } # [doc = "Field `I2C_1` reader - Линия прерывания I2C_1"]
pub type I2c1R = crate :: BitReader < I2c1 > ; impl I2c1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> I2c1 { match self . bits { false => I2c1 :: Disable , true => I2c1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == I2c1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == I2c1 :: Enable } } # [doc = "Field `I2C_1` writer - Линия прерывания I2C_1"]
pub type I2c1W < 'a , REG > = crate :: BitWriter1C < 'a , REG , I2c1 > ; impl < 'a , REG > I2c1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (I2c1 :: Enable) } } # [doc = "Линия прерывания сторожевого таймера (WDT)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wdt { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Wdt > for bool { # [inline (always)]
fn from (variant : Wdt) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT` reader - Линия прерывания сторожевого таймера (WDT)"]
pub type WdtR = crate :: BitReader < Wdt > ; impl WdtR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wdt { match self . bits { false => Wdt :: Disable , true => Wdt :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Wdt :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Wdt :: Enable } } # [doc = "Field `WDT` writer - Линия прерывания сторожевого таймера (WDT)"]
pub type WdtW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Wdt > ; impl < 'a , REG > WdtW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Wdt :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Wdt :: Enable) } } # [doc = "Линия прерывания Timer16_0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer16_0 > for bool { # [inline (always)]
fn from (variant : Timer16_0) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_0` reader - Линия прерывания Timer16_0"]
pub type Timer16_0R = crate :: BitReader < Timer16_0 > ; impl Timer16_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_0 { match self . bits { false => Timer16_0 :: Disable , true => Timer16_0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_0 :: Enable } } # [doc = "Field `Timer16_0` writer - Линия прерывания Timer16_0"]
pub type Timer16_0W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Timer16_0 > ; impl < 'a , REG > Timer16_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_0 :: Enable) } } # [doc = "Линия прерывания Timer16_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer16_1 > for bool { # [inline (always)]
fn from (variant : Timer16_1) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_1` reader - Линия прерывания Timer16_1"]
pub type Timer16_1R = crate :: BitReader < Timer16_1 > ; impl Timer16_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_1 { match self . bits { false => Timer16_1 :: Disable , true => Timer16_1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_1 :: Enable } } # [doc = "Field `Timer16_1` writer - Линия прерывания Timer16_1"]
pub type Timer16_1W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Timer16_1 > ; impl < 'a , REG > Timer16_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_1 :: Enable) } } # [doc = "Линия прерывания Timer16_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer16_2 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer16_2 > for bool { # [inline (always)]
fn from (variant : Timer16_2) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer16_2` reader - Линия прерывания Timer16_2"]
pub type Timer16_2R = crate :: BitReader < Timer16_2 > ; impl Timer16_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer16_2 { match self . bits { false => Timer16_2 :: Disable , true => Timer16_2 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer16_2 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer16_2 :: Enable } } # [doc = "Field `Timer16_2` writer - Линия прерывания Timer16_2"]
pub type Timer16_2W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Timer16_2 > ; impl < 'a , REG > Timer16_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_2 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer16_2 :: Enable) } } # [doc = "Линия прерывания Timer32_1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer32_1 > for bool { # [inline (always)]
fn from (variant : Timer32_1) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_1` reader - Линия прерывания Timer32_1"]
pub type Timer32_1R = crate :: BitReader < Timer32_1 > ; impl Timer32_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_1 { match self . bits { false => Timer32_1 :: Disable , true => Timer32_1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_1 :: Enable } } # [doc = "Field `Timer32_1` writer - Линия прерывания Timer32_1"]
pub type Timer32_1W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Timer32_1 > ; impl < 'a , REG > Timer32_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_1 :: Enable) } } # [doc = "Линия прерывания Timer32_2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timer32_2 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Timer32_2 > for bool { # [inline (always)]
fn from (variant : Timer32_2) -> Self { variant as u8 != 0 } } # [doc = "Field `Timer32_2` reader - Линия прерывания Timer32_2"]
pub type Timer32_2R = crate :: BitReader < Timer32_2 > ; impl Timer32_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timer32_2 { match self . bits { false => Timer32_2 :: Disable , true => Timer32_2 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timer32_2 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timer32_2 :: Enable } } # [doc = "Field `Timer32_2` writer - Линия прерывания Timer32_2"]
pub type Timer32_2W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Timer32_2 > ; impl < 'a , REG > Timer32_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_2 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Timer32_2 :: Enable) } } # [doc = "Линия прерывания SPIFI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spifi { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Spifi > for bool { # [inline (always)]
fn from (variant : Spifi) -> Self { variant as u8 != 0 } } # [doc = "Field `SPIFI` reader - Линия прерывания SPIFI"]
pub type SpifiR = crate :: BitReader < Spifi > ; impl SpifiR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spifi { match self . bits { false => Spifi :: Disable , true => Spifi :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spifi :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spifi :: Enable } } # [doc = "Field `SPIFI` writer - Линия прерывания SPIFI"]
pub type SpifiW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Spifi > ; impl < 'a , REG > SpifiW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spifi :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spifi :: Enable) } } # [doc = "Линия прерывания RTC\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rtc { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Rtc > for bool { # [inline (always)]
fn from (variant : Rtc) -> Self { variant as u8 != 0 } } # [doc = "Field `RTC` reader - Линия прерывания RTC"]
pub type RtcR = crate :: BitReader < Rtc > ; impl RtcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rtc { match self . bits { false => Rtc :: Disable , true => Rtc :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Rtc :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Rtc :: Enable } } # [doc = "Field `RTC` writer - Линия прерывания RTC"]
pub type RtcW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Rtc > ; impl < 'a , REG > RtcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Rtc :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Rtc :: Enable) } } # [doc = "Линия прерывания EEPROM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Eeprom { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Eeprom > for bool { # [inline (always)]
fn from (variant : Eeprom) -> Self { variant as u8 != 0 } } # [doc = "Field `EEPROM` reader - Линия прерывания EEPROM"]
pub type EepromR = crate :: BitReader < Eeprom > ; impl EepromR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Eeprom { match self . bits { false => Eeprom :: Disable , true => Eeprom :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Eeprom :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Eeprom :: Enable } } # [doc = "Field `EEPROM` writer - Линия прерывания EEPROM"]
pub type EepromW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Eeprom > ; impl < 'a , REG > EepromW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Eeprom :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Eeprom :: Enable) } } # [doc = "Линия прерывания сторожевого таймера шины (периферийные устройства)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WdtBusDom3 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < WdtBusDom3 > for bool { # [inline (always)]
fn from (variant : WdtBusDom3) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT_BUS_DOM3` reader - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
pub type WdtBusDom3R = crate :: BitReader < WdtBusDom3 > ; impl WdtBusDom3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WdtBusDom3 { match self . bits { false => WdtBusDom3 :: Disable , true => WdtBusDom3 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WdtBusDom3 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WdtBusDom3 :: Enable } } # [doc = "Field `WDT_BUS_DOM3` writer - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
pub type WdtBusDom3W < 'a , REG > = crate :: BitWriter1C < 'a , REG , WdtBusDom3 > ; impl < 'a , REG > WdtBusDom3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusDom3 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusDom3 :: Enable) } } # [doc = "Линия прерывания сторожевого таймера шины (SPIFI)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WdtBusSpifi { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < WdtBusSpifi > for bool { # [inline (always)]
fn from (variant : WdtBusSpifi) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT_BUS_SPIFI` reader - Линия прерывания сторожевого таймера шины (SPIFI)"]
pub type WdtBusSpifiR = crate :: BitReader < WdtBusSpifi > ; impl WdtBusSpifiR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WdtBusSpifi { match self . bits { false => WdtBusSpifi :: Disable , true => WdtBusSpifi :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WdtBusSpifi :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WdtBusSpifi :: Enable } } # [doc = "Field `WDT_BUS_SPIFI` writer - Линия прерывания сторожевого таймера шины (SPIFI)"]
pub type WdtBusSpifiW < 'a , REG > = crate :: BitWriter1C < 'a , REG , WdtBusSpifi > ; impl < 'a , REG > WdtBusSpifiW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusSpifi :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusSpifi :: Enable) } } # [doc = "Линия прерывания сторожевого таймера шины (EEPROM)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WdtBusEeprom { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < WdtBusEeprom > for bool { # [inline (always)]
fn from (variant : WdtBusEeprom) -> Self { variant as u8 != 0 } } # [doc = "Field `WDT_BUS_EEPROM` reader - Линия прерывания сторожевого таймера шины (EEPROM)"]
pub type WdtBusEepromR = crate :: BitReader < WdtBusEeprom > ; impl WdtBusEepromR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WdtBusEeprom { match self . bits { false => WdtBusEeprom :: Disable , true => WdtBusEeprom :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == WdtBusEeprom :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == WdtBusEeprom :: Enable } } # [doc = "Field `WDT_BUS_EEPROM` writer - Линия прерывания сторожевого таймера шины (EEPROM)"]
pub type WdtBusEepromW < 'a , REG > = crate :: BitWriter1C < 'a , REG , WdtBusEeprom > ; impl < 'a , REG > WdtBusEepromW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusEeprom :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (WdtBusEeprom :: Enable) } } # [doc = "Линия прерывания ПДП\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dma { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Dma > for bool { # [inline (always)]
fn from (variant : Dma) -> Self { variant as u8 != 0 } } # [doc = "Field `DMA` reader - Линия прерывания ПДП"]
pub type DmaR = crate :: BitReader < Dma > ; impl DmaR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dma { match self . bits { false => Dma :: Disable , true => Dma :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dma :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dma :: Enable } } # [doc = "Field `DMA` writer - Линия прерывания ПДП"]
pub type DmaW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Dma > ; impl < 'a , REG > DmaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dma :: Enable) } } # [doc = "Линия прерывания монитора частоты\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum FrequencyMonitor { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < FrequencyMonitor > for bool { # [inline (always)]
fn from (variant : FrequencyMonitor) -> Self { variant as u8 != 0 } } # [doc = "Field `Frequency_monitor` reader - Линия прерывания монитора частоты"]
pub type FrequencyMonitorR = crate :: BitReader < FrequencyMonitor > ; impl FrequencyMonitorR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> FrequencyMonitor { match self . bits { false => FrequencyMonitor :: Disable , true => FrequencyMonitor :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == FrequencyMonitor :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == FrequencyMonitor :: Enable } } # [doc = "Field `Frequency_monitor` writer - Линия прерывания монитора частоты"]
pub type FrequencyMonitorW < 'a , REG > = crate :: BitWriter1C < 'a , REG , FrequencyMonitor > ; impl < 'a , REG > FrequencyMonitorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (FrequencyMonitor :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (FrequencyMonitor :: Enable) } } # [doc = "Линия прерывания монитора напряжения AVCC (ниже порога)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PvdAvccUnder { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < PvdAvccUnder > for bool { # [inline (always)]
fn from (variant : PvdAvccUnder) -> Self { variant as u8 != 0 } } # [doc = "Field `PVD_AVCC_under` reader - Линия прерывания монитора напряжения AVCC (ниже порога)"]
pub type PvdAvccUnderR = crate :: BitReader < PvdAvccUnder > ; impl PvdAvccUnderR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PvdAvccUnder { match self . bits { false => PvdAvccUnder :: Disable , true => PvdAvccUnder :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PvdAvccUnder :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PvdAvccUnder :: Enable } } # [doc = "Field `PVD_AVCC_under` writer - Линия прерывания монитора напряжения AVCC (ниже порога)"]
pub type PvdAvccUnderW < 'a , REG > = crate :: BitWriter1C < 'a , REG , PvdAvccUnder > ; impl < 'a , REG > PvdAvccUnderW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdAvccUnder :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdAvccUnder :: Enable) } } # [doc = "Линия прерывания монитора напряжения AVCC (выше порога)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PvdAvccOver { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < PvdAvccOver > for bool { # [inline (always)]
fn from (variant : PvdAvccOver) -> Self { variant as u8 != 0 } } # [doc = "Field `PVD_AVCC_over` reader - Линия прерывания монитора напряжения AVCC (выше порога)"]
pub type PvdAvccOverR = crate :: BitReader < PvdAvccOver > ; impl PvdAvccOverR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PvdAvccOver { match self . bits { false => PvdAvccOver :: Disable , true => PvdAvccOver :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PvdAvccOver :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PvdAvccOver :: Enable } } # [doc = "Field `PVD_AVCC_over` writer - Линия прерывания монитора напряжения AVCC (выше порога)"]
pub type PvdAvccOverW < 'a , REG > = crate :: BitWriter1C < 'a , REG , PvdAvccOver > ; impl < 'a , REG > PvdAvccOverW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdAvccOver :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdAvccOver :: Enable) } } # [doc = "Линия прерывания монитора напряжения VCC (ниже порога)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PvdVccUnder { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < PvdVccUnder > for bool { # [inline (always)]
fn from (variant : PvdVccUnder) -> Self { variant as u8 != 0 } } # [doc = "Field `PVD_VCC_under` reader - Линия прерывания монитора напряжения VCC (ниже порога)"]
pub type PvdVccUnderR = crate :: BitReader < PvdVccUnder > ; impl PvdVccUnderR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PvdVccUnder { match self . bits { false => PvdVccUnder :: Disable , true => PvdVccUnder :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PvdVccUnder :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PvdVccUnder :: Enable } } # [doc = "Field `PVD_VCC_under` writer - Линия прерывания монитора напряжения VCC (ниже порога)"]
pub type PvdVccUnderW < 'a , REG > = crate :: BitWriter1C < 'a , REG , PvdVccUnder > ; impl < 'a , REG > PvdVccUnderW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdVccUnder :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdVccUnder :: Enable) } } # [doc = "Линия прерывания монитора напряжения VCC (выше порога)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PvdVccOver { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < PvdVccOver > for bool { # [inline (always)]
fn from (variant : PvdVccOver) -> Self { variant as u8 != 0 } } # [doc = "Field `PVD_VCC_over` reader - Линия прерывания монитора напряжения VCC (выше порога)"]
pub type PvdVccOverR = crate :: BitReader < PvdVccOver > ; impl PvdVccOverR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PvdVccOver { match self . bits { false => PvdVccOver :: Disable , true => PvdVccOver :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PvdVccOver :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PvdVccOver :: Enable } } # [doc = "Field `PVD_VCC_over` writer - Линия прерывания монитора напряжения VCC (выше порога)"]
pub type PvdVccOverW < 'a , REG > = crate :: BitWriter1C < 'a , REG , PvdVccOver > ; impl < 'a , REG > PvdVccOverW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdVccOver :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PvdVccOver :: Enable) } } # [doc = "Линия прерывания недостаточного напряжения батареи\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum BatteryNonGood { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < BatteryNonGood > for bool { # [inline (always)]
fn from (variant : BatteryNonGood) -> Self { variant as u8 != 0 } } # [doc = "Field `BATTERY_NON_GOOD` reader - Линия прерывания недостаточного напряжения батареи"]
pub type BatteryNonGoodR = crate :: BitReader < BatteryNonGood > ; impl BatteryNonGoodR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> BatteryNonGood { match self . bits { false => BatteryNonGood :: Disable , true => BatteryNonGood :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == BatteryNonGood :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == BatteryNonGood :: Enable } } # [doc = "Field `BATTERY_NON_GOOD` writer - Линия прерывания недостаточного напряжения батареи"]
pub type BatteryNonGoodW < 'a , REG > = crate :: BitWriter1C < 'a , REG , BatteryNonGood > ; impl < 'a , REG > BatteryNonGoodW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (BatteryNonGood :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (BatteryNonGood :: Enable) } } # [doc = "Линия прерывания BrouwnOut детектора\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Bor { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Bor > for bool { # [inline (always)]
fn from (variant : Bor) -> Self { variant as u8 != 0 } } # [doc = "Field `BOR` reader - Линия прерывания BrouwnOut детектора"]
pub type BorR = crate :: BitReader < Bor > ; impl BorR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Bor { match self . bits { false => Bor :: Disable , true => Bor :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Bor :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Bor :: Enable } } # [doc = "Field `BOR` writer - Линия прерывания BrouwnOut детектора"]
pub type BorW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Bor > ; impl < 'a , REG > BorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Bor :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Bor :: Enable) } } # [doc = "Линия прерывания монитора температуры\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Tsens { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Tsens > for bool { # [inline (always)]
fn from (variant : Tsens) -> Self { variant as u8 != 0 } } # [doc = "Field `TSENS` reader - Линия прерывания монитора температуры"]
pub type TsensR = crate :: BitReader < Tsens > ; impl TsensR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Tsens { match self . bits { false => Tsens :: Disable , true => Tsens :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Tsens :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Tsens :: Enable } } # [doc = "Field `TSENS` writer - Линия прерывания монитора температуры"]
pub type TsensW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Tsens > ; impl < 'a , REG > TsensW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Tsens :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Tsens :: Enable) } } # [doc = "Линия прерывания АЦП\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Adc { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Adc > for bool { # [inline (always)]
fn from (variant : Adc) -> Self { variant as u8 != 0 } } # [doc = "Field `ADC` reader - Линия прерывания АЦП"]
pub type AdcR = crate :: BitReader < Adc > ; impl AdcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Adc { match self . bits { false => Adc :: Disable , true => Adc :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Adc :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Adc :: Enable } } # [doc = "Field `ADC` writer - Линия прерывания АЦП"]
pub type AdcW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Adc > ; impl < 'a , REG > AdcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Adc :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Adc :: Enable) } } # [doc = "Линия прерывания ЦАП0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dac0 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Dac0 > for bool { # [inline (always)]
fn from (variant : Dac0) -> Self { variant as u8 != 0 } } # [doc = "Field `DAC0` reader - Линия прерывания ЦАП0"]
pub type Dac0R = crate :: BitReader < Dac0 > ; impl Dac0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dac0 { match self . bits { false => Dac0 :: Disable , true => Dac0 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dac0 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dac0 :: Enable } } # [doc = "Field `DAC0` writer - Линия прерывания ЦАП0"]
pub type Dac0W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Dac0 > ; impl < 'a , REG > Dac0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dac0 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dac0 :: Enable) } } # [doc = "Линия прерывания ЦАП1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dac1 { # [doc = "0: Прерывание по фронту запрешено"]
Disable = 0 , # [doc = "1: Прерывание по фронту разрешено"]
Enable = 1 , } impl From < Dac1 > for bool { # [inline (always)]
fn from (variant : Dac1) -> Self { variant as u8 != 0 } } # [doc = "Field `DAC1` reader - Линия прерывания ЦАП1"]
pub type Dac1R = crate :: BitReader < Dac1 > ; impl Dac1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dac1 { match self . bits { false => Dac1 :: Disable , true => Dac1 :: Enable , } } # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dac1 :: Disable } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dac1 :: Enable } } # [doc = "Field `DAC1` writer - Линия прерывания ЦАП1"]
pub type Dac1W < 'a , REG > = crate :: BitWriter1C < 'a , REG , Dac1 > ; impl < 'a , REG > Dac1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по фронту запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dac1 :: Disable) } # [doc = "Прерывание по фронту разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dac1 :: Enable) } } impl R { # [doc = "Bit 0 - Линия прерывания Timer32_0"]
# [inline (always)]
pub fn timer32_0 (& self) -> Timer32_0R { Timer32_0R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Линия прерывания USART_0"]
# [inline (always)]
pub fn usart_0 (& self) -> Usart0R { Usart0R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Линия прерывания USART_1"]
# [inline (always)]
pub fn usart_1 (& self) -> Usart1R { Usart1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Линия прерывания SPI_0"]
# [inline (always)]
pub fn spi_0 (& self) -> Spi0R { Spi0R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Линия прерывания SPI_1"]
# [inline (always)]
pub fn spi_1 (& self) -> Spi1R { Spi1R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Линия прерывания GPIO"]
# [inline (always)]
pub fn gpio (& self) -> GpioR { GpioR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Линия прерывания I2C_0"]
# [inline (always)]
pub fn i2c_0 (& self) -> I2c0R { I2c0R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Линия прерывания I2C_1"]
# [inline (always)]
pub fn i2c_1 (& self) -> I2c1R { I2c1R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Линия прерывания сторожевого таймера (WDT)"]
# [inline (always)]
pub fn wdt (& self) -> WdtR { WdtR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Линия прерывания Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& self) -> Timer16_0R { Timer16_0R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Линия прерывания Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& self) -> Timer16_1R { Timer16_1R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Линия прерывания Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& self) -> Timer16_2R { Timer16_2R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Линия прерывания Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& self) -> Timer32_1R { Timer32_1R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Линия прерывания Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& self) -> Timer32_2R { Timer32_2R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Линия прерывания SPIFI"]
# [inline (always)]
pub fn spifi (& self) -> SpifiR { SpifiR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Линия прерывания RTC"]
# [inline (always)]
pub fn rtc (& self) -> RtcR { RtcR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Линия прерывания EEPROM"]
# [inline (always)]
pub fn eeprom (& self) -> EepromR { EepromR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
# [inline (always)]
pub fn wdt_bus_dom3 (& self) -> WdtBusDom3R { WdtBusDom3R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Линия прерывания сторожевого таймера шины (SPIFI)"]
# [inline (always)]
pub fn wdt_bus_spifi (& self) -> WdtBusSpifiR { WdtBusSpifiR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Линия прерывания сторожевого таймера шины (EEPROM)"]
# [inline (always)]
pub fn wdt_bus_eeprom (& self) -> WdtBusEepromR { WdtBusEepromR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Линия прерывания ПДП"]
# [inline (always)]
pub fn dma (& self) -> DmaR { DmaR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Линия прерывания монитора частоты"]
# [inline (always)]
pub fn frequency_monitor (& self) -> FrequencyMonitorR { FrequencyMonitorR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Линия прерывания монитора напряжения AVCC (ниже порога)"]
# [inline (always)]
pub fn pvd_avcc_under (& self) -> PvdAvccUnderR { PvdAvccUnderR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Линия прерывания монитора напряжения AVCC (выше порога)"]
# [inline (always)]
pub fn pvd_avcc_over (& self) -> PvdAvccOverR { PvdAvccOverR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 24 - Линия прерывания монитора напряжения VCC (ниже порога)"]
# [inline (always)]
pub fn pvd_vcc_under (& self) -> PvdVccUnderR { PvdVccUnderR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Линия прерывания монитора напряжения VCC (выше порога)"]
# [inline (always)]
pub fn pvd_vcc_over (& self) -> PvdVccOverR { PvdVccOverR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Линия прерывания недостаточного напряжения батареи"]
# [inline (always)]
pub fn battery_non_good (& self) -> BatteryNonGoodR { BatteryNonGoodR :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Линия прерывания BrouwnOut детектора"]
# [inline (always)]
pub fn bor (& self) -> BorR { BorR :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 28 - Линия прерывания монитора температуры"]
# [inline (always)]
pub fn tsens (& self) -> TsensR { TsensR :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Линия прерывания АЦП"]
# [inline (always)]
pub fn adc (& self) -> AdcR { AdcR :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Линия прерывания ЦАП0"]
# [inline (always)]
pub fn dac0 (& self) -> Dac0R { Dac0R :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - Линия прерывания ЦАП1"]
# [inline (always)]
pub fn dac1 (& self) -> Dac1R { Dac1R :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bit 0 - Линия прерывания Timer32_0"]
# [inline (always)]
pub fn timer32_0 (& mut self) -> Timer32_0W < MaskEdgeClearSpec > { Timer32_0W :: new (self , 0) } # [doc = "Bit 1 - Линия прерывания USART_0"]
# [inline (always)]
pub fn usart_0 (& mut self) -> Usart0W < MaskEdgeClearSpec > { Usart0W :: new (self , 1) } # [doc = "Bit 2 - Линия прерывания USART_1"]
# [inline (always)]
pub fn usart_1 (& mut self) -> Usart1W < MaskEdgeClearSpec > { Usart1W :: new (self , 2) } # [doc = "Bit 3 - Линия прерывания SPI_0"]
# [inline (always)]
pub fn spi_0 (& mut self) -> Spi0W < MaskEdgeClearSpec > { Spi0W :: new (self , 3) } # [doc = "Bit 4 - Линия прерывания SPI_1"]
# [inline (always)]
pub fn spi_1 (& mut self) -> Spi1W < MaskEdgeClearSpec > { Spi1W :: new (self , 4) } # [doc = "Bit 5 - Линия прерывания GPIO"]
# [inline (always)]
pub fn gpio (& mut self) -> GpioW < MaskEdgeClearSpec > { GpioW :: new (self , 5) } # [doc = "Bit 6 - Линия прерывания I2C_0"]
# [inline (always)]
pub fn i2c_0 (& mut self) -> I2c0W < MaskEdgeClearSpec > { I2c0W :: new (self , 6) } # [doc = "Bit 7 - Линия прерывания I2C_1"]
# [inline (always)]
pub fn i2c_1 (& mut self) -> I2c1W < MaskEdgeClearSpec > { I2c1W :: new (self , 7) } # [doc = "Bit 8 - Линия прерывания сторожевого таймера (WDT)"]
# [inline (always)]
pub fn wdt (& mut self) -> WdtW < MaskEdgeClearSpec > { WdtW :: new (self , 8) } # [doc = "Bit 9 - Линия прерывания Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& mut self) -> Timer16_0W < MaskEdgeClearSpec > { Timer16_0W :: new (self , 9) } # [doc = "Bit 10 - Линия прерывания Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& mut self) -> Timer16_1W < MaskEdgeClearSpec > { Timer16_1W :: new (self , 10) } # [doc = "Bit 11 - Линия прерывания Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& mut self) -> Timer16_2W < MaskEdgeClearSpec > { Timer16_2W :: new (self , 11) } # [doc = "Bit 12 - Линия прерывания Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& mut self) -> Timer32_1W < MaskEdgeClearSpec > { Timer32_1W :: new (self , 12) } # [doc = "Bit 13 - Линия прерывания Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& mut self) -> Timer32_2W < MaskEdgeClearSpec > { Timer32_2W :: new (self , 13) } # [doc = "Bit 14 - Линия прерывания SPIFI"]
# [inline (always)]
pub fn spifi (& mut self) -> SpifiW < MaskEdgeClearSpec > { SpifiW :: new (self , 14) } # [doc = "Bit 15 - Линия прерывания RTC"]
# [inline (always)]
pub fn rtc (& mut self) -> RtcW < MaskEdgeClearSpec > { RtcW :: new (self , 15) } # [doc = "Bit 16 - Линия прерывания EEPROM"]
# [inline (always)]
pub fn eeprom (& mut self) -> EepromW < MaskEdgeClearSpec > { EepromW :: new (self , 16) } # [doc = "Bit 17 - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
# [inline (always)]
pub fn wdt_bus_dom3 (& mut self) -> WdtBusDom3W < MaskEdgeClearSpec > { WdtBusDom3W :: new (self , 17) } # [doc = "Bit 18 - Линия прерывания сторожевого таймера шины (SPIFI)"]
# [inline (always)]
pub fn wdt_bus_spifi (& mut self) -> WdtBusSpifiW < MaskEdgeClearSpec > { WdtBusSpifiW :: new (self , 18) } # [doc = "Bit 19 - Линия прерывания сторожевого таймера шины (EEPROM)"]
# [inline (always)]
pub fn wdt_bus_eeprom (& mut self) -> WdtBusEepromW < MaskEdgeClearSpec > { WdtBusEepromW :: new (self , 19) } # [doc = "Bit 20 - Линия прерывания ПДП"]
# [inline (always)]
pub fn dma (& mut self) -> DmaW < MaskEdgeClearSpec > { DmaW :: new (self , 20) } # [doc = "Bit 21 - Линия прерывания монитора частоты"]
# [inline (always)]
pub fn frequency_monitor (& mut self) -> FrequencyMonitorW < MaskEdgeClearSpec > { FrequencyMonitorW :: new (self , 21) } # [doc = "Bit 22 - Линия прерывания монитора напряжения AVCC (ниже порога)"]
# [inline (always)]
pub fn pvd_avcc_under (& mut self) -> PvdAvccUnderW < MaskEdgeClearSpec > { PvdAvccUnderW :: new (self , 22) } # [doc = "Bit 23 - Линия прерывания монитора напряжения AVCC (выше порога)"]
# [inline (always)]
pub fn pvd_avcc_over (& mut self) -> PvdAvccOverW < MaskEdgeClearSpec > { PvdAvccOverW :: new (self , 23) } # [doc = "Bit 24 - Линия прерывания монитора напряжения VCC (ниже порога)"]
# [inline (always)]
pub fn pvd_vcc_under (& mut self) -> PvdVccUnderW < MaskEdgeClearSpec > { PvdVccUnderW :: new (self , 24) } # [doc = "Bit 25 - Линия прерывания монитора напряжения VCC (выше порога)"]
# [inline (always)]
pub fn pvd_vcc_over (& mut self) -> PvdVccOverW < MaskEdgeClearSpec > { PvdVccOverW :: new (self , 25) } # [doc = "Bit 26 - Линия прерывания недостаточного напряжения батареи"]
# [inline (always)]
pub fn battery_non_good (& mut self) -> BatteryNonGoodW < MaskEdgeClearSpec > { BatteryNonGoodW :: new (self , 26) } # [doc = "Bit 27 - Линия прерывания BrouwnOut детектора"]
# [inline (always)]
pub fn bor (& mut self) -> BorW < MaskEdgeClearSpec > { BorW :: new (self , 27) } # [doc = "Bit 28 - Линия прерывания монитора температуры"]
# [inline (always)]
pub fn tsens (& mut self) -> TsensW < MaskEdgeClearSpec > { TsensW :: new (self , 28) } # [doc = "Bit 29 - Линия прерывания АЦП"]
# [inline (always)]
pub fn adc (& mut self) -> AdcW < MaskEdgeClearSpec > { AdcW :: new (self , 29) } # [doc = "Bit 30 - Линия прерывания ЦАП0"]
# [inline (always)]
pub fn dac0 (& mut self) -> Dac0W < MaskEdgeClearSpec > { Dac0W :: new (self , 30) } # [doc = "Bit 31 - Линия прерывания ЦАП1"]
# [inline (always)]
pub fn dac1 (& mut self) -> Dac1W < MaskEdgeClearSpec > { Dac1W :: new (self , 31) } } # [doc = "Установка маски прерываний по фронту\n\nYou can [`read`](crate::Reg::read) this register and get [`mask_edge_clear::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mask_edge_clear::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MaskEdgeClearSpec ; impl crate :: RegisterSpec for MaskEdgeClearSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mask_edge_clear::R`](R) reader structure"]
impl crate :: Readable for MaskEdgeClearSpec { } # [doc = "`write(|w| ..)` method takes [`mask_edge_clear::W`](W) writer structure"]
impl crate :: Writable for MaskEdgeClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0xffff_ffff ; } # [doc = "`reset()` method sets MASK_EDGE_CLEAR to value 0"]
impl crate :: Resettable for MaskEdgeClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MASK_LEVEL_SET (w) register accessor: Установка маски прерываний по уровню\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mask_level_set::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mask_level_set`]
module"]
# [doc (alias = "MASK_LEVEL_SET")]
pub type MaskLevelSet = crate :: Reg < mask_level_set :: MaskLevelSetSpec > ; # [doc = "Установка маски прерываний по уровню"]
pub mod mask_level_set { # [doc = "Register `MASK_LEVEL_SET` writer"]
pub type W = crate :: W < MaskLevelSetSpec > ; # [doc = "Field `Timer32_0` writer - Линия прерывания Timer32_0"]
pub type Timer32_0W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `USART_0` writer - Линия прерывания USART_0"]
pub type Usart0W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `USART_1` writer - Линия прерывания USART_1"]
pub type Usart1W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `SPI_0` writer - Линия прерывания SPI_0"]
pub type Spi0W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `SPI_1` writer - Линия прерывания SPI_1"]
pub type Spi1W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `GPIO` writer - Линия прерывания GPIO"]
pub type GpioW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `I2C_0` writer - Линия прерывания I2C_0"]
pub type I2c0W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `I2C_1` writer - Линия прерывания I2C_1"]
pub type I2c1W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `WDT` writer - Линия прерывания сторожевого таймера (WDT)"]
pub type WdtW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `Timer16_0` writer - Линия прерывания Timer16_0"]
pub type Timer16_0W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `Timer16_1` writer - Линия прерывания Timer16_1"]
pub type Timer16_1W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `Timer16_2` writer - Линия прерывания Timer16_2"]
pub type Timer16_2W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `Timer32_1` writer - Линия прерывания Timer32_1"]
pub type Timer32_1W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `Timer32_2` writer - Линия прерывания Timer32_2"]
pub type Timer32_2W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `SPIFI` writer - Линия прерывания SPIFI"]
pub type SpifiW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `RTC` writer - Линия прерывания RTC"]
pub type RtcW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `EEPROM` writer - Линия прерывания EEPROM"]
pub type EepromW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `WDT_BUS_DOM3` writer - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
pub type WdtBusDom3W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `WDT_BUS_SPIFI` writer - Линия прерывания сторожевого таймера шины (SPIFI)"]
pub type WdtBusSpifiW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `WDT_BUS_EEPROM` writer - Линия прерывания сторожевого таймера шины (EEPROM)"]
pub type WdtBusEepromW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `DMA` writer - Линия прерывания ПДП"]
pub type DmaW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `Frequency_monitor` writer - Линия прерывания монитора частоты"]
pub type FrequencyMonitorW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `PVD_AVCC_under` writer - Линия прерывания монитора напряжения AVCC (ниже порога)"]
pub type PvdAvccUnderW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `PVD_AVCC_over` writer - Линия прерывания монитора напряжения AVCC (выше порога)"]
pub type PvdAvccOverW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `PVD_VCC_under` writer - Линия прерывания монитора напряжения VCC (ниже порога)"]
pub type PvdVccUnderW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `PVD_VCC_over` writer - Линия прерывания монитора напряжения VCC (выше порога)"]
pub type PvdVccOverW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `BATTERY_NON_GOOD` writer - Линия прерывания недостаточного напряжения батареи"]
pub type BatteryNonGoodW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `BOR` writer - Линия прерывания BrouwnOut детектора"]
pub type BorW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `TSENS` writer - Линия прерывания монитора температуры"]
pub type TsensW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `ADC` writer - Линия прерывания АЦП"]
pub type AdcW < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `DAC0` writer - Линия прерывания ЦАП0"]
pub type Dac0W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; # [doc = "Field `DAC1` writer - Линия прерывания ЦАП1"]
pub type Dac1W < 'a , REG > = crate :: BitWriter1S < 'a , REG > ; impl W { # [doc = "Bit 0 - Линия прерывания Timer32_0"]
# [inline (always)]
pub fn timer32_0 (& mut self) -> Timer32_0W < MaskLevelSetSpec > { Timer32_0W :: new (self , 0) } # [doc = "Bit 1 - Линия прерывания USART_0"]
# [inline (always)]
pub fn usart_0 (& mut self) -> Usart0W < MaskLevelSetSpec > { Usart0W :: new (self , 1) } # [doc = "Bit 2 - Линия прерывания USART_1"]
# [inline (always)]
pub fn usart_1 (& mut self) -> Usart1W < MaskLevelSetSpec > { Usart1W :: new (self , 2) } # [doc = "Bit 3 - Линия прерывания SPI_0"]
# [inline (always)]
pub fn spi_0 (& mut self) -> Spi0W < MaskLevelSetSpec > { Spi0W :: new (self , 3) } # [doc = "Bit 4 - Линия прерывания SPI_1"]
# [inline (always)]
pub fn spi_1 (& mut self) -> Spi1W < MaskLevelSetSpec > { Spi1W :: new (self , 4) } # [doc = "Bit 5 - Линия прерывания GPIO"]
# [inline (always)]
pub fn gpio (& mut self) -> GpioW < MaskLevelSetSpec > { GpioW :: new (self , 5) } # [doc = "Bit 6 - Линия прерывания I2C_0"]
# [inline (always)]
pub fn i2c_0 (& mut self) -> I2c0W < MaskLevelSetSpec > { I2c0W :: new (self , 6) } # [doc = "Bit 7 - Линия прерывания I2C_1"]
# [inline (always)]
pub fn i2c_1 (& mut self) -> I2c1W < MaskLevelSetSpec > { I2c1W :: new (self , 7) } # [doc = "Bit 8 - Линия прерывания сторожевого таймера (WDT)"]
# [inline (always)]
pub fn wdt (& mut self) -> WdtW < MaskLevelSetSpec > { WdtW :: new (self , 8) } # [doc = "Bit 9 - Линия прерывания Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& mut self) -> Timer16_0W < MaskLevelSetSpec > { Timer16_0W :: new (self , 9) } # [doc = "Bit 10 - Линия прерывания Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& mut self) -> Timer16_1W < MaskLevelSetSpec > { Timer16_1W :: new (self , 10) } # [doc = "Bit 11 - Линия прерывания Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& mut self) -> Timer16_2W < MaskLevelSetSpec > { Timer16_2W :: new (self , 11) } # [doc = "Bit 12 - Линия прерывания Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& mut self) -> Timer32_1W < MaskLevelSetSpec > { Timer32_1W :: new (self , 12) } # [doc = "Bit 13 - Линия прерывания Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& mut self) -> Timer32_2W < MaskLevelSetSpec > { Timer32_2W :: new (self , 13) } # [doc = "Bit 14 - Линия прерывания SPIFI"]
# [inline (always)]
pub fn spifi (& mut self) -> SpifiW < MaskLevelSetSpec > { SpifiW :: new (self , 14) } # [doc = "Bit 15 - Линия прерывания RTC"]
# [inline (always)]
pub fn rtc (& mut self) -> RtcW < MaskLevelSetSpec > { RtcW :: new (self , 15) } # [doc = "Bit 16 - Линия прерывания EEPROM"]
# [inline (always)]
pub fn eeprom (& mut self) -> EepromW < MaskLevelSetSpec > { EepromW :: new (self , 16) } # [doc = "Bit 17 - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
# [inline (always)]
pub fn wdt_bus_dom3 (& mut self) -> WdtBusDom3W < MaskLevelSetSpec > { WdtBusDom3W :: new (self , 17) } # [doc = "Bit 18 - Линия прерывания сторожевого таймера шины (SPIFI)"]
# [inline (always)]
pub fn wdt_bus_spifi (& mut self) -> WdtBusSpifiW < MaskLevelSetSpec > { WdtBusSpifiW :: new (self , 18) } # [doc = "Bit 19 - Линия прерывания сторожевого таймера шины (EEPROM)"]
# [inline (always)]
pub fn wdt_bus_eeprom (& mut self) -> WdtBusEepromW < MaskLevelSetSpec > { WdtBusEepromW :: new (self , 19) } # [doc = "Bit 20 - Линия прерывания ПДП"]
# [inline (always)]
pub fn dma (& mut self) -> DmaW < MaskLevelSetSpec > { DmaW :: new (self , 20) } # [doc = "Bit 21 - Линия прерывания монитора частоты"]
# [inline (always)]
pub fn frequency_monitor (& mut self) -> FrequencyMonitorW < MaskLevelSetSpec > { FrequencyMonitorW :: new (self , 21) } # [doc = "Bit 22 - Линия прерывания монитора напряжения AVCC (ниже порога)"]
# [inline (always)]
pub fn pvd_avcc_under (& mut self) -> PvdAvccUnderW < MaskLevelSetSpec > { PvdAvccUnderW :: new (self , 22) } # [doc = "Bit 23 - Линия прерывания монитора напряжения AVCC (выше порога)"]
# [inline (always)]
pub fn pvd_avcc_over (& mut self) -> PvdAvccOverW < MaskLevelSetSpec > { PvdAvccOverW :: new (self , 23) } # [doc = "Bit 24 - Линия прерывания монитора напряжения VCC (ниже порога)"]
# [inline (always)]
pub fn pvd_vcc_under (& mut self) -> PvdVccUnderW < MaskLevelSetSpec > { PvdVccUnderW :: new (self , 24) } # [doc = "Bit 25 - Линия прерывания монитора напряжения VCC (выше порога)"]
# [inline (always)]
pub fn pvd_vcc_over (& mut self) -> PvdVccOverW < MaskLevelSetSpec > { PvdVccOverW :: new (self , 25) } # [doc = "Bit 26 - Линия прерывания недостаточного напряжения батареи"]
# [inline (always)]
pub fn battery_non_good (& mut self) -> BatteryNonGoodW < MaskLevelSetSpec > { BatteryNonGoodW :: new (self , 26) } # [doc = "Bit 27 - Линия прерывания BrouwnOut детектора"]
# [inline (always)]
pub fn bor (& mut self) -> BorW < MaskLevelSetSpec > { BorW :: new (self , 27) } # [doc = "Bit 28 - Линия прерывания монитора температуры"]
# [inline (always)]
pub fn tsens (& mut self) -> TsensW < MaskLevelSetSpec > { TsensW :: new (self , 28) } # [doc = "Bit 29 - Линия прерывания АЦП"]
# [inline (always)]
pub fn adc (& mut self) -> AdcW < MaskLevelSetSpec > { AdcW :: new (self , 29) } # [doc = "Bit 30 - Линия прерывания ЦАП0"]
# [inline (always)]
pub fn dac0 (& mut self) -> Dac0W < MaskLevelSetSpec > { Dac0W :: new (self , 30) } # [doc = "Bit 31 - Линия прерывания ЦАП1"]
# [inline (always)]
pub fn dac1 (& mut self) -> Dac1W < MaskLevelSetSpec > { Dac1W :: new (self , 31) } } # [doc = "Установка маски прерываний по уровню\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mask_level_set::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MaskLevelSetSpec ; impl crate :: RegisterSpec for MaskLevelSetSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`mask_level_set::W`](W) writer structure"]
impl crate :: Writable for MaskLevelSetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0xffff_ffff ; } # [doc = "`reset()` method sets MASK_LEVEL_SET to value 0"]
impl crate :: Resettable for MaskLevelSetSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MASK_LEVEL_CLEAR (w) register accessor: Сброс маски прерываний по уровню\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mask_level_clear::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mask_level_clear`]
module"]
# [doc (alias = "MASK_LEVEL_CLEAR")]
pub type MaskLevelClear = crate :: Reg < mask_level_clear :: MaskLevelClearSpec > ; # [doc = "Сброс маски прерываний по уровню"]
pub mod mask_level_clear { # [doc = "Register `MASK_LEVEL_CLEAR` writer"]
pub type W = crate :: W < MaskLevelClearSpec > ; # [doc = "Field `Timer32_0` writer - Линия прерывания Timer32_0"]
pub type Timer32_0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `USART_0` writer - Линия прерывания USART_0"]
pub type Usart0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `USART_1` writer - Линия прерывания USART_1"]
pub type Usart1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `SPI_0` writer - Линия прерывания SPI_0"]
pub type Spi0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `SPI_1` writer - Линия прерывания SPI_1"]
pub type Spi1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `GPIO` writer - Линия прерывания GPIO"]
pub type GpioW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `I2C_0` writer - Линия прерывания I2C_0"]
pub type I2c0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `I2C_1` writer - Линия прерывания I2C_1"]
pub type I2c1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `WDT` writer - Линия прерывания сторожевого таймера (WDT)"]
pub type WdtW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Timer16_0` writer - Линия прерывания Timer16_0"]
pub type Timer16_0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Timer16_1` writer - Линия прерывания Timer16_1"]
pub type Timer16_1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Timer16_2` writer - Линия прерывания Timer16_2"]
pub type Timer16_2W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Timer32_1` writer - Линия прерывания Timer32_1"]
pub type Timer32_1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Timer32_2` writer - Линия прерывания Timer32_2"]
pub type Timer32_2W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `SPIFI` writer - Линия прерывания SPIFI"]
pub type SpifiW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `RTC` writer - Линия прерывания RTC"]
pub type RtcW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `EEPROM` writer - Линия прерывания EEPROM"]
pub type EepromW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `WDT_BUS_DOM3` writer - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
pub type WdtBusDom3W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `WDT_BUS_SPIFI` writer - Линия прерывания сторожевого таймера шины (SPIFI)"]
pub type WdtBusSpifiW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `WDT_BUS_EEPROM` writer - Линия прерывания сторожевого таймера шины (EEPROM)"]
pub type WdtBusEepromW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `DMA` writer - Линия прерывания ПДП"]
pub type DmaW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Frequency_monitor` writer - Линия прерывания монитора частоты"]
pub type FrequencyMonitorW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `PVD_AVCC_under` writer - Линия прерывания монитора напряжения AVCC (ниже порога)"]
pub type PvdAvccUnderW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `PVD_AVCC_over` writer - Линия прерывания монитора напряжения AVCC (выше порога)"]
pub type PvdAvccOverW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `PVD_VCC_under` writer - Линия прерывания монитора напряжения VCC (ниже порога)"]
pub type PvdVccUnderW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `PVD_VCC_over` writer - Линия прерывания монитора напряжения VCC (выше порога)"]
pub type PvdVccOverW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `BATTERY_NON_GOOD` writer - Линия прерывания недостаточного напряжения батареи"]
pub type BatteryNonGoodW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `BOR` writer - Линия прерывания BrouwnOut детектора"]
pub type BorW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `TSENS` writer - Линия прерывания монитора температуры"]
pub type TsensW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `ADC` writer - Линия прерывания АЦП"]
pub type AdcW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `DAC0` writer - Линия прерывания ЦАП0"]
pub type Dac0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `DAC1` writer - Линия прерывания ЦАП1"]
pub type Dac1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; impl W { # [doc = "Bit 0 - Линия прерывания Timer32_0"]
# [inline (always)]
pub fn timer32_0 (& mut self) -> Timer32_0W < MaskLevelClearSpec > { Timer32_0W :: new (self , 0) } # [doc = "Bit 1 - Линия прерывания USART_0"]
# [inline (always)]
pub fn usart_0 (& mut self) -> Usart0W < MaskLevelClearSpec > { Usart0W :: new (self , 1) } # [doc = "Bit 2 - Линия прерывания USART_1"]
# [inline (always)]
pub fn usart_1 (& mut self) -> Usart1W < MaskLevelClearSpec > { Usart1W :: new (self , 2) } # [doc = "Bit 3 - Линия прерывания SPI_0"]
# [inline (always)]
pub fn spi_0 (& mut self) -> Spi0W < MaskLevelClearSpec > { Spi0W :: new (self , 3) } # [doc = "Bit 4 - Линия прерывания SPI_1"]
# [inline (always)]
pub fn spi_1 (& mut self) -> Spi1W < MaskLevelClearSpec > { Spi1W :: new (self , 4) } # [doc = "Bit 5 - Линия прерывания GPIO"]
# [inline (always)]
pub fn gpio (& mut self) -> GpioW < MaskLevelClearSpec > { GpioW :: new (self , 5) } # [doc = "Bit 6 - Линия прерывания I2C_0"]
# [inline (always)]
pub fn i2c_0 (& mut self) -> I2c0W < MaskLevelClearSpec > { I2c0W :: new (self , 6) } # [doc = "Bit 7 - Линия прерывания I2C_1"]
# [inline (always)]
pub fn i2c_1 (& mut self) -> I2c1W < MaskLevelClearSpec > { I2c1W :: new (self , 7) } # [doc = "Bit 8 - Линия прерывания сторожевого таймера (WDT)"]
# [inline (always)]
pub fn wdt (& mut self) -> WdtW < MaskLevelClearSpec > { WdtW :: new (self , 8) } # [doc = "Bit 9 - Линия прерывания Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& mut self) -> Timer16_0W < MaskLevelClearSpec > { Timer16_0W :: new (self , 9) } # [doc = "Bit 10 - Линия прерывания Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& mut self) -> Timer16_1W < MaskLevelClearSpec > { Timer16_1W :: new (self , 10) } # [doc = "Bit 11 - Линия прерывания Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& mut self) -> Timer16_2W < MaskLevelClearSpec > { Timer16_2W :: new (self , 11) } # [doc = "Bit 12 - Линия прерывания Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& mut self) -> Timer32_1W < MaskLevelClearSpec > { Timer32_1W :: new (self , 12) } # [doc = "Bit 13 - Линия прерывания Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& mut self) -> Timer32_2W < MaskLevelClearSpec > { Timer32_2W :: new (self , 13) } # [doc = "Bit 14 - Линия прерывания SPIFI"]
# [inline (always)]
pub fn spifi (& mut self) -> SpifiW < MaskLevelClearSpec > { SpifiW :: new (self , 14) } # [doc = "Bit 15 - Линия прерывания RTC"]
# [inline (always)]
pub fn rtc (& mut self) -> RtcW < MaskLevelClearSpec > { RtcW :: new (self , 15) } # [doc = "Bit 16 - Линия прерывания EEPROM"]
# [inline (always)]
pub fn eeprom (& mut self) -> EepromW < MaskLevelClearSpec > { EepromW :: new (self , 16) } # [doc = "Bit 17 - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
# [inline (always)]
pub fn wdt_bus_dom3 (& mut self) -> WdtBusDom3W < MaskLevelClearSpec > { WdtBusDom3W :: new (self , 17) } # [doc = "Bit 18 - Линия прерывания сторожевого таймера шины (SPIFI)"]
# [inline (always)]
pub fn wdt_bus_spifi (& mut self) -> WdtBusSpifiW < MaskLevelClearSpec > { WdtBusSpifiW :: new (self , 18) } # [doc = "Bit 19 - Линия прерывания сторожевого таймера шины (EEPROM)"]
# [inline (always)]
pub fn wdt_bus_eeprom (& mut self) -> WdtBusEepromW < MaskLevelClearSpec > { WdtBusEepromW :: new (self , 19) } # [doc = "Bit 20 - Линия прерывания ПДП"]
# [inline (always)]
pub fn dma (& mut self) -> DmaW < MaskLevelClearSpec > { DmaW :: new (self , 20) } # [doc = "Bit 21 - Линия прерывания монитора частоты"]
# [inline (always)]
pub fn frequency_monitor (& mut self) -> FrequencyMonitorW < MaskLevelClearSpec > { FrequencyMonitorW :: new (self , 21) } # [doc = "Bit 22 - Линия прерывания монитора напряжения AVCC (ниже порога)"]
# [inline (always)]
pub fn pvd_avcc_under (& mut self) -> PvdAvccUnderW < MaskLevelClearSpec > { PvdAvccUnderW :: new (self , 22) } # [doc = "Bit 23 - Линия прерывания монитора напряжения AVCC (выше порога)"]
# [inline (always)]
pub fn pvd_avcc_over (& mut self) -> PvdAvccOverW < MaskLevelClearSpec > { PvdAvccOverW :: new (self , 23) } # [doc = "Bit 24 - Линия прерывания монитора напряжения VCC (ниже порога)"]
# [inline (always)]
pub fn pvd_vcc_under (& mut self) -> PvdVccUnderW < MaskLevelClearSpec > { PvdVccUnderW :: new (self , 24) } # [doc = "Bit 25 - Линия прерывания монитора напряжения VCC (выше порога)"]
# [inline (always)]
pub fn pvd_vcc_over (& mut self) -> PvdVccOverW < MaskLevelClearSpec > { PvdVccOverW :: new (self , 25) } # [doc = "Bit 26 - Линия прерывания недостаточного напряжения батареи"]
# [inline (always)]
pub fn battery_non_good (& mut self) -> BatteryNonGoodW < MaskLevelClearSpec > { BatteryNonGoodW :: new (self , 26) } # [doc = "Bit 27 - Линия прерывания BrouwnOut детектора"]
# [inline (always)]
pub fn bor (& mut self) -> BorW < MaskLevelClearSpec > { BorW :: new (self , 27) } # [doc = "Bit 28 - Линия прерывания монитора температуры"]
# [inline (always)]
pub fn tsens (& mut self) -> TsensW < MaskLevelClearSpec > { TsensW :: new (self , 28) } # [doc = "Bit 29 - Линия прерывания АЦП"]
# [inline (always)]
pub fn adc (& mut self) -> AdcW < MaskLevelClearSpec > { AdcW :: new (self , 29) } # [doc = "Bit 30 - Линия прерывания ЦАП0"]
# [inline (always)]
pub fn dac0 (& mut self) -> Dac0W < MaskLevelClearSpec > { Dac0W :: new (self , 30) } # [doc = "Bit 31 - Линия прерывания ЦАП1"]
# [inline (always)]
pub fn dac1 (& mut self) -> Dac1W < MaskLevelClearSpec > { Dac1W :: new (self , 31) } } # [doc = "Сброс маски прерываний по уровню\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mask_level_clear::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MaskLevelClearSpec ; impl crate :: RegisterSpec for MaskLevelClearSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`mask_level_clear::W`](W) writer structure"]
impl crate :: Writable for MaskLevelClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0xffff_ffff ; } # [doc = "`reset()` method sets MASK_LEVEL_CLEAR to value 0"]
impl crate :: Resettable for MaskLevelClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CLEAR (w) register accessor: Сброс флагов в статусе прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clear::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clear`]
module"]
# [doc (alias = "CLEAR")]
pub type Clear = crate :: Reg < clear :: ClearSpec > ; # [doc = "Сброс флагов в статусе прерываний"]
pub mod clear { # [doc = "Register `CLEAR` writer"]
pub type W = crate :: W < ClearSpec > ; # [doc = "Field `Timer32_0` writer - Линия прерывания Timer32_0"]
pub type Timer32_0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `USART_0` writer - Линия прерывания USART_0"]
pub type Usart0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `USART_1` writer - Линия прерывания USART_1"]
pub type Usart1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `SPI_0` writer - Линия прерывания SPI_0"]
pub type Spi0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `SPI_1` writer - Линия прерывания SPI_1"]
pub type Spi1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `GPIO` writer - Линия прерывания GPIO"]
pub type GpioW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `I2C_0` writer - Линия прерывания I2C_0"]
pub type I2c0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `I2C_1` writer - Линия прерывания I2C_1"]
pub type I2c1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `WDT` writer - Линия прерывания сторожевого таймера (WDT)"]
pub type WdtW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Timer16_0` writer - Линия прерывания Timer16_0"]
pub type Timer16_0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Timer16_1` writer - Линия прерывания Timer16_1"]
pub type Timer16_1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Timer16_2` writer - Линия прерывания Timer16_2"]
pub type Timer16_2W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Timer32_1` writer - Линия прерывания Timer32_1"]
pub type Timer32_1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Timer32_2` writer - Линия прерывания Timer32_2"]
pub type Timer32_2W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `SPIFI` writer - Линия прерывания SPIFI"]
pub type SpifiW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `RTC` writer - Линия прерывания RTC"]
pub type RtcW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `EEPROM` writer - Линия прерывания EEPROM"]
pub type EepromW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `WDT_BUS_DOM3` writer - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
pub type WdtBusDom3W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `WDT_BUS_SPIFI` writer - Линия прерывания сторожевого таймера шины (SPIFI)"]
pub type WdtBusSpifiW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `WDT_BUS_EEPROM` writer - Линия прерывания сторожевого таймера шины (EEPROM)"]
pub type WdtBusEepromW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `DMA` writer - Линия прерывания ПДП"]
pub type DmaW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `Frequency_monitor` writer - Линия прерывания монитора частоты"]
pub type FrequencyMonitorW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `PVD_AVCC_under` writer - Линия прерывания монитора напряжения AVCC (ниже порога)"]
pub type PvdAvccUnderW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `PVD_AVCC_over` writer - Линия прерывания монитора напряжения AVCC (выше порога)"]
pub type PvdAvccOverW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `PVD_VCC_under` writer - Линия прерывания монитора напряжения VCC (ниже порога)"]
pub type PvdVccUnderW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `PVD_VCC_over` writer - Линия прерывания монитора напряжения VCC (выше порога)"]
pub type PvdVccOverW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `BATTERY_NON_GOOD` writer - Линия прерывания недостаточного напряжения батареи"]
pub type BatteryNonGoodW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `BOR` writer - Линия прерывания BrouwnOut детектора"]
pub type BorW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `TSENS` writer - Линия прерывания монитора температуры"]
pub type TsensW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `ADC` writer - Линия прерывания АЦП"]
pub type AdcW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `DAC0` writer - Линия прерывания ЦАП0"]
pub type Dac0W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `DAC1` writer - Линия прерывания ЦАП1"]
pub type Dac1W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; impl W { # [doc = "Bit 0 - Линия прерывания Timer32_0"]
# [inline (always)]
pub fn timer32_0 (& mut self) -> Timer32_0W < ClearSpec > { Timer32_0W :: new (self , 0) } # [doc = "Bit 1 - Линия прерывания USART_0"]
# [inline (always)]
pub fn usart_0 (& mut self) -> Usart0W < ClearSpec > { Usart0W :: new (self , 1) } # [doc = "Bit 2 - Линия прерывания USART_1"]
# [inline (always)]
pub fn usart_1 (& mut self) -> Usart1W < ClearSpec > { Usart1W :: new (self , 2) } # [doc = "Bit 3 - Линия прерывания SPI_0"]
# [inline (always)]
pub fn spi_0 (& mut self) -> Spi0W < ClearSpec > { Spi0W :: new (self , 3) } # [doc = "Bit 4 - Линия прерывания SPI_1"]
# [inline (always)]
pub fn spi_1 (& mut self) -> Spi1W < ClearSpec > { Spi1W :: new (self , 4) } # [doc = "Bit 5 - Линия прерывания GPIO"]
# [inline (always)]
pub fn gpio (& mut self) -> GpioW < ClearSpec > { GpioW :: new (self , 5) } # [doc = "Bit 6 - Линия прерывания I2C_0"]
# [inline (always)]
pub fn i2c_0 (& mut self) -> I2c0W < ClearSpec > { I2c0W :: new (self , 6) } # [doc = "Bit 7 - Линия прерывания I2C_1"]
# [inline (always)]
pub fn i2c_1 (& mut self) -> I2c1W < ClearSpec > { I2c1W :: new (self , 7) } # [doc = "Bit 8 - Линия прерывания сторожевого таймера (WDT)"]
# [inline (always)]
pub fn wdt (& mut self) -> WdtW < ClearSpec > { WdtW :: new (self , 8) } # [doc = "Bit 9 - Линия прерывания Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& mut self) -> Timer16_0W < ClearSpec > { Timer16_0W :: new (self , 9) } # [doc = "Bit 10 - Линия прерывания Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& mut self) -> Timer16_1W < ClearSpec > { Timer16_1W :: new (self , 10) } # [doc = "Bit 11 - Линия прерывания Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& mut self) -> Timer16_2W < ClearSpec > { Timer16_2W :: new (self , 11) } # [doc = "Bit 12 - Линия прерывания Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& mut self) -> Timer32_1W < ClearSpec > { Timer32_1W :: new (self , 12) } # [doc = "Bit 13 - Линия прерывания Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& mut self) -> Timer32_2W < ClearSpec > { Timer32_2W :: new (self , 13) } # [doc = "Bit 14 - Линия прерывания SPIFI"]
# [inline (always)]
pub fn spifi (& mut self) -> SpifiW < ClearSpec > { SpifiW :: new (self , 14) } # [doc = "Bit 15 - Линия прерывания RTC"]
# [inline (always)]
pub fn rtc (& mut self) -> RtcW < ClearSpec > { RtcW :: new (self , 15) } # [doc = "Bit 16 - Линия прерывания EEPROM"]
# [inline (always)]
pub fn eeprom (& mut self) -> EepromW < ClearSpec > { EepromW :: new (self , 16) } # [doc = "Bit 17 - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
# [inline (always)]
pub fn wdt_bus_dom3 (& mut self) -> WdtBusDom3W < ClearSpec > { WdtBusDom3W :: new (self , 17) } # [doc = "Bit 18 - Линия прерывания сторожевого таймера шины (SPIFI)"]
# [inline (always)]
pub fn wdt_bus_spifi (& mut self) -> WdtBusSpifiW < ClearSpec > { WdtBusSpifiW :: new (self , 18) } # [doc = "Bit 19 - Линия прерывания сторожевого таймера шины (EEPROM)"]
# [inline (always)]
pub fn wdt_bus_eeprom (& mut self) -> WdtBusEepromW < ClearSpec > { WdtBusEepromW :: new (self , 19) } # [doc = "Bit 20 - Линия прерывания ПДП"]
# [inline (always)]
pub fn dma (& mut self) -> DmaW < ClearSpec > { DmaW :: new (self , 20) } # [doc = "Bit 21 - Линия прерывания монитора частоты"]
# [inline (always)]
pub fn frequency_monitor (& mut self) -> FrequencyMonitorW < ClearSpec > { FrequencyMonitorW :: new (self , 21) } # [doc = "Bit 22 - Линия прерывания монитора напряжения AVCC (ниже порога)"]
# [inline (always)]
pub fn pvd_avcc_under (& mut self) -> PvdAvccUnderW < ClearSpec > { PvdAvccUnderW :: new (self , 22) } # [doc = "Bit 23 - Линия прерывания монитора напряжения AVCC (выше порога)"]
# [inline (always)]
pub fn pvd_avcc_over (& mut self) -> PvdAvccOverW < ClearSpec > { PvdAvccOverW :: new (self , 23) } # [doc = "Bit 24 - Линия прерывания монитора напряжения VCC (ниже порога)"]
# [inline (always)]
pub fn pvd_vcc_under (& mut self) -> PvdVccUnderW < ClearSpec > { PvdVccUnderW :: new (self , 24) } # [doc = "Bit 25 - Линия прерывания монитора напряжения VCC (выше порога)"]
# [inline (always)]
pub fn pvd_vcc_over (& mut self) -> PvdVccOverW < ClearSpec > { PvdVccOverW :: new (self , 25) } # [doc = "Bit 26 - Линия прерывания недостаточного напряжения батареи"]
# [inline (always)]
pub fn battery_non_good (& mut self) -> BatteryNonGoodW < ClearSpec > { BatteryNonGoodW :: new (self , 26) } # [doc = "Bit 27 - Линия прерывания BrouwnOut детектора"]
# [inline (always)]
pub fn bor (& mut self) -> BorW < ClearSpec > { BorW :: new (self , 27) } # [doc = "Bit 28 - Линия прерывания монитора температуры"]
# [inline (always)]
pub fn tsens (& mut self) -> TsensW < ClearSpec > { TsensW :: new (self , 28) } # [doc = "Bit 29 - Линия прерывания АЦП"]
# [inline (always)]
pub fn adc (& mut self) -> AdcW < ClearSpec > { AdcW :: new (self , 29) } # [doc = "Bit 30 - Линия прерывания ЦАП0"]
# [inline (always)]
pub fn dac0 (& mut self) -> Dac0W < ClearSpec > { Dac0W :: new (self , 30) } # [doc = "Bit 31 - Линия прерывания ЦАП1"]
# [inline (always)]
pub fn dac1 (& mut self) -> Dac1W < ClearSpec > { Dac1W :: new (self , 31) } } # [doc = "Сброс флагов в статусе прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clear::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClearSpec ; impl crate :: RegisterSpec for ClearSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`clear::W`](W) writer structure"]
impl crate :: Writable for ClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0xffff_ffff ; } # [doc = "`reset()` method sets CLEAR to value 0"]
impl crate :: Resettable for ClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "STATUS (r) register accessor: Сброс прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@status`]
module"]
# [doc (alias = "STATUS")]
pub type Status = crate :: Reg < status :: StatusSpec > ; # [doc = "Сброс прерываний"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub type R = crate :: R < StatusSpec > ; # [doc = "Field `Timer32_0` reader - Линия прерывания Timer32_0"]
pub type Timer32_0R = crate :: BitReader ; # [doc = "Field `USART_0` reader - Линия прерывания USART_0"]
pub type Usart0R = crate :: BitReader ; # [doc = "Field `USART_1` reader - Линия прерывания USART_1"]
pub type Usart1R = crate :: BitReader ; # [doc = "Field `SPI_0` reader - Линия прерывания SPI_0"]
pub type Spi0R = crate :: BitReader ; # [doc = "Field `SPI_1` reader - Линия прерывания SPI_1"]
pub type Spi1R = crate :: BitReader ; # [doc = "Field `GPIO` reader - Линия прерывания GPIO"]
pub type GpioR = crate :: BitReader ; # [doc = "Field `I2C_0` reader - Линия прерывания I2C_0"]
pub type I2c0R = crate :: BitReader ; # [doc = "Field `I2C_1` reader - Линия прерывания I2C_1"]
pub type I2c1R = crate :: BitReader ; # [doc = "Field `WDT` reader - Линия прерывания сторожевого таймера (WDT)"]
pub type WdtR = crate :: BitReader ; # [doc = "Field `Timer16_0` reader - Линия прерывания Timer16_0"]
pub type Timer16_0R = crate :: BitReader ; # [doc = "Field `Timer16_1` reader - Линия прерывания Timer16_1"]
pub type Timer16_1R = crate :: BitReader ; # [doc = "Field `Timer16_2` reader - Линия прерывания Timer16_2"]
pub type Timer16_2R = crate :: BitReader ; # [doc = "Field `Timer32_1` reader - Линия прерывания Timer32_1"]
pub type Timer32_1R = crate :: BitReader ; # [doc = "Field `Timer32_2` reader - Линия прерывания Timer32_2"]
pub type Timer32_2R = crate :: BitReader ; # [doc = "Field `SPIFI` reader - Линия прерывания SPIFI"]
pub type SpifiR = crate :: BitReader ; # [doc = "Field `RTC` reader - Линия прерывания RTC"]
pub type RtcR = crate :: BitReader ; # [doc = "Field `EEPROM` reader - Линия прерывания EEPROM"]
pub type EepromR = crate :: BitReader ; # [doc = "Field `WDT_BUS_DOM3` reader - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
pub type WdtBusDom3R = crate :: BitReader ; # [doc = "Field `WDT_BUS_SPIFI` reader - Линия прерывания сторожевого таймера шины (SPIFI)"]
pub type WdtBusSpifiR = crate :: BitReader ; # [doc = "Field `WDT_BUS_EEPROM` reader - Линия прерывания сторожевого таймера шины (EEPROM)"]
pub type WdtBusEepromR = crate :: BitReader ; # [doc = "Field `DMA` reader - Линия прерывания ПДП"]
pub type DmaR = crate :: BitReader ; # [doc = "Field `Frequency_monitor` reader - Линия прерывания монитора частоты"]
pub type FrequencyMonitorR = crate :: BitReader ; # [doc = "Field `PVD_AVCC_under` reader - Линия прерывания монитора напряжения AVCC (ниже порога)"]
pub type PvdAvccUnderR = crate :: BitReader ; # [doc = "Field `PVD_AVCC_over` reader - Линия прерывания монитора напряжения AVCC (выше порога)"]
pub type PvdAvccOverR = crate :: BitReader ; # [doc = "Field `PVD_VCC_under` reader - Линия прерывания монитора напряжения VCC (ниже порога)"]
pub type PvdVccUnderR = crate :: BitReader ; # [doc = "Field `PVD_VCC_over` reader - Линия прерывания монитора напряжения VCC (выше порога)"]
pub type PvdVccOverR = crate :: BitReader ; # [doc = "Field `BATTERY_NON_GOOD` reader - Линия прерывания недостаточного напряжения батареи"]
pub type BatteryNonGoodR = crate :: BitReader ; # [doc = "Field `BOR` reader - Линия прерывания BrouwnOut детектора"]
pub type BorR = crate :: BitReader ; # [doc = "Field `TSENS` reader - Линия прерывания монитора температуры"]
pub type TsensR = crate :: BitReader ; # [doc = "Field `ADC` reader - Линия прерывания АЦП"]
pub type AdcR = crate :: BitReader ; # [doc = "Field `DAC0` reader - Линия прерывания ЦАП0"]
pub type Dac0R = crate :: BitReader ; # [doc = "Field `DAC1` reader - Линия прерывания ЦАП1"]
pub type Dac1R = crate :: BitReader ; impl R { # [doc = "Bit 0 - Линия прерывания Timer32_0"]
# [inline (always)]
pub fn timer32_0 (& self) -> Timer32_0R { Timer32_0R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Линия прерывания USART_0"]
# [inline (always)]
pub fn usart_0 (& self) -> Usart0R { Usart0R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Линия прерывания USART_1"]
# [inline (always)]
pub fn usart_1 (& self) -> Usart1R { Usart1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Линия прерывания SPI_0"]
# [inline (always)]
pub fn spi_0 (& self) -> Spi0R { Spi0R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Линия прерывания SPI_1"]
# [inline (always)]
pub fn spi_1 (& self) -> Spi1R { Spi1R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Линия прерывания GPIO"]
# [inline (always)]
pub fn gpio (& self) -> GpioR { GpioR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Линия прерывания I2C_0"]
# [inline (always)]
pub fn i2c_0 (& self) -> I2c0R { I2c0R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Линия прерывания I2C_1"]
# [inline (always)]
pub fn i2c_1 (& self) -> I2c1R { I2c1R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Линия прерывания сторожевого таймера (WDT)"]
# [inline (always)]
pub fn wdt (& self) -> WdtR { WdtR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Линия прерывания Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& self) -> Timer16_0R { Timer16_0R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Линия прерывания Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& self) -> Timer16_1R { Timer16_1R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Линия прерывания Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& self) -> Timer16_2R { Timer16_2R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Линия прерывания Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& self) -> Timer32_1R { Timer32_1R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Линия прерывания Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& self) -> Timer32_2R { Timer32_2R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Линия прерывания SPIFI"]
# [inline (always)]
pub fn spifi (& self) -> SpifiR { SpifiR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Линия прерывания RTC"]
# [inline (always)]
pub fn rtc (& self) -> RtcR { RtcR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Линия прерывания EEPROM"]
# [inline (always)]
pub fn eeprom (& self) -> EepromR { EepromR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
# [inline (always)]
pub fn wdt_bus_dom3 (& self) -> WdtBusDom3R { WdtBusDom3R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Линия прерывания сторожевого таймера шины (SPIFI)"]
# [inline (always)]
pub fn wdt_bus_spifi (& self) -> WdtBusSpifiR { WdtBusSpifiR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Линия прерывания сторожевого таймера шины (EEPROM)"]
# [inline (always)]
pub fn wdt_bus_eeprom (& self) -> WdtBusEepromR { WdtBusEepromR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Линия прерывания ПДП"]
# [inline (always)]
pub fn dma (& self) -> DmaR { DmaR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Линия прерывания монитора частоты"]
# [inline (always)]
pub fn frequency_monitor (& self) -> FrequencyMonitorR { FrequencyMonitorR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Линия прерывания монитора напряжения AVCC (ниже порога)"]
# [inline (always)]
pub fn pvd_avcc_under (& self) -> PvdAvccUnderR { PvdAvccUnderR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Линия прерывания монитора напряжения AVCC (выше порога)"]
# [inline (always)]
pub fn pvd_avcc_over (& self) -> PvdAvccOverR { PvdAvccOverR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 24 - Линия прерывания монитора напряжения VCC (ниже порога)"]
# [inline (always)]
pub fn pvd_vcc_under (& self) -> PvdVccUnderR { PvdVccUnderR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Линия прерывания монитора напряжения VCC (выше порога)"]
# [inline (always)]
pub fn pvd_vcc_over (& self) -> PvdVccOverR { PvdVccOverR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Линия прерывания недостаточного напряжения батареи"]
# [inline (always)]
pub fn battery_non_good (& self) -> BatteryNonGoodR { BatteryNonGoodR :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Линия прерывания BrouwnOut детектора"]
# [inline (always)]
pub fn bor (& self) -> BorR { BorR :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 28 - Линия прерывания монитора температуры"]
# [inline (always)]
pub fn tsens (& self) -> TsensR { TsensR :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Линия прерывания АЦП"]
# [inline (always)]
pub fn adc (& self) -> AdcR { AdcR :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Линия прерывания ЦАП0"]
# [inline (always)]
pub fn dac0 (& self) -> Dac0R { Dac0R :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - Линия прерывания ЦАП1"]
# [inline (always)]
pub fn dac1 (& self) -> Dac1R { Dac1R :: new (((self . bits >> 31) & 1) != 0) } } # [doc = "Сброс прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StatusSpec ; impl crate :: RegisterSpec for StatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`status::R`](R) reader structure"]
impl crate :: Readable for StatusSpec { } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for StatusSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RAW_STATUS (r) register accessor: Текущее состоянии линий прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`raw_status::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@raw_status`]
module"]
# [doc (alias = "RAW_STATUS")]
pub type RawStatus = crate :: Reg < raw_status :: RawStatusSpec > ; # [doc = "Текущее состоянии линий прерываний"]
pub mod raw_status { # [doc = "Register `RAW_STATUS` reader"]
pub type R = crate :: R < RawStatusSpec > ; # [doc = "Field `Timer32_0` reader - Линия прерывания Timer32_0"]
pub type Timer32_0R = crate :: BitReader ; # [doc = "Field `USART_0` reader - Линия прерывания USART_0"]
pub type Usart0R = crate :: BitReader ; # [doc = "Field `USART_1` reader - Линия прерывания USART_1"]
pub type Usart1R = crate :: BitReader ; # [doc = "Field `SPI_0` reader - Линия прерывания SPI_0"]
pub type Spi0R = crate :: BitReader ; # [doc = "Field `SPI_1` reader - Линия прерывания SPI_1"]
pub type Spi1R = crate :: BitReader ; # [doc = "Field `GPIO` reader - Линия прерывания GPIO"]
pub type GpioR = crate :: BitReader ; # [doc = "Field `I2C_0` reader - Линия прерывания I2C_0"]
pub type I2c0R = crate :: BitReader ; # [doc = "Field `I2C_1` reader - Линия прерывания I2C_1"]
pub type I2c1R = crate :: BitReader ; # [doc = "Field `WDT` reader - Линия прерывания сторожевого таймера (WDT)"]
pub type WdtR = crate :: BitReader ; # [doc = "Field `Timer16_0` reader - Линия прерывания Timer16_0"]
pub type Timer16_0R = crate :: BitReader ; # [doc = "Field `Timer16_1` reader - Линия прерывания Timer16_1"]
pub type Timer16_1R = crate :: BitReader ; # [doc = "Field `Timer16_2` reader - Линия прерывания Timer16_2"]
pub type Timer16_2R = crate :: BitReader ; # [doc = "Field `Timer32_1` reader - Линия прерывания Timer32_1"]
pub type Timer32_1R = crate :: BitReader ; # [doc = "Field `Timer32_2` reader - Линия прерывания Timer32_2"]
pub type Timer32_2R = crate :: BitReader ; # [doc = "Field `SPIFI` reader - Линия прерывания SPIFI"]
pub type SpifiR = crate :: BitReader ; # [doc = "Field `RTC` reader - Линия прерывания RTC"]
pub type RtcR = crate :: BitReader ; # [doc = "Field `EEPROM` reader - Линия прерывания EEPROM"]
pub type EepromR = crate :: BitReader ; # [doc = "Field `WDT_BUS_DOM3` reader - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
pub type WdtBusDom3R = crate :: BitReader ; # [doc = "Field `WDT_BUS_SPIFI` reader - Линия прерывания сторожевого таймера шины (SPIFI)"]
pub type WdtBusSpifiR = crate :: BitReader ; # [doc = "Field `WDT_BUS_EEPROM` reader - Линия прерывания сторожевого таймера шины (EEPROM)"]
pub type WdtBusEepromR = crate :: BitReader ; # [doc = "Field `DMA` reader - Линия прерывания ПДП"]
pub type DmaR = crate :: BitReader ; # [doc = "Field `Frequency_monitor` reader - Линия прерывания монитора частоты"]
pub type FrequencyMonitorR = crate :: BitReader ; # [doc = "Field `PVD_AVCC_under` reader - Линия прерывания монитора напряжения AVCC (ниже порога)"]
pub type PvdAvccUnderR = crate :: BitReader ; # [doc = "Field `PVD_AVCC_over` reader - Линия прерывания монитора напряжения AVCC (выше порога)"]
pub type PvdAvccOverR = crate :: BitReader ; # [doc = "Field `PVD_VCC_under` reader - Линия прерывания монитора напряжения VCC (ниже порога)"]
pub type PvdVccUnderR = crate :: BitReader ; # [doc = "Field `PVD_VCC_over` reader - Линия прерывания монитора напряжения VCC (выше порога)"]
pub type PvdVccOverR = crate :: BitReader ; # [doc = "Field `BATTERY_NON_GOOD` reader - Линия прерывания недостаточного напряжения батареи"]
pub type BatteryNonGoodR = crate :: BitReader ; # [doc = "Field `BOR` reader - Линия прерывания BrouwnOut детектора"]
pub type BorR = crate :: BitReader ; # [doc = "Field `TSENS` reader - Линия прерывания монитора температуры"]
pub type TsensR = crate :: BitReader ; # [doc = "Field `ADC` reader - Линия прерывания АЦП"]
pub type AdcR = crate :: BitReader ; # [doc = "Field `DAC0` reader - Линия прерывания ЦАП0"]
pub type Dac0R = crate :: BitReader ; # [doc = "Field `DAC1` reader - Линия прерывания ЦАП1"]
pub type Dac1R = crate :: BitReader ; impl R { # [doc = "Bit 0 - Линия прерывания Timer32_0"]
# [inline (always)]
pub fn timer32_0 (& self) -> Timer32_0R { Timer32_0R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Линия прерывания USART_0"]
# [inline (always)]
pub fn usart_0 (& self) -> Usart0R { Usart0R :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Линия прерывания USART_1"]
# [inline (always)]
pub fn usart_1 (& self) -> Usart1R { Usart1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Линия прерывания SPI_0"]
# [inline (always)]
pub fn spi_0 (& self) -> Spi0R { Spi0R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Линия прерывания SPI_1"]
# [inline (always)]
pub fn spi_1 (& self) -> Spi1R { Spi1R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Линия прерывания GPIO"]
# [inline (always)]
pub fn gpio (& self) -> GpioR { GpioR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Линия прерывания I2C_0"]
# [inline (always)]
pub fn i2c_0 (& self) -> I2c0R { I2c0R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Линия прерывания I2C_1"]
# [inline (always)]
pub fn i2c_1 (& self) -> I2c1R { I2c1R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Линия прерывания сторожевого таймера (WDT)"]
# [inline (always)]
pub fn wdt (& self) -> WdtR { WdtR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Линия прерывания Timer16_0"]
# [inline (always)]
pub fn timer16_0 (& self) -> Timer16_0R { Timer16_0R :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Линия прерывания Timer16_1"]
# [inline (always)]
pub fn timer16_1 (& self) -> Timer16_1R { Timer16_1R :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Линия прерывания Timer16_2"]
# [inline (always)]
pub fn timer16_2 (& self) -> Timer16_2R { Timer16_2R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Линия прерывания Timer32_1"]
# [inline (always)]
pub fn timer32_1 (& self) -> Timer32_1R { Timer32_1R :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Линия прерывания Timer32_2"]
# [inline (always)]
pub fn timer32_2 (& self) -> Timer32_2R { Timer32_2R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Линия прерывания SPIFI"]
# [inline (always)]
pub fn spifi (& self) -> SpifiR { SpifiR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Линия прерывания RTC"]
# [inline (always)]
pub fn rtc (& self) -> RtcR { RtcR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Линия прерывания EEPROM"]
# [inline (always)]
pub fn eeprom (& self) -> EepromR { EepromR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Линия прерывания сторожевого таймера шины (периферийные устройства)"]
# [inline (always)]
pub fn wdt_bus_dom3 (& self) -> WdtBusDom3R { WdtBusDom3R :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Линия прерывания сторожевого таймера шины (SPIFI)"]
# [inline (always)]
pub fn wdt_bus_spifi (& self) -> WdtBusSpifiR { WdtBusSpifiR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Линия прерывания сторожевого таймера шины (EEPROM)"]
# [inline (always)]
pub fn wdt_bus_eeprom (& self) -> WdtBusEepromR { WdtBusEepromR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Линия прерывания ПДП"]
# [inline (always)]
pub fn dma (& self) -> DmaR { DmaR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Линия прерывания монитора частоты"]
# [inline (always)]
pub fn frequency_monitor (& self) -> FrequencyMonitorR { FrequencyMonitorR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Линия прерывания монитора напряжения AVCC (ниже порога)"]
# [inline (always)]
pub fn pvd_avcc_under (& self) -> PvdAvccUnderR { PvdAvccUnderR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Линия прерывания монитора напряжения AVCC (выше порога)"]
# [inline (always)]
pub fn pvd_avcc_over (& self) -> PvdAvccOverR { PvdAvccOverR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 24 - Линия прерывания монитора напряжения VCC (ниже порога)"]
# [inline (always)]
pub fn pvd_vcc_under (& self) -> PvdVccUnderR { PvdVccUnderR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Линия прерывания монитора напряжения VCC (выше порога)"]
# [inline (always)]
pub fn pvd_vcc_over (& self) -> PvdVccOverR { PvdVccOverR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Линия прерывания недостаточного напряжения батареи"]
# [inline (always)]
pub fn battery_non_good (& self) -> BatteryNonGoodR { BatteryNonGoodR :: new (((self . bits >> 26) & 1) != 0) } # [doc = "Bit 27 - Линия прерывания BrouwnOut детектора"]
# [inline (always)]
pub fn bor (& self) -> BorR { BorR :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 28 - Линия прерывания монитора температуры"]
# [inline (always)]
pub fn tsens (& self) -> TsensR { TsensR :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Линия прерывания АЦП"]
# [inline (always)]
pub fn adc (& self) -> AdcR { AdcR :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Линия прерывания ЦАП0"]
# [inline (always)]
pub fn dac0 (& self) -> Dac0R { Dac0R :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - Линия прерывания ЦАП1"]
# [inline (always)]
pub fn dac1 (& self) -> Dac1R { Dac1R :: new (((self . bits >> 31) & 1) != 0) } } # [doc = "Текущее состоянии линий прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`raw_status::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RawStatusSpec ; impl crate :: RegisterSpec for RawStatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`raw_status::R`](R) reader structure"]
impl crate :: Readable for RawStatusSpec { } # [doc = "`reset()` method sets RAW_STATUS to value 0"]
impl crate :: Resettable for RawStatusSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "регистры модуля таймера_0"]
pub struct Timer32_0 { _marker : PhantomData < * const () > } unsafe impl Send for Timer32_0 { } impl Timer32_0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer32_0 :: RegisterBlock = 0x0005_0800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer32_0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Timer32_0 { type Target = timer32_0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Timer32_0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer32_0") . finish () } } # [doc = "регистры модуля таймера_0"]
pub mod timer32_0 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { value : Value , top : Top , prescale : Prescale , control : Control , enable : Enable , int_mask : IntMask , int_clear : IntClear , int_flag : IntFlag , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn value (& self) -> & Value { & self . value } # [doc = "0x04 - максимальное значение счетной последовательности"]
# [inline (always)]
pub const fn top (& self) -> & Top { & self . top } # [doc = "0x08 - значение делителя"]
# [inline (always)]
pub const fn prescale (& self) -> & Prescale { & self . prescale } # [doc = "0x0c - Конфигурационный регистр основного таймера"]
# [inline (always)]
pub const fn control (& self) -> & Control { & self . control } # [doc = "0x10 - Регистр включения таймера"]
# [inline (always)]
pub const fn enable (& self) -> & Enable { & self . enable } # [doc = "0x14 - Регистр маски прерываний"]
# [inline (always)]
pub const fn int_mask (& self) -> & IntMask { & self . int_mask } # [doc = "0x18 - Регистр сброса флагов прерываний"]
# [inline (always)]
pub const fn int_clear (& self) -> & IntClear { & self . int_clear } # [doc = "0x1c - Регистр флагов прерываний"]
# [inline (always)]
pub const fn int_flag (& self) -> & IntFlag { & self . int_flag } } # [doc = "VALUE (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`value::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`value::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@value`]
module"]
# [doc (alias = "VALUE")]
pub type Value = crate :: Reg < value :: ValueSpec > ; # [doc = ""]
pub mod value { # [doc = "Register `VALUE` reader"]
pub type R = crate :: R < ValueSpec > ; # [doc = "Register `VALUE` writer"]
pub type W = crate :: W < ValueSpec > ; # [doc = "Field `TIM_VAL` reader - текущее значение счетчика"]
pub type TimValR = crate :: FieldReader < u32 > ; impl R { # [doc = "Bits 0:31 - текущее значение счетчика"]
# [inline (always)]
pub fn tim_val (& self) -> TimValR { TimValR :: new (self . bits) } } impl W { } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`value::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`value::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ValueSpec ; impl crate :: RegisterSpec for ValueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`value::R`](R) reader structure"]
impl crate :: Readable for ValueSpec { } # [doc = "`write(|w| ..)` method takes [`value::W`](W) writer structure"]
impl crate :: Writable for ValueSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets VALUE to value 0"]
impl crate :: Resettable for ValueSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TOP (rw) register accessor: максимальное значение счетной последовательности\n\nYou can [`read`](crate::Reg::read) this register and get [`top::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`top::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@top`]
module"]
# [doc (alias = "TOP")]
pub type Top = crate :: Reg < top :: TopSpec > ; # [doc = "максимальное значение счетной последовательности"]
pub mod top { # [doc = "Register `TOP` reader"]
pub type R = crate :: R < TopSpec > ; # [doc = "Register `TOP` writer"]
pub type W = crate :: W < TopSpec > ; # [doc = "Field `TIM_TOP` reader - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
pub type TimTopR = crate :: FieldReader < u32 > ; # [doc = "Field `TIM_TOP` writer - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
pub type TimTopW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
# [inline (always)]
pub fn tim_top (& self) -> TimTopR { TimTopR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
# [inline (always)]
pub fn tim_top (& mut self) -> TimTopW < TopSpec > { TimTopW :: new (self , 0) } } # [doc = "максимальное значение счетной последовательности\n\nYou can [`read`](crate::Reg::read) this register and get [`top::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`top::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TopSpec ; impl crate :: RegisterSpec for TopSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`top::R`](R) reader structure"]
impl crate :: Readable for TopSpec { } # [doc = "`write(|w| ..)` method takes [`top::W`](W) writer structure"]
impl crate :: Writable for TopSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TOP to value 0xffff_ffff"]
impl crate :: Resettable for TopSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } } # [doc = "PRESCALE (rw) register accessor: значение делителя\n\nYou can [`read`](crate::Reg::read) this register and get [`prescale::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prescale::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@prescale`]
module"]
# [doc (alias = "PRESCALE")]
pub type Prescale = crate :: Reg < prescale :: PrescaleSpec > ; # [doc = "значение делителя"]
pub mod prescale { # [doc = "Register `PRESCALE` reader"]
pub type R = crate :: R < PrescaleSpec > ; # [doc = "Register `PRESCALE` writer"]
pub type W = crate :: W < PrescaleSpec > ; # [doc = "Field `TIM_PRESCALE` reader - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
pub type TimPrescaleR = crate :: FieldReader < u32 > ; # [doc = "Field `TIM_PRESCALE` writer - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
pub type TimPrescaleW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
# [inline (always)]
pub fn tim_prescale (& self) -> TimPrescaleR { TimPrescaleR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
# [inline (always)]
pub fn tim_prescale (& mut self) -> TimPrescaleW < PrescaleSpec > { TimPrescaleW :: new (self , 0) } } # [doc = "значение делителя\n\nYou can [`read`](crate::Reg::read) this register and get [`prescale::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prescale::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct PrescaleSpec ; impl crate :: RegisterSpec for PrescaleSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`prescale::R`](R) reader structure"]
impl crate :: Readable for PrescaleSpec { } # [doc = "`write(|w| ..)` method takes [`prescale::W`](W) writer structure"]
impl crate :: Writable for PrescaleSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PRESCALE to value 0"]
impl crate :: Resettable for PrescaleSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONTROL (rw) register accessor: Конфигурационный регистр основного таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control`]
module"]
# [doc (alias = "CONTROL")]
pub type Control = crate :: Reg < control :: ControlSpec > ; # [doc = "Конфигурационный регистр основного таймера"]
pub mod control { # [doc = "Register `CONTROL` reader"]
pub type R = crate :: R < ControlSpec > ; # [doc = "Register `CONTROL` writer"]
pub type W = crate :: W < ControlSpec > ; # [doc = "Режим счёта таймера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CountMode { # [doc = "0: Прямой режим"]
Direct = 0 , # [doc = "1: Обратный режим"]
Reverse = 1 , # [doc = "2: Двунаправленный режим"]
Bidirectional = 2 , } impl From < CountMode > for u8 { # [inline (always)]
fn from (variant : CountMode) -> Self { variant as _ } } impl crate :: FieldSpec for CountMode { type Ux = u8 ; } impl crate :: IsEnum for CountMode { } # [doc = "Field `COUNT_MODE` reader - Режим счёта таймера"]
pub type CountModeR = crate :: FieldReader < CountMode > ; impl CountModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < CountMode > { match self . bits { 0 => Some (CountMode :: Direct) , 1 => Some (CountMode :: Reverse) , 2 => Some (CountMode :: Bidirectional) , _ => None , } } # [doc = "Прямой режим"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == CountMode :: Direct } # [doc = "Обратный режим"]
# [inline (always)]
pub fn is_reverse (& self) -> bool { * self == CountMode :: Reverse } # [doc = "Двунаправленный режим"]
# [inline (always)]
pub fn is_bidirectional (& self) -> bool { * self == CountMode :: Bidirectional } } # [doc = "Field `COUNT_MODE` writer - Режим счёта таймера"]
pub type CountModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , CountMode > ; impl < 'a , REG > CountModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Прямой режим"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Direct) } # [doc = "Обратный режим"]
# [inline (always)]
pub fn reverse (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Reverse) } # [doc = "Двунаправленный режим"]
# [inline (always)]
pub fn bidirectional (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Bidirectional) } } # [doc = "Выбор источника тактового сигнала для счета\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Sourse { # [doc = "0: Вход модуля TIM1"]
Tim1 = 0 , # [doc = "2: Вход модуля TIM2"]
Tim2 = 2 , # [doc = "3: Выход предделителя"]
Tim3 = 3 , } impl From < Sourse > for u8 { # [inline (always)]
fn from (variant : Sourse) -> Self { variant as _ } } impl crate :: FieldSpec for Sourse { type Ux = u8 ; } impl crate :: IsEnum for Sourse { } # [doc = "Field `SOURSE` reader - Выбор источника тактового сигнала для счета"]
pub type SourseR = crate :: FieldReader < Sourse > ; impl SourseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Sourse > { match self . bits { 0 => Some (Sourse :: Tim1) , 2 => Some (Sourse :: Tim2) , 3 => Some (Sourse :: Tim3) , _ => None , } } # [doc = "Вход модуля TIM1"]
# [inline (always)]
pub fn is_tim1 (& self) -> bool { * self == Sourse :: Tim1 } # [doc = "Вход модуля TIM2"]
# [inline (always)]
pub fn is_tim2 (& self) -> bool { * self == Sourse :: Tim2 } # [doc = "Выход предделителя"]
# [inline (always)]
pub fn is_tim3 (& self) -> bool { * self == Sourse :: Tim3 } } # [doc = "Field `SOURSE` writer - Выбор источника тактового сигнала для счета"]
pub type SourseW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Sourse > ; impl < 'a , REG > SourseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Вход модуля TIM1"]
# [inline (always)]
pub fn tim1 (self) -> & 'a mut crate :: W < REG > { self . variant (Sourse :: Tim1) } # [doc = "Вход модуля TIM2"]
# [inline (always)]
pub fn tim2 (self) -> & 'a mut crate :: W < REG > { self . variant (Sourse :: Tim2) } # [doc = "Выход предделителя"]
# [inline (always)]
pub fn tim3 (self) -> & 'a mut crate :: W < REG > { self . variant (Sourse :: Tim3) } } impl R { # [doc = "Bits 0:1 - Режим счёта таймера"]
# [inline (always)]
pub fn count_mode (& self) -> CountModeR { CountModeR :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Выбор источника тактового сигнала для счета"]
# [inline (always)]
pub fn sourse (& self) -> SourseR { SourseR :: new (((self . bits >> 2) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Режим счёта таймера"]
# [inline (always)]
pub fn count_mode (& mut self) -> CountModeW < ControlSpec > { CountModeW :: new (self , 0) } # [doc = "Bits 2:3 - Выбор источника тактового сигнала для счета"]
# [inline (always)]
pub fn sourse (& mut self) -> SourseW < ControlSpec > { SourseW :: new (self , 2) } } # [doc = "Конфигурационный регистр основного таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ControlSpec ; impl crate :: RegisterSpec for ControlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`control::R`](R) reader structure"]
impl crate :: Readable for ControlSpec { } # [doc = "`write(|w| ..)` method takes [`control::W`](W) writer structure"]
impl crate :: Writable for ControlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL to value 0"]
impl crate :: Resettable for ControlSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ENABLE (rw) register accessor: Регистр включения таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable`]
module"]
# [doc (alias = "ENABLE")]
pub type Enable = crate :: Reg < enable :: EnableSpec > ; # [doc = "Регистр включения таймера"]
pub mod enable { # [doc = "Register `ENABLE` reader"]
pub type R = crate :: R < EnableSpec > ; # [doc = "Register `ENABLE` writer"]
pub type W = crate :: W < EnableSpec > ; # [doc = "Запуск/остановка работы счетчика\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TimEn { # [doc = "0: Счетчик выключен"]
Disable = 0 , # [doc = "1: Счетчик работает"]
Enable = 1 , } impl From < TimEn > for bool { # [inline (always)]
fn from (variant : TimEn) -> Self { variant as u8 != 0 } } # [doc = "Field `TIM_EN` reader - Запуск/остановка работы счетчика"]
pub type TimEnR = crate :: BitReader < TimEn > ; impl TimEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TimEn { match self . bits { false => TimEn :: Disable , true => TimEn :: Enable , } } # [doc = "Счетчик выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == TimEn :: Disable } # [doc = "Счетчик работает"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == TimEn :: Enable } } # [doc = "Field `TIM_EN` writer - Запуск/остановка работы счетчика"]
pub type TimEnW < 'a , REG > = crate :: BitWriter < 'a , REG , TimEn > ; impl < 'a , REG > TimEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Счетчик выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (TimEn :: Disable) } # [doc = "Счетчик работает"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (TimEn :: Enable) } } # [doc = "Field `TIM_CLR` writer - Сброс (обнуление) текущего значения счетчика при записи «1»"]
pub type TimClrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Запуск/остановка работы счетчика"]
# [inline (always)]
pub fn tim_en (& self) -> TimEnR { TimEnR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Запуск/остановка работы счетчика"]
# [inline (always)]
pub fn tim_en (& mut self) -> TimEnW < EnableSpec > { TimEnW :: new (self , 0) } # [doc = "Bit 1 - Сброс (обнуление) текущего значения счетчика при записи «1»"]
# [inline (always)]
pub fn tim_clr (& mut self) -> TimClrW < EnableSpec > { TimClrW :: new (self , 1) } } # [doc = "Регистр включения таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EnableSpec ; impl crate :: RegisterSpec for EnableSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`enable::R`](R) reader structure"]
impl crate :: Readable for EnableSpec { } # [doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
impl crate :: Writable for EnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ENABLE to value 0"]
impl crate :: Resettable for EnableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INT_MASK (rw) register accessor: Регистр маски прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mask::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mask::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_mask`]
module"]
# [doc (alias = "INT_MASK")]
pub type IntMask = crate :: Reg < int_mask :: IntMaskSpec > ; # [doc = "Регистр маски прерываний"]
pub mod int_mask { # [doc = "Register `INT_MASK` reader"]
pub type R = crate :: R < IntMaskSpec > ; # [doc = "Register `INT_MASK` writer"]
pub type W = crate :: W < IntMaskSpec > ; # [doc = "Field `OVF_Int` reader - Маска прерывания по переполнению счетчика"]
pub type OvfIntR = crate :: BitReader ; # [doc = "Field `OVF_Int` writer - Маска прерывания по переполнению счетчика"]
pub type OvfIntW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `UDF_Int` reader - Маска прерывания опустошения счетчика"]
pub type UdfIntR = crate :: BitReader ; # [doc = "Field `UDF_Int` writer - Маска прерывания опустошения счетчика"]
pub type UdfIntW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH1` reader - Маска прерывания захвата 1 канала таймера"]
pub type IcIntCh1R = crate :: BitReader ; # [doc = "Field `IC_Int_CH1` writer - Маска прерывания захвата 1 канала таймера"]
pub type IcIntCh1W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH2` reader - Маска прерывания захвата 2 канала таймера"]
pub type IcIntCh2R = crate :: BitReader ; # [doc = "Field `IC_Int_CH2` writer - Маска прерывания захвата 2 канала таймера"]
pub type IcIntCh2W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH3` reader - Маска прерывания захвата 3 канала таймера"]
pub type IcIntCh3R = crate :: BitReader ; # [doc = "Field `IC_Int_CH3` writer - Маска прерывания захвата 3 канала таймера"]
pub type IcIntCh3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH4` reader - Маска прерывания захвата 4 канала таймера"]
pub type IcIntCh4R = crate :: BitReader ; # [doc = "Field `IC_Int_CH4` writer - Маска прерывания захвата 4 канала таймера"]
pub type IcIntCh4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH1` reader - Маска прерывания совпадения 1 канала таймера"]
pub type OcIntCh1R = crate :: BitReader ; # [doc = "Field `OC_Int_CH1` writer - Маска прерывания совпадения 1 канала таймера"]
pub type OcIntCh1W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH2` reader - Маска прерывания совпадения 2 канала таймера"]
pub type OcIntCh2R = crate :: BitReader ; # [doc = "Field `OC_Int_CH2` writer - Маска прерывания совпадения 2 канала таймера"]
pub type OcIntCh2W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH3` reader - Маска прерывания совпадения 3 канала таймера"]
pub type OcIntCh3R = crate :: BitReader ; # [doc = "Field `OC_Int_CH3` writer - Маска прерывания совпадения 3 канала таймера"]
pub type OcIntCh3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH4` reader - Маска прерывания совпадения 4 канала таймера"]
pub type OcIntCh4R = crate :: BitReader ; # [doc = "Field `OC_Int_CH4` writer - Маска прерывания совпадения 4 канала таймера"]
pub type OcIntCh4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Маска прерывания по переполнению счетчика"]
# [inline (always)]
pub fn ovf_int (& self) -> OvfIntR { OvfIntR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Маска прерывания опустошения счетчика"]
# [inline (always)]
pub fn udf_int (& self) -> UdfIntR { UdfIntR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Маска прерывания захвата 1 канала таймера"]
# [inline (always)]
pub fn ic_int_ch1 (& self) -> IcIntCh1R { IcIntCh1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Маска прерывания захвата 2 канала таймера"]
# [inline (always)]
pub fn ic_int_ch2 (& self) -> IcIntCh2R { IcIntCh2R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Маска прерывания захвата 3 канала таймера"]
# [inline (always)]
pub fn ic_int_ch3 (& self) -> IcIntCh3R { IcIntCh3R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Маска прерывания захвата 4 канала таймера"]
# [inline (always)]
pub fn ic_int_ch4 (& self) -> IcIntCh4R { IcIntCh4R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Маска прерывания совпадения 1 канала таймера"]
# [inline (always)]
pub fn oc_int_ch1 (& self) -> OcIntCh1R { OcIntCh1R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Маска прерывания совпадения 2 канала таймера"]
# [inline (always)]
pub fn oc_int_ch2 (& self) -> OcIntCh2R { OcIntCh2R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Маска прерывания совпадения 3 канала таймера"]
# [inline (always)]
pub fn oc_int_ch3 (& self) -> OcIntCh3R { OcIntCh3R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Маска прерывания совпадения 4 канала таймера"]
# [inline (always)]
pub fn oc_int_ch4 (& self) -> OcIntCh4R { OcIntCh4R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Маска прерывания по переполнению счетчика"]
# [inline (always)]
pub fn ovf_int (& mut self) -> OvfIntW < IntMaskSpec > { OvfIntW :: new (self , 0) } # [doc = "Bit 1 - Маска прерывания опустошения счетчика"]
# [inline (always)]
pub fn udf_int (& mut self) -> UdfIntW < IntMaskSpec > { UdfIntW :: new (self , 1) } # [doc = "Bit 2 - Маска прерывания захвата 1 канала таймера"]
# [inline (always)]
pub fn ic_int_ch1 (& mut self) -> IcIntCh1W < IntMaskSpec > { IcIntCh1W :: new (self , 2) } # [doc = "Bit 3 - Маска прерывания захвата 2 канала таймера"]
# [inline (always)]
pub fn ic_int_ch2 (& mut self) -> IcIntCh2W < IntMaskSpec > { IcIntCh2W :: new (self , 3) } # [doc = "Bit 4 - Маска прерывания захвата 3 канала таймера"]
# [inline (always)]
pub fn ic_int_ch3 (& mut self) -> IcIntCh3W < IntMaskSpec > { IcIntCh3W :: new (self , 4) } # [doc = "Bit 5 - Маска прерывания захвата 4 канала таймера"]
# [inline (always)]
pub fn ic_int_ch4 (& mut self) -> IcIntCh4W < IntMaskSpec > { IcIntCh4W :: new (self , 5) } # [doc = "Bit 6 - Маска прерывания совпадения 1 канала таймера"]
# [inline (always)]
pub fn oc_int_ch1 (& mut self) -> OcIntCh1W < IntMaskSpec > { OcIntCh1W :: new (self , 6) } # [doc = "Bit 7 - Маска прерывания совпадения 2 канала таймера"]
# [inline (always)]
pub fn oc_int_ch2 (& mut self) -> OcIntCh2W < IntMaskSpec > { OcIntCh2W :: new (self , 7) } # [doc = "Bit 8 - Маска прерывания совпадения 3 канала таймера"]
# [inline (always)]
pub fn oc_int_ch3 (& mut self) -> OcIntCh3W < IntMaskSpec > { OcIntCh3W :: new (self , 8) } # [doc = "Bit 9 - Маска прерывания совпадения 4 канала таймера"]
# [inline (always)]
pub fn oc_int_ch4 (& mut self) -> OcIntCh4W < IntMaskSpec > { OcIntCh4W :: new (self , 9) } } # [doc = "Регистр маски прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mask::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mask::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntMaskSpec ; impl crate :: RegisterSpec for IntMaskSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`int_mask::R`](R) reader structure"]
impl crate :: Readable for IntMaskSpec { } # [doc = "`write(|w| ..)` method takes [`int_mask::W`](W) writer structure"]
impl crate :: Writable for IntMaskSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_MASK to value 0"]
impl crate :: Resettable for IntMaskSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INT_CLEAR (rw) register accessor: Регистр сброса флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_clear::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_clear::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_clear`]
module"]
# [doc (alias = "INT_CLEAR")]
pub type IntClear = crate :: Reg < int_clear :: IntClearSpec > ; # [doc = "Регистр сброса флагов прерываний"]
pub mod int_clear { # [doc = "Register `INT_CLEAR` reader"]
pub type R = crate :: R < IntClearSpec > ; # [doc = "Register `INT_CLEAR` writer"]
pub type W = crate :: W < IntClearSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр сброса флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_clear::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_clear::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntClearSpec ; impl crate :: RegisterSpec for IntClearSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`int_clear::R`](R) reader structure"]
impl crate :: Readable for IntClearSpec { } # [doc = "`write(|w| ..)` method takes [`int_clear::W`](W) writer structure"]
impl crate :: Writable for IntClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_CLEAR to value 0xffff_ffff"]
impl crate :: Resettable for IntClearSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } } # [doc = "INT_FLAG (rw) register accessor: Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`]
module"]
# [doc (alias = "INT_FLAG")]
pub type IntFlag = crate :: Reg < int_flag :: IntFlagSpec > ; # [doc = "Регистр флагов прерываний"]
pub mod int_flag { # [doc = "Register `INT_FLAG` reader"]
pub type R = crate :: R < IntFlagSpec > ; # [doc = "Register `INT_FLAG` writer"]
pub type W = crate :: W < IntFlagSpec > ; # [doc = "Field `OVF_Int` reader - Статус прерывания по переполнению счетчика"]
pub type OvfIntR = crate :: BitReader ; # [doc = "Field `UDF_Int` reader - Статус прерывания опустошения счетчика"]
pub type UdfIntR = crate :: BitReader ; # [doc = "Field `IC_Int_CH1` reader - Статус прерывания захвата 1 канала таймера"]
pub type IcIntCh1R = crate :: BitReader ; # [doc = "Field `IC_Int_CH2` reader - Статус прерывания захвата 2 канала таймера"]
pub type IcIntCh2R = crate :: BitReader ; # [doc = "Field `IC_Int_CH3` reader - Статус прерывания захвата 3 канала таймера"]
pub type IcIntCh3R = crate :: BitReader ; # [doc = "Field `IC_Int_CH4` reader - Статус прерывания захвата 4 канала таймера"]
pub type IcIntCh4R = crate :: BitReader ; # [doc = "Field `OC_Int_CH1` reader - Статус прерывания совпадения 1 канала таймера"]
pub type OcIntCh1R = crate :: BitReader ; # [doc = "Field `OC_Int_CH2` reader - Статус прерывания совпадения 2 канала таймера"]
pub type OcIntCh2R = crate :: BitReader ; # [doc = "Field `OC_Int_CH3` reader - Статус прерывания совпадения 3 канала таймера"]
pub type OcIntCh3R = crate :: BitReader ; # [doc = "Field `OC_Int_CH4` reader - Статус прерывания совпадения 4 канала таймера"]
pub type OcIntCh4R = crate :: BitReader ; impl R { # [doc = "Bit 0 - Статус прерывания по переполнению счетчика"]
# [inline (always)]
pub fn ovf_int (& self) -> OvfIntR { OvfIntR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Статус прерывания опустошения счетчика"]
# [inline (always)]
pub fn udf_int (& self) -> UdfIntR { UdfIntR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Статус прерывания захвата 1 канала таймера"]
# [inline (always)]
pub fn ic_int_ch1 (& self) -> IcIntCh1R { IcIntCh1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Статус прерывания захвата 2 канала таймера"]
# [inline (always)]
pub fn ic_int_ch2 (& self) -> IcIntCh2R { IcIntCh2R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Статус прерывания захвата 3 канала таймера"]
# [inline (always)]
pub fn ic_int_ch3 (& self) -> IcIntCh3R { IcIntCh3R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Статус прерывания захвата 4 канала таймера"]
# [inline (always)]
pub fn ic_int_ch4 (& self) -> IcIntCh4R { IcIntCh4R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Статус прерывания совпадения 1 канала таймера"]
# [inline (always)]
pub fn oc_int_ch1 (& self) -> OcIntCh1R { OcIntCh1R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Статус прерывания совпадения 2 канала таймера"]
# [inline (always)]
pub fn oc_int_ch2 (& self) -> OcIntCh2R { OcIntCh2R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Статус прерывания совпадения 3 канала таймера"]
# [inline (always)]
pub fn oc_int_ch3 (& self) -> OcIntCh3R { OcIntCh3R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Статус прерывания совпадения 4 канала таймера"]
# [inline (always)]
pub fn oc_int_ch4 (& self) -> OcIntCh4R { OcIntCh4R :: new (((self . bits >> 9) & 1) != 0) } } impl W { } # [doc = "Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntFlagSpec ; impl crate :: RegisterSpec for IntFlagSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`int_flag::R`](R) reader structure"]
impl crate :: Readable for IntFlagSpec { } # [doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"]
impl crate :: Writable for IntFlagSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_FLAG to value 0"]
impl crate :: Resettable for IntFlagSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Управление монитором напряжения VCC"]
pub struct PvdVcc { _marker : PhantomData < * const () > } unsafe impl Send for PvdVcc { } impl PvdVcc { # [doc = r"Pointer to the register block"]
pub const PTR : * const pvd_vcc :: RegisterBlock = 0x0005_1800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pvd_vcc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for PvdVcc { type Target = pvd_vcc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PvdVcc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PvdVcc") . finish () } } # [doc = "Управление монитором напряжения VCC"]
pub mod pvd_vcc { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { dpf_value : DpfValue , config : Config , status : Status , } impl RegisterBlock { # [doc = "0x00 - Настройка цифрового фильтра"]
# [inline (always)]
pub const fn dpf_value (& self) -> & DpfValue { & self . dpf_value } # [doc = "0x04 - Регистр настроек"]
# [inline (always)]
pub const fn config (& self) -> & Config { & self . config } # [doc = "0x08 - Регистр статуса"]
# [inline (always)]
pub const fn status (& self) -> & Status { & self . status } } # [doc = "DPF_VALUE (rw) register accessor: Настройка цифрового фильтра\n\nYou can [`read`](crate::Reg::read) this register and get [`dpf_value::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dpf_value::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dpf_value`]
module"]
# [doc (alias = "DPF_VALUE")]
pub type DpfValue = crate :: Reg < dpf_value :: DpfValueSpec > ; # [doc = "Настройка цифрового фильтра"]
pub mod dpf_value { # [doc = "Register `DPF_VALUE` reader"]
pub type R = crate :: R < DpfValueSpec > ; # [doc = "Register `DPF_VALUE` writer"]
pub type W = crate :: W < DpfValueSpec > ; # [doc = "Field `DPF` reader - Коэффициент, определяющий длительность отфильтровываемых импульсов (на системной частоте)"]
pub type DpfR = crate :: FieldReader < u16 > ; # [doc = "Field `DPF` writer - Коэффициент, определяющий длительность отфильтровываемых импульсов (на системной частоте)"]
pub type DpfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - Коэффициент, определяющий длительность отфильтровываемых импульсов (на системной частоте)"]
# [inline (always)]
pub fn dpf (& self) -> DpfR { DpfR :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15 - Коэффициент, определяющий длительность отфильтровываемых импульсов (на системной частоте)"]
# [inline (always)]
pub fn dpf (& mut self) -> DpfW < DpfValueSpec > { DpfW :: new (self , 0) } } # [doc = "Настройка цифрового фильтра\n\nYou can [`read`](crate::Reg::read) this register and get [`dpf_value::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dpf_value::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DpfValueSpec ; impl crate :: RegisterSpec for DpfValueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dpf_value::R`](R) reader structure"]
impl crate :: Readable for DpfValueSpec { } # [doc = "`write(|w| ..)` method takes [`dpf_value::W`](W) writer structure"]
impl crate :: Writable for DpfValueSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DPF_VALUE to value 0x05dc"]
impl crate :: Resettable for DpfValueSpec { const RESET_VALUE : u32 = 0x05dc ; } } # [doc = "CONFIG (rw) register accessor: Регистр настроек\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@config`]
module"]
# [doc (alias = "CONFIG")]
pub type Config = crate :: Reg < config :: ConfigSpec > ; # [doc = "Регистр настроек"]
pub mod config { # [doc = "Register `CONFIG` reader"]
pub type R = crate :: R < ConfigSpec > ; # [doc = "Register `CONFIG` writer"]
pub type W = crate :: W < ConfigSpec > ; # [doc = "Управление питанием монитора\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pd { # [doc = "0: Монитор включен"]
Enable = 0 , # [doc = "1: Монитор выключен"]
Disable = 1 , } impl From < Pd > for bool { # [inline (always)]
fn from (variant : Pd) -> Self { variant as u8 != 0 } } # [doc = "Field `PD` reader - Управление питанием монитора"]
pub type PdR = crate :: BitReader < Pd > ; impl PdR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pd { match self . bits { false => Pd :: Enable , true => Pd :: Disable , } } # [doc = "Монитор включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Pd :: Enable } # [doc = "Монитор выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Pd :: Disable } } # [doc = "Field `PD` writer - Управление питанием монитора"]
pub type PdW < 'a , REG > = crate :: BitWriter < 'a , REG , Pd > ; impl < 'a , REG > PdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Монитор включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Pd :: Enable) } # [doc = "Монитор выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Pd :: Disable) } } # [doc = "Отключение (сброс) детектирования нижнего порога\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nresetu { # [doc = "0: Детектирование не выполняется, схема в состоянии сброса"]
Reset = 0 , # [doc = "1: Нормальная работа"]
Normal = 1 , } impl From < Nresetu > for bool { # [inline (always)]
fn from (variant : Nresetu) -> Self { variant as u8 != 0 } } # [doc = "Field `NRESETU` reader - Отключение (сброс) детектирования нижнего порога"]
pub type NresetuR = crate :: BitReader < Nresetu > ; impl NresetuR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nresetu { match self . bits { false => Nresetu :: Reset , true => Nresetu :: Normal , } } # [doc = "Детектирование не выполняется, схема в состоянии сброса"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == Nresetu :: Reset } # [doc = "Нормальная работа"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == Nresetu :: Normal } } # [doc = "Field `NRESETU` writer - Отключение (сброс) детектирования нижнего порога"]
pub type NresetuW < 'a , REG > = crate :: BitWriter < 'a , REG , Nresetu > ; impl < 'a , REG > NresetuW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Детектирование не выполняется, схема в состоянии сброса"]
# [inline (always)]
pub fn reset (self) -> & 'a mut crate :: W < REG > { self . variant (Nresetu :: Reset) } # [doc = "Нормальная работа"]
# [inline (always)]
pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Nresetu :: Normal) } } # [doc = "Отключение (сброс) детектирования вехнего порога\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nreseto { # [doc = "0: Детектирование не выполняется, схема в состоянии сброса"]
Reset = 0 , # [doc = "1: Нормальная работа"]
Normal = 1 , } impl From < Nreseto > for bool { # [inline (always)]
fn from (variant : Nreseto) -> Self { variant as u8 != 0 } } # [doc = "Field `NRESETO` reader - Отключение (сброс) детектирования вехнего порога"]
pub type NresetoR = crate :: BitReader < Nreseto > ; impl NresetoR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nreseto { match self . bits { false => Nreseto :: Reset , true => Nreseto :: Normal , } } # [doc = "Детектирование не выполняется, схема в состоянии сброса"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == Nreseto :: Reset } # [doc = "Нормальная работа"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == Nreseto :: Normal } } # [doc = "Field `NRESETO` writer - Отключение (сброс) детектирования вехнего порога"]
pub type NresetoW < 'a , REG > = crate :: BitWriter < 'a , REG , Nreseto > ; impl < 'a , REG > NresetoW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Детектирование не выполняется, схема в состоянии сброса"]
# [inline (always)]
pub fn reset (self) -> & 'a mut crate :: W < REG > { self . variant (Nreseto :: Reset) } # [doc = "Нормальная работа"]
# [inline (always)]
pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Nreseto :: Normal) } } # [doc = "Field `TESTMODE` reader - Переход в тестовый режим"]
pub type TestmodeR = crate :: BitReader ; # [doc = "Field `TESTMODE` writer - Переход в тестовый режим"]
pub type TestmodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `UNDER_THRESH` reader - Нижний порог срабатывания монитора"]
pub type UnderThreshR = crate :: FieldReader ; # [doc = "Field `UNDER_THRESH` writer - Нижний порог срабатывания монитора"]
pub type UnderThreshW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `OVER_THRESH` reader - Верхний порог срабатывания монитора"]
pub type OverThreshR = crate :: FieldReader ; # [doc = "Field `OVER_THRESH` writer - Верхний порог срабатывания монитора"]
pub type OverThreshW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `EN_VREFCLB` reader - Использование в качестве опорного источника напряжения каллибруемый ОИН"]
pub type EnVrefclbR = crate :: BitReader ; # [doc = "Field `EN_VREFCLB` writer - Использование в качестве опорного источника напряжения каллибруемый ОИН"]
pub type EnVrefclbW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Управление питанием монитора"]
# [inline (always)]
pub fn pd (& self) -> PdR { PdR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Отключение (сброс) детектирования нижнего порога"]
# [inline (always)]
pub fn nresetu (& self) -> NresetuR { NresetuR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Отключение (сброс) детектирования вехнего порога"]
# [inline (always)]
pub fn nreseto (& self) -> NresetoR { NresetoR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Переход в тестовый режим"]
# [inline (always)]
pub fn testmode (& self) -> TestmodeR { TestmodeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:7 - Нижний порог срабатывания монитора"]
# [inline (always)]
pub fn under_thresh (& self) -> UnderThreshR { UnderThreshR :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bits 8:11 - Верхний порог срабатывания монитора"]
# [inline (always)]
pub fn over_thresh (& self) -> OverThreshR { OverThreshR :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bit 12 - Использование в качестве опорного источника напряжения каллибруемый ОИН"]
# [inline (always)]
pub fn en_vrefclb (& self) -> EnVrefclbR { EnVrefclbR :: new (((self . bits >> 12) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление питанием монитора"]
# [inline (always)]
pub fn pd (& mut self) -> PdW < ConfigSpec > { PdW :: new (self , 0) } # [doc = "Bit 1 - Отключение (сброс) детектирования нижнего порога"]
# [inline (always)]
pub fn nresetu (& mut self) -> NresetuW < ConfigSpec > { NresetuW :: new (self , 1) } # [doc = "Bit 2 - Отключение (сброс) детектирования вехнего порога"]
# [inline (always)]
pub fn nreseto (& mut self) -> NresetoW < ConfigSpec > { NresetoW :: new (self , 2) } # [doc = "Bit 3 - Переход в тестовый режим"]
# [inline (always)]
pub fn testmode (& mut self) -> TestmodeW < ConfigSpec > { TestmodeW :: new (self , 3) } # [doc = "Bits 4:7 - Нижний порог срабатывания монитора"]
# [inline (always)]
pub fn under_thresh (& mut self) -> UnderThreshW < ConfigSpec > { UnderThreshW :: new (self , 4) } # [doc = "Bits 8:11 - Верхний порог срабатывания монитора"]
# [inline (always)]
pub fn over_thresh (& mut self) -> OverThreshW < ConfigSpec > { OverThreshW :: new (self , 8) } # [doc = "Bit 12 - Использование в качестве опорного источника напряжения каллибруемый ОИН"]
# [inline (always)]
pub fn en_vrefclb (& mut self) -> EnVrefclbW < ConfigSpec > { EnVrefclbW :: new (self , 12) } } # [doc = "Регистр настроек\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ConfigSpec ; impl crate :: RegisterSpec for ConfigSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`config::R`](R) reader structure"]
impl crate :: Readable for ConfigSpec { } # [doc = "`write(|w| ..)` method takes [`config::W`](W) writer structure"]
impl crate :: Writable for ConfigSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONFIG to value 0x01"]
impl crate :: Resettable for ConfigSpec { const RESET_VALUE : u32 = 0x01 ; } } # [doc = "STATUS (r) register accessor: Регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@status`]
module"]
# [doc (alias = "STATUS")]
pub type Status = crate :: Reg < status :: StatusSpec > ; # [doc = "Регистр статуса"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub type R = crate :: R < StatusSpec > ; # [doc = "Field `OUT_UNDER_VALUE` reader - Текущее состояние линии монитора нижнего порога без цифровой фильтрации"]
pub type OutUnderValueR = crate :: BitReader ; # [doc = "Field `OUT_OVER_VALUE` reader - Текущее состояние линии монитора верхнего порога без цифровой фильтрации"]
pub type OutOverValueR = crate :: BitReader ; # [doc = "Field `OUT_UNDER_FLAG` reader - Текущее состояние линии монитора нижнего порога с учетом цифровой фильтрации"]
pub type OutUnderFlagR = crate :: BitReader ; # [doc = "Field `OUT_OVER_FLAG` reader - Текущее состояние линии монитора верхнего порога с учетом цифровой фильтрации"]
pub type OutOverFlagR = crate :: BitReader ; impl R { # [doc = "Bit 0 - Текущее состояние линии монитора нижнего порога без цифровой фильтрации"]
# [inline (always)]
pub fn out_under_value (& self) -> OutUnderValueR { OutUnderValueR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Текущее состояние линии монитора верхнего порога без цифровой фильтрации"]
# [inline (always)]
pub fn out_over_value (& self) -> OutOverValueR { OutOverValueR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Текущее состояние линии монитора нижнего порога с учетом цифровой фильтрации"]
# [inline (always)]
pub fn out_under_flag (& self) -> OutUnderFlagR { OutUnderFlagR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Текущее состояние линии монитора верхнего порога с учетом цифровой фильтрации"]
# [inline (always)]
pub fn out_over_flag (& self) -> OutOverFlagR { OutOverFlagR :: new (((self . bits >> 3) & 1) != 0) } } # [doc = "Регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StatusSpec ; impl crate :: RegisterSpec for StatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`status::R`](R) reader structure"]
impl crate :: Readable for StatusSpec { } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for StatusSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Модуль управления функцией ввода/вывода"]
pub struct PadConfig { _marker : PhantomData < * const () > } unsafe impl Send for PadConfig { } impl PadConfig { # [doc = r"Pointer to the register block"]
pub const PTR : * const pad_config :: RegisterBlock = 0x0005_0c00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pad_config :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for PadConfig { type Target = pad_config :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PadConfig { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PadConfig") . finish () } } # [doc = "Модуль управления функцией ввода/вывода"]
pub mod pad_config { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { pad0_cfg : Pad0Cfg , pad0_ds : Pad0Ds , pad0_pupd : Pad0Pupd , pad1_cfg : Pad1Cfg , pad1_ds : Pad1Ds , pad1_pupd : Pad1Pupd , pad2_cfg : Pad2Cfg , pad2_ds : Pad2Ds , pad2_pupd : Pad2Pupd , } impl RegisterBlock { # [doc = "0x00 - Управление функциями выводов PORT0"]
# [inline (always)]
pub const fn pad0_cfg (& self) -> & Pad0Cfg { & self . pad0_cfg } # [doc = "0x04 - Управление нагрузочной способностью выводов PORT0"]
# [inline (always)]
pub const fn pad0_ds (& self) -> & Pad0Ds { & self . pad0_ds } # [doc = "0x08 - Управление резисторами подтяжки выводов PORT0"]
# [inline (always)]
pub const fn pad0_pupd (& self) -> & Pad0Pupd { & self . pad0_pupd } # [doc = "0x0c - Управление функциями выводов PORT1"]
# [inline (always)]
pub const fn pad1_cfg (& self) -> & Pad1Cfg { & self . pad1_cfg } # [doc = "0x10 - Управление нагрузочной способностью выводов PORT1"]
# [inline (always)]
pub const fn pad1_ds (& self) -> & Pad1Ds { & self . pad1_ds } # [doc = "0x14 - Управление резисторами подтяжки выводов PORT1"]
# [inline (always)]
pub const fn pad1_pupd (& self) -> & Pad1Pupd { & self . pad1_pupd } # [doc = "0x18 - Управление функциями выводов PORT2"]
# [inline (always)]
pub const fn pad2_cfg (& self) -> & Pad2Cfg { & self . pad2_cfg } # [doc = "0x1c - Управление нагрузочной способностью выводов PORT2"]
# [inline (always)]
pub const fn pad2_ds (& self) -> & Pad2Ds { & self . pad2_ds } # [doc = "0x20 - Управление резисторами подтяжки выводов PORT2"]
# [inline (always)]
pub const fn pad2_pupd (& self) -> & Pad2Pupd { & self . pad2_pupd } } # [doc = "PAD0_CFG (rw) register accessor: Управление функциями выводов PORT0\n\nYou can [`read`](crate::Reg::read) this register and get [`pad0_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad0_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pad0_cfg`]
module"]
# [doc (alias = "PAD0_CFG")]
pub type Pad0Cfg = crate :: Reg < pad0_cfg :: Pad0CfgSpec > ; # [doc = "Управление функциями выводов PORT0"]
pub mod pad0_cfg { # [doc = "Register `PAD0_CFG` reader"]
pub type R = crate :: R < Pad0CfgSpec > ; # [doc = "Register `PAD0_CFG` writer"]
pub type W = crate :: W < Pad0CfgSpec > ; # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_0 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_0 > for u8 { # [inline (always)]
fn from (variant : Port0_0) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_0 { type Ux = u8 ; } impl crate :: IsEnum for Port0_0 { } # [doc = "Field `Port_0_0` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_0R = crate :: FieldReader < Port0_0 > ; impl Port0_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_0 { match self . bits { 0 => Port0_0 :: Func1Gpio , 1 => Port0_0 :: Func2Interface , 2 => Port0_0 :: Func3InterfaceOrTimer , 3 => Port0_0 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_0 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_0 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_0 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_0 :: Func4Analog } } # [doc = "Field `Port_0_0` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_0 , crate :: Safe > ; impl < 'a , REG > Port0_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_0 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_0 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_0 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_0 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_1 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_1 > for u8 { # [inline (always)]
fn from (variant : Port0_1) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_1 { type Ux = u8 ; } impl crate :: IsEnum for Port0_1 { } # [doc = "Field `Port_0_1` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_1R = crate :: FieldReader < Port0_1 > ; impl Port0_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_1 { match self . bits { 0 => Port0_1 :: Func1Gpio , 1 => Port0_1 :: Func2Interface , 2 => Port0_1 :: Func3InterfaceOrTimer , 3 => Port0_1 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_1 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_1 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_1 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_1 :: Func4Analog } } # [doc = "Field `Port_0_1` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_1 , crate :: Safe > ; impl < 'a , REG > Port0_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_1 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_1 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_1 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_1 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_2 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_2 > for u8 { # [inline (always)]
fn from (variant : Port0_2) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_2 { type Ux = u8 ; } impl crate :: IsEnum for Port0_2 { } # [doc = "Field `Port_0_2` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_2R = crate :: FieldReader < Port0_2 > ; impl Port0_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_2 { match self . bits { 0 => Port0_2 :: Func1Gpio , 1 => Port0_2 :: Func2Interface , 2 => Port0_2 :: Func3InterfaceOrTimer , 3 => Port0_2 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_2 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_2 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_2 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_2 :: Func4Analog } } # [doc = "Field `Port_0_2` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_2 , crate :: Safe > ; impl < 'a , REG > Port0_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_2 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_2 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_2 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_2 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_3 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_3 > for u8 { # [inline (always)]
fn from (variant : Port0_3) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_3 { type Ux = u8 ; } impl crate :: IsEnum for Port0_3 { } # [doc = "Field `Port_0_3` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_3R = crate :: FieldReader < Port0_3 > ; impl Port0_3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_3 { match self . bits { 0 => Port0_3 :: Func1Gpio , 1 => Port0_3 :: Func2Interface , 2 => Port0_3 :: Func3InterfaceOrTimer , 3 => Port0_3 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_3 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_3 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_3 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_3 :: Func4Analog } } # [doc = "Field `Port_0_3` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_3 , crate :: Safe > ; impl < 'a , REG > Port0_3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_3 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_3 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_3 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_3 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_4 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_4 > for u8 { # [inline (always)]
fn from (variant : Port0_4) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_4 { type Ux = u8 ; } impl crate :: IsEnum for Port0_4 { } # [doc = "Field `Port_0_4` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_4R = crate :: FieldReader < Port0_4 > ; impl Port0_4R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_4 { match self . bits { 0 => Port0_4 :: Func1Gpio , 1 => Port0_4 :: Func2Interface , 2 => Port0_4 :: Func3InterfaceOrTimer , 3 => Port0_4 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_4 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_4 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_4 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_4 :: Func4Analog } } # [doc = "Field `Port_0_4` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_4 , crate :: Safe > ; impl < 'a , REG > Port0_4W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_4 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_4 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_4 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_4 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_5 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_5 > for u8 { # [inline (always)]
fn from (variant : Port0_5) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_5 { type Ux = u8 ; } impl crate :: IsEnum for Port0_5 { } # [doc = "Field `Port_0_5` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_5R = crate :: FieldReader < Port0_5 > ; impl Port0_5R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_5 { match self . bits { 0 => Port0_5 :: Func1Gpio , 1 => Port0_5 :: Func2Interface , 2 => Port0_5 :: Func3InterfaceOrTimer , 3 => Port0_5 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_5 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_5 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_5 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_5 :: Func4Analog } } # [doc = "Field `Port_0_5` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_5 , crate :: Safe > ; impl < 'a , REG > Port0_5W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_5 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_5 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_5 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_5 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_6 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_6 > for u8 { # [inline (always)]
fn from (variant : Port0_6) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_6 { type Ux = u8 ; } impl crate :: IsEnum for Port0_6 { } # [doc = "Field `Port_0_6` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_6R = crate :: FieldReader < Port0_6 > ; impl Port0_6R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_6 { match self . bits { 0 => Port0_6 :: Func1Gpio , 1 => Port0_6 :: Func2Interface , 2 => Port0_6 :: Func3InterfaceOrTimer , 3 => Port0_6 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_6 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_6 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_6 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_6 :: Func4Analog } } # [doc = "Field `Port_0_6` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_6 , crate :: Safe > ; impl < 'a , REG > Port0_6W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_6 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_6 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_6 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_6 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_7 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_7 > for u8 { # [inline (always)]
fn from (variant : Port0_7) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_7 { type Ux = u8 ; } impl crate :: IsEnum for Port0_7 { } # [doc = "Field `Port_0_7` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_7R = crate :: FieldReader < Port0_7 > ; impl Port0_7R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_7 { match self . bits { 0 => Port0_7 :: Func1Gpio , 1 => Port0_7 :: Func2Interface , 2 => Port0_7 :: Func3InterfaceOrTimer , 3 => Port0_7 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_7 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_7 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_7 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_7 :: Func4Analog } } # [doc = "Field `Port_0_7` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_7 , crate :: Safe > ; impl < 'a , REG > Port0_7W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_7 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_7 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_7 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_7 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_8 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_8 > for u8 { # [inline (always)]
fn from (variant : Port0_8) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_8 { type Ux = u8 ; } impl crate :: IsEnum for Port0_8 { } # [doc = "Field `Port_0_8` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_8R = crate :: FieldReader < Port0_8 > ; impl Port0_8R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_8 { match self . bits { 0 => Port0_8 :: Func1Gpio , 1 => Port0_8 :: Func2Interface , 2 => Port0_8 :: Func3InterfaceOrTimer , 3 => Port0_8 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_8 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_8 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_8 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_8 :: Func4Analog } } # [doc = "Field `Port_0_8` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_8 , crate :: Safe > ; impl < 'a , REG > Port0_8W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_8 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_8 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_8 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_8 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_9 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_9 > for u8 { # [inline (always)]
fn from (variant : Port0_9) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_9 { type Ux = u8 ; } impl crate :: IsEnum for Port0_9 { } # [doc = "Field `Port_0_9` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_9R = crate :: FieldReader < Port0_9 > ; impl Port0_9R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_9 { match self . bits { 0 => Port0_9 :: Func1Gpio , 1 => Port0_9 :: Func2Interface , 2 => Port0_9 :: Func3InterfaceOrTimer , 3 => Port0_9 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_9 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_9 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_9 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_9 :: Func4Analog } } # [doc = "Field `Port_0_9` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_9 , crate :: Safe > ; impl < 'a , REG > Port0_9W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_9 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_9 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_9 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_9 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_10 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_10 > for u8 { # [inline (always)]
fn from (variant : Port0_10) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_10 { type Ux = u8 ; } impl crate :: IsEnum for Port0_10 { } # [doc = "Field `Port_0_10` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_10R = crate :: FieldReader < Port0_10 > ; impl Port0_10R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_10 { match self . bits { 0 => Port0_10 :: Func1Gpio , 1 => Port0_10 :: Func2Interface , 2 => Port0_10 :: Func3InterfaceOrTimer , 3 => Port0_10 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_10 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_10 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_10 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_10 :: Func4Analog } } # [doc = "Field `Port_0_10` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_10 , crate :: Safe > ; impl < 'a , REG > Port0_10W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_10 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_10 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_10 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_10 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_11 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_11 > for u8 { # [inline (always)]
fn from (variant : Port0_11) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_11 { type Ux = u8 ; } impl crate :: IsEnum for Port0_11 { } # [doc = "Field `Port_0_11` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_11R = crate :: FieldReader < Port0_11 > ; impl Port0_11R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_11 { match self . bits { 0 => Port0_11 :: Func1Gpio , 1 => Port0_11 :: Func2Interface , 2 => Port0_11 :: Func3InterfaceOrTimer , 3 => Port0_11 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_11 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_11 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_11 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_11 :: Func4Analog } } # [doc = "Field `Port_0_11` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_11 , crate :: Safe > ; impl < 'a , REG > Port0_11W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_11 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_11 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_11 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_11 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_12 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_12 > for u8 { # [inline (always)]
fn from (variant : Port0_12) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_12 { type Ux = u8 ; } impl crate :: IsEnum for Port0_12 { } # [doc = "Field `Port_0_12` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_12R = crate :: FieldReader < Port0_12 > ; impl Port0_12R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_12 { match self . bits { 0 => Port0_12 :: Func1Gpio , 1 => Port0_12 :: Func2Interface , 2 => Port0_12 :: Func3InterfaceOrTimer , 3 => Port0_12 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_12 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_12 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_12 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_12 :: Func4Analog } } # [doc = "Field `Port_0_12` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_12 , crate :: Safe > ; impl < 'a , REG > Port0_12W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_12 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_12 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_12 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_12 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_13 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_13 > for u8 { # [inline (always)]
fn from (variant : Port0_13) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_13 { type Ux = u8 ; } impl crate :: IsEnum for Port0_13 { } # [doc = "Field `Port_0_13` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_13R = crate :: FieldReader < Port0_13 > ; impl Port0_13R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_13 { match self . bits { 0 => Port0_13 :: Func1Gpio , 1 => Port0_13 :: Func2Interface , 2 => Port0_13 :: Func3InterfaceOrTimer , 3 => Port0_13 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_13 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_13 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_13 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_13 :: Func4Analog } } # [doc = "Field `Port_0_13` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_13 , crate :: Safe > ; impl < 'a , REG > Port0_13W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_13 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_13 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_13 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_13 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_14 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_14 > for u8 { # [inline (always)]
fn from (variant : Port0_14) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_14 { type Ux = u8 ; } impl crate :: IsEnum for Port0_14 { } # [doc = "Field `Port_0_14` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_14R = crate :: FieldReader < Port0_14 > ; impl Port0_14R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_14 { match self . bits { 0 => Port0_14 :: Func1Gpio , 1 => Port0_14 :: Func2Interface , 2 => Port0_14 :: Func3InterfaceOrTimer , 3 => Port0_14 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_14 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_14 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_14 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_14 :: Func4Analog } } # [doc = "Field `Port_0_14` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_14 , crate :: Safe > ; impl < 'a , REG > Port0_14W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_14 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_14 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_14 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_14 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_15 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port0_15 > for u8 { # [inline (always)]
fn from (variant : Port0_15) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_15 { type Ux = u8 ; } impl crate :: IsEnum for Port0_15 { } # [doc = "Field `Port_0_15` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_15R = crate :: FieldReader < Port0_15 > ; impl Port0_15R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port0_15 { match self . bits { 0 => Port0_15 :: Func1Gpio , 1 => Port0_15 :: Func2Interface , 2 => Port0_15 :: Func3InterfaceOrTimer , 3 => Port0_15 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port0_15 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port0_15 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port0_15 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port0_15 :: Func4Analog } } # [doc = "Field `Port_0_15` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port0_15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_15 , crate :: Safe > ; impl < 'a , REG > Port0_15W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_15 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_15 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_15 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_15 :: Func4Analog) } } impl R { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_0 (& self) -> Port0_0R { Port0_0R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_1 (& self) -> Port0_1R { Port0_1R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_2 (& self) -> Port0_2R { Port0_2R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_3 (& self) -> Port0_3R { Port0_3R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_4 (& self) -> Port0_4R { Port0_4R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_5 (& self) -> Port0_5R { Port0_5R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_6 (& self) -> Port0_6R { Port0_6R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_7 (& self) -> Port0_7R { Port0_7R :: new (((self . bits >> 14) & 3) as u8) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_8 (& self) -> Port0_8R { Port0_8R :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_9 (& self) -> Port0_9R { Port0_9R :: new (((self . bits >> 18) & 3) as u8) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_10 (& self) -> Port0_10R { Port0_10R :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_11 (& self) -> Port0_11R { Port0_11R :: new (((self . bits >> 22) & 3) as u8) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_12 (& self) -> Port0_12R { Port0_12R :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_13 (& self) -> Port0_13R { Port0_13R :: new (((self . bits >> 26) & 3) as u8) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_14 (& self) -> Port0_14R { Port0_14R :: new (((self . bits >> 28) & 3) as u8) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_15 (& self) -> Port0_15R { Port0_15R :: new (((self . bits >> 30) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_0 (& mut self) -> Port0_0W < Pad0CfgSpec > { Port0_0W :: new (self , 0) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_1 (& mut self) -> Port0_1W < Pad0CfgSpec > { Port0_1W :: new (self , 2) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_2 (& mut self) -> Port0_2W < Pad0CfgSpec > { Port0_2W :: new (self , 4) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_3 (& mut self) -> Port0_3W < Pad0CfgSpec > { Port0_3W :: new (self , 6) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_4 (& mut self) -> Port0_4W < Pad0CfgSpec > { Port0_4W :: new (self , 8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_5 (& mut self) -> Port0_5W < Pad0CfgSpec > { Port0_5W :: new (self , 10) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_6 (& mut self) -> Port0_6W < Pad0CfgSpec > { Port0_6W :: new (self , 12) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_7 (& mut self) -> Port0_7W < Pad0CfgSpec > { Port0_7W :: new (self , 14) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_8 (& mut self) -> Port0_8W < Pad0CfgSpec > { Port0_8W :: new (self , 16) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_9 (& mut self) -> Port0_9W < Pad0CfgSpec > { Port0_9W :: new (self , 18) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_10 (& mut self) -> Port0_10W < Pad0CfgSpec > { Port0_10W :: new (self , 20) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_11 (& mut self) -> Port0_11W < Pad0CfgSpec > { Port0_11W :: new (self , 22) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_12 (& mut self) -> Port0_12W < Pad0CfgSpec > { Port0_12W :: new (self , 24) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_13 (& mut self) -> Port0_13W < Pad0CfgSpec > { Port0_13W :: new (self , 26) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_14 (& mut self) -> Port0_14W < Pad0CfgSpec > { Port0_14W :: new (self , 28) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_0_15 (& mut self) -> Port0_15W < Pad0CfgSpec > { Port0_15W :: new (self , 30) } } # [doc = "Управление функциями выводов PORT0\n\nYou can [`read`](crate::Reg::read) this register and get [`pad0_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad0_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Pad0CfgSpec ; impl crate :: RegisterSpec for Pad0CfgSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`pad0_cfg::R`](R) reader structure"]
impl crate :: Readable for Pad0CfgSpec { } # [doc = "`write(|w| ..)` method takes [`pad0_cfg::W`](W) writer structure"]
impl crate :: Writable for Pad0CfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PAD0_CFG to value 0x5540_0000"]
impl crate :: Resettable for Pad0CfgSpec { const RESET_VALUE : u32 = 0x5540_0000 ; } } # [doc = "PAD0_DS (rw) register accessor: Управление нагрузочной способностью выводов PORT0\n\nYou can [`read`](crate::Reg::read) this register and get [`pad0_ds::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad0_ds::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pad0_ds`]
module"]
# [doc (alias = "PAD0_DS")]
pub type Pad0Ds = crate :: Reg < pad0_ds :: Pad0DsSpec > ; # [doc = "Управление нагрузочной способностью выводов PORT0"]
pub mod pad0_ds { # [doc = "Register `PAD0_DS` reader"]
pub type R = crate :: R < Pad0DsSpec > ; # [doc = "Register `PAD0_DS` writer"]
pub type W = crate :: W < Pad0DsSpec > ; # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_0 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_0 > for u8 { # [inline (always)]
fn from (variant : Port0_0) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_0 { type Ux = u8 ; } impl crate :: IsEnum for Port0_0 { } # [doc = "Field `Port_0_0` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_0R = crate :: FieldReader < Port0_0 > ; impl Port0_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_0 > { match self . bits { 0 => Some (Port0_0 :: _2mA) , 1 => Some (Port0_0 :: _4mA) , 2 => Some (Port0_0 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_0 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_0 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_0 :: _8mA } } # [doc = "Field `Port_0_0` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_0 > ; impl < 'a , REG > Port0_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_0 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_0 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_0 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_1 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_1 > for u8 { # [inline (always)]
fn from (variant : Port0_1) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_1 { type Ux = u8 ; } impl crate :: IsEnum for Port0_1 { } # [doc = "Field `Port_0_1` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_1R = crate :: FieldReader < Port0_1 > ; impl Port0_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_1 > { match self . bits { 0 => Some (Port0_1 :: _2mA) , 1 => Some (Port0_1 :: _4mA) , 2 => Some (Port0_1 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_1 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_1 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_1 :: _8mA } } # [doc = "Field `Port_0_1` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_1 > ; impl < 'a , REG > Port0_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_1 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_1 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_1 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_2 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_2 > for u8 { # [inline (always)]
fn from (variant : Port0_2) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_2 { type Ux = u8 ; } impl crate :: IsEnum for Port0_2 { } # [doc = "Field `Port_0_2` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_2R = crate :: FieldReader < Port0_2 > ; impl Port0_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_2 > { match self . bits { 0 => Some (Port0_2 :: _2mA) , 1 => Some (Port0_2 :: _4mA) , 2 => Some (Port0_2 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_2 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_2 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_2 :: _8mA } } # [doc = "Field `Port_0_2` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_2 > ; impl < 'a , REG > Port0_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_2 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_2 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_2 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_3 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_3 > for u8 { # [inline (always)]
fn from (variant : Port0_3) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_3 { type Ux = u8 ; } impl crate :: IsEnum for Port0_3 { } # [doc = "Field `Port_0_3` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_3R = crate :: FieldReader < Port0_3 > ; impl Port0_3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_3 > { match self . bits { 0 => Some (Port0_3 :: _2mA) , 1 => Some (Port0_3 :: _4mA) , 2 => Some (Port0_3 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_3 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_3 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_3 :: _8mA } } # [doc = "Field `Port_0_3` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_3 > ; impl < 'a , REG > Port0_3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_3 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_3 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_3 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_4 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_4 > for u8 { # [inline (always)]
fn from (variant : Port0_4) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_4 { type Ux = u8 ; } impl crate :: IsEnum for Port0_4 { } # [doc = "Field `Port_0_4` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_4R = crate :: FieldReader < Port0_4 > ; impl Port0_4R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_4 > { match self . bits { 0 => Some (Port0_4 :: _2mA) , 1 => Some (Port0_4 :: _4mA) , 2 => Some (Port0_4 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_4 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_4 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_4 :: _8mA } } # [doc = "Field `Port_0_4` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_4 > ; impl < 'a , REG > Port0_4W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_4 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_4 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_4 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_5 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_5 > for u8 { # [inline (always)]
fn from (variant : Port0_5) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_5 { type Ux = u8 ; } impl crate :: IsEnum for Port0_5 { } # [doc = "Field `Port_0_5` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_5R = crate :: FieldReader < Port0_5 > ; impl Port0_5R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_5 > { match self . bits { 0 => Some (Port0_5 :: _2mA) , 1 => Some (Port0_5 :: _4mA) , 2 => Some (Port0_5 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_5 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_5 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_5 :: _8mA } } # [doc = "Field `Port_0_5` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_5 > ; impl < 'a , REG > Port0_5W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_5 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_5 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_5 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_6 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_6 > for u8 { # [inline (always)]
fn from (variant : Port0_6) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_6 { type Ux = u8 ; } impl crate :: IsEnum for Port0_6 { } # [doc = "Field `Port_0_6` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_6R = crate :: FieldReader < Port0_6 > ; impl Port0_6R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_6 > { match self . bits { 0 => Some (Port0_6 :: _2mA) , 1 => Some (Port0_6 :: _4mA) , 2 => Some (Port0_6 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_6 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_6 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_6 :: _8mA } } # [doc = "Field `Port_0_6` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_6 > ; impl < 'a , REG > Port0_6W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_6 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_6 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_6 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_7 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_7 > for u8 { # [inline (always)]
fn from (variant : Port0_7) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_7 { type Ux = u8 ; } impl crate :: IsEnum for Port0_7 { } # [doc = "Field `Port_0_7` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_7R = crate :: FieldReader < Port0_7 > ; impl Port0_7R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_7 > { match self . bits { 0 => Some (Port0_7 :: _2mA) , 1 => Some (Port0_7 :: _4mA) , 2 => Some (Port0_7 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_7 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_7 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_7 :: _8mA } } # [doc = "Field `Port_0_7` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_7 > ; impl < 'a , REG > Port0_7W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_7 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_7 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_7 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_8 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_8 > for u8 { # [inline (always)]
fn from (variant : Port0_8) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_8 { type Ux = u8 ; } impl crate :: IsEnum for Port0_8 { } # [doc = "Field `Port_0_8` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_8R = crate :: FieldReader < Port0_8 > ; impl Port0_8R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_8 > { match self . bits { 0 => Some (Port0_8 :: _2mA) , 1 => Some (Port0_8 :: _4mA) , 2 => Some (Port0_8 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_8 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_8 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_8 :: _8mA } } # [doc = "Field `Port_0_8` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_8 > ; impl < 'a , REG > Port0_8W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_8 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_8 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_8 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_9 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_9 > for u8 { # [inline (always)]
fn from (variant : Port0_9) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_9 { type Ux = u8 ; } impl crate :: IsEnum for Port0_9 { } # [doc = "Field `Port_0_9` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_9R = crate :: FieldReader < Port0_9 > ; impl Port0_9R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_9 > { match self . bits { 0 => Some (Port0_9 :: _2mA) , 1 => Some (Port0_9 :: _4mA) , 2 => Some (Port0_9 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_9 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_9 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_9 :: _8mA } } # [doc = "Field `Port_0_9` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_9 > ; impl < 'a , REG > Port0_9W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_9 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_9 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_9 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_10 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_10 > for u8 { # [inline (always)]
fn from (variant : Port0_10) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_10 { type Ux = u8 ; } impl crate :: IsEnum for Port0_10 { } # [doc = "Field `Port_0_10` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_10R = crate :: FieldReader < Port0_10 > ; impl Port0_10R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_10 > { match self . bits { 0 => Some (Port0_10 :: _2mA) , 1 => Some (Port0_10 :: _4mA) , 2 => Some (Port0_10 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_10 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_10 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_10 :: _8mA } } # [doc = "Field `Port_0_10` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_10 > ; impl < 'a , REG > Port0_10W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_10 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_10 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_10 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_11 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_11 > for u8 { # [inline (always)]
fn from (variant : Port0_11) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_11 { type Ux = u8 ; } impl crate :: IsEnum for Port0_11 { } # [doc = "Field `Port_0_11` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_11R = crate :: FieldReader < Port0_11 > ; impl Port0_11R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_11 > { match self . bits { 0 => Some (Port0_11 :: _2mA) , 1 => Some (Port0_11 :: _4mA) , 2 => Some (Port0_11 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_11 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_11 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_11 :: _8mA } } # [doc = "Field `Port_0_11` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_11 > ; impl < 'a , REG > Port0_11W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_11 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_11 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_11 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_12 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_12 > for u8 { # [inline (always)]
fn from (variant : Port0_12) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_12 { type Ux = u8 ; } impl crate :: IsEnum for Port0_12 { } # [doc = "Field `Port_0_12` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_12R = crate :: FieldReader < Port0_12 > ; impl Port0_12R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_12 > { match self . bits { 0 => Some (Port0_12 :: _2mA) , 1 => Some (Port0_12 :: _4mA) , 2 => Some (Port0_12 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_12 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_12 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_12 :: _8mA } } # [doc = "Field `Port_0_12` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_12 > ; impl < 'a , REG > Port0_12W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_12 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_12 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_12 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_13 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_13 > for u8 { # [inline (always)]
fn from (variant : Port0_13) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_13 { type Ux = u8 ; } impl crate :: IsEnum for Port0_13 { } # [doc = "Field `Port_0_13` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_13R = crate :: FieldReader < Port0_13 > ; impl Port0_13R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_13 > { match self . bits { 0 => Some (Port0_13 :: _2mA) , 1 => Some (Port0_13 :: _4mA) , 2 => Some (Port0_13 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_13 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_13 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_13 :: _8mA } } # [doc = "Field `Port_0_13` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_13 > ; impl < 'a , REG > Port0_13W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_13 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_13 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_13 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_14 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_14 > for u8 { # [inline (always)]
fn from (variant : Port0_14) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_14 { type Ux = u8 ; } impl crate :: IsEnum for Port0_14 { } # [doc = "Field `Port_0_14` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_14R = crate :: FieldReader < Port0_14 > ; impl Port0_14R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_14 > { match self . bits { 0 => Some (Port0_14 :: _2mA) , 1 => Some (Port0_14 :: _4mA) , 2 => Some (Port0_14 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_14 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_14 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_14 :: _8mA } } # [doc = "Field `Port_0_14` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_14 > ; impl < 'a , REG > Port0_14W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_14 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_14 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_14 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_15 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port0_15 > for u8 { # [inline (always)]
fn from (variant : Port0_15) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_15 { type Ux = u8 ; } impl crate :: IsEnum for Port0_15 { } # [doc = "Field `Port_0_15` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_15R = crate :: FieldReader < Port0_15 > ; impl Port0_15R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_15 > { match self . bits { 0 => Some (Port0_15 :: _2mA) , 1 => Some (Port0_15 :: _4mA) , 2 => Some (Port0_15 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port0_15 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port0_15 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port0_15 :: _8mA } } # [doc = "Field `Port_0_15` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_15 > ; impl < 'a , REG > Port0_15W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_15 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_15 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_15 :: _8mA) } } impl R { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_0 (& self) -> Port0_0R { Port0_0R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_1 (& self) -> Port0_1R { Port0_1R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_2 (& self) -> Port0_2R { Port0_2R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_3 (& self) -> Port0_3R { Port0_3R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_4 (& self) -> Port0_4R { Port0_4R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_5 (& self) -> Port0_5R { Port0_5R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_6 (& self) -> Port0_6R { Port0_6R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_7 (& self) -> Port0_7R { Port0_7R :: new (((self . bits >> 14) & 3) as u8) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_8 (& self) -> Port0_8R { Port0_8R :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_9 (& self) -> Port0_9R { Port0_9R :: new (((self . bits >> 18) & 3) as u8) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_10 (& self) -> Port0_10R { Port0_10R :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_11 (& self) -> Port0_11R { Port0_11R :: new (((self . bits >> 22) & 3) as u8) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_12 (& self) -> Port0_12R { Port0_12R :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_13 (& self) -> Port0_13R { Port0_13R :: new (((self . bits >> 26) & 3) as u8) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_14 (& self) -> Port0_14R { Port0_14R :: new (((self . bits >> 28) & 3) as u8) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_15 (& self) -> Port0_15R { Port0_15R :: new (((self . bits >> 30) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_0 (& mut self) -> Port0_0W < Pad0DsSpec > { Port0_0W :: new (self , 0) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_1 (& mut self) -> Port0_1W < Pad0DsSpec > { Port0_1W :: new (self , 2) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_2 (& mut self) -> Port0_2W < Pad0DsSpec > { Port0_2W :: new (self , 4) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_3 (& mut self) -> Port0_3W < Pad0DsSpec > { Port0_3W :: new (self , 6) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_4 (& mut self) -> Port0_4W < Pad0DsSpec > { Port0_4W :: new (self , 8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_5 (& mut self) -> Port0_5W < Pad0DsSpec > { Port0_5W :: new (self , 10) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_6 (& mut self) -> Port0_6W < Pad0DsSpec > { Port0_6W :: new (self , 12) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_7 (& mut self) -> Port0_7W < Pad0DsSpec > { Port0_7W :: new (self , 14) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_8 (& mut self) -> Port0_8W < Pad0DsSpec > { Port0_8W :: new (self , 16) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_9 (& mut self) -> Port0_9W < Pad0DsSpec > { Port0_9W :: new (self , 18) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_10 (& mut self) -> Port0_10W < Pad0DsSpec > { Port0_10W :: new (self , 20) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_11 (& mut self) -> Port0_11W < Pad0DsSpec > { Port0_11W :: new (self , 22) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_12 (& mut self) -> Port0_12W < Pad0DsSpec > { Port0_12W :: new (self , 24) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_13 (& mut self) -> Port0_13W < Pad0DsSpec > { Port0_13W :: new (self , 26) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_14 (& mut self) -> Port0_14W < Pad0DsSpec > { Port0_14W :: new (self , 28) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_15 (& mut self) -> Port0_15W < Pad0DsSpec > { Port0_15W :: new (self , 30) } } # [doc = "Управление нагрузочной способностью выводов PORT0\n\nYou can [`read`](crate::Reg::read) this register and get [`pad0_ds::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad0_ds::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Pad0DsSpec ; impl crate :: RegisterSpec for Pad0DsSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`pad0_ds::R`](R) reader structure"]
impl crate :: Readable for Pad0DsSpec { } # [doc = "`write(|w| ..)` method takes [`pad0_ds::W`](W) writer structure"]
impl crate :: Writable for Pad0DsSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PAD0_DS to value 0"]
impl crate :: Resettable for Pad0DsSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PAD0_PUPD (rw) register accessor: Управление резисторами подтяжки выводов PORT0\n\nYou can [`read`](crate::Reg::read) this register and get [`pad0_pupd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad0_pupd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pad0_pupd`]
module"]
# [doc (alias = "PAD0_PUPD")]
pub type Pad0Pupd = crate :: Reg < pad0_pupd :: Pad0PupdSpec > ; # [doc = "Управление резисторами подтяжки выводов PORT0"]
pub mod pad0_pupd { # [doc = "Register `PAD0_PUPD` reader"]
pub type R = crate :: R < Pad0PupdSpec > ; # [doc = "Register `PAD0_PUPD` writer"]
pub type W = crate :: W < Pad0PupdSpec > ; # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_0 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_0 > for u8 { # [inline (always)]
fn from (variant : Port0_0) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_0 { type Ux = u8 ; } impl crate :: IsEnum for Port0_0 { } # [doc = "Field `Port_0_0` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_0R = crate :: FieldReader < Port0_0 > ; impl Port0_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_0 > { match self . bits { 0 => Some (Port0_0 :: PullNone) , 1 => Some (Port0_0 :: PullUp) , 2 => Some (Port0_0 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_0 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_0 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_0 :: PullDown } } # [doc = "Field `Port_0_0` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_0 > ; impl < 'a , REG > Port0_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_0 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_0 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_0 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_1 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_1 > for u8 { # [inline (always)]
fn from (variant : Port0_1) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_1 { type Ux = u8 ; } impl crate :: IsEnum for Port0_1 { } # [doc = "Field `Port_0_1` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_1R = crate :: FieldReader < Port0_1 > ; impl Port0_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_1 > { match self . bits { 0 => Some (Port0_1 :: PullNone) , 1 => Some (Port0_1 :: PullUp) , 2 => Some (Port0_1 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_1 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_1 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_1 :: PullDown } } # [doc = "Field `Port_0_1` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_1 > ; impl < 'a , REG > Port0_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_1 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_1 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_1 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_2 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_2 > for u8 { # [inline (always)]
fn from (variant : Port0_2) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_2 { type Ux = u8 ; } impl crate :: IsEnum for Port0_2 { } # [doc = "Field `Port_0_2` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_2R = crate :: FieldReader < Port0_2 > ; impl Port0_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_2 > { match self . bits { 0 => Some (Port0_2 :: PullNone) , 1 => Some (Port0_2 :: PullUp) , 2 => Some (Port0_2 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_2 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_2 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_2 :: PullDown } } # [doc = "Field `Port_0_2` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_2 > ; impl < 'a , REG > Port0_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_2 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_2 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_2 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_3 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_3 > for u8 { # [inline (always)]
fn from (variant : Port0_3) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_3 { type Ux = u8 ; } impl crate :: IsEnum for Port0_3 { } # [doc = "Field `Port_0_3` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_3R = crate :: FieldReader < Port0_3 > ; impl Port0_3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_3 > { match self . bits { 0 => Some (Port0_3 :: PullNone) , 1 => Some (Port0_3 :: PullUp) , 2 => Some (Port0_3 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_3 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_3 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_3 :: PullDown } } # [doc = "Field `Port_0_3` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_3 > ; impl < 'a , REG > Port0_3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_3 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_3 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_3 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_4 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_4 > for u8 { # [inline (always)]
fn from (variant : Port0_4) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_4 { type Ux = u8 ; } impl crate :: IsEnum for Port0_4 { } # [doc = "Field `Port_0_4` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_4R = crate :: FieldReader < Port0_4 > ; impl Port0_4R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_4 > { match self . bits { 0 => Some (Port0_4 :: PullNone) , 1 => Some (Port0_4 :: PullUp) , 2 => Some (Port0_4 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_4 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_4 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_4 :: PullDown } } # [doc = "Field `Port_0_4` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_4 > ; impl < 'a , REG > Port0_4W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_4 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_4 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_4 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_5 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_5 > for u8 { # [inline (always)]
fn from (variant : Port0_5) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_5 { type Ux = u8 ; } impl crate :: IsEnum for Port0_5 { } # [doc = "Field `Port_0_5` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_5R = crate :: FieldReader < Port0_5 > ; impl Port0_5R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_5 > { match self . bits { 0 => Some (Port0_5 :: PullNone) , 1 => Some (Port0_5 :: PullUp) , 2 => Some (Port0_5 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_5 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_5 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_5 :: PullDown } } # [doc = "Field `Port_0_5` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_5 > ; impl < 'a , REG > Port0_5W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_5 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_5 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_5 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_6 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_6 > for u8 { # [inline (always)]
fn from (variant : Port0_6) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_6 { type Ux = u8 ; } impl crate :: IsEnum for Port0_6 { } # [doc = "Field `Port_0_6` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_6R = crate :: FieldReader < Port0_6 > ; impl Port0_6R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_6 > { match self . bits { 0 => Some (Port0_6 :: PullNone) , 1 => Some (Port0_6 :: PullUp) , 2 => Some (Port0_6 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_6 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_6 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_6 :: PullDown } } # [doc = "Field `Port_0_6` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_6 > ; impl < 'a , REG > Port0_6W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_6 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_6 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_6 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_7 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_7 > for u8 { # [inline (always)]
fn from (variant : Port0_7) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_7 { type Ux = u8 ; } impl crate :: IsEnum for Port0_7 { } # [doc = "Field `Port_0_7` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_7R = crate :: FieldReader < Port0_7 > ; impl Port0_7R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_7 > { match self . bits { 0 => Some (Port0_7 :: PullNone) , 1 => Some (Port0_7 :: PullUp) , 2 => Some (Port0_7 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_7 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_7 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_7 :: PullDown } } # [doc = "Field `Port_0_7` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_7 > ; impl < 'a , REG > Port0_7W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_7 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_7 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_7 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_8 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_8 > for u8 { # [inline (always)]
fn from (variant : Port0_8) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_8 { type Ux = u8 ; } impl crate :: IsEnum for Port0_8 { } # [doc = "Field `Port_0_8` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_8R = crate :: FieldReader < Port0_8 > ; impl Port0_8R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_8 > { match self . bits { 0 => Some (Port0_8 :: PullNone) , 1 => Some (Port0_8 :: PullUp) , 2 => Some (Port0_8 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_8 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_8 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_8 :: PullDown } } # [doc = "Field `Port_0_8` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_8 > ; impl < 'a , REG > Port0_8W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_8 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_8 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_8 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_9 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_9 > for u8 { # [inline (always)]
fn from (variant : Port0_9) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_9 { type Ux = u8 ; } impl crate :: IsEnum for Port0_9 { } # [doc = "Field `Port_0_9` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_9R = crate :: FieldReader < Port0_9 > ; impl Port0_9R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_9 > { match self . bits { 0 => Some (Port0_9 :: PullNone) , 1 => Some (Port0_9 :: PullUp) , 2 => Some (Port0_9 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_9 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_9 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_9 :: PullDown } } # [doc = "Field `Port_0_9` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_9 > ; impl < 'a , REG > Port0_9W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_9 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_9 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_9 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_10 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_10 > for u8 { # [inline (always)]
fn from (variant : Port0_10) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_10 { type Ux = u8 ; } impl crate :: IsEnum for Port0_10 { } # [doc = "Field `Port_0_10` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_10R = crate :: FieldReader < Port0_10 > ; impl Port0_10R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_10 > { match self . bits { 0 => Some (Port0_10 :: PullNone) , 1 => Some (Port0_10 :: PullUp) , 2 => Some (Port0_10 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_10 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_10 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_10 :: PullDown } } # [doc = "Field `Port_0_10` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_10 > ; impl < 'a , REG > Port0_10W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_10 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_10 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_10 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_11 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_11 > for u8 { # [inline (always)]
fn from (variant : Port0_11) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_11 { type Ux = u8 ; } impl crate :: IsEnum for Port0_11 { } # [doc = "Field `Port_0_11` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_11R = crate :: FieldReader < Port0_11 > ; impl Port0_11R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_11 > { match self . bits { 0 => Some (Port0_11 :: PullNone) , 1 => Some (Port0_11 :: PullUp) , 2 => Some (Port0_11 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_11 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_11 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_11 :: PullDown } } # [doc = "Field `Port_0_11` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_11 > ; impl < 'a , REG > Port0_11W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_11 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_11 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_11 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_12 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_12 > for u8 { # [inline (always)]
fn from (variant : Port0_12) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_12 { type Ux = u8 ; } impl crate :: IsEnum for Port0_12 { } # [doc = "Field `Port_0_12` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_12R = crate :: FieldReader < Port0_12 > ; impl Port0_12R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_12 > { match self . bits { 0 => Some (Port0_12 :: PullNone) , 1 => Some (Port0_12 :: PullUp) , 2 => Some (Port0_12 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_12 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_12 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_12 :: PullDown } } # [doc = "Field `Port_0_12` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_12 > ; impl < 'a , REG > Port0_12W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_12 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_12 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_12 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_13 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_13 > for u8 { # [inline (always)]
fn from (variant : Port0_13) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_13 { type Ux = u8 ; } impl crate :: IsEnum for Port0_13 { } # [doc = "Field `Port_0_13` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_13R = crate :: FieldReader < Port0_13 > ; impl Port0_13R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_13 > { match self . bits { 0 => Some (Port0_13 :: PullNone) , 1 => Some (Port0_13 :: PullUp) , 2 => Some (Port0_13 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_13 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_13 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_13 :: PullDown } } # [doc = "Field `Port_0_13` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_13 > ; impl < 'a , REG > Port0_13W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_13 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_13 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_13 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_14 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_14 > for u8 { # [inline (always)]
fn from (variant : Port0_14) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_14 { type Ux = u8 ; } impl crate :: IsEnum for Port0_14 { } # [doc = "Field `Port_0_14` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_14R = crate :: FieldReader < Port0_14 > ; impl Port0_14R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_14 > { match self . bits { 0 => Some (Port0_14 :: PullNone) , 1 => Some (Port0_14 :: PullUp) , 2 => Some (Port0_14 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_14 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_14 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_14 :: PullDown } } # [doc = "Field `Port_0_14` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_14 > ; impl < 'a , REG > Port0_14W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_14 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_14 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_14 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port0_15 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port0_15 > for u8 { # [inline (always)]
fn from (variant : Port0_15) -> Self { variant as _ } } impl crate :: FieldSpec for Port0_15 { type Ux = u8 ; } impl crate :: IsEnum for Port0_15 { } # [doc = "Field `Port_0_15` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_15R = crate :: FieldReader < Port0_15 > ; impl Port0_15R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port0_15 > { match self . bits { 0 => Some (Port0_15 :: PullNone) , 1 => Some (Port0_15 :: PullUp) , 2 => Some (Port0_15 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port0_15 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port0_15 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port0_15 :: PullDown } } # [doc = "Field `Port_0_15` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port0_15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port0_15 > ; impl < 'a , REG > Port0_15W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_15 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_15 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port0_15 :: PullDown) } } impl R { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_0 (& self) -> Port0_0R { Port0_0R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_1 (& self) -> Port0_1R { Port0_1R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_2 (& self) -> Port0_2R { Port0_2R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_3 (& self) -> Port0_3R { Port0_3R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_4 (& self) -> Port0_4R { Port0_4R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_5 (& self) -> Port0_5R { Port0_5R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_6 (& self) -> Port0_6R { Port0_6R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_7 (& self) -> Port0_7R { Port0_7R :: new (((self . bits >> 14) & 3) as u8) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_8 (& self) -> Port0_8R { Port0_8R :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_9 (& self) -> Port0_9R { Port0_9R :: new (((self . bits >> 18) & 3) as u8) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_10 (& self) -> Port0_10R { Port0_10R :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_11 (& self) -> Port0_11R { Port0_11R :: new (((self . bits >> 22) & 3) as u8) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_12 (& self) -> Port0_12R { Port0_12R :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_13 (& self) -> Port0_13R { Port0_13R :: new (((self . bits >> 26) & 3) as u8) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_14 (& self) -> Port0_14R { Port0_14R :: new (((self . bits >> 28) & 3) as u8) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_15 (& self) -> Port0_15R { Port0_15R :: new (((self . bits >> 30) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_0 (& mut self) -> Port0_0W < Pad0PupdSpec > { Port0_0W :: new (self , 0) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_1 (& mut self) -> Port0_1W < Pad0PupdSpec > { Port0_1W :: new (self , 2) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_2 (& mut self) -> Port0_2W < Pad0PupdSpec > { Port0_2W :: new (self , 4) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_3 (& mut self) -> Port0_3W < Pad0PupdSpec > { Port0_3W :: new (self , 6) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_4 (& mut self) -> Port0_4W < Pad0PupdSpec > { Port0_4W :: new (self , 8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_5 (& mut self) -> Port0_5W < Pad0PupdSpec > { Port0_5W :: new (self , 10) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_6 (& mut self) -> Port0_6W < Pad0PupdSpec > { Port0_6W :: new (self , 12) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_7 (& mut self) -> Port0_7W < Pad0PupdSpec > { Port0_7W :: new (self , 14) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_8 (& mut self) -> Port0_8W < Pad0PupdSpec > { Port0_8W :: new (self , 16) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_9 (& mut self) -> Port0_9W < Pad0PupdSpec > { Port0_9W :: new (self , 18) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_10 (& mut self) -> Port0_10W < Pad0PupdSpec > { Port0_10W :: new (self , 20) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_11 (& mut self) -> Port0_11W < Pad0PupdSpec > { Port0_11W :: new (self , 22) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_12 (& mut self) -> Port0_12W < Pad0PupdSpec > { Port0_12W :: new (self , 24) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_13 (& mut self) -> Port0_13W < Pad0PupdSpec > { Port0_13W :: new (self , 26) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_14 (& mut self) -> Port0_14W < Pad0PupdSpec > { Port0_14W :: new (self , 28) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_0_15 (& mut self) -> Port0_15W < Pad0PupdSpec > { Port0_15W :: new (self , 30) } } # [doc = "Управление резисторами подтяжки выводов PORT0\n\nYou can [`read`](crate::Reg::read) this register and get [`pad0_pupd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad0_pupd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Pad0PupdSpec ; impl crate :: RegisterSpec for Pad0PupdSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`pad0_pupd::R`](R) reader structure"]
impl crate :: Readable for Pad0PupdSpec { } # [doc = "`write(|w| ..)` method takes [`pad0_pupd::W`](W) writer structure"]
impl crate :: Writable for Pad0PupdSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PAD0_PUPD to value 0"]
impl crate :: Resettable for Pad0PupdSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PAD1_CFG (rw) register accessor: Управление функциями выводов PORT1\n\nYou can [`read`](crate::Reg::read) this register and get [`pad1_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad1_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pad1_cfg`]
module"]
# [doc (alias = "PAD1_CFG")]
pub type Pad1Cfg = crate :: Reg < pad1_cfg :: Pad1CfgSpec > ; # [doc = "Управление функциями выводов PORT1"]
pub mod pad1_cfg { # [doc = "Register `PAD1_CFG` reader"]
pub type R = crate :: R < Pad1CfgSpec > ; # [doc = "Register `PAD1_CFG` writer"]
pub type W = crate :: W < Pad1CfgSpec > ; # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_0 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_0 > for u8 { # [inline (always)]
fn from (variant : Port1_0) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_0 { type Ux = u8 ; } impl crate :: IsEnum for Port1_0 { } # [doc = "Field `Port_1_0` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_0R = crate :: FieldReader < Port1_0 > ; impl Port1_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_0 { match self . bits { 0 => Port1_0 :: Func1Gpio , 1 => Port1_0 :: Func2Interface , 2 => Port1_0 :: Func3InterfaceOrTimer , 3 => Port1_0 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_0 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_0 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_0 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_0 :: Func4Analog } } # [doc = "Field `Port_1_0` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_0 , crate :: Safe > ; impl < 'a , REG > Port1_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_0 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_0 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_0 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_0 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_1 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_1 > for u8 { # [inline (always)]
fn from (variant : Port1_1) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_1 { type Ux = u8 ; } impl crate :: IsEnum for Port1_1 { } # [doc = "Field `Port_1_1` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_1R = crate :: FieldReader < Port1_1 > ; impl Port1_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_1 { match self . bits { 0 => Port1_1 :: Func1Gpio , 1 => Port1_1 :: Func2Interface , 2 => Port1_1 :: Func3InterfaceOrTimer , 3 => Port1_1 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_1 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_1 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_1 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_1 :: Func4Analog } } # [doc = "Field `Port_1_1` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_1 , crate :: Safe > ; impl < 'a , REG > Port1_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_1 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_1 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_1 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_1 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_2 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_2 > for u8 { # [inline (always)]
fn from (variant : Port1_2) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_2 { type Ux = u8 ; } impl crate :: IsEnum for Port1_2 { } # [doc = "Field `Port_1_2` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_2R = crate :: FieldReader < Port1_2 > ; impl Port1_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_2 { match self . bits { 0 => Port1_2 :: Func1Gpio , 1 => Port1_2 :: Func2Interface , 2 => Port1_2 :: Func3InterfaceOrTimer , 3 => Port1_2 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_2 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_2 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_2 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_2 :: Func4Analog } } # [doc = "Field `Port_1_2` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_2 , crate :: Safe > ; impl < 'a , REG > Port1_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_2 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_2 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_2 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_2 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_3 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_3 > for u8 { # [inline (always)]
fn from (variant : Port1_3) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_3 { type Ux = u8 ; } impl crate :: IsEnum for Port1_3 { } # [doc = "Field `Port_1_3` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_3R = crate :: FieldReader < Port1_3 > ; impl Port1_3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_3 { match self . bits { 0 => Port1_3 :: Func1Gpio , 1 => Port1_3 :: Func2Interface , 2 => Port1_3 :: Func3InterfaceOrTimer , 3 => Port1_3 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_3 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_3 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_3 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_3 :: Func4Analog } } # [doc = "Field `Port_1_3` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_3 , crate :: Safe > ; impl < 'a , REG > Port1_3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_3 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_3 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_3 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_3 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_4 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_4 > for u8 { # [inline (always)]
fn from (variant : Port1_4) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_4 { type Ux = u8 ; } impl crate :: IsEnum for Port1_4 { } # [doc = "Field `Port_1_4` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_4R = crate :: FieldReader < Port1_4 > ; impl Port1_4R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_4 { match self . bits { 0 => Port1_4 :: Func1Gpio , 1 => Port1_4 :: Func2Interface , 2 => Port1_4 :: Func3InterfaceOrTimer , 3 => Port1_4 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_4 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_4 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_4 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_4 :: Func4Analog } } # [doc = "Field `Port_1_4` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_4 , crate :: Safe > ; impl < 'a , REG > Port1_4W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_4 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_4 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_4 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_4 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_5 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_5 > for u8 { # [inline (always)]
fn from (variant : Port1_5) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_5 { type Ux = u8 ; } impl crate :: IsEnum for Port1_5 { } # [doc = "Field `Port_1_5` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_5R = crate :: FieldReader < Port1_5 > ; impl Port1_5R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_5 { match self . bits { 0 => Port1_5 :: Func1Gpio , 1 => Port1_5 :: Func2Interface , 2 => Port1_5 :: Func3InterfaceOrTimer , 3 => Port1_5 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_5 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_5 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_5 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_5 :: Func4Analog } } # [doc = "Field `Port_1_5` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_5 , crate :: Safe > ; impl < 'a , REG > Port1_5W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_5 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_5 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_5 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_5 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_6 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_6 > for u8 { # [inline (always)]
fn from (variant : Port1_6) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_6 { type Ux = u8 ; } impl crate :: IsEnum for Port1_6 { } # [doc = "Field `Port_1_6` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_6R = crate :: FieldReader < Port1_6 > ; impl Port1_6R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_6 { match self . bits { 0 => Port1_6 :: Func1Gpio , 1 => Port1_6 :: Func2Interface , 2 => Port1_6 :: Func3InterfaceOrTimer , 3 => Port1_6 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_6 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_6 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_6 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_6 :: Func4Analog } } # [doc = "Field `Port_1_6` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_6 , crate :: Safe > ; impl < 'a , REG > Port1_6W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_6 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_6 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_6 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_6 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_7 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_7 > for u8 { # [inline (always)]
fn from (variant : Port1_7) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_7 { type Ux = u8 ; } impl crate :: IsEnum for Port1_7 { } # [doc = "Field `Port_1_7` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_7R = crate :: FieldReader < Port1_7 > ; impl Port1_7R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_7 { match self . bits { 0 => Port1_7 :: Func1Gpio , 1 => Port1_7 :: Func2Interface , 2 => Port1_7 :: Func3InterfaceOrTimer , 3 => Port1_7 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_7 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_7 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_7 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_7 :: Func4Analog } } # [doc = "Field `Port_1_7` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_7 , crate :: Safe > ; impl < 'a , REG > Port1_7W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_7 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_7 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_7 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_7 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_8 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_8 > for u8 { # [inline (always)]
fn from (variant : Port1_8) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_8 { type Ux = u8 ; } impl crate :: IsEnum for Port1_8 { } # [doc = "Field `Port_1_8` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_8R = crate :: FieldReader < Port1_8 > ; impl Port1_8R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_8 { match self . bits { 0 => Port1_8 :: Func1Gpio , 1 => Port1_8 :: Func2Interface , 2 => Port1_8 :: Func3InterfaceOrTimer , 3 => Port1_8 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_8 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_8 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_8 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_8 :: Func4Analog } } # [doc = "Field `Port_1_8` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_8 , crate :: Safe > ; impl < 'a , REG > Port1_8W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_8 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_8 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_8 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_8 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_9 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_9 > for u8 { # [inline (always)]
fn from (variant : Port1_9) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_9 { type Ux = u8 ; } impl crate :: IsEnum for Port1_9 { } # [doc = "Field `Port_1_9` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_9R = crate :: FieldReader < Port1_9 > ; impl Port1_9R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_9 { match self . bits { 0 => Port1_9 :: Func1Gpio , 1 => Port1_9 :: Func2Interface , 2 => Port1_9 :: Func3InterfaceOrTimer , 3 => Port1_9 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_9 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_9 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_9 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_9 :: Func4Analog } } # [doc = "Field `Port_1_9` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_9 , crate :: Safe > ; impl < 'a , REG > Port1_9W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_9 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_9 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_9 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_9 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_10 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_10 > for u8 { # [inline (always)]
fn from (variant : Port1_10) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_10 { type Ux = u8 ; } impl crate :: IsEnum for Port1_10 { } # [doc = "Field `Port_1_10` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_10R = crate :: FieldReader < Port1_10 > ; impl Port1_10R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_10 { match self . bits { 0 => Port1_10 :: Func1Gpio , 1 => Port1_10 :: Func2Interface , 2 => Port1_10 :: Func3InterfaceOrTimer , 3 => Port1_10 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_10 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_10 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_10 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_10 :: Func4Analog } } # [doc = "Field `Port_1_10` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_10 , crate :: Safe > ; impl < 'a , REG > Port1_10W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_10 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_10 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_10 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_10 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_11 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_11 > for u8 { # [inline (always)]
fn from (variant : Port1_11) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_11 { type Ux = u8 ; } impl crate :: IsEnum for Port1_11 { } # [doc = "Field `Port_1_11` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_11R = crate :: FieldReader < Port1_11 > ; impl Port1_11R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_11 { match self . bits { 0 => Port1_11 :: Func1Gpio , 1 => Port1_11 :: Func2Interface , 2 => Port1_11 :: Func3InterfaceOrTimer , 3 => Port1_11 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_11 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_11 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_11 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_11 :: Func4Analog } } # [doc = "Field `Port_1_11` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_11 , crate :: Safe > ; impl < 'a , REG > Port1_11W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_11 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_11 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_11 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_11 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_12 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_12 > for u8 { # [inline (always)]
fn from (variant : Port1_12) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_12 { type Ux = u8 ; } impl crate :: IsEnum for Port1_12 { } # [doc = "Field `Port_1_12` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_12R = crate :: FieldReader < Port1_12 > ; impl Port1_12R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_12 { match self . bits { 0 => Port1_12 :: Func1Gpio , 1 => Port1_12 :: Func2Interface , 2 => Port1_12 :: Func3InterfaceOrTimer , 3 => Port1_12 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_12 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_12 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_12 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_12 :: Func4Analog } } # [doc = "Field `Port_1_12` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_12 , crate :: Safe > ; impl < 'a , REG > Port1_12W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_12 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_12 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_12 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_12 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_13 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_13 > for u8 { # [inline (always)]
fn from (variant : Port1_13) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_13 { type Ux = u8 ; } impl crate :: IsEnum for Port1_13 { } # [doc = "Field `Port_1_13` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_13R = crate :: FieldReader < Port1_13 > ; impl Port1_13R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_13 { match self . bits { 0 => Port1_13 :: Func1Gpio , 1 => Port1_13 :: Func2Interface , 2 => Port1_13 :: Func3InterfaceOrTimer , 3 => Port1_13 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_13 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_13 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_13 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_13 :: Func4Analog } } # [doc = "Field `Port_1_13` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_13 , crate :: Safe > ; impl < 'a , REG > Port1_13W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_13 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_13 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_13 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_13 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_14 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_14 > for u8 { # [inline (always)]
fn from (variant : Port1_14) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_14 { type Ux = u8 ; } impl crate :: IsEnum for Port1_14 { } # [doc = "Field `Port_1_14` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_14R = crate :: FieldReader < Port1_14 > ; impl Port1_14R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_14 { match self . bits { 0 => Port1_14 :: Func1Gpio , 1 => Port1_14 :: Func2Interface , 2 => Port1_14 :: Func3InterfaceOrTimer , 3 => Port1_14 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_14 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_14 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_14 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_14 :: Func4Analog } } # [doc = "Field `Port_1_14` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_14 , crate :: Safe > ; impl < 'a , REG > Port1_14W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_14 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_14 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_14 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_14 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_15 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port1_15 > for u8 { # [inline (always)]
fn from (variant : Port1_15) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_15 { type Ux = u8 ; } impl crate :: IsEnum for Port1_15 { } # [doc = "Field `Port_1_15` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_15R = crate :: FieldReader < Port1_15 > ; impl Port1_15R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port1_15 { match self . bits { 0 => Port1_15 :: Func1Gpio , 1 => Port1_15 :: Func2Interface , 2 => Port1_15 :: Func3InterfaceOrTimer , 3 => Port1_15 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port1_15 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port1_15 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port1_15 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port1_15 :: Func4Analog } } # [doc = "Field `Port_1_15` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port1_15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_15 , crate :: Safe > ; impl < 'a , REG > Port1_15W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_15 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_15 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_15 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_15 :: Func4Analog) } } impl R { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_0 (& self) -> Port1_0R { Port1_0R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_1 (& self) -> Port1_1R { Port1_1R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_2 (& self) -> Port1_2R { Port1_2R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_3 (& self) -> Port1_3R { Port1_3R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_4 (& self) -> Port1_4R { Port1_4R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_5 (& self) -> Port1_5R { Port1_5R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_6 (& self) -> Port1_6R { Port1_6R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_7 (& self) -> Port1_7R { Port1_7R :: new (((self . bits >> 14) & 3) as u8) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_8 (& self) -> Port1_8R { Port1_8R :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_9 (& self) -> Port1_9R { Port1_9R :: new (((self . bits >> 18) & 3) as u8) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_10 (& self) -> Port1_10R { Port1_10R :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_11 (& self) -> Port1_11R { Port1_11R :: new (((self . bits >> 22) & 3) as u8) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_12 (& self) -> Port1_12R { Port1_12R :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_13 (& self) -> Port1_13R { Port1_13R :: new (((self . bits >> 26) & 3) as u8) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_14 (& self) -> Port1_14R { Port1_14R :: new (((self . bits >> 28) & 3) as u8) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_15 (& self) -> Port1_15R { Port1_15R :: new (((self . bits >> 30) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_0 (& mut self) -> Port1_0W < Pad1CfgSpec > { Port1_0W :: new (self , 0) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_1 (& mut self) -> Port1_1W < Pad1CfgSpec > { Port1_1W :: new (self , 2) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_2 (& mut self) -> Port1_2W < Pad1CfgSpec > { Port1_2W :: new (self , 4) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_3 (& mut self) -> Port1_3W < Pad1CfgSpec > { Port1_3W :: new (self , 6) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_4 (& mut self) -> Port1_4W < Pad1CfgSpec > { Port1_4W :: new (self , 8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_5 (& mut self) -> Port1_5W < Pad1CfgSpec > { Port1_5W :: new (self , 10) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_6 (& mut self) -> Port1_6W < Pad1CfgSpec > { Port1_6W :: new (self , 12) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_7 (& mut self) -> Port1_7W < Pad1CfgSpec > { Port1_7W :: new (self , 14) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_8 (& mut self) -> Port1_8W < Pad1CfgSpec > { Port1_8W :: new (self , 16) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_9 (& mut self) -> Port1_9W < Pad1CfgSpec > { Port1_9W :: new (self , 18) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_10 (& mut self) -> Port1_10W < Pad1CfgSpec > { Port1_10W :: new (self , 20) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_11 (& mut self) -> Port1_11W < Pad1CfgSpec > { Port1_11W :: new (self , 22) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_12 (& mut self) -> Port1_12W < Pad1CfgSpec > { Port1_12W :: new (self , 24) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_13 (& mut self) -> Port1_13W < Pad1CfgSpec > { Port1_13W :: new (self , 26) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_14 (& mut self) -> Port1_14W < Pad1CfgSpec > { Port1_14W :: new (self , 28) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_1_15 (& mut self) -> Port1_15W < Pad1CfgSpec > { Port1_15W :: new (self , 30) } } # [doc = "Управление функциями выводов PORT1\n\nYou can [`read`](crate::Reg::read) this register and get [`pad1_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad1_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Pad1CfgSpec ; impl crate :: RegisterSpec for Pad1CfgSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`pad1_cfg::R`](R) reader structure"]
impl crate :: Readable for Pad1CfgSpec { } # [doc = "`write(|w| ..)` method takes [`pad1_cfg::W`](W) writer structure"]
impl crate :: Writable for Pad1CfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PAD1_CFG to value 0"]
impl crate :: Resettable for Pad1CfgSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PAD1_DS (rw) register accessor: Управление нагрузочной способностью выводов PORT1\n\nYou can [`read`](crate::Reg::read) this register and get [`pad1_ds::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad1_ds::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pad1_ds`]
module"]
# [doc (alias = "PAD1_DS")]
pub type Pad1Ds = crate :: Reg < pad1_ds :: Pad1DsSpec > ; # [doc = "Управление нагрузочной способностью выводов PORT1"]
pub mod pad1_ds { # [doc = "Register `PAD1_DS` reader"]
pub type R = crate :: R < Pad1DsSpec > ; # [doc = "Register `PAD1_DS` writer"]
pub type W = crate :: W < Pad1DsSpec > ; # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_0 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_0 > for u8 { # [inline (always)]
fn from (variant : Port1_0) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_0 { type Ux = u8 ; } impl crate :: IsEnum for Port1_0 { } # [doc = "Field `Port_1_0` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_0R = crate :: FieldReader < Port1_0 > ; impl Port1_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_0 > { match self . bits { 0 => Some (Port1_0 :: _2mA) , 1 => Some (Port1_0 :: _4mA) , 2 => Some (Port1_0 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_0 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_0 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_0 :: _8mA } } # [doc = "Field `Port_1_0` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_0 > ; impl < 'a , REG > Port1_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_0 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_0 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_0 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_1 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_1 > for u8 { # [inline (always)]
fn from (variant : Port1_1) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_1 { type Ux = u8 ; } impl crate :: IsEnum for Port1_1 { } # [doc = "Field `Port_1_1` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_1R = crate :: FieldReader < Port1_1 > ; impl Port1_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_1 > { match self . bits { 0 => Some (Port1_1 :: _2mA) , 1 => Some (Port1_1 :: _4mA) , 2 => Some (Port1_1 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_1 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_1 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_1 :: _8mA } } # [doc = "Field `Port_1_1` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_1 > ; impl < 'a , REG > Port1_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_1 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_1 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_1 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_2 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_2 > for u8 { # [inline (always)]
fn from (variant : Port1_2) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_2 { type Ux = u8 ; } impl crate :: IsEnum for Port1_2 { } # [doc = "Field `Port_1_2` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_2R = crate :: FieldReader < Port1_2 > ; impl Port1_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_2 > { match self . bits { 0 => Some (Port1_2 :: _2mA) , 1 => Some (Port1_2 :: _4mA) , 2 => Some (Port1_2 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_2 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_2 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_2 :: _8mA } } # [doc = "Field `Port_1_2` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_2 > ; impl < 'a , REG > Port1_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_2 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_2 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_2 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_3 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_3 > for u8 { # [inline (always)]
fn from (variant : Port1_3) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_3 { type Ux = u8 ; } impl crate :: IsEnum for Port1_3 { } # [doc = "Field `Port_1_3` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_3R = crate :: FieldReader < Port1_3 > ; impl Port1_3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_3 > { match self . bits { 0 => Some (Port1_3 :: _2mA) , 1 => Some (Port1_3 :: _4mA) , 2 => Some (Port1_3 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_3 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_3 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_3 :: _8mA } } # [doc = "Field `Port_1_3` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_3 > ; impl < 'a , REG > Port1_3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_3 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_3 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_3 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_4 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_4 > for u8 { # [inline (always)]
fn from (variant : Port1_4) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_4 { type Ux = u8 ; } impl crate :: IsEnum for Port1_4 { } # [doc = "Field `Port_1_4` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_4R = crate :: FieldReader < Port1_4 > ; impl Port1_4R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_4 > { match self . bits { 0 => Some (Port1_4 :: _2mA) , 1 => Some (Port1_4 :: _4mA) , 2 => Some (Port1_4 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_4 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_4 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_4 :: _8mA } } # [doc = "Field `Port_1_4` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_4 > ; impl < 'a , REG > Port1_4W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_4 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_4 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_4 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_5 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_5 > for u8 { # [inline (always)]
fn from (variant : Port1_5) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_5 { type Ux = u8 ; } impl crate :: IsEnum for Port1_5 { } # [doc = "Field `Port_1_5` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_5R = crate :: FieldReader < Port1_5 > ; impl Port1_5R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_5 > { match self . bits { 0 => Some (Port1_5 :: _2mA) , 1 => Some (Port1_5 :: _4mA) , 2 => Some (Port1_5 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_5 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_5 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_5 :: _8mA } } # [doc = "Field `Port_1_5` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_5 > ; impl < 'a , REG > Port1_5W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_5 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_5 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_5 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_6 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_6 > for u8 { # [inline (always)]
fn from (variant : Port1_6) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_6 { type Ux = u8 ; } impl crate :: IsEnum for Port1_6 { } # [doc = "Field `Port_1_6` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_6R = crate :: FieldReader < Port1_6 > ; impl Port1_6R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_6 > { match self . bits { 0 => Some (Port1_6 :: _2mA) , 1 => Some (Port1_6 :: _4mA) , 2 => Some (Port1_6 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_6 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_6 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_6 :: _8mA } } # [doc = "Field `Port_1_6` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_6 > ; impl < 'a , REG > Port1_6W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_6 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_6 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_6 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_7 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_7 > for u8 { # [inline (always)]
fn from (variant : Port1_7) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_7 { type Ux = u8 ; } impl crate :: IsEnum for Port1_7 { } # [doc = "Field `Port_1_7` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_7R = crate :: FieldReader < Port1_7 > ; impl Port1_7R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_7 > { match self . bits { 0 => Some (Port1_7 :: _2mA) , 1 => Some (Port1_7 :: _4mA) , 2 => Some (Port1_7 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_7 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_7 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_7 :: _8mA } } # [doc = "Field `Port_1_7` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_7 > ; impl < 'a , REG > Port1_7W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_7 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_7 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_7 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_8 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_8 > for u8 { # [inline (always)]
fn from (variant : Port1_8) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_8 { type Ux = u8 ; } impl crate :: IsEnum for Port1_8 { } # [doc = "Field `Port_1_8` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_8R = crate :: FieldReader < Port1_8 > ; impl Port1_8R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_8 > { match self . bits { 0 => Some (Port1_8 :: _2mA) , 1 => Some (Port1_8 :: _4mA) , 2 => Some (Port1_8 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_8 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_8 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_8 :: _8mA } } # [doc = "Field `Port_1_8` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_8 > ; impl < 'a , REG > Port1_8W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_8 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_8 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_8 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_9 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_9 > for u8 { # [inline (always)]
fn from (variant : Port1_9) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_9 { type Ux = u8 ; } impl crate :: IsEnum for Port1_9 { } # [doc = "Field `Port_1_9` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_9R = crate :: FieldReader < Port1_9 > ; impl Port1_9R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_9 > { match self . bits { 0 => Some (Port1_9 :: _2mA) , 1 => Some (Port1_9 :: _4mA) , 2 => Some (Port1_9 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_9 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_9 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_9 :: _8mA } } # [doc = "Field `Port_1_9` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_9 > ; impl < 'a , REG > Port1_9W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_9 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_9 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_9 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_10 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_10 > for u8 { # [inline (always)]
fn from (variant : Port1_10) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_10 { type Ux = u8 ; } impl crate :: IsEnum for Port1_10 { } # [doc = "Field `Port_1_10` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_10R = crate :: FieldReader < Port1_10 > ; impl Port1_10R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_10 > { match self . bits { 0 => Some (Port1_10 :: _2mA) , 1 => Some (Port1_10 :: _4mA) , 2 => Some (Port1_10 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_10 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_10 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_10 :: _8mA } } # [doc = "Field `Port_1_10` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_10 > ; impl < 'a , REG > Port1_10W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_10 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_10 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_10 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_11 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_11 > for u8 { # [inline (always)]
fn from (variant : Port1_11) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_11 { type Ux = u8 ; } impl crate :: IsEnum for Port1_11 { } # [doc = "Field `Port_1_11` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_11R = crate :: FieldReader < Port1_11 > ; impl Port1_11R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_11 > { match self . bits { 0 => Some (Port1_11 :: _2mA) , 1 => Some (Port1_11 :: _4mA) , 2 => Some (Port1_11 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_11 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_11 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_11 :: _8mA } } # [doc = "Field `Port_1_11` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_11 > ; impl < 'a , REG > Port1_11W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_11 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_11 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_11 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_12 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_12 > for u8 { # [inline (always)]
fn from (variant : Port1_12) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_12 { type Ux = u8 ; } impl crate :: IsEnum for Port1_12 { } # [doc = "Field `Port_1_12` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_12R = crate :: FieldReader < Port1_12 > ; impl Port1_12R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_12 > { match self . bits { 0 => Some (Port1_12 :: _2mA) , 1 => Some (Port1_12 :: _4mA) , 2 => Some (Port1_12 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_12 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_12 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_12 :: _8mA } } # [doc = "Field `Port_1_12` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_12 > ; impl < 'a , REG > Port1_12W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_12 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_12 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_12 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_13 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_13 > for u8 { # [inline (always)]
fn from (variant : Port1_13) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_13 { type Ux = u8 ; } impl crate :: IsEnum for Port1_13 { } # [doc = "Field `Port_1_13` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_13R = crate :: FieldReader < Port1_13 > ; impl Port1_13R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_13 > { match self . bits { 0 => Some (Port1_13 :: _2mA) , 1 => Some (Port1_13 :: _4mA) , 2 => Some (Port1_13 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_13 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_13 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_13 :: _8mA } } # [doc = "Field `Port_1_13` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_13 > ; impl < 'a , REG > Port1_13W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_13 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_13 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_13 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_14 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_14 > for u8 { # [inline (always)]
fn from (variant : Port1_14) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_14 { type Ux = u8 ; } impl crate :: IsEnum for Port1_14 { } # [doc = "Field `Port_1_14` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_14R = crate :: FieldReader < Port1_14 > ; impl Port1_14R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_14 > { match self . bits { 0 => Some (Port1_14 :: _2mA) , 1 => Some (Port1_14 :: _4mA) , 2 => Some (Port1_14 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_14 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_14 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_14 :: _8mA } } # [doc = "Field `Port_1_14` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_14 > ; impl < 'a , REG > Port1_14W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_14 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_14 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_14 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_15 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port1_15 > for u8 { # [inline (always)]
fn from (variant : Port1_15) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_15 { type Ux = u8 ; } impl crate :: IsEnum for Port1_15 { } # [doc = "Field `Port_1_15` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_15R = crate :: FieldReader < Port1_15 > ; impl Port1_15R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_15 > { match self . bits { 0 => Some (Port1_15 :: _2mA) , 1 => Some (Port1_15 :: _4mA) , 2 => Some (Port1_15 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port1_15 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port1_15 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port1_15 :: _8mA } } # [doc = "Field `Port_1_15` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_15 > ; impl < 'a , REG > Port1_15W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_15 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_15 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_15 :: _8mA) } } impl R { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_0 (& self) -> Port1_0R { Port1_0R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_1 (& self) -> Port1_1R { Port1_1R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_2 (& self) -> Port1_2R { Port1_2R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_3 (& self) -> Port1_3R { Port1_3R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_4 (& self) -> Port1_4R { Port1_4R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_5 (& self) -> Port1_5R { Port1_5R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_6 (& self) -> Port1_6R { Port1_6R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_7 (& self) -> Port1_7R { Port1_7R :: new (((self . bits >> 14) & 3) as u8) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_8 (& self) -> Port1_8R { Port1_8R :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_9 (& self) -> Port1_9R { Port1_9R :: new (((self . bits >> 18) & 3) as u8) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_10 (& self) -> Port1_10R { Port1_10R :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_11 (& self) -> Port1_11R { Port1_11R :: new (((self . bits >> 22) & 3) as u8) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_12 (& self) -> Port1_12R { Port1_12R :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_13 (& self) -> Port1_13R { Port1_13R :: new (((self . bits >> 26) & 3) as u8) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_14 (& self) -> Port1_14R { Port1_14R :: new (((self . bits >> 28) & 3) as u8) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_15 (& self) -> Port1_15R { Port1_15R :: new (((self . bits >> 30) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_0 (& mut self) -> Port1_0W < Pad1DsSpec > { Port1_0W :: new (self , 0) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_1 (& mut self) -> Port1_1W < Pad1DsSpec > { Port1_1W :: new (self , 2) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_2 (& mut self) -> Port1_2W < Pad1DsSpec > { Port1_2W :: new (self , 4) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_3 (& mut self) -> Port1_3W < Pad1DsSpec > { Port1_3W :: new (self , 6) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_4 (& mut self) -> Port1_4W < Pad1DsSpec > { Port1_4W :: new (self , 8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_5 (& mut self) -> Port1_5W < Pad1DsSpec > { Port1_5W :: new (self , 10) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_6 (& mut self) -> Port1_6W < Pad1DsSpec > { Port1_6W :: new (self , 12) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_7 (& mut self) -> Port1_7W < Pad1DsSpec > { Port1_7W :: new (self , 14) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_8 (& mut self) -> Port1_8W < Pad1DsSpec > { Port1_8W :: new (self , 16) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_9 (& mut self) -> Port1_9W < Pad1DsSpec > { Port1_9W :: new (self , 18) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_10 (& mut self) -> Port1_10W < Pad1DsSpec > { Port1_10W :: new (self , 20) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_11 (& mut self) -> Port1_11W < Pad1DsSpec > { Port1_11W :: new (self , 22) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_12 (& mut self) -> Port1_12W < Pad1DsSpec > { Port1_12W :: new (self , 24) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_13 (& mut self) -> Port1_13W < Pad1DsSpec > { Port1_13W :: new (self , 26) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_14 (& mut self) -> Port1_14W < Pad1DsSpec > { Port1_14W :: new (self , 28) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_15 (& mut self) -> Port1_15W < Pad1DsSpec > { Port1_15W :: new (self , 30) } } # [doc = "Управление нагрузочной способностью выводов PORT1\n\nYou can [`read`](crate::Reg::read) this register and get [`pad1_ds::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad1_ds::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Pad1DsSpec ; impl crate :: RegisterSpec for Pad1DsSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`pad1_ds::R`](R) reader structure"]
impl crate :: Readable for Pad1DsSpec { } # [doc = "`write(|w| ..)` method takes [`pad1_ds::W`](W) writer structure"]
impl crate :: Writable for Pad1DsSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PAD1_DS to value 0"]
impl crate :: Resettable for Pad1DsSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PAD1_PUPD (rw) register accessor: Управление резисторами подтяжки выводов PORT1\n\nYou can [`read`](crate::Reg::read) this register and get [`pad1_pupd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad1_pupd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pad1_pupd`]
module"]
# [doc (alias = "PAD1_PUPD")]
pub type Pad1Pupd = crate :: Reg < pad1_pupd :: Pad1PupdSpec > ; # [doc = "Управление резисторами подтяжки выводов PORT1"]
pub mod pad1_pupd { # [doc = "Register `PAD1_PUPD` reader"]
pub type R = crate :: R < Pad1PupdSpec > ; # [doc = "Register `PAD1_PUPD` writer"]
pub type W = crate :: W < Pad1PupdSpec > ; # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_0 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_0 > for u8 { # [inline (always)]
fn from (variant : Port1_0) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_0 { type Ux = u8 ; } impl crate :: IsEnum for Port1_0 { } # [doc = "Field `Port_1_0` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_0R = crate :: FieldReader < Port1_0 > ; impl Port1_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_0 > { match self . bits { 0 => Some (Port1_0 :: PullNone) , 1 => Some (Port1_0 :: PullUp) , 2 => Some (Port1_0 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_0 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_0 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_0 :: PullDown } } # [doc = "Field `Port_1_0` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_0 > ; impl < 'a , REG > Port1_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_0 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_0 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_0 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_1 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_1 > for u8 { # [inline (always)]
fn from (variant : Port1_1) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_1 { type Ux = u8 ; } impl crate :: IsEnum for Port1_1 { } # [doc = "Field `Port_1_1` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_1R = crate :: FieldReader < Port1_1 > ; impl Port1_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_1 > { match self . bits { 0 => Some (Port1_1 :: PullNone) , 1 => Some (Port1_1 :: PullUp) , 2 => Some (Port1_1 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_1 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_1 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_1 :: PullDown } } # [doc = "Field `Port_1_1` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_1 > ; impl < 'a , REG > Port1_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_1 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_1 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_1 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_2 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_2 > for u8 { # [inline (always)]
fn from (variant : Port1_2) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_2 { type Ux = u8 ; } impl crate :: IsEnum for Port1_2 { } # [doc = "Field `Port_1_2` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_2R = crate :: FieldReader < Port1_2 > ; impl Port1_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_2 > { match self . bits { 0 => Some (Port1_2 :: PullNone) , 1 => Some (Port1_2 :: PullUp) , 2 => Some (Port1_2 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_2 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_2 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_2 :: PullDown } } # [doc = "Field `Port_1_2` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_2 > ; impl < 'a , REG > Port1_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_2 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_2 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_2 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_3 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_3 > for u8 { # [inline (always)]
fn from (variant : Port1_3) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_3 { type Ux = u8 ; } impl crate :: IsEnum for Port1_3 { } # [doc = "Field `Port_1_3` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_3R = crate :: FieldReader < Port1_3 > ; impl Port1_3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_3 > { match self . bits { 0 => Some (Port1_3 :: PullNone) , 1 => Some (Port1_3 :: PullUp) , 2 => Some (Port1_3 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_3 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_3 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_3 :: PullDown } } # [doc = "Field `Port_1_3` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_3 > ; impl < 'a , REG > Port1_3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_3 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_3 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_3 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_4 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_4 > for u8 { # [inline (always)]
fn from (variant : Port1_4) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_4 { type Ux = u8 ; } impl crate :: IsEnum for Port1_4 { } # [doc = "Field `Port_1_4` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_4R = crate :: FieldReader < Port1_4 > ; impl Port1_4R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_4 > { match self . bits { 0 => Some (Port1_4 :: PullNone) , 1 => Some (Port1_4 :: PullUp) , 2 => Some (Port1_4 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_4 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_4 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_4 :: PullDown } } # [doc = "Field `Port_1_4` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_4 > ; impl < 'a , REG > Port1_4W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_4 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_4 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_4 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_5 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_5 > for u8 { # [inline (always)]
fn from (variant : Port1_5) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_5 { type Ux = u8 ; } impl crate :: IsEnum for Port1_5 { } # [doc = "Field `Port_1_5` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_5R = crate :: FieldReader < Port1_5 > ; impl Port1_5R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_5 > { match self . bits { 0 => Some (Port1_5 :: PullNone) , 1 => Some (Port1_5 :: PullUp) , 2 => Some (Port1_5 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_5 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_5 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_5 :: PullDown } } # [doc = "Field `Port_1_5` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_5 > ; impl < 'a , REG > Port1_5W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_5 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_5 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_5 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_6 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_6 > for u8 { # [inline (always)]
fn from (variant : Port1_6) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_6 { type Ux = u8 ; } impl crate :: IsEnum for Port1_6 { } # [doc = "Field `Port_1_6` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_6R = crate :: FieldReader < Port1_6 > ; impl Port1_6R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_6 > { match self . bits { 0 => Some (Port1_6 :: PullNone) , 1 => Some (Port1_6 :: PullUp) , 2 => Some (Port1_6 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_6 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_6 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_6 :: PullDown } } # [doc = "Field `Port_1_6` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_6 > ; impl < 'a , REG > Port1_6W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_6 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_6 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_6 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_7 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_7 > for u8 { # [inline (always)]
fn from (variant : Port1_7) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_7 { type Ux = u8 ; } impl crate :: IsEnum for Port1_7 { } # [doc = "Field `Port_1_7` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_7R = crate :: FieldReader < Port1_7 > ; impl Port1_7R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_7 > { match self . bits { 0 => Some (Port1_7 :: PullNone) , 1 => Some (Port1_7 :: PullUp) , 2 => Some (Port1_7 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_7 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_7 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_7 :: PullDown } } # [doc = "Field `Port_1_7` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_7 > ; impl < 'a , REG > Port1_7W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_7 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_7 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_7 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_8 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_8 > for u8 { # [inline (always)]
fn from (variant : Port1_8) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_8 { type Ux = u8 ; } impl crate :: IsEnum for Port1_8 { } # [doc = "Field `Port_1_8` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_8R = crate :: FieldReader < Port1_8 > ; impl Port1_8R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_8 > { match self . bits { 0 => Some (Port1_8 :: PullNone) , 1 => Some (Port1_8 :: PullUp) , 2 => Some (Port1_8 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_8 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_8 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_8 :: PullDown } } # [doc = "Field `Port_1_8` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_8 > ; impl < 'a , REG > Port1_8W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_8 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_8 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_8 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_9 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_9 > for u8 { # [inline (always)]
fn from (variant : Port1_9) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_9 { type Ux = u8 ; } impl crate :: IsEnum for Port1_9 { } # [doc = "Field `Port_1_9` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_9R = crate :: FieldReader < Port1_9 > ; impl Port1_9R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_9 > { match self . bits { 0 => Some (Port1_9 :: PullNone) , 1 => Some (Port1_9 :: PullUp) , 2 => Some (Port1_9 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_9 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_9 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_9 :: PullDown } } # [doc = "Field `Port_1_9` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_9W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_9 > ; impl < 'a , REG > Port1_9W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_9 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_9 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_9 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_10 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_10 > for u8 { # [inline (always)]
fn from (variant : Port1_10) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_10 { type Ux = u8 ; } impl crate :: IsEnum for Port1_10 { } # [doc = "Field `Port_1_10` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_10R = crate :: FieldReader < Port1_10 > ; impl Port1_10R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_10 > { match self . bits { 0 => Some (Port1_10 :: PullNone) , 1 => Some (Port1_10 :: PullUp) , 2 => Some (Port1_10 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_10 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_10 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_10 :: PullDown } } # [doc = "Field `Port_1_10` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_10W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_10 > ; impl < 'a , REG > Port1_10W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_10 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_10 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_10 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_11 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_11 > for u8 { # [inline (always)]
fn from (variant : Port1_11) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_11 { type Ux = u8 ; } impl crate :: IsEnum for Port1_11 { } # [doc = "Field `Port_1_11` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_11R = crate :: FieldReader < Port1_11 > ; impl Port1_11R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_11 > { match self . bits { 0 => Some (Port1_11 :: PullNone) , 1 => Some (Port1_11 :: PullUp) , 2 => Some (Port1_11 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_11 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_11 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_11 :: PullDown } } # [doc = "Field `Port_1_11` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_11W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_11 > ; impl < 'a , REG > Port1_11W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_11 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_11 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_11 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_12 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_12 > for u8 { # [inline (always)]
fn from (variant : Port1_12) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_12 { type Ux = u8 ; } impl crate :: IsEnum for Port1_12 { } # [doc = "Field `Port_1_12` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_12R = crate :: FieldReader < Port1_12 > ; impl Port1_12R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_12 > { match self . bits { 0 => Some (Port1_12 :: PullNone) , 1 => Some (Port1_12 :: PullUp) , 2 => Some (Port1_12 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_12 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_12 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_12 :: PullDown } } # [doc = "Field `Port_1_12` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_12W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_12 > ; impl < 'a , REG > Port1_12W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_12 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_12 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_12 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_13 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_13 > for u8 { # [inline (always)]
fn from (variant : Port1_13) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_13 { type Ux = u8 ; } impl crate :: IsEnum for Port1_13 { } # [doc = "Field `Port_1_13` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_13R = crate :: FieldReader < Port1_13 > ; impl Port1_13R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_13 > { match self . bits { 0 => Some (Port1_13 :: PullNone) , 1 => Some (Port1_13 :: PullUp) , 2 => Some (Port1_13 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_13 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_13 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_13 :: PullDown } } # [doc = "Field `Port_1_13` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_13W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_13 > ; impl < 'a , REG > Port1_13W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_13 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_13 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_13 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_14 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_14 > for u8 { # [inline (always)]
fn from (variant : Port1_14) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_14 { type Ux = u8 ; } impl crate :: IsEnum for Port1_14 { } # [doc = "Field `Port_1_14` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_14R = crate :: FieldReader < Port1_14 > ; impl Port1_14R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_14 > { match self . bits { 0 => Some (Port1_14 :: PullNone) , 1 => Some (Port1_14 :: PullUp) , 2 => Some (Port1_14 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_14 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_14 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_14 :: PullDown } } # [doc = "Field `Port_1_14` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_14W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_14 > ; impl < 'a , REG > Port1_14W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_14 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_14 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_14 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port1_15 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port1_15 > for u8 { # [inline (always)]
fn from (variant : Port1_15) -> Self { variant as _ } } impl crate :: FieldSpec for Port1_15 { type Ux = u8 ; } impl crate :: IsEnum for Port1_15 { } # [doc = "Field `Port_1_15` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_15R = crate :: FieldReader < Port1_15 > ; impl Port1_15R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port1_15 > { match self . bits { 0 => Some (Port1_15 :: PullNone) , 1 => Some (Port1_15 :: PullUp) , 2 => Some (Port1_15 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port1_15 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port1_15 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port1_15 :: PullDown } } # [doc = "Field `Port_1_15` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port1_15W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port1_15 > ; impl < 'a , REG > Port1_15W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_15 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_15 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port1_15 :: PullDown) } } impl R { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_0 (& self) -> Port1_0R { Port1_0R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_1 (& self) -> Port1_1R { Port1_1R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_2 (& self) -> Port1_2R { Port1_2R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_3 (& self) -> Port1_3R { Port1_3R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_4 (& self) -> Port1_4R { Port1_4R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_5 (& self) -> Port1_5R { Port1_5R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_6 (& self) -> Port1_6R { Port1_6R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_7 (& self) -> Port1_7R { Port1_7R :: new (((self . bits >> 14) & 3) as u8) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_8 (& self) -> Port1_8R { Port1_8R :: new (((self . bits >> 16) & 3) as u8) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_9 (& self) -> Port1_9R { Port1_9R :: new (((self . bits >> 18) & 3) as u8) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_10 (& self) -> Port1_10R { Port1_10R :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_11 (& self) -> Port1_11R { Port1_11R :: new (((self . bits >> 22) & 3) as u8) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_12 (& self) -> Port1_12R { Port1_12R :: new (((self . bits >> 24) & 3) as u8) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_13 (& self) -> Port1_13R { Port1_13R :: new (((self . bits >> 26) & 3) as u8) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_14 (& self) -> Port1_14R { Port1_14R :: new (((self . bits >> 28) & 3) as u8) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_15 (& self) -> Port1_15R { Port1_15R :: new (((self . bits >> 30) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_0 (& mut self) -> Port1_0W < Pad1PupdSpec > { Port1_0W :: new (self , 0) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_1 (& mut self) -> Port1_1W < Pad1PupdSpec > { Port1_1W :: new (self , 2) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_2 (& mut self) -> Port1_2W < Pad1PupdSpec > { Port1_2W :: new (self , 4) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_3 (& mut self) -> Port1_3W < Pad1PupdSpec > { Port1_3W :: new (self , 6) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_4 (& mut self) -> Port1_4W < Pad1PupdSpec > { Port1_4W :: new (self , 8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_5 (& mut self) -> Port1_5W < Pad1PupdSpec > { Port1_5W :: new (self , 10) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_6 (& mut self) -> Port1_6W < Pad1PupdSpec > { Port1_6W :: new (self , 12) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_7 (& mut self) -> Port1_7W < Pad1PupdSpec > { Port1_7W :: new (self , 14) } # [doc = "Bits 16:17 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_8 (& mut self) -> Port1_8W < Pad1PupdSpec > { Port1_8W :: new (self , 16) } # [doc = "Bits 18:19 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_9 (& mut self) -> Port1_9W < Pad1PupdSpec > { Port1_9W :: new (self , 18) } # [doc = "Bits 20:21 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_10 (& mut self) -> Port1_10W < Pad1PupdSpec > { Port1_10W :: new (self , 20) } # [doc = "Bits 22:23 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_11 (& mut self) -> Port1_11W < Pad1PupdSpec > { Port1_11W :: new (self , 22) } # [doc = "Bits 24:25 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_12 (& mut self) -> Port1_12W < Pad1PupdSpec > { Port1_12W :: new (self , 24) } # [doc = "Bits 26:27 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_13 (& mut self) -> Port1_13W < Pad1PupdSpec > { Port1_13W :: new (self , 26) } # [doc = "Bits 28:29 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_14 (& mut self) -> Port1_14W < Pad1PupdSpec > { Port1_14W :: new (self , 28) } # [doc = "Bits 30:31 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_1_15 (& mut self) -> Port1_15W < Pad1PupdSpec > { Port1_15W :: new (self , 30) } } # [doc = "Управление резисторами подтяжки выводов PORT1\n\nYou can [`read`](crate::Reg::read) this register and get [`pad1_pupd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad1_pupd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Pad1PupdSpec ; impl crate :: RegisterSpec for Pad1PupdSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`pad1_pupd::R`](R) reader structure"]
impl crate :: Readable for Pad1PupdSpec { } # [doc = "`write(|w| ..)` method takes [`pad1_pupd::W`](W) writer structure"]
impl crate :: Writable for Pad1PupdSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PAD1_PUPD to value 0"]
impl crate :: Resettable for Pad1PupdSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PAD2_CFG (rw) register accessor: Управление функциями выводов PORT2\n\nYou can [`read`](crate::Reg::read) this register and get [`pad2_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad2_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pad2_cfg`]
module"]
# [doc (alias = "PAD2_CFG")]
pub type Pad2Cfg = crate :: Reg < pad2_cfg :: Pad2CfgSpec > ; # [doc = "Управление функциями выводов PORT2"]
pub mod pad2_cfg { # [doc = "Register `PAD2_CFG` reader"]
pub type R = crate :: R < Pad2CfgSpec > ; # [doc = "Register `PAD2_CFG` writer"]
pub type W = crate :: W < Pad2CfgSpec > ; # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_0 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port2_0 > for u8 { # [inline (always)]
fn from (variant : Port2_0) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_0 { type Ux = u8 ; } impl crate :: IsEnum for Port2_0 { } # [doc = "Field `Port_2_0` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_0R = crate :: FieldReader < Port2_0 > ; impl Port2_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port2_0 { match self . bits { 0 => Port2_0 :: Func1Gpio , 1 => Port2_0 :: Func2Interface , 2 => Port2_0 :: Func3InterfaceOrTimer , 3 => Port2_0 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port2_0 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port2_0 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port2_0 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port2_0 :: Func4Analog } } # [doc = "Field `Port_2_0` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_0 , crate :: Safe > ; impl < 'a , REG > Port2_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_0 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_0 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_0 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_0 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_1 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port2_1 > for u8 { # [inline (always)]
fn from (variant : Port2_1) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_1 { type Ux = u8 ; } impl crate :: IsEnum for Port2_1 { } # [doc = "Field `Port_2_1` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_1R = crate :: FieldReader < Port2_1 > ; impl Port2_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port2_1 { match self . bits { 0 => Port2_1 :: Func1Gpio , 1 => Port2_1 :: Func2Interface , 2 => Port2_1 :: Func3InterfaceOrTimer , 3 => Port2_1 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port2_1 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port2_1 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port2_1 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port2_1 :: Func4Analog } } # [doc = "Field `Port_2_1` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_1 , crate :: Safe > ; impl < 'a , REG > Port2_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_1 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_1 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_1 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_1 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_2 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port2_2 > for u8 { # [inline (always)]
fn from (variant : Port2_2) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_2 { type Ux = u8 ; } impl crate :: IsEnum for Port2_2 { } # [doc = "Field `Port_2_2` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_2R = crate :: FieldReader < Port2_2 > ; impl Port2_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port2_2 { match self . bits { 0 => Port2_2 :: Func1Gpio , 1 => Port2_2 :: Func2Interface , 2 => Port2_2 :: Func3InterfaceOrTimer , 3 => Port2_2 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port2_2 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port2_2 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port2_2 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port2_2 :: Func4Analog } } # [doc = "Field `Port_2_2` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_2 , crate :: Safe > ; impl < 'a , REG > Port2_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_2 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_2 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_2 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_2 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_3 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port2_3 > for u8 { # [inline (always)]
fn from (variant : Port2_3) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_3 { type Ux = u8 ; } impl crate :: IsEnum for Port2_3 { } # [doc = "Field `Port_2_3` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_3R = crate :: FieldReader < Port2_3 > ; impl Port2_3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port2_3 { match self . bits { 0 => Port2_3 :: Func1Gpio , 1 => Port2_3 :: Func2Interface , 2 => Port2_3 :: Func3InterfaceOrTimer , 3 => Port2_3 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port2_3 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port2_3 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port2_3 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port2_3 :: Func4Analog } } # [doc = "Field `Port_2_3` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_3 , crate :: Safe > ; impl < 'a , REG > Port2_3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_3 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_3 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_3 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_3 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_4 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port2_4 > for u8 { # [inline (always)]
fn from (variant : Port2_4) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_4 { type Ux = u8 ; } impl crate :: IsEnum for Port2_4 { } # [doc = "Field `Port_2_4` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_4R = crate :: FieldReader < Port2_4 > ; impl Port2_4R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port2_4 { match self . bits { 0 => Port2_4 :: Func1Gpio , 1 => Port2_4 :: Func2Interface , 2 => Port2_4 :: Func3InterfaceOrTimer , 3 => Port2_4 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port2_4 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port2_4 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port2_4 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port2_4 :: Func4Analog } } # [doc = "Field `Port_2_4` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_4 , crate :: Safe > ; impl < 'a , REG > Port2_4W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_4 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_4 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_4 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_4 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_5 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port2_5 > for u8 { # [inline (always)]
fn from (variant : Port2_5) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_5 { type Ux = u8 ; } impl crate :: IsEnum for Port2_5 { } # [doc = "Field `Port_2_5` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_5R = crate :: FieldReader < Port2_5 > ; impl Port2_5R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port2_5 { match self . bits { 0 => Port2_5 :: Func1Gpio , 1 => Port2_5 :: Func2Interface , 2 => Port2_5 :: Func3InterfaceOrTimer , 3 => Port2_5 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port2_5 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port2_5 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port2_5 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port2_5 :: Func4Analog } } # [doc = "Field `Port_2_5` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_5 , crate :: Safe > ; impl < 'a , REG > Port2_5W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_5 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_5 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_5 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_5 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_6 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port2_6 > for u8 { # [inline (always)]
fn from (variant : Port2_6) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_6 { type Ux = u8 ; } impl crate :: IsEnum for Port2_6 { } # [doc = "Field `Port_2_6` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_6R = crate :: FieldReader < Port2_6 > ; impl Port2_6R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port2_6 { match self . bits { 0 => Port2_6 :: Func1Gpio , 1 => Port2_6 :: Func2Interface , 2 => Port2_6 :: Func3InterfaceOrTimer , 3 => Port2_6 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port2_6 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port2_6 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port2_6 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port2_6 :: Func4Analog } } # [doc = "Field `Port_2_6` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_6 , crate :: Safe > ; impl < 'a , REG > Port2_6W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_6 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_6 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_6 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_6 :: Func4Analog) } } # [doc = "Значения двух бит кодируют выбранный функционал для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_7 { # [doc = "0: Первая функция (порт общего назначения)"]
Func1Gpio = 0 , # [doc = "1: Вторая функция (последовательный интерфейс)"]
Func2Interface = 1 , # [doc = "2: Третья функция (последовательный интерфейс или таймер)"]
Func3InterfaceOrTimer = 2 , # [doc = "3: Четвертая функция (аналоговый сигнал)"]
Func4Analog = 3 , } impl From < Port2_7 > for u8 { # [inline (always)]
fn from (variant : Port2_7) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_7 { type Ux = u8 ; } impl crate :: IsEnum for Port2_7 { } # [doc = "Field `Port_2_7` reader - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_7R = crate :: FieldReader < Port2_7 > ; impl Port2_7R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Port2_7 { match self . bits { 0 => Port2_7 :: Func1Gpio , 1 => Port2_7 :: Func2Interface , 2 => Port2_7 :: Func3InterfaceOrTimer , 3 => Port2_7 :: Func4Analog , _ => unreachable ! () , } } # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn is_func1_gpio (& self) -> bool { * self == Port2_7 :: Func1Gpio } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn is_func2_interface (& self) -> bool { * self == Port2_7 :: Func2Interface } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn is_func3_interface_or_timer (& self) -> bool { * self == Port2_7 :: Func3InterfaceOrTimer } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn is_func4_analog (& self) -> bool { * self == Port2_7 :: Func4Analog } } # [doc = "Field `Port_2_7` writer - Значения двух бит кодируют выбранный функционал для вывода"]
pub type Port2_7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_7 , crate :: Safe > ; impl < 'a , REG > Port2_7W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Первая функция (порт общего назначения)"]
# [inline (always)]
pub fn func1_gpio (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_7 :: Func1Gpio) } # [doc = "Вторая функция (последовательный интерфейс)"]
# [inline (always)]
pub fn func2_interface (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_7 :: Func2Interface) } # [doc = "Третья функция (последовательный интерфейс или таймер)"]
# [inline (always)]
pub fn func3_interface_or_timer (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_7 :: Func3InterfaceOrTimer) } # [doc = "Четвертая функция (аналоговый сигнал)"]
# [inline (always)]
pub fn func4_analog (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_7 :: Func4Analog) } } impl R { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_0 (& self) -> Port2_0R { Port2_0R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_1 (& self) -> Port2_1R { Port2_1R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_2 (& self) -> Port2_2R { Port2_2R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_3 (& self) -> Port2_3R { Port2_3R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_4 (& self) -> Port2_4R { Port2_4R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_5 (& self) -> Port2_5R { Port2_5R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_6 (& self) -> Port2_6R { Port2_6R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_7 (& self) -> Port2_7R { Port2_7R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_0 (& mut self) -> Port2_0W < Pad2CfgSpec > { Port2_0W :: new (self , 0) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_1 (& mut self) -> Port2_1W < Pad2CfgSpec > { Port2_1W :: new (self , 2) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_2 (& mut self) -> Port2_2W < Pad2CfgSpec > { Port2_2W :: new (self , 4) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_3 (& mut self) -> Port2_3W < Pad2CfgSpec > { Port2_3W :: new (self , 6) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_4 (& mut self) -> Port2_4W < Pad2CfgSpec > { Port2_4W :: new (self , 8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_5 (& mut self) -> Port2_5W < Pad2CfgSpec > { Port2_5W :: new (self , 10) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_6 (& mut self) -> Port2_6W < Pad2CfgSpec > { Port2_6W :: new (self , 12) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный функционал для вывода"]
# [inline (always)]
pub fn port_2_7 (& mut self) -> Port2_7W < Pad2CfgSpec > { Port2_7W :: new (self , 14) } } # [doc = "Управление функциями выводов PORT2\n\nYou can [`read`](crate::Reg::read) this register and get [`pad2_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad2_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Pad2CfgSpec ; impl crate :: RegisterSpec for Pad2CfgSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`pad2_cfg::R`](R) reader structure"]
impl crate :: Readable for Pad2CfgSpec { } # [doc = "`write(|w| ..)` method takes [`pad2_cfg::W`](W) writer structure"]
impl crate :: Writable for Pad2CfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PAD2_CFG to value 0"]
impl crate :: Resettable for Pad2CfgSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PAD2_DS (rw) register accessor: Управление нагрузочной способностью выводов PORT2\n\nYou can [`read`](crate::Reg::read) this register and get [`pad2_ds::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad2_ds::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pad2_ds`]
module"]
# [doc (alias = "PAD2_DS")]
pub type Pad2Ds = crate :: Reg < pad2_ds :: Pad2DsSpec > ; # [doc = "Управление нагрузочной способностью выводов PORT2"]
pub mod pad2_ds { # [doc = "Register `PAD2_DS` reader"]
pub type R = crate :: R < Pad2DsSpec > ; # [doc = "Register `PAD2_DS` writer"]
pub type W = crate :: W < Pad2DsSpec > ; # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_0 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port2_0 > for u8 { # [inline (always)]
fn from (variant : Port2_0) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_0 { type Ux = u8 ; } impl crate :: IsEnum for Port2_0 { } # [doc = "Field `Port_2_0` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_0R = crate :: FieldReader < Port2_0 > ; impl Port2_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_0 > { match self . bits { 0 => Some (Port2_0 :: _2mA) , 1 => Some (Port2_0 :: _4mA) , 2 => Some (Port2_0 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port2_0 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port2_0 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port2_0 :: _8mA } } # [doc = "Field `Port_2_0` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_0 > ; impl < 'a , REG > Port2_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_0 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_0 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_0 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_1 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port2_1 > for u8 { # [inline (always)]
fn from (variant : Port2_1) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_1 { type Ux = u8 ; } impl crate :: IsEnum for Port2_1 { } # [doc = "Field `Port_2_1` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_1R = crate :: FieldReader < Port2_1 > ; impl Port2_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_1 > { match self . bits { 0 => Some (Port2_1 :: _2mA) , 1 => Some (Port2_1 :: _4mA) , 2 => Some (Port2_1 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port2_1 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port2_1 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port2_1 :: _8mA } } # [doc = "Field `Port_2_1` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_1 > ; impl < 'a , REG > Port2_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_1 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_1 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_1 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_2 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port2_2 > for u8 { # [inline (always)]
fn from (variant : Port2_2) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_2 { type Ux = u8 ; } impl crate :: IsEnum for Port2_2 { } # [doc = "Field `Port_2_2` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_2R = crate :: FieldReader < Port2_2 > ; impl Port2_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_2 > { match self . bits { 0 => Some (Port2_2 :: _2mA) , 1 => Some (Port2_2 :: _4mA) , 2 => Some (Port2_2 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port2_2 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port2_2 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port2_2 :: _8mA } } # [doc = "Field `Port_2_2` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_2 > ; impl < 'a , REG > Port2_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_2 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_2 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_2 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_3 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port2_3 > for u8 { # [inline (always)]
fn from (variant : Port2_3) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_3 { type Ux = u8 ; } impl crate :: IsEnum for Port2_3 { } # [doc = "Field `Port_2_3` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_3R = crate :: FieldReader < Port2_3 > ; impl Port2_3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_3 > { match self . bits { 0 => Some (Port2_3 :: _2mA) , 1 => Some (Port2_3 :: _4mA) , 2 => Some (Port2_3 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port2_3 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port2_3 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port2_3 :: _8mA } } # [doc = "Field `Port_2_3` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_3 > ; impl < 'a , REG > Port2_3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_3 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_3 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_3 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_4 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port2_4 > for u8 { # [inline (always)]
fn from (variant : Port2_4) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_4 { type Ux = u8 ; } impl crate :: IsEnum for Port2_4 { } # [doc = "Field `Port_2_4` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_4R = crate :: FieldReader < Port2_4 > ; impl Port2_4R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_4 > { match self . bits { 0 => Some (Port2_4 :: _2mA) , 1 => Some (Port2_4 :: _4mA) , 2 => Some (Port2_4 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port2_4 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port2_4 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port2_4 :: _8mA } } # [doc = "Field `Port_2_4` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_4 > ; impl < 'a , REG > Port2_4W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_4 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_4 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_4 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_5 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port2_5 > for u8 { # [inline (always)]
fn from (variant : Port2_5) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_5 { type Ux = u8 ; } impl crate :: IsEnum for Port2_5 { } # [doc = "Field `Port_2_5` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_5R = crate :: FieldReader < Port2_5 > ; impl Port2_5R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_5 > { match self . bits { 0 => Some (Port2_5 :: _2mA) , 1 => Some (Port2_5 :: _4mA) , 2 => Some (Port2_5 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port2_5 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port2_5 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port2_5 :: _8mA } } # [doc = "Field `Port_2_5` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_5 > ; impl < 'a , REG > Port2_5W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_5 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_5 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_5 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_6 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port2_6 > for u8 { # [inline (always)]
fn from (variant : Port2_6) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_6 { type Ux = u8 ; } impl crate :: IsEnum for Port2_6 { } # [doc = "Field `Port_2_6` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_6R = crate :: FieldReader < Port2_6 > ; impl Port2_6R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_6 > { match self . bits { 0 => Some (Port2_6 :: _2mA) , 1 => Some (Port2_6 :: _4mA) , 2 => Some (Port2_6 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port2_6 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port2_6 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port2_6 :: _8mA } } # [doc = "Field `Port_2_6` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_6 > ; impl < 'a , REG > Port2_6W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_6 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_6 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_6 :: _8mA) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_7 { # [doc = "0: Нагрузочная способность вывода 2мА"]
_2mA = 0 , # [doc = "1: Нагрузочная способность вывода 4мА"]
_4mA = 1 , # [doc = "2: Нагрузочная способность вывода 8мА"]
_8mA = 2 , } impl From < Port2_7 > for u8 { # [inline (always)]
fn from (variant : Port2_7) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_7 { type Ux = u8 ; } impl crate :: IsEnum for Port2_7 { } # [doc = "Field `Port_2_7` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_7R = crate :: FieldReader < Port2_7 > ; impl Port2_7R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_7 > { match self . bits { 0 => Some (Port2_7 :: _2mA) , 1 => Some (Port2_7 :: _4mA) , 2 => Some (Port2_7 :: _8mA) , _ => None , } } # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn is_2m_a (& self) -> bool { * self == Port2_7 :: _2mA } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn is_4m_a (& self) -> bool { * self == Port2_7 :: _4mA } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn is_8m_a (& self) -> bool { * self == Port2_7 :: _8mA } } # [doc = "Field `Port_2_7` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_7 > ; impl < 'a , REG > Port2_7W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нагрузочная способность вывода 2мА"]
# [inline (always)]
pub fn _2m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_7 :: _2mA) } # [doc = "Нагрузочная способность вывода 4мА"]
# [inline (always)]
pub fn _4m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_7 :: _4mA) } # [doc = "Нагрузочная способность вывода 8мА"]
# [inline (always)]
pub fn _8m_a (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_7 :: _8mA) } } impl R { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_0 (& self) -> Port2_0R { Port2_0R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_1 (& self) -> Port2_1R { Port2_1R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_2 (& self) -> Port2_2R { Port2_2R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_3 (& self) -> Port2_3R { Port2_3R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_4 (& self) -> Port2_4R { Port2_4R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_5 (& self) -> Port2_5R { Port2_5R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_6 (& self) -> Port2_6R { Port2_6R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_7 (& self) -> Port2_7R { Port2_7R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_0 (& mut self) -> Port2_0W < Pad2DsSpec > { Port2_0W :: new (self , 0) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_1 (& mut self) -> Port2_1W < Pad2DsSpec > { Port2_1W :: new (self , 2) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_2 (& mut self) -> Port2_2W < Pad2DsSpec > { Port2_2W :: new (self , 4) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_3 (& mut self) -> Port2_3W < Pad2DsSpec > { Port2_3W :: new (self , 6) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_4 (& mut self) -> Port2_4W < Pad2DsSpec > { Port2_4W :: new (self , 8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_5 (& mut self) -> Port2_5W < Pad2DsSpec > { Port2_5W :: new (self , 10) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_6 (& mut self) -> Port2_6W < Pad2DsSpec > { Port2_6W :: new (self , 12) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_7 (& mut self) -> Port2_7W < Pad2DsSpec > { Port2_7W :: new (self , 14) } } # [doc = "Управление нагрузочной способностью выводов PORT2\n\nYou can [`read`](crate::Reg::read) this register and get [`pad2_ds::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad2_ds::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Pad2DsSpec ; impl crate :: RegisterSpec for Pad2DsSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`pad2_ds::R`](R) reader structure"]
impl crate :: Readable for Pad2DsSpec { } # [doc = "`write(|w| ..)` method takes [`pad2_ds::W`](W) writer structure"]
impl crate :: Writable for Pad2DsSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PAD2_DS to value 0"]
impl crate :: Resettable for Pad2DsSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "PAD2_PUPD (rw) register accessor: Управление резисторами подтяжки выводов PORT2\n\nYou can [`read`](crate::Reg::read) this register and get [`pad2_pupd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad2_pupd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@pad2_pupd`]
module"]
# [doc (alias = "PAD2_PUPD")]
pub type Pad2Pupd = crate :: Reg < pad2_pupd :: Pad2PupdSpec > ; # [doc = "Управление резисторами подтяжки выводов PORT2"]
pub mod pad2_pupd { # [doc = "Register `PAD2_PUPD` reader"]
pub type R = crate :: R < Pad2PupdSpec > ; # [doc = "Register `PAD2_PUPD` writer"]
pub type W = crate :: W < Pad2PupdSpec > ; # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_0 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port2_0 > for u8 { # [inline (always)]
fn from (variant : Port2_0) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_0 { type Ux = u8 ; } impl crate :: IsEnum for Port2_0 { } # [doc = "Field `Port_2_0` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_0R = crate :: FieldReader < Port2_0 > ; impl Port2_0R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_0 > { match self . bits { 0 => Some (Port2_0 :: PullNone) , 1 => Some (Port2_0 :: PullUp) , 2 => Some (Port2_0 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port2_0 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port2_0 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port2_0 :: PullDown } } # [doc = "Field `Port_2_0` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_0W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_0 > ; impl < 'a , REG > Port2_0W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_0 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_0 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_0 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_1 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port2_1 > for u8 { # [inline (always)]
fn from (variant : Port2_1) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_1 { type Ux = u8 ; } impl crate :: IsEnum for Port2_1 { } # [doc = "Field `Port_2_1` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_1R = crate :: FieldReader < Port2_1 > ; impl Port2_1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_1 > { match self . bits { 0 => Some (Port2_1 :: PullNone) , 1 => Some (Port2_1 :: PullUp) , 2 => Some (Port2_1 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port2_1 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port2_1 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port2_1 :: PullDown } } # [doc = "Field `Port_2_1` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_1 > ; impl < 'a , REG > Port2_1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_1 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_1 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_1 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_2 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port2_2 > for u8 { # [inline (always)]
fn from (variant : Port2_2) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_2 { type Ux = u8 ; } impl crate :: IsEnum for Port2_2 { } # [doc = "Field `Port_2_2` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_2R = crate :: FieldReader < Port2_2 > ; impl Port2_2R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_2 > { match self . bits { 0 => Some (Port2_2 :: PullNone) , 1 => Some (Port2_2 :: PullUp) , 2 => Some (Port2_2 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port2_2 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port2_2 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port2_2 :: PullDown } } # [doc = "Field `Port_2_2` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_2 > ; impl < 'a , REG > Port2_2W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_2 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_2 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_2 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_3 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port2_3 > for u8 { # [inline (always)]
fn from (variant : Port2_3) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_3 { type Ux = u8 ; } impl crate :: IsEnum for Port2_3 { } # [doc = "Field `Port_2_3` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_3R = crate :: FieldReader < Port2_3 > ; impl Port2_3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_3 > { match self . bits { 0 => Some (Port2_3 :: PullNone) , 1 => Some (Port2_3 :: PullUp) , 2 => Some (Port2_3 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port2_3 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port2_3 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port2_3 :: PullDown } } # [doc = "Field `Port_2_3` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_3W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_3 > ; impl < 'a , REG > Port2_3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_3 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_3 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_3 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_4 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port2_4 > for u8 { # [inline (always)]
fn from (variant : Port2_4) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_4 { type Ux = u8 ; } impl crate :: IsEnum for Port2_4 { } # [doc = "Field `Port_2_4` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_4R = crate :: FieldReader < Port2_4 > ; impl Port2_4R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_4 > { match self . bits { 0 => Some (Port2_4 :: PullNone) , 1 => Some (Port2_4 :: PullUp) , 2 => Some (Port2_4 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port2_4 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port2_4 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port2_4 :: PullDown } } # [doc = "Field `Port_2_4` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_4W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_4 > ; impl < 'a , REG > Port2_4W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_4 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_4 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_4 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_5 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port2_5 > for u8 { # [inline (always)]
fn from (variant : Port2_5) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_5 { type Ux = u8 ; } impl crate :: IsEnum for Port2_5 { } # [doc = "Field `Port_2_5` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_5R = crate :: FieldReader < Port2_5 > ; impl Port2_5R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_5 > { match self . bits { 0 => Some (Port2_5 :: PullNone) , 1 => Some (Port2_5 :: PullUp) , 2 => Some (Port2_5 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port2_5 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port2_5 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port2_5 :: PullDown } } # [doc = "Field `Port_2_5` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_5W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_5 > ; impl < 'a , REG > Port2_5W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_5 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_5 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_5 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_6 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port2_6 > for u8 { # [inline (always)]
fn from (variant : Port2_6) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_6 { type Ux = u8 ; } impl crate :: IsEnum for Port2_6 { } # [doc = "Field `Port_2_6` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_6R = crate :: FieldReader < Port2_6 > ; impl Port2_6R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_6 > { match self . bits { 0 => Some (Port2_6 :: PullNone) , 1 => Some (Port2_6 :: PullUp) , 2 => Some (Port2_6 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port2_6 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port2_6 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port2_6 :: PullDown } } # [doc = "Field `Port_2_6` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_6W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_6 > ; impl < 'a , REG > Port2_6W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_6 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_6 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_6 :: PullDown) } } # [doc = "Значения двух бит кодируют выбранный режим для вывода\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Port2_7 { # [doc = "0: Без подтяжки"]
PullNone = 0 , # [doc = "1: Подтяжка к питанию"]
PullUp = 1 , # [doc = "2: Подтяжка к земле"]
PullDown = 2 , } impl From < Port2_7 > for u8 { # [inline (always)]
fn from (variant : Port2_7) -> Self { variant as _ } } impl crate :: FieldSpec for Port2_7 { type Ux = u8 ; } impl crate :: IsEnum for Port2_7 { } # [doc = "Field `Port_2_7` reader - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_7R = crate :: FieldReader < Port2_7 > ; impl Port2_7R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Port2_7 > { match self . bits { 0 => Some (Port2_7 :: PullNone) , 1 => Some (Port2_7 :: PullUp) , 2 => Some (Port2_7 :: PullDown) , _ => None , } } # [doc = "Без подтяжки"]
# [inline (always)]
pub fn is_pull_none (& self) -> bool { * self == Port2_7 :: PullNone } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn is_pull_up (& self) -> bool { * self == Port2_7 :: PullUp } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn is_pull_down (& self) -> bool { * self == Port2_7 :: PullDown } } # [doc = "Field `Port_2_7` writer - Значения двух бит кодируют выбранный режим для вывода"]
pub type Port2_7W < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Port2_7 > ; impl < 'a , REG > Port2_7W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Без подтяжки"]
# [inline (always)]
pub fn pull_none (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_7 :: PullNone) } # [doc = "Подтяжка к питанию"]
# [inline (always)]
pub fn pull_up (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_7 :: PullUp) } # [doc = "Подтяжка к земле"]
# [inline (always)]
pub fn pull_down (self) -> & 'a mut crate :: W < REG > { self . variant (Port2_7 :: PullDown) } } impl R { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_0 (& self) -> Port2_0R { Port2_0R :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_1 (& self) -> Port2_1R { Port2_1R :: new (((self . bits >> 2) & 3) as u8) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_2 (& self) -> Port2_2R { Port2_2R :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_3 (& self) -> Port2_3R { Port2_3R :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_4 (& self) -> Port2_4R { Port2_4R :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_5 (& self) -> Port2_5R { Port2_5R :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_6 (& self) -> Port2_6R { Port2_6R :: new (((self . bits >> 12) & 3) as u8) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_7 (& self) -> Port2_7R { Port2_7R :: new (((self . bits >> 14) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_0 (& mut self) -> Port2_0W < Pad2PupdSpec > { Port2_0W :: new (self , 0) } # [doc = "Bits 2:3 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_1 (& mut self) -> Port2_1W < Pad2PupdSpec > { Port2_1W :: new (self , 2) } # [doc = "Bits 4:5 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_2 (& mut self) -> Port2_2W < Pad2PupdSpec > { Port2_2W :: new (self , 4) } # [doc = "Bits 6:7 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_3 (& mut self) -> Port2_3W < Pad2PupdSpec > { Port2_3W :: new (self , 6) } # [doc = "Bits 8:9 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_4 (& mut self) -> Port2_4W < Pad2PupdSpec > { Port2_4W :: new (self , 8) } # [doc = "Bits 10:11 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_5 (& mut self) -> Port2_5W < Pad2PupdSpec > { Port2_5W :: new (self , 10) } # [doc = "Bits 12:13 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_6 (& mut self) -> Port2_6W < Pad2PupdSpec > { Port2_6W :: new (self , 12) } # [doc = "Bits 14:15 - Значения двух бит кодируют выбранный режим для вывода"]
# [inline (always)]
pub fn port_2_7 (& mut self) -> Port2_7W < Pad2PupdSpec > { Port2_7W :: new (self , 14) } } # [doc = "Управление резисторами подтяжки выводов PORT2\n\nYou can [`read`](crate::Reg::read) this register and get [`pad2_pupd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`pad2_pupd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Pad2PupdSpec ; impl crate :: RegisterSpec for Pad2PupdSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`pad2_pupd::R`](R) reader structure"]
impl crate :: Readable for Pad2PupdSpec { } # [doc = "`write(|w| ..)` method takes [`pad2_pupd::W`](W) writer structure"]
impl crate :: Writable for Pad2PupdSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PAD2_PUPD to value 0"]
impl crate :: Resettable for Pad2PupdSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Сторожевой таймер шины"]
pub struct WdtBus { _marker : PhantomData < * const () > } unsafe impl Send for WdtBus { } impl WdtBus { # [doc = r"Pointer to the register block"]
pub const PTR : * const wdt_bus :: RegisterBlock = 0x0005_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const wdt_bus :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for WdtBus { type Target = wdt_bus :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WdtBus { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WdtBus") . finish () } } # [doc = "Сторожевой таймер шины"]
pub mod wdt_bus { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { timeout : Timeout , irq_clear : IrqClear , enable : Enable , } impl RegisterBlock { # [doc = "0x00 - Определеяет количество циклов ожидания до формирования ошибки. Значения от 0 до 15. Количество циклов ожидания вычисляется как 2^TIMEOUT."]
# [inline (always)]
pub const fn timeout (& self) -> & Timeout { & self . timeout } # [doc = "0x04 - Сброс прерываний"]
# [inline (always)]
pub const fn irq_clear (& self) -> & IrqClear { & self . irq_clear } # [doc = "0x08 - Запуск/отключение мониторов шины"]
# [inline (always)]
pub const fn enable (& self) -> & Enable { & self . enable } } # [doc = "TIMEOUT (rw) register accessor: Определеяет количество циклов ожидания до формирования ошибки. Значения от 0 до 15. Количество циклов ожидания вычисляется как 2^TIMEOUT.\n\nYou can [`read`](crate::Reg::read) this register and get [`timeout::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timeout::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@timeout`]
module"]
# [doc (alias = "TIMEOUT")]
pub type Timeout = crate :: Reg < timeout :: TimeoutSpec > ; # [doc = "Определеяет количество циклов ожидания до формирования ошибки. Значения от 0 до 15. Количество циклов ожидания вычисляется как 2^TIMEOUT."]
pub mod timeout { # [doc = "Register `TIMEOUT` reader"]
pub type R = crate :: R < TimeoutSpec > ; # [doc = "Register `TIMEOUT` writer"]
pub type W = crate :: W < TimeoutSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Определеяет количество циклов ожидания до формирования ошибки. Значения от 0 до 15. Количество циклов ожидания вычисляется как 2^TIMEOUT.\n\nYou can [`read`](crate::Reg::read) this register and get [`timeout::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timeout::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TimeoutSpec ; impl crate :: RegisterSpec for TimeoutSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`timeout::R`](R) reader structure"]
impl crate :: Readable for TimeoutSpec { } # [doc = "`write(|w| ..)` method takes [`timeout::W`](W) writer structure"]
impl crate :: Writable for TimeoutSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TIMEOUT to value 0"]
impl crate :: Resettable for TimeoutSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "IRQ_CLEAR (w) register accessor: Сброс прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irq_clear::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@irq_clear`]
module"]
# [doc (alias = "IRQ_CLEAR")]
pub type IrqClear = crate :: Reg < irq_clear :: IrqClearSpec > ; # [doc = "Сброс прерываний"]
pub mod irq_clear { # [doc = "Register `IRQ_CLEAR` writer"]
pub type W = crate :: W < IrqClearSpec > ; # [doc = "Field `DOM3` writer - Сброс прерываний для монитора шины периферийных устройств"]
pub type Dom3W < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `SPIFI` writer - Сброс прерываний для монитора шины SPIFI"]
pub type SpifiW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `EEPROM` writer - Сброс прерываний для монитора шины EEPROM"]
pub type EepromW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; impl W { # [doc = "Bit 0 - Сброс прерываний для монитора шины периферийных устройств"]
# [inline (always)]
pub fn dom3 (& mut self) -> Dom3W < IrqClearSpec > { Dom3W :: new (self , 0) } # [doc = "Bit 1 - Сброс прерываний для монитора шины SPIFI"]
# [inline (always)]
pub fn spifi (& mut self) -> SpifiW < IrqClearSpec > { SpifiW :: new (self , 1) } # [doc = "Bit 2 - Сброс прерываний для монитора шины EEPROM"]
# [inline (always)]
pub fn eeprom (& mut self) -> EepromW < IrqClearSpec > { EepromW :: new (self , 2) } } # [doc = "Сброс прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`irq_clear::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IrqClearSpec ; impl crate :: RegisterSpec for IrqClearSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`irq_clear::W`](W) writer structure"]
impl crate :: Writable for IrqClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0x07 ; } # [doc = "`reset()` method sets IRQ_CLEAR to value 0"]
impl crate :: Resettable for IrqClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ENABLE (rw) register accessor: Запуск/отключение мониторов шины\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable`]
module"]
# [doc (alias = "ENABLE")]
pub type Enable = crate :: Reg < enable :: EnableSpec > ; # [doc = "Запуск/отключение мониторов шины"]
pub mod enable { # [doc = "Register `ENABLE` reader"]
pub type R = crate :: R < EnableSpec > ; # [doc = "Register `ENABLE` writer"]
pub type W = crate :: W < EnableSpec > ; # [doc = "Управление монитором шины периферийных устройств\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dom3 { # [doc = "0: Монитор шины выключен"]
Disable = 0 , # [doc = "1: Монитор шины включен"]
Enable = 1 , } impl From < Dom3 > for bool { # [inline (always)]
fn from (variant : Dom3) -> Self { variant as u8 != 0 } } # [doc = "Field `DOM3` reader - Управление монитором шины периферийных устройств"]
pub type Dom3R = crate :: BitReader < Dom3 > ; impl Dom3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dom3 { match self . bits { false => Dom3 :: Disable , true => Dom3 :: Enable , } } # [doc = "Монитор шины выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dom3 :: Disable } # [doc = "Монитор шины включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dom3 :: Enable } } # [doc = "Field `DOM3` writer - Управление монитором шины периферийных устройств"]
pub type Dom3W < 'a , REG > = crate :: BitWriter < 'a , REG , Dom3 > ; impl < 'a , REG > Dom3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Монитор шины выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dom3 :: Disable) } # [doc = "Монитор шины включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dom3 :: Enable) } } # [doc = "Управление монитором шины SPIFI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Spifi { # [doc = "0: Монитор шины выключен"]
Disable = 0 , # [doc = "1: Монитор шины включен"]
Enable = 1 , } impl From < Spifi > for bool { # [inline (always)]
fn from (variant : Spifi) -> Self { variant as u8 != 0 } } # [doc = "Field `SPIFI` reader - Управление монитором шины SPIFI"]
pub type SpifiR = crate :: BitReader < Spifi > ; impl SpifiR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Spifi { match self . bits { false => Spifi :: Disable , true => Spifi :: Enable , } } # [doc = "Монитор шины выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Spifi :: Disable } # [doc = "Монитор шины включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Spifi :: Enable } } # [doc = "Field `SPIFI` writer - Управление монитором шины SPIFI"]
pub type SpifiW < 'a , REG > = crate :: BitWriter < 'a , REG , Spifi > ; impl < 'a , REG > SpifiW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Монитор шины выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Spifi :: Disable) } # [doc = "Монитор шины включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Spifi :: Enable) } } # [doc = "Управление монитором шины EEPROM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Eeprom { # [doc = "0: Монитор шины выключен"]
Disable = 0 , # [doc = "1: Монитор шины включен"]
Enable = 1 , } impl From < Eeprom > for bool { # [inline (always)]
fn from (variant : Eeprom) -> Self { variant as u8 != 0 } } # [doc = "Field `EEPROM` reader - Управление монитором шины EEPROM"]
pub type EepromR = crate :: BitReader < Eeprom > ; impl EepromR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Eeprom { match self . bits { false => Eeprom :: Disable , true => Eeprom :: Enable , } } # [doc = "Монитор шины выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Eeprom :: Disable } # [doc = "Монитор шины включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Eeprom :: Enable } } # [doc = "Field `EEPROM` writer - Управление монитором шины EEPROM"]
pub type EepromW < 'a , REG > = crate :: BitWriter < 'a , REG , Eeprom > ; impl < 'a , REG > EepromW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Монитор шины выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Eeprom :: Disable) } # [doc = "Монитор шины включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Eeprom :: Enable) } } impl R { # [doc = "Bit 0 - Управление монитором шины периферийных устройств"]
# [inline (always)]
pub fn dom3 (& self) -> Dom3R { Dom3R :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Управление монитором шины SPIFI"]
# [inline (always)]
pub fn spifi (& self) -> SpifiR { SpifiR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Управление монитором шины EEPROM"]
# [inline (always)]
pub fn eeprom (& self) -> EepromR { EepromR :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление монитором шины периферийных устройств"]
# [inline (always)]
pub fn dom3 (& mut self) -> Dom3W < EnableSpec > { Dom3W :: new (self , 0) } # [doc = "Bit 1 - Управление монитором шины SPIFI"]
# [inline (always)]
pub fn spifi (& mut self) -> SpifiW < EnableSpec > { SpifiW :: new (self , 1) } # [doc = "Bit 2 - Управление монитором шины EEPROM"]
# [inline (always)]
pub fn eeprom (& mut self) -> EepromW < EnableSpec > { EepromW :: new (self , 2) } } # [doc = "Запуск/отключение мониторов шины\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EnableSpec ; impl crate :: RegisterSpec for EnableSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`enable::R`](R) reader structure"]
impl crate :: Readable for EnableSpec { } # [doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
impl crate :: Writable for EnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ENABLE to value 0"]
impl crate :: Resettable for EnableSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Контроллер блока однократно-программируемой памяти"]
pub struct Otp { _marker : PhantomData < * const () > } unsafe impl Send for Otp { } impl Otp { # [doc = r"Pointer to the register block"]
pub const PTR : * const otp :: RegisterBlock = 0x0005_1400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const otp :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Otp { type Target = otp :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Otp { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Otp") . finish () } } # [doc = "Контроллер блока однократно-программируемой памяти"]
pub mod otp { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { otpdat : Otpdat , otpa : Otpa , otpcon : Otpcon , otpsta : Otpsta , otpdec : Otpdec , otpadj : Otpadj , otpwt1 : Otpwt1 , otpwt2 : Otpwt2 , } impl RegisterBlock { # [doc = "0x00 - Регистр чтения/записи данных"]
# [inline (always)]
pub const fn otpdat (& self) -> & Otpdat { & self . otpdat } # [doc = "0x04 - Регистр адреса страницы"]
# [inline (always)]
pub const fn otpa (& self) -> & Otpa { & self . otpa } # [doc = "0x08 - Регистр управления"]
# [inline (always)]
pub const fn otpcon (& self) -> & Otpcon { & self . otpcon } # [doc = "0x0c - Регистр статуса"]
# [inline (always)]
pub const fn otpsta (& self) -> & Otpsta { & self . otpsta } # [doc = "0x10 - Регистр дешифратора строк"]
# [inline (always)]
pub const fn otpdec (& self) -> & Otpdec { & self . otpdec } # [doc = "0x14 - Регистр управления временными параметрами процедуры чтения и доп. настройками"]
# [inline (always)]
pub const fn otpadj (& self) -> & Otpadj { & self . otpadj } # [doc = "0x18 - Регистр подстройки длительности процедуры записи 1"]
# [inline (always)]
pub const fn otpwt1 (& self) -> & Otpwt1 { & self . otpwt1 } # [doc = "0x1c - Регистр подстройки длительности процедуры записи 2"]
# [inline (always)]
pub const fn otpwt2 (& self) -> & Otpwt2 { & self . otpwt2 } } # [doc = "OTPDAT (rw) register accessor: Регистр чтения/записи данных\n\nYou can [`read`](crate::Reg::read) this register and get [`otpdat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpdat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otpdat`]
module"]
# [doc (alias = "OTPDAT")]
pub type Otpdat = crate :: Reg < otpdat :: OtpdatSpec > ; # [doc = "Регистр чтения/записи данных"]
pub mod otpdat { # [doc = "Register `OTPDAT` reader"]
pub type R = crate :: R < OtpdatSpec > ; # [doc = "Register `OTPDAT` writer"]
pub type W = crate :: W < OtpdatSpec > ; # [doc = "Field `DATA` reader - Сразу после выполнения записи в этот регистр будет запущена внутренняя процедура записи загруженных данных в массив antifuse OTP. Временные параметры данной операции могут быть настроены с помощью других регистров. При чтении из этого регистра считываются данные, полученные из OTP"]
pub type DataR = crate :: FieldReader < u32 > ; # [doc = "Field `DATA` writer - Сразу после выполнения записи в этот регистр будет запущена внутренняя процедура записи загруженных данных в массив antifuse OTP. Временные параметры данной операции могут быть настроены с помощью других регистров. При чтении из этого регистра считываются данные, полученные из OTP"]
pub type DataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Сразу после выполнения записи в этот регистр будет запущена внутренняя процедура записи загруженных данных в массив antifuse OTP. Временные параметры данной операции могут быть настроены с помощью других регистров. При чтении из этого регистра считываются данные, полученные из OTP"]
# [inline (always)]
pub fn data (& self) -> DataR { DataR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Сразу после выполнения записи в этот регистр будет запущена внутренняя процедура записи загруженных данных в массив antifuse OTP. Временные параметры данной операции могут быть настроены с помощью других регистров. При чтении из этого регистра считываются данные, полученные из OTP"]
# [inline (always)]
pub fn data (& mut self) -> DataW < OtpdatSpec > { DataW :: new (self , 0) } } # [doc = "Регистр чтения/записи данных\n\nYou can [`read`](crate::Reg::read) this register and get [`otpdat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpdat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OtpdatSpec ; impl crate :: RegisterSpec for OtpdatSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`otpdat::R`](R) reader structure"]
impl crate :: Readable for OtpdatSpec { } # [doc = "`write(|w| ..)` method takes [`otpdat::W`](W) writer structure"]
impl crate :: Writable for OtpdatSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OTPDAT to value 0"]
impl crate :: Resettable for OtpdatSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "OTPA (rw) register accessor: Регистр адреса страницы\n\nYou can [`read`](crate::Reg::read) this register and get [`otpa::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpa::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otpa`]
module"]
# [doc (alias = "OTPA")]
pub type Otpa = crate :: Reg < otpa :: OtpaSpec > ; # [doc = "Регистр адреса страницы"]
pub mod otpa { # [doc = "Register `OTPA` reader"]
pub type R = crate :: R < OtpaSpec > ; # [doc = "Register `OTPA` writer"]
pub type W = crate :: W < OtpaSpec > ; # [doc = "Адрес слова для выполнения записи/чтения.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Addr { # [doc = "0: Номер строки основного массива OTP"]
MainArray = 0 , # [doc = "4: Тестовая строка OTP"]
TestRow = 4 , # [doc = "8: Тестовый столбец OTP"]
TestColumn = 8 , # [doc = "12: Тестовый бит"]
TestBit = 12 , } impl From < Addr > for u8 { # [inline (always)]
fn from (variant : Addr) -> Self { variant as _ } } impl crate :: FieldSpec for Addr { type Ux = u8 ; } impl crate :: IsEnum for Addr { } # [doc = "Field `ADDR` reader - Адрес слова для выполнения записи/чтения."]
pub type AddrR = crate :: FieldReader < Addr > ; impl AddrR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Addr > { match self . bits { 0 => Some (Addr :: MainArray) , 4 => Some (Addr :: TestRow) , 8 => Some (Addr :: TestColumn) , 12 => Some (Addr :: TestBit) , _ => None , } } # [doc = "Номер строки основного массива OTP"]
# [inline (always)]
pub fn is_main_array (& self) -> bool { * self == Addr :: MainArray } # [doc = "Тестовая строка OTP"]
# [inline (always)]
pub fn is_test_row (& self) -> bool { * self == Addr :: TestRow } # [doc = "Тестовый столбец OTP"]
# [inline (always)]
pub fn is_test_column (& self) -> bool { * self == Addr :: TestColumn } # [doc = "Тестовый бит"]
# [inline (always)]
pub fn is_test_bit (& self) -> bool { * self == Addr :: TestBit } } # [doc = "Field `ADDR` writer - Адрес слова для выполнения записи/чтения."]
pub type AddrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 5 , Addr > ; impl < 'a , REG > AddrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Номер строки основного массива OTP"]
# [inline (always)]
pub fn main_array (self) -> & 'a mut crate :: W < REG > { self . variant (Addr :: MainArray) } # [doc = "Тестовая строка OTP"]
# [inline (always)]
pub fn test_row (self) -> & 'a mut crate :: W < REG > { self . variant (Addr :: TestRow) } # [doc = "Тестовый столбец OTP"]
# [inline (always)]
pub fn test_column (self) -> & 'a mut crate :: W < REG > { self . variant (Addr :: TestColumn) } # [doc = "Тестовый бит"]
# [inline (always)]
pub fn test_bit (self) -> & 'a mut crate :: W < REG > { self . variant (Addr :: TestBit) } } impl R { # [doc = "Bits 0:4 - Адрес слова для выполнения записи/чтения."]
# [inline (always)]
pub fn addr (& self) -> AddrR { AddrR :: new ((self . bits & 0x1f) as u8) } } impl W { # [doc = "Bits 0:4 - Адрес слова для выполнения записи/чтения."]
# [inline (always)]
pub fn addr (& mut self) -> AddrW < OtpaSpec > { AddrW :: new (self , 0) } } # [doc = "Регистр адреса страницы\n\nYou can [`read`](crate::Reg::read) this register and get [`otpa::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpa::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OtpaSpec ; impl crate :: RegisterSpec for OtpaSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`otpa::R`](R) reader structure"]
impl crate :: Readable for OtpaSpec { } # [doc = "`write(|w| ..)` method takes [`otpa::W`](W) writer structure"]
impl crate :: Writable for OtpaSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OTPA to value 0"]
impl crate :: Resettable for OtpaSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "OTPCON (w) register accessor: Регистр управления\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpcon::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otpcon`]
module"]
# [doc (alias = "OTPCON")]
pub type Otpcon = crate :: Reg < otpcon :: OtpconSpec > ; # [doc = "Регистр управления"]
pub mod otpcon { # [doc = "Register `OTPCON` writer"]
pub type W = crate :: W < OtpconSpec > ; # [doc = "Field `APBNWS` writer - Отключение вставки тактов ожидания в процессе обмена по APB при чтении данных (обращении к регистру OTPDAT на чтение). Если такты ожидания отключены (APBNWS=1), то требуется производить опрос флага OTPSTA.BSY после за¬писи адреса в OTPA до тех пор, пока EESTA.BSY не станет равным 0"]
pub type ApbnwsW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `man_we_i` writer - Ручное управление сигналом we i блока Hard IP. Используется для тестирования"]
pub type ManWeIW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `man_re_i` writer - Ручное управление сигналом re i блока Hard IP. Используется для тестирования"]
pub type ManReIW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `MME` writer - Режим ручного управления включен. В этом режиме автоматизированные операции чтения и записи не выполняются. Используется для тестирования"]
pub type MmeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W { # [doc = "Bit 0 - Отключение вставки тактов ожидания в процессе обмена по APB при чтении данных (обращении к регистру OTPDAT на чтение). Если такты ожидания отключены (APBNWS=1), то требуется производить опрос флага OTPSTA.BSY после за¬писи адреса в OTPA до тех пор, пока EESTA.BSY не станет равным 0"]
# [inline (always)]
pub fn apbnws (& mut self) -> ApbnwsW < OtpconSpec > { ApbnwsW :: new (self , 0) } # [doc = "Bit 1 - Ручное управление сигналом we i блока Hard IP. Используется для тестирования"]
# [inline (always)]
pub fn man_we_i (& mut self) -> ManWeIW < OtpconSpec > { ManWeIW :: new (self , 1) } # [doc = "Bit 2 - Ручное управление сигналом re i блока Hard IP. Используется для тестирования"]
# [inline (always)]
pub fn man_re_i (& mut self) -> ManReIW < OtpconSpec > { ManReIW :: new (self , 2) } # [doc = "Bit 3 - Режим ручного управления включен. В этом режиме автоматизированные операции чтения и записи не выполняются. Используется для тестирования"]
# [inline (always)]
pub fn mme (& mut self) -> MmeW < OtpconSpec > { MmeW :: new (self , 3) } } # [doc = "Регистр управления\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpcon::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OtpconSpec ; impl crate :: RegisterSpec for OtpconSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`otpcon::W`](W) writer structure"]
impl crate :: Writable for OtpconSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OTPCON to value 0"]
impl crate :: Resettable for OtpconSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "OTPSTA (r) register accessor: Регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`otpsta::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otpsta`]
module"]
# [doc (alias = "OTPSTA")]
pub type Otpsta = crate :: Reg < otpsta :: OtpstaSpec > ; # [doc = "Регистр статуса"]
pub mod otpsta { # [doc = "Register `OTPSTA` reader"]
pub type R = crate :: R < OtpstaSpec > ; # [doc = "Блок занят (выполняется запрошенная операция)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Bsy { # [doc = "0: Блок готов"]
Ready = 0 , # [doc = "1: Блок занят"]
Busy = 1 , } impl From < Bsy > for bool { # [inline (always)]
fn from (variant : Bsy) -> Self { variant as u8 != 0 } } # [doc = "Field `BSY` reader - Блок занят (выполняется запрошенная операция)"]
pub type BsyR = crate :: BitReader < Bsy > ; impl BsyR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Bsy { match self . bits { false => Bsy :: Ready , true => Bsy :: Busy , } } # [doc = "Блок готов"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Bsy :: Ready } # [doc = "Блок занят"]
# [inline (always)]
pub fn is_busy (& self) -> bool { * self == Bsy :: Busy } } impl R { # [doc = "Bit 0 - Блок занят (выполняется запрошенная операция)"]
# [inline (always)]
pub fn bsy (& self) -> BsyR { BsyR :: new ((self . bits & 1) != 0) } } # [doc = "Регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`otpsta::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OtpstaSpec ; impl crate :: RegisterSpec for OtpstaSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`otpsta::R`](R) reader structure"]
impl crate :: Readable for OtpstaSpec { } # [doc = "`reset()` method sets OTPSTA to value 0"]
impl crate :: Resettable for OtpstaSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "OTPDEC (r) register accessor: Регистр дешифратора строк\n\nYou can [`read`](crate::Reg::read) this register and get [`otpdec::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otpdec`]
module"]
# [doc (alias = "OTPDEC")]
pub type Otpdec = crate :: Reg < otpdec :: OtpdecSpec > ; # [doc = "Регистр дешифратора строк"]
pub mod otpdec { # [doc = "Register `OTPDEC` reader"]
pub type R = crate :: R < OtpdecSpec > ; # [doc = "Field `DECO` reader - Выход дешифратора строк блока OTP. Используется для тестирования. Проверка функционирования дешифратора строк осуществляется путем смены адреса тестового столбца, страницы и контроля выходов дешифратора"]
pub type DecoR = crate :: FieldReader < u16 > ; impl R { # [doc = "Bits 0:8 - Выход дешифратора строк блока OTP. Используется для тестирования. Проверка функционирования дешифратора строк осуществляется путем смены адреса тестового столбца, страницы и контроля выходов дешифратора"]
# [inline (always)]
pub fn deco (& self) -> DecoR { DecoR :: new ((self . bits & 0x01ff) as u16) } } # [doc = "Регистр дешифратора строк\n\nYou can [`read`](crate::Reg::read) this register and get [`otpdec::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OtpdecSpec ; impl crate :: RegisterSpec for OtpdecSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`otpdec::R`](R) reader structure"]
impl crate :: Readable for OtpdecSpec { } # [doc = "`reset()` method sets OTPDEC to value 0"]
impl crate :: Resettable for OtpdecSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "OTPADJ (rw) register accessor: Регистр управления временными параметрами процедуры чтения и доп. настройками\n\nYou can [`read`](crate::Reg::read) this register and get [`otpadj::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpadj::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otpadj`]
module"]
# [doc (alias = "OTPADJ")]
pub type Otpadj = crate :: Reg < otpadj :: OtpadjSpec > ; # [doc = "Регистр управления временными параметрами процедуры чтения и доп. настройками"]
pub mod otpadj { # [doc = "Register `OTPADJ` reader"]
pub type R = crate :: R < OtpadjSpec > ; # [doc = "Register `OTPADJ` writer"]
pub type W = crate :: W < OtpadjSpec > ; # [doc = "Field `N_RSU` reader - Время между моментом начала транзакции на APB и положительным фронтом re i в тактах. Должно использоваться для обеспечения требования к временам предустановки Hard IP. Учитывая то, что на входе i удерживаются стабильные уровни в результате предыдущей операции записи в регистр OTPA, при частотах ниже 200 МГц данное значение рекомендуется устанавливать равным 0"]
pub type NRsuR = crate :: FieldReader ; # [doc = "Field `N_RSU` writer - Время между моментом начала транзакции на APB и положительным фронтом re i в тактах. Должно использоваться для обеспечения требования к временам предустановки Hard IP. Учитывая то, что на входе i удерживаются стабильные уровни в результате предыдущей операции записи в регистр OTPA, при частотах ниже 200 МГц данное значение рекомендуется устанавливать равным 0"]
pub type NRsuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `N_RA` reader - Длительность высокого уровня сигнала re_i (вход Hard IP) в тактах. Рекомендуемое значение N_RA = ceil(40/Pclk), где Pclk – период тактового сигнала в ceil – функция округле¬ния до ближайшего большего целого числа. Пример: два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
pub type NRaR = crate :: FieldReader ; # [doc = "Field `N_RA` writer - Длительность высокого уровня сигнала re_i (вход Hard IP) в тактах. Рекомендуемое значение N_RA = ceil(40/Pclk), где Pclk – период тактового сигнала в ceil – функция округле¬ния до ближайшего большего целого числа. Пример: два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
pub type NRaW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `N_RH` reader - Время между задним фронтом re_i и моментом, в который мо¬жет быть начата новая транзакция на APB. Должно исполь¬зоваться для обеспечения требования к временам удержания Hard IP. Рекомендуемое значение N_RH = =ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округле¬ния до ближайшего большего целого числа. Пример: два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
pub type NRhR = crate :: FieldReader ; # [doc = "Field `N_RH` writer - Время между задним фронтом re_i и моментом, в который мо¬жет быть начата новая транзакция на APB. Должно исполь¬зоваться для обеспечения требования к временам удержания Hard IP. Рекомендуемое значение N_RH = =ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округле¬ния до ближайшего большего целого числа. Пример: два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
pub type NRhW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Выбор напряжения чтения\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SelUppReadI { # [doc = "0: Напряжения чтения 2,0 В"]
_2v = 0 , # [doc = "1: Напряжения чтения 2,5 B"]
_2_5v = 1 , # [doc = "3: Напряжения чтения 3,0 B"]
_3v = 3 , # [doc = "2: Напряжения чтения VDD18"]
Vdd18 = 2 , # [doc = "6: Напряжения чтения VDD5"]
Vdd5 = 6 , } impl From < SelUppReadI > for u8 { # [inline (always)]
fn from (variant : SelUppReadI) -> Self { variant as _ } } impl crate :: FieldSpec for SelUppReadI { type Ux = u8 ; } impl crate :: IsEnum for SelUppReadI { } # [doc = "Field `sel_upp_read_i` reader - Выбор напряжения чтения"]
pub type SelUppReadIR = crate :: FieldReader < SelUppReadI > ; impl SelUppReadIR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < SelUppReadI > { match self . bits { 0 => Some (SelUppReadI :: _2v) , 1 => Some (SelUppReadI :: _2_5v) , 3 => Some (SelUppReadI :: _3v) , 2 => Some (SelUppReadI :: Vdd18) , 6 => Some (SelUppReadI :: Vdd5) , _ => None , } } # [doc = "Напряжения чтения 2,0 В"]
# [inline (always)]
pub fn is_2v (& self) -> bool { * self == SelUppReadI :: _2v } # [doc = "Напряжения чтения 2,5 B"]
# [inline (always)]
pub fn is_2_5v (& self) -> bool { * self == SelUppReadI :: _2_5v } # [doc = "Напряжения чтения 3,0 B"]
# [inline (always)]
pub fn is_3v (& self) -> bool { * self == SelUppReadI :: _3v } # [doc = "Напряжения чтения VDD18"]
# [inline (always)]
pub fn is_vdd18 (& self) -> bool { * self == SelUppReadI :: Vdd18 } # [doc = "Напряжения чтения VDD5"]
# [inline (always)]
pub fn is_vdd5 (& self) -> bool { * self == SelUppReadI :: Vdd5 } } # [doc = "Field `sel_upp_read_i` writer - Выбор напряжения чтения"]
pub type SelUppReadIW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , SelUppReadI > ; impl < 'a , REG > SelUppReadIW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Напряжения чтения 2,0 В"]
# [inline (always)]
pub fn _2v (self) -> & 'a mut crate :: W < REG > { self . variant (SelUppReadI :: _2v) } # [doc = "Напряжения чтения 2,5 B"]
# [inline (always)]
pub fn _2_5v (self) -> & 'a mut crate :: W < REG > { self . variant (SelUppReadI :: _2_5v) } # [doc = "Напряжения чтения 3,0 B"]
# [inline (always)]
pub fn _3v (self) -> & 'a mut crate :: W < REG > { self . variant (SelUppReadI :: _3v) } # [doc = "Напряжения чтения VDD18"]
# [inline (always)]
pub fn vdd18 (self) -> & 'a mut crate :: W < REG > { self . variant (SelUppReadI :: Vdd18) } # [doc = "Напряжения чтения VDD5"]
# [inline (always)]
pub fn vdd5 (self) -> & 'a mut crate :: W < REG > { self . variant (SelUppReadI :: Vdd5) } } # [doc = "Выбор тока считывания. Используется для тестирования. Не рекомендуется изменять в штатном режиме работы.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SelReadCurI { # [doc = "0: Ток считывания 2мкА"]
_2uA = 0 , # [doc = "1: Ток считывания 0,2мкА"]
_0_2uA = 1 , } impl From < SelReadCurI > for bool { # [inline (always)]
fn from (variant : SelReadCurI) -> Self { variant as u8 != 0 } } # [doc = "Field `sel_read_cur_i` reader - Выбор тока считывания. Используется для тестирования. Не рекомендуется изменять в штатном режиме работы."]
pub type SelReadCurIR = crate :: BitReader < SelReadCurI > ; impl SelReadCurIR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> SelReadCurI { match self . bits { false => SelReadCurI :: _2uA , true => SelReadCurI :: _0_2uA , } } # [doc = "Ток считывания 2мкА"]
# [inline (always)]
pub fn is_2u_a (& self) -> bool { * self == SelReadCurI :: _2uA } # [doc = "Ток считывания 0,2мкА"]
# [inline (always)]
pub fn is_0_2u_a (& self) -> bool { * self == SelReadCurI :: _0_2uA } } # [doc = "Field `sel_read_cur_i` writer - Выбор тока считывания. Используется для тестирования. Не рекомендуется изменять в штатном режиме работы."]
pub type SelReadCurIW < 'a , REG > = crate :: BitWriter < 'a , REG , SelReadCurI > ; impl < 'a , REG > SelReadCurIW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Ток считывания 2мкА"]
# [inline (always)]
pub fn _2u_a (self) -> & 'a mut crate :: W < REG > { self . variant (SelReadCurI :: _2uA) } # [doc = "Ток считывания 0,2мкА"]
# [inline (always)]
pub fn _0_2u_a (self) -> & 'a mut crate :: W < REG > { self . variant (SelReadCurI :: _0_2uA) } } # [doc = "Режим пониженного энергопотребления. После вывода Hard IP из режима пониженного энергопотребления требуется некоторое время перед тем, как могут быть начаты новые операции\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PowerOffI { # [doc = "0: Hard IP выведен из режима пониженного энергопотребления и может выполнять операции чтения и записи"]
ActiveMode = 0 , # [doc = "1: Hard IP введен в режим пониженного энергопотребления, операции записи и чтения запрещены"]
LowPowerMode = 1 , } impl From < PowerOffI > for bool { # [inline (always)]
fn from (variant : PowerOffI) -> Self { variant as u8 != 0 } } # [doc = "Field `power_off_i` reader - Режим пониженного энергопотребления. После вывода Hard IP из режима пониженного энергопотребления требуется некоторое время перед тем, как могут быть начаты новые операции"]
pub type PowerOffIR = crate :: BitReader < PowerOffI > ; impl PowerOffIR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PowerOffI { match self . bits { false => PowerOffI :: ActiveMode , true => PowerOffI :: LowPowerMode , } } # [doc = "Hard IP выведен из режима пониженного энергопотребления и может выполнять операции чтения и записи"]
# [inline (always)]
pub fn is_active_mode (& self) -> bool { * self == PowerOffI :: ActiveMode } # [doc = "Hard IP введен в режим пониженного энергопотребления, операции записи и чтения запрещены"]
# [inline (always)]
pub fn is_low_power_mode (& self) -> bool { * self == PowerOffI :: LowPowerMode } } # [doc = "Field `power_off_i` writer - Режим пониженного энергопотребления. После вывода Hard IP из режима пониженного энергопотребления требуется некоторое время перед тем, как могут быть начаты новые операции"]
pub type PowerOffIW < 'a , REG > = crate :: BitWriter < 'a , REG , PowerOffI > ; impl < 'a , REG > PowerOffIW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Hard IP выведен из режима пониженного энергопотребления и может выполнять операции чтения и записи"]
# [inline (always)]
pub fn active_mode (self) -> & 'a mut crate :: W < REG > { self . variant (PowerOffI :: ActiveMode) } # [doc = "Hard IP введен в режим пониженного энергопотребления, операции записи и чтения запрещены"]
# [inline (always)]
pub fn low_power_mode (self) -> & 'a mut crate :: W < REG > { self . variant (PowerOffI :: LowPowerMode) } } impl R { # [doc = "Bits 0:2 - Время между моментом начала транзакции на APB и положительным фронтом re i в тактах. Должно использоваться для обеспечения требования к временам предустановки Hard IP. Учитывая то, что на входе i удерживаются стабильные уровни в результате предыдущей операции записи в регистр OTPA, при частотах ниже 200 МГц данное значение рекомендуется устанавливать равным 0"]
# [inline (always)]
pub fn n_rsu (& self) -> NRsuR { NRsuR :: new ((self . bits & 7) as u8) } # [doc = "Bits 8:10 - Длительность высокого уровня сигнала re_i (вход Hard IP) в тактах. Рекомендуемое значение N_RA = ceil(40/Pclk), где Pclk – период тактового сигнала в ceil – функция округле¬ния до ближайшего большего целого числа. Пример: два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
# [inline (always)]
pub fn n_ra (& self) -> NRaR { NRaR :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bits 16:18 - Время между задним фронтом re_i и моментом, в который мо¬жет быть начата новая транзакция на APB. Должно исполь¬зоваться для обеспечения требования к временам удержания Hard IP. Рекомендуемое значение N_RH = =ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округле¬ния до ближайшего большего целого числа. Пример: два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
# [inline (always)]
pub fn n_rh (& self) -> NRhR { NRhR :: new (((self . bits >> 16) & 7) as u8) } # [doc = "Bits 24:26 - Выбор напряжения чтения"]
# [inline (always)]
pub fn sel_upp_read_i (& self) -> SelUppReadIR { SelUppReadIR :: new (((self . bits >> 24) & 7) as u8) } # [doc = "Bit 27 - Выбор тока считывания. Используется для тестирования. Не рекомендуется изменять в штатном режиме работы."]
# [inline (always)]
pub fn sel_read_cur_i (& self) -> SelReadCurIR { SelReadCurIR :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 28 - Режим пониженного энергопотребления. После вывода Hard IP из режима пониженного энергопотребления требуется некоторое время перед тем, как могут быть начаты новые операции"]
# [inline (always)]
pub fn power_off_i (& self) -> PowerOffIR { PowerOffIR :: new (((self . bits >> 28) & 1) != 0) } } impl W { # [doc = "Bits 0:2 - Время между моментом начала транзакции на APB и положительным фронтом re i в тактах. Должно использоваться для обеспечения требования к временам предустановки Hard IP. Учитывая то, что на входе i удерживаются стабильные уровни в результате предыдущей операции записи в регистр OTPA, при частотах ниже 200 МГц данное значение рекомендуется устанавливать равным 0"]
# [inline (always)]
pub fn n_rsu (& mut self) -> NRsuW < OtpadjSpec > { NRsuW :: new (self , 0) } # [doc = "Bits 8:10 - Длительность высокого уровня сигнала re_i (вход Hard IP) в тактах. Рекомендуемое значение N_RA = ceil(40/Pclk), где Pclk – период тактового сигнала в ceil – функция округле¬ния до ближайшего большего целого числа. Пример: два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
# [inline (always)]
pub fn n_ra (& mut self) -> NRaW < OtpadjSpec > { NRaW :: new (self , 8) } # [doc = "Bits 16:18 - Время между задним фронтом re_i и моментом, в который мо¬жет быть начата новая транзакция на APB. Должно исполь¬зоваться для обеспечения требования к временам удержания Hard IP. Рекомендуемое значение N_RH = =ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округле¬ния до ближайшего большего целого числа. Пример: два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
# [inline (always)]
pub fn n_rh (& mut self) -> NRhW < OtpadjSpec > { NRhW :: new (self , 16) } # [doc = "Bits 24:26 - Выбор напряжения чтения"]
# [inline (always)]
pub fn sel_upp_read_i (& mut self) -> SelUppReadIW < OtpadjSpec > { SelUppReadIW :: new (self , 24) } # [doc = "Bit 27 - Выбор тока считывания. Используется для тестирования. Не рекомендуется изменять в штатном режиме работы."]
# [inline (always)]
pub fn sel_read_cur_i (& mut self) -> SelReadCurIW < OtpadjSpec > { SelReadCurIW :: new (self , 27) } # [doc = "Bit 28 - Режим пониженного энергопотребления. После вывода Hard IP из режима пониженного энергопотребления требуется некоторое время перед тем, как могут быть начаты новые операции"]
# [inline (always)]
pub fn power_off_i (& mut self) -> PowerOffIW < OtpadjSpec > { PowerOffIW :: new (self , 28) } } # [doc = "Регистр управления временными параметрами процедуры чтения и доп. настройками\n\nYou can [`read`](crate::Reg::read) this register and get [`otpadj::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpadj::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OtpadjSpec ; impl crate :: RegisterSpec for OtpadjSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`otpadj::R`](R) reader structure"]
impl crate :: Readable for OtpadjSpec { } # [doc = "`write(|w| ..)` method takes [`otpadj::W`](W) writer structure"]
impl crate :: Writable for OtpadjSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OTPADJ to value 0x0101_0100"]
impl crate :: Resettable for OtpadjSpec { const RESET_VALUE : u32 = 0x0101_0100 ; } } # [doc = "OTPWT1 (rw) register accessor: Регистр подстройки длительности процедуры записи 1\n\nYou can [`read`](crate::Reg::read) this register and get [`otpwt1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpwt1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otpwt1`]
module"]
# [doc (alias = "OTPWT1")]
pub type Otpwt1 = crate :: Reg < otpwt1 :: Otpwt1Spec > ; # [doc = "Регистр подстройки длительности процедуры записи 1"]
pub mod otpwt1 { # [doc = "Register `OTPWT1` reader"]
pub type R = crate :: R < Otpwt1Spec > ; # [doc = "Register `OTPWT1` writer"]
pub type W = crate :: W < Otpwt1Spec > ; # [doc = "Field `N_SU` reader - Время между моментом окончания транзакции на APB и положительным фронтом we i в тактах. Должно использоваться для обеспечения требования к временам предустановки Hard IP. Рекомендуемое значение N_SU = =ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округле-ния до ближайшего большего целого числа. Пример – два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
pub type NSuR = crate :: FieldReader ; # [doc = "Field `N_SU` writer - Время между моментом окончания транзакции на APB и положительным фронтом we i в тактах. Должно использоваться для обеспечения требования к временам предустановки Hard IP. Рекомендуемое значение N_SU = =ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округле-ния до ближайшего большего целого числа. Пример – два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
pub type NSuW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `N_H` reader - Время между задним фронтом we_i и задним фронтом OTPSTA.BSY в тактах. Должно использоваться для обеспече¬ния требования к временам удержания Hard IP. Рекомендуемое значение N_H=ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округления до ближайшего боль¬шего целого числа. Пример – ldf такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
pub type NHR = crate :: FieldReader ; # [doc = "Field `N_H` writer - Время между задним фронтом we_i и задним фронтом OTPSTA.BSY в тактах. Должно использоваться для обеспече¬ния требования к временам удержания Hard IP. Рекомендуемое значение N_H=ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округления до ближайшего боль¬шего целого числа. Пример – ldf такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
pub type NHW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; impl R { # [doc = "Bits 0:2 - Время между моментом окончания транзакции на APB и положительным фронтом we i в тактах. Должно использоваться для обеспечения требования к временам предустановки Hard IP. Рекомендуемое значение N_SU = =ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округле-ния до ближайшего большего целого числа. Пример – два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
# [inline (always)]
pub fn n_su (& self) -> NSuR { NSuR :: new ((self . bits & 7) as u8) } # [doc = "Bits 8:10 - Время между задним фронтом we_i и задним фронтом OTPSTA.BSY в тактах. Должно использоваться для обеспече¬ния требования к временам удержания Hard IP. Рекомендуемое значение N_H=ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округления до ближайшего боль¬шего целого числа. Пример – ldf такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
# [inline (always)]
pub fn n_h (& self) -> NHR { NHR :: new (((self . bits >> 8) & 7) as u8) } } impl W { # [doc = "Bits 0:2 - Время между моментом окончания транзакции на APB и положительным фронтом we i в тактах. Должно использоваться для обеспечения требования к временам предустановки Hard IP. Рекомендуемое значение N_SU = =ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округле-ния до ближайшего большего целого числа. Пример – два такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
# [inline (always)]
pub fn n_su (& mut self) -> NSuW < Otpwt1Spec > { NSuW :: new (self , 0) } # [doc = "Bits 8:10 - Время между задним фронтом we_i и задним фронтом OTPSTA.BSY в тактах. Должно использоваться для обеспече¬ния требования к временам удержания Hard IP. Рекомендуемое значение N_H=ceil(40/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округления до ближайшего боль¬шего целого числа. Пример – ldf такта для частоты Fclk = 33,3 МГц. Для корректной работы схемы значение должно быть больше 0"]
# [inline (always)]
pub fn n_h (& mut self) -> NHW < Otpwt1Spec > { NHW :: new (self , 8) } } # [doc = "Регистр подстройки длительности процедуры записи 1\n\nYou can [`read`](crate::Reg::read) this register and get [`otpwt1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpwt1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Otpwt1Spec ; impl crate :: RegisterSpec for Otpwt1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`otpwt1::R`](R) reader structure"]
impl crate :: Readable for Otpwt1Spec { } # [doc = "`write(|w| ..)` method takes [`otpwt1::W`](W) writer structure"]
impl crate :: Writable for Otpwt1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OTPWT1 to value 0x0202"]
impl crate :: Resettable for Otpwt1Spec { const RESET_VALUE : u32 = 0x0202 ; } } # [doc = "OTPWT2 (rw) register accessor: Регистр подстройки длительности процедуры записи 2\n\nYou can [`read`](crate::Reg::read) this register and get [`otpwt2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpwt2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@otpwt2`]
module"]
# [doc (alias = "OTPWT2")]
pub type Otpwt2 = crate :: Reg < otpwt2 :: Otpwt2Spec > ; # [doc = "Регистр подстройки длительности процедуры записи 2"]
pub mod otpwt2 { # [doc = "Register `OTPWT2` reader"]
pub type R = crate :: R < Otpwt2Spec > ; # [doc = "Register `OTPWT2` writer"]
pub type W = crate :: W < Otpwt2Spec > ; # [doc = "Field `N_W` reader - Длительность высокого уровня сигнала we i (вход Hard IP) в тактах. Рекомендуемое значение N_W = 50000000 нс/Pclk, где Pclk – период тактового сигнала в нс. Пример– 1666667 тактов для частоты Fclk = 33,3 МГц"]
pub type NWR = crate :: FieldReader < u32 > ; # [doc = "Field `N_W` writer - Длительность высокого уровня сигнала we i (вход Hard IP) в тактах. Рекомендуемое значение N_W = 50000000 нс/Pclk, где Pclk – период тактового сигнала в нс. Пример– 1666667 тактов для частоты Fclk = 33,3 МГц"]
pub type NWW < 'a , REG > = crate :: FieldWriter < 'a , REG , 24 , u32 > ; impl R { # [doc = "Bits 0:23 - Длительность высокого уровня сигнала we i (вход Hard IP) в тактах. Рекомендуемое значение N_W = 50000000 нс/Pclk, где Pclk – период тактового сигнала в нс. Пример– 1666667 тактов для частоты Fclk = 33,3 МГц"]
# [inline (always)]
pub fn n_w (& self) -> NWR { NWR :: new (self . bits & 0x00ff_ffff) } } impl W { # [doc = "Bits 0:23 - Длительность высокого уровня сигнала we i (вход Hard IP) в тактах. Рекомендуемое значение N_W = 50000000 нс/Pclk, где Pclk – период тактового сигнала в нс. Пример– 1666667 тактов для частоты Fclk = 33,3 МГц"]
# [inline (always)]
pub fn n_w (& mut self) -> NWW < Otpwt2Spec > { NWW :: new (self , 0) } } # [doc = "Регистр подстройки длительности процедуры записи 2\n\nYou can [`read`](crate::Reg::read) this register and get [`otpwt2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`otpwt2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Otpwt2Spec ; impl crate :: RegisterSpec for Otpwt2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`otpwt2::R`](R) reader structure"]
impl crate :: Readable for Otpwt2Spec { } # [doc = "`write(|w| ..)` method takes [`otpwt2::W`](W) writer structure"]
impl crate :: Writable for Otpwt2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OTPWT2 to value 0x0019_6e6b"]
impl crate :: Resettable for Otpwt2Spec { const RESET_VALUE : u32 = 0x0019_6e6b ; } } } # [doc = "Блок WakeUp - управление питанием системным доменом, управление источниками тактовых сигналов"]
pub struct WakeUp { _marker : PhantomData < * const () > } unsafe impl Send for WakeUp { } impl WakeUp { # [doc = r"Pointer to the register block"]
pub const PTR : * const wake_up :: RegisterBlock = 0x0006_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const wake_up :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for WakeUp { type Target = wake_up :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for WakeUp { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("WakeUp") . finish () } } # [doc = "Блок WakeUp - управление питанием системным доменом, управление источниками тактовых сигналов"]
pub mod wake_up { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { sys_mask : SysMask , sys_level : SysLevel , sys_poweroff : SysPoweroff , power_switch : PowerSwitch , clocks_bu : ClocksBu , clocks_sys : ClocksSys , rtc_control : RtcControl , stop : Stop , } impl RegisterBlock { # [doc = "0x00 - Маски событий для включения и сброса системного домена"]
# [inline (always)]
pub const fn sys_mask (& self) -> & SysMask { & self . sys_mask } # [doc = "0x04 - Активные уровни событий для включения и сброса системного домена"]
# [inline (always)]
pub const fn sys_level (& self) -> & SysLevel { & self . sys_level } # [doc = "0x08 - Запись в регистр «1» отключает питание системного домена"]
# [inline (always)]
pub const fn sys_poweroff (& self) -> & SysPoweroff { & self . sys_poweroff } # [doc = "0x0c - Регистр управления и статуса схемы слежения за питанием"]
# [inline (always)]
pub const fn power_switch (& self) -> & PowerSwitch { & self . power_switch } # [doc = "0x10 - Регистр управления тактированием батарейного домена"]
# [inline (always)]
pub const fn clocks_bu (& self) -> & ClocksBu { & self . clocks_bu } # [doc = "0x14 - Регистр управления тактированием системного домена"]
# [inline (always)]
pub const fn clocks_sys (& self) -> & ClocksSys { & self . clocks_sys } # [doc = "0x18 - Сброс RTC происходит при записи “1”"]
# [inline (always)]
pub const fn rtc_control (& self) -> & RtcControl { & self . rtc_control } # [doc = "0x1c - Переход в режим “Стоп”. Осуществляется записью “1” Отключает тактирования системной шины."]
# [inline (always)]
pub const fn stop (& self) -> & Stop { & self . stop } } # [doc = "SYS_MASK (rw) register accessor: Маски событий для включения и сброса системного домена\n\nYou can [`read`](crate::Reg::read) this register and get [`sys_mask::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sys_mask::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sys_mask`]
module"]
# [doc (alias = "SYS_MASK")]
pub type SysMask = crate :: Reg < sys_mask :: SysMaskSpec > ; # [doc = "Маски событий для включения и сброса системного домена"]
pub mod sys_mask { # [doc = "Register `SYS_MASK` reader"]
pub type R = crate :: R < SysMaskSpec > ; # [doc = "Register `SYS_MASK` writer"]
pub type W = crate :: W < SysMaskSpec > ; # [doc = "Разрешение включение системного домена (из режима СТОП) при срабатывании будильника\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SysUpRtc { # [doc = "0: Запрещено"]
Disable = 0 , # [doc = "1: Разрешено"]
Enable = 1 , } impl From < SysUpRtc > for bool { # [inline (always)]
fn from (variant : SysUpRtc) -> Self { variant as u8 != 0 } } # [doc = "Field `SYS_UP_RTC` reader - Разрешение включение системного домена (из режима СТОП) при срабатывании будильника"]
pub type SysUpRtcR = crate :: BitReader < SysUpRtc > ; impl SysUpRtcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> SysUpRtc { match self . bits { false => SysUpRtc :: Disable , true => SysUpRtc :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SysUpRtc :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == SysUpRtc :: Enable } } # [doc = "Field `SYS_UP_RTC` writer - Разрешение включение системного домена (из режима СТОП) при срабатывании будильника"]
pub type SysUpRtcW < 'a , REG > = crate :: BitWriter < 'a , REG , SysUpRtc > ; impl < 'a , REG > SysUpRtcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (SysUpRtc :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (SysUpRtc :: Enable) } } # [doc = "Разрешение включение системного домена (из режима СТОП) при активном уровне внешнего вывода ext_wu\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SysUpWu { # [doc = "0: Запрещено"]
Disable = 0 , # [doc = "1: Разрешено"]
Enable = 1 , } impl From < SysUpWu > for bool { # [inline (always)]
fn from (variant : SysUpWu) -> Self { variant as u8 != 0 } } # [doc = "Field `SYS_UP_WU` reader - Разрешение включение системного домена (из режима СТОП) при активном уровне внешнего вывода ext_wu"]
pub type SysUpWuR = crate :: BitReader < SysUpWu > ; impl SysUpWuR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> SysUpWu { match self . bits { false => SysUpWu :: Disable , true => SysUpWu :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SysUpWu :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == SysUpWu :: Enable } } # [doc = "Field `SYS_UP_WU` writer - Разрешение включение системного домена (из режима СТОП) при активном уровне внешнего вывода ext_wu"]
pub type SysUpWuW < 'a , REG > = crate :: BitWriter < 'a , REG , SysUpWu > ; impl < 'a , REG > SysUpWuW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (SysUpWu :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (SysUpWu :: Enable) } } # [doc = "Запрещение формирования сброса системного домена при снижении питания (индикация от LDO_SYS)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SysRstLdo { # [doc = "1: Запрещено"]
Disable = 1 , # [doc = "0: Разрешено"]
Enable = 0 , } impl From < SysRstLdo > for bool { # [inline (always)]
fn from (variant : SysRstLdo) -> Self { variant as u8 != 0 } } # [doc = "Field `SYS_RST_LDO` reader - Запрещение формирования сброса системного домена при снижении питания (индикация от LDO_SYS)"]
pub type SysRstLdoR = crate :: BitReader < SysRstLdo > ; impl SysRstLdoR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> SysRstLdo { match self . bits { true => SysRstLdo :: Disable , false => SysRstLdo :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SysRstLdo :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == SysRstLdo :: Enable } } # [doc = "Field `SYS_RST_LDO` writer - Запрещение формирования сброса системного домена при снижении питания (индикация от LDO_SYS)"]
pub type SysRstLdoW < 'a , REG > = crate :: BitWriter < 'a , REG , SysRstLdo > ; impl < 'a , REG > SysRstLdoW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (SysRstLdo :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (SysRstLdo :: Enable) } } # [doc = "Запрещение формирования сброса системного домена при снижении питания (индикация от схемы слежения)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SysRstPs { # [doc = "1: Запрещено"]
Disable = 1 , # [doc = "0: Разрешено"]
Enable = 0 , } impl From < SysRstPs > for bool { # [inline (always)]
fn from (variant : SysRstPs) -> Self { variant as u8 != 0 } } # [doc = "Field `SYS_RST_PS` reader - Запрещение формирования сброса системного домена при снижении питания (индикация от схемы слежения)"]
pub type SysRstPsR = crate :: BitReader < SysRstPs > ; impl SysRstPsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> SysRstPs { match self . bits { true => SysRstPs :: Disable , false => SysRstPs :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SysRstPs :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == SysRstPs :: Enable } } # [doc = "Field `SYS_RST_PS` writer - Запрещение формирования сброса системного домена при снижении питания (индикация от схемы слежения)"]
pub type SysRstPsW < 'a , REG > = crate :: BitWriter < 'a , REG , SysRstPs > ; impl < 'a , REG > SysRstPsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (SysRstPs :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (SysRstPs :: Enable) } } # [doc = "Запрещение формирования сброса системного домена при появлении сигнала BOR\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SysRstBor { # [doc = "1: Запрещено"]
Disable = 1 , # [doc = "0: Разрешено"]
Enable = 0 , } impl From < SysRstBor > for bool { # [inline (always)]
fn from (variant : SysRstBor) -> Self { variant as u8 != 0 } } # [doc = "Field `SYS_RST_BOR` reader - Запрещение формирования сброса системного домена при появлении сигнала BOR"]
pub type SysRstBorR = crate :: BitReader < SysRstBor > ; impl SysRstBorR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> SysRstBor { match self . bits { true => SysRstBor :: Disable , false => SysRstBor :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SysRstBor :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == SysRstBor :: Enable } } # [doc = "Field `SYS_RST_BOR` writer - Запрещение формирования сброса системного домена при появлении сигнала BOR"]
pub type SysRstBorW < 'a , REG > = crate :: BitWriter < 'a , REG , SysRstBor > ; impl < 'a , REG > SysRstBorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (SysRstBor :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (SysRstBor :: Enable) } } # [doc = "Запрещение формирования сброса батарейного домена при появлении сигнала BOR\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum BuRstBor { # [doc = "1: Запрещено"]
Disable = 1 , # [doc = "0: Разрешено"]
Enable = 0 , } impl From < BuRstBor > for bool { # [inline (always)]
fn from (variant : BuRstBor) -> Self { variant as u8 != 0 } } # [doc = "Field `BU_RST_BOR` reader - Запрещение формирования сброса батарейного домена при появлении сигнала BOR"]
pub type BuRstBorR = crate :: BitReader < BuRstBor > ; impl BuRstBorR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> BuRstBor { match self . bits { true => BuRstBor :: Disable , false => BuRstBor :: Enable , } } # [doc = "Запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == BuRstBor :: Disable } # [doc = "Разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == BuRstBor :: Enable } } # [doc = "Field `BU_RST_BOR` writer - Запрещение формирования сброса батарейного домена при появлении сигнала BOR"]
pub type BuRstBorW < 'a , REG > = crate :: BitWriter < 'a , REG , BuRstBor > ; impl < 'a , REG > BuRstBorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (BuRstBor :: Disable) } # [doc = "Разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (BuRstBor :: Enable) } } impl R { # [doc = "Bit 0 - Разрешение включение системного домена (из режима СТОП) при срабатывании будильника"]
# [inline (always)]
pub fn sys_up_rtc (& self) -> SysUpRtcR { SysUpRtcR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Разрешение включение системного домена (из режима СТОП) при активном уровне внешнего вывода ext_wu"]
# [inline (always)]
pub fn sys_up_wu (& self) -> SysUpWuR { SysUpWuR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Запрещение формирования сброса системного домена при снижении питания (индикация от LDO_SYS)"]
# [inline (always)]
pub fn sys_rst_ldo (& self) -> SysRstLdoR { SysRstLdoR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Запрещение формирования сброса системного домена при снижении питания (индикация от схемы слежения)"]
# [inline (always)]
pub fn sys_rst_ps (& self) -> SysRstPsR { SysRstPsR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Запрещение формирования сброса системного домена при появлении сигнала BOR"]
# [inline (always)]
pub fn sys_rst_bor (& self) -> SysRstBorR { SysRstBorR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Запрещение формирования сброса батарейного домена при появлении сигнала BOR"]
# [inline (always)]
pub fn bu_rst_bor (& self) -> BuRstBorR { BuRstBorR :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Разрешение включение системного домена (из режима СТОП) при срабатывании будильника"]
# [inline (always)]
pub fn sys_up_rtc (& mut self) -> SysUpRtcW < SysMaskSpec > { SysUpRtcW :: new (self , 0) } # [doc = "Bit 1 - Разрешение включение системного домена (из режима СТОП) при активном уровне внешнего вывода ext_wu"]
# [inline (always)]
pub fn sys_up_wu (& mut self) -> SysUpWuW < SysMaskSpec > { SysUpWuW :: new (self , 1) } # [doc = "Bit 2 - Запрещение формирования сброса системного домена при снижении питания (индикация от LDO_SYS)"]
# [inline (always)]
pub fn sys_rst_ldo (& mut self) -> SysRstLdoW < SysMaskSpec > { SysRstLdoW :: new (self , 2) } # [doc = "Bit 3 - Запрещение формирования сброса системного домена при снижении питания (индикация от схемы слежения)"]
# [inline (always)]
pub fn sys_rst_ps (& mut self) -> SysRstPsW < SysMaskSpec > { SysRstPsW :: new (self , 3) } # [doc = "Bit 4 - Запрещение формирования сброса системного домена при появлении сигнала BOR"]
# [inline (always)]
pub fn sys_rst_bor (& mut self) -> SysRstBorW < SysMaskSpec > { SysRstBorW :: new (self , 4) } # [doc = "Bit 5 - Запрещение формирования сброса батарейного домена при появлении сигнала BOR"]
# [inline (always)]
pub fn bu_rst_bor (& mut self) -> BuRstBorW < SysMaskSpec > { BuRstBorW :: new (self , 5) } } # [doc = "Маски событий для включения и сброса системного домена\n\nYou can [`read`](crate::Reg::read) this register and get [`sys_mask::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sys_mask::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SysMaskSpec ; impl crate :: RegisterSpec for SysMaskSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sys_mask::R`](R) reader structure"]
impl crate :: Readable for SysMaskSpec { } # [doc = "`write(|w| ..)` method takes [`sys_mask::W`](W) writer structure"]
impl crate :: Writable for SysMaskSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SYS_MASK to value 0x10"]
impl crate :: Resettable for SysMaskSpec { const RESET_VALUE : u32 = 0x10 ; } } # [doc = "SYS_LEVEL (rw) register accessor: Активные уровни событий для включения и сброса системного домена\n\nYou can [`read`](crate::Reg::read) this register and get [`sys_level::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sys_level::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sys_level`]
module"]
# [doc (alias = "SYS_LEVEL")]
pub type SysLevel = crate :: Reg < sys_level :: SysLevelSpec > ; # [doc = "Активные уровни событий для включения и сброса системного домена"]
pub mod sys_level { # [doc = "Register `SYS_LEVEL` reader"]
pub type R = crate :: R < SysLevelSpec > ; # [doc = "Register `SYS_LEVEL` writer"]
pub type W = crate :: W < SysLevelSpec > ; # [doc = "Активный уровень срабатывания будильника RTC\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum LvlRtc { # [doc = "0: Активный уровень \"0\""]
Low = 0 , # [doc = "1: Активный уровень \"1\""]
High = 1 , } impl From < LvlRtc > for bool { # [inline (always)]
fn from (variant : LvlRtc) -> Self { variant as u8 != 0 } } # [doc = "Field `LVL_RTC` reader - Активный уровень срабатывания будильника RTC"]
pub type LvlRtcR = crate :: BitReader < LvlRtc > ; impl LvlRtcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> LvlRtc { match self . bits { false => LvlRtc :: Low , true => LvlRtc :: High , } } # [doc = "Активный уровень \"0\""]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == LvlRtc :: Low } # [doc = "Активный уровень \"1\""]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == LvlRtc :: High } } # [doc = "Field `LVL_RTC` writer - Активный уровень срабатывания будильника RTC"]
pub type LvlRtcW < 'a , REG > = crate :: BitWriter < 'a , REG , LvlRtc > ; impl < 'a , REG > LvlRtcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Активный уровень \"0\""]
# [inline (always)]
pub fn low (self) -> & 'a mut crate :: W < REG > { self . variant (LvlRtc :: Low) } # [doc = "Активный уровень \"1\""]
# [inline (always)]
pub fn high (self) -> & 'a mut crate :: W < REG > { self . variant (LvlRtc :: High) } } # [doc = "Активный уровень внешнего вывода ext_wu\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum LvlWu { # [doc = "0: Активный уровень \"0\""]
Low = 0 , # [doc = "1: Активный уровень \"1\""]
High = 1 , } impl From < LvlWu > for bool { # [inline (always)]
fn from (variant : LvlWu) -> Self { variant as u8 != 0 } } # [doc = "Field `LVL_WU` reader - Активный уровень внешнего вывода ext_wu"]
pub type LvlWuR = crate :: BitReader < LvlWu > ; impl LvlWuR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> LvlWu { match self . bits { false => LvlWu :: Low , true => LvlWu :: High , } } # [doc = "Активный уровень \"0\""]
# [inline (always)]
pub fn is_low (& self) -> bool { * self == LvlWu :: Low } # [doc = "Активный уровень \"1\""]
# [inline (always)]
pub fn is_high (& self) -> bool { * self == LvlWu :: High } } # [doc = "Field `LVL_WU` writer - Активный уровень внешнего вывода ext_wu"]
pub type LvlWuW < 'a , REG > = crate :: BitWriter < 'a , REG , LvlWu > ; impl < 'a , REG > LvlWuW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Активный уровень \"0\""]
# [inline (always)]
pub fn low (self) -> & 'a mut crate :: W < REG > { self . variant (LvlWu :: Low) } # [doc = "Активный уровень \"1\""]
# [inline (always)]
pub fn high (self) -> & 'a mut crate :: W < REG > { self . variant (LvlWu :: High) } } impl R { # [doc = "Bit 0 - Активный уровень срабатывания будильника RTC"]
# [inline (always)]
pub fn lvl_rtc (& self) -> LvlRtcR { LvlRtcR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Активный уровень внешнего вывода ext_wu"]
# [inline (always)]
pub fn lvl_wu (& self) -> LvlWuR { LvlWuR :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Активный уровень срабатывания будильника RTC"]
# [inline (always)]
pub fn lvl_rtc (& mut self) -> LvlRtcW < SysLevelSpec > { LvlRtcW :: new (self , 0) } # [doc = "Bit 1 - Активный уровень внешнего вывода ext_wu"]
# [inline (always)]
pub fn lvl_wu (& mut self) -> LvlWuW < SysLevelSpec > { LvlWuW :: new (self , 1) } } # [doc = "Активные уровни событий для включения и сброса системного домена\n\nYou can [`read`](crate::Reg::read) this register and get [`sys_level::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sys_level::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SysLevelSpec ; impl crate :: RegisterSpec for SysLevelSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sys_level::R`](R) reader structure"]
impl crate :: Readable for SysLevelSpec { } # [doc = "`write(|w| ..)` method takes [`sys_level::W`](W) writer structure"]
impl crate :: Writable for SysLevelSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SYS_LEVEL to value 0x03"]
impl crate :: Resettable for SysLevelSpec { const RESET_VALUE : u32 = 0x03 ; } } # [doc = "SYS_POWEROFF (w) register accessor: Запись в регистр «1» отключает питание системного домена\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sys_poweroff::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sys_poweroff`]
module"]
# [doc (alias = "SYS_POWEROFF")]
pub type SysPoweroff = crate :: Reg < sys_poweroff :: SysPoweroffSpec > ; # [doc = "Запись в регистр «1» отключает питание системного домена"]
pub mod sys_poweroff { # [doc = "Register `SYS_POWEROFF` writer"]
pub type W = crate :: W < SysPoweroffSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < SysPoweroffSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Запись в регистр «1» отключает питание системного домена\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sys_poweroff::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SysPoweroffSpec ; impl crate :: RegisterSpec for SysPoweroffSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`sys_poweroff::W`](W) writer structure"]
impl crate :: Writable for SysPoweroffSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SYS_POWEROFF to value 0"]
impl crate :: Resettable for SysPoweroffSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "POWER_SWITCH (rw) register accessor: Регистр управления и статуса схемы слежения за питанием\n\nYou can [`read`](crate::Reg::read) this register and get [`power_switch::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`power_switch::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@power_switch`]
module"]
# [doc (alias = "POWER_SWITCH")]
pub type PowerSwitch = crate :: Reg < power_switch :: PowerSwitchSpec > ; # [doc = "Регистр управления и статуса схемы слежения за питанием"]
pub mod power_switch { # [doc = "Register `POWER_SWITCH` reader"]
pub type R = crate :: R < PowerSwitchSpec > ; # [doc = "Register `POWER_SWITCH` writer"]
pub type W = crate :: W < PowerSwitchSpec > ; # [doc = "Разрешение принудительного переключения на один из источников питания\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum En { # [doc = "0: Автоматическое переключение на один из источников питания"]
Automatic = 0 , # [doc = "1: Принудительное переключение на один из источников питания"]
Forced = 1 , } impl From < En > for bool { # [inline (always)]
fn from (variant : En) -> Self { variant as u8 != 0 } } # [doc = "Field `EN` reader - Разрешение принудительного переключения на один из источников питания"]
pub type EnR = crate :: BitReader < En > ; impl EnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> En { match self . bits { false => En :: Automatic , true => En :: Forced , } } # [doc = "Автоматическое переключение на один из источников питания"]
# [inline (always)]
pub fn is_automatic (& self) -> bool { * self == En :: Automatic } # [doc = "Принудительное переключение на один из источников питания"]
# [inline (always)]
pub fn is_forced (& self) -> bool { * self == En :: Forced } } # [doc = "Field `EN` writer - Разрешение принудительного переключения на один из источников питания"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG , En > ; impl < 'a , REG > EnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Автоматическое переключение на один из источников питания"]
# [inline (always)]
pub fn automatic (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Automatic) } # [doc = "Принудительное переключение на один из источников питания"]
# [inline (always)]
pub fn forced (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Forced) } } # [doc = "Выбор источника напряжения VCC_BU при принудительного переключения (при En = \"1\")\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Control { # [doc = "0: VCC - источник напряжения VCC_BU"]
Vcc = 0 , # [doc = "1: VCC_BAT - источник напряжения VCC_BU"]
VccBat = 1 , } impl From < Control > for bool { # [inline (always)]
fn from (variant : Control) -> Self { variant as u8 != 0 } } # [doc = "Field `CONTROL` reader - Выбор источника напряжения VCC_BU при принудительного переключения (при En = \"1\")"]
pub type ControlR = crate :: BitReader < Control > ; impl ControlR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Control { match self . bits { false => Control :: Vcc , true => Control :: VccBat , } } # [doc = "VCC - источник напряжения VCC_BU"]
# [inline (always)]
pub fn is_vcc (& self) -> bool { * self == Control :: Vcc } # [doc = "VCC_BAT - источник напряжения VCC_BU"]
# [inline (always)]
pub fn is_vcc_bat (& self) -> bool { * self == Control :: VccBat } } # [doc = "Field `CONTROL` writer - Выбор источника напряжения VCC_BU при принудительного переключения (при En = \"1\")"]
pub type ControlW < 'a , REG > = crate :: BitWriter < 'a , REG , Control > ; impl < 'a , REG > ControlW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "VCC - источник напряжения VCC_BU"]
# [inline (always)]
pub fn vcc (self) -> & 'a mut crate :: W < REG > { self . variant (Control :: Vcc) } # [doc = "VCC_BAT - источник напряжения VCC_BU"]
# [inline (always)]
pub fn vcc_bat (self) -> & 'a mut crate :: W < REG > { self . variant (Control :: VccBat) } } # [doc = "Field `BATT_GOOD` reader - Флаг состояние резервного (батарейного) источника питания"]
pub type BattGoodR = crate :: BitReader ; impl R { # [doc = "Bit 0 - Разрешение принудительного переключения на один из источников питания"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Выбор источника напряжения VCC_BU при принудительного переключения (при En = \"1\")"]
# [inline (always)]
pub fn control (& self) -> ControlR { ControlR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Флаг состояние резервного (батарейного) источника питания"]
# [inline (always)]
pub fn batt_good (& self) -> BattGoodR { BattGoodR :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Разрешение принудительного переключения на один из источников питания"]
# [inline (always)]
pub fn en (& mut self) -> EnW < PowerSwitchSpec > { EnW :: new (self , 0) } # [doc = "Bit 1 - Выбор источника напряжения VCC_BU при принудительного переключения (при En = \"1\")"]
# [inline (always)]
pub fn control (& mut self) -> ControlW < PowerSwitchSpec > { ControlW :: new (self , 1) } } # [doc = "Регистр управления и статуса схемы слежения за питанием\n\nYou can [`read`](crate::Reg::read) this register and get [`power_switch::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`power_switch::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct PowerSwitchSpec ; impl crate :: RegisterSpec for PowerSwitchSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`power_switch::R`](R) reader structure"]
impl crate :: Readable for PowerSwitchSpec { } # [doc = "`write(|w| ..)` method takes [`power_switch::W`](W) writer structure"]
impl crate :: Writable for PowerSwitchSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets POWER_SWITCH to value 0"]
impl crate :: Resettable for PowerSwitchSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CLOCKS_BU (rw) register accessor: Регистр управления тактированием батарейного домена\n\nYou can [`read`](crate::Reg::read) this register and get [`clocks_bu::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clocks_bu::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clocks_bu`]
module"]
# [doc (alias = "CLOCKS_BU")]
pub type ClocksBu = crate :: Reg < clocks_bu :: ClocksBuSpec > ; # [doc = "Регистр управления тактированием батарейного домена"]
pub mod clocks_bu { # [doc = "Register `CLOCKS_BU` reader"]
pub type R = crate :: R < ClocksBuSpec > ; # [doc = "Register `CLOCKS_BU` writer"]
pub type W = crate :: W < ClocksBuSpec > ; # [doc = "Включение/отключение внешнего осциллятора на 32 KГц\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Osc32kEn { # [doc = "0: Включение OSC32K"]
Enable = 0 , # [doc = "1: Отключение OSC32K"]
Disable = 1 , } impl From < Osc32kEn > for bool { # [inline (always)]
fn from (variant : Osc32kEn) -> Self { variant as u8 != 0 } } # [doc = "Field `OSC32K_EN` reader - Включение/отключение внешнего осциллятора на 32 KГц"]
pub type Osc32kEnR = crate :: BitReader < Osc32kEn > ; impl Osc32kEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Osc32kEn { match self . bits { false => Osc32kEn :: Enable , true => Osc32kEn :: Disable , } } # [doc = "Включение OSC32K"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Osc32kEn :: Enable } # [doc = "Отключение OSC32K"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Osc32kEn :: Disable } } # [doc = "Field `OSC32K_EN` writer - Включение/отключение внешнего осциллятора на 32 KГц"]
pub type Osc32kEnW < 'a , REG > = crate :: BitWriter < 'a , REG , Osc32kEn > ; impl < 'a , REG > Osc32kEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Включение OSC32K"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Osc32kEn :: Enable) } # [doc = "Отключение OSC32K"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Osc32kEn :: Disable) } } # [doc = "Включение/отключение LSI32К\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Lsi32kEn { # [doc = "0: Включение LSI32К"]
Enable = 0 , # [doc = "1: Отключение LSI32К"]
Disable = 1 , } impl From < Lsi32kEn > for bool { # [inline (always)]
fn from (variant : Lsi32kEn) -> Self { variant as u8 != 0 } } # [doc = "Field `LSI32K_EN` reader - Включение/отключение LSI32К"]
pub type Lsi32kEnR = crate :: BitReader < Lsi32kEn > ; impl Lsi32kEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Lsi32kEn { match self . bits { false => Lsi32kEn :: Enable , true => Lsi32kEn :: Disable , } } # [doc = "Включение LSI32К"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Lsi32kEn :: Enable } # [doc = "Отключение LSI32К"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Lsi32kEn :: Disable } } # [doc = "Field `LSI32K_EN` writer - Включение/отключение LSI32К"]
pub type Lsi32kEnW < 'a , REG > = crate :: BitWriter < 'a , REG , Lsi32kEn > ; impl < 'a , REG > Lsi32kEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Включение LSI32К"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Lsi32kEn :: Enable) } # [doc = "Отключение LSI32К"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Lsi32kEn :: Disable) } } # [doc = "Field `ADJ_LSI32K` reader - Поправочные коэффициенты LSI32К"]
pub type AdjLsi32kR = crate :: FieldReader ; # [doc = "Field `ADJ_LSI32K` writer - Поправочные коэффициенты LSI32К"]
pub type AdjLsi32kW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Выбор приоритетного источника тактирования часов реального времени: 0x0 – автоматический выбор. При наличии обоих источников 32кГц выбирается внутренний LSI32K\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum RtcClkMux { # [doc = "0: Автоматический выбор. При наличии обоих источников 32кГц выбирается внутренний LSI32K"]
Automatic = 0 , # [doc = "1: Внутренний LSI32K"]
Lsi32k = 1 , # [doc = "2: Внешний осциллятор OSC32K"]
Osc32k = 2 , } impl From < RtcClkMux > for u8 { # [inline (always)]
fn from (variant : RtcClkMux) -> Self { variant as _ } } impl crate :: FieldSpec for RtcClkMux { type Ux = u8 ; } impl crate :: IsEnum for RtcClkMux { } # [doc = "Field `RTC_CLK_MUX` reader - Выбор приоритетного источника тактирования часов реального времени: 0x0 – автоматический выбор. При наличии обоих источников 32кГц выбирается внутренний LSI32K"]
pub type RtcClkMuxR = crate :: FieldReader < RtcClkMux > ; impl RtcClkMuxR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < RtcClkMux > { match self . bits { 0 => Some (RtcClkMux :: Automatic) , 1 => Some (RtcClkMux :: Lsi32k) , 2 => Some (RtcClkMux :: Osc32k) , _ => None , } } # [doc = "Автоматический выбор. При наличии обоих источников 32кГц выбирается внутренний LSI32K"]
# [inline (always)]
pub fn is_automatic (& self) -> bool { * self == RtcClkMux :: Automatic } # [doc = "Внутренний LSI32K"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == RtcClkMux :: Lsi32k } # [doc = "Внешний осциллятор OSC32K"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == RtcClkMux :: Osc32k } } # [doc = "Field `RTC_CLK_MUX` writer - Выбор приоритетного источника тактирования часов реального времени: 0x0 – автоматический выбор. При наличии обоих источников 32кГц выбирается внутренний LSI32K"]
pub type RtcClkMuxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , RtcClkMux > ; impl < 'a , REG > RtcClkMuxW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Автоматический выбор. При наличии обоих источников 32кГц выбирается внутренний LSI32K"]
# [inline (always)]
pub fn automatic (self) -> & 'a mut crate :: W < REG > { self . variant (RtcClkMux :: Automatic) } # [doc = "Внутренний LSI32K"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (RtcClkMux :: Lsi32k) } # [doc = "Внешний осциллятор OSC32K"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (RtcClkMux :: Osc32k) } } # [doc = "Field `OSC32K_SM` reader - Режим повышенного потребления, активный уровень “0” для OSC32K"]
pub type Osc32kSmR = crate :: BitReader ; # [doc = "Field `OSC32K_SM` writer - Режим повышенного потребления, активный уровень “0” для OSC32K"]
pub type Osc32kSmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Включение/отключение внешнего осциллятора на 32 KГц"]
# [inline (always)]
pub fn osc32k_en (& self) -> Osc32kEnR { Osc32kEnR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Включение/отключение LSI32К"]
# [inline (always)]
pub fn lsi32k_en (& self) -> Lsi32kEnR { Lsi32kEnR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 6:9 - Поправочные коэффициенты LSI32К"]
# [inline (always)]
pub fn adj_lsi32k (& self) -> AdjLsi32kR { AdjLsi32kR :: new (((self . bits >> 6) & 0x0f) as u8) } # [doc = "Bits 10:11 - Выбор приоритетного источника тактирования часов реального времени: 0x0 – автоматический выбор. При наличии обоих источников 32кГц выбирается внутренний LSI32K"]
# [inline (always)]
pub fn rtc_clk_mux (& self) -> RtcClkMuxR { RtcClkMuxR :: new (((self . bits >> 10) & 3) as u8) } # [doc = "Bit 14 - Режим повышенного потребления, активный уровень “0” для OSC32K"]
# [inline (always)]
pub fn osc32k_sm (& self) -> Osc32kSmR { Osc32kSmR :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bit 0 - Включение/отключение внешнего осциллятора на 32 KГц"]
# [inline (always)]
pub fn osc32k_en (& mut self) -> Osc32kEnW < ClocksBuSpec > { Osc32kEnW :: new (self , 0) } # [doc = "Bit 1 - Включение/отключение LSI32К"]
# [inline (always)]
pub fn lsi32k_en (& mut self) -> Lsi32kEnW < ClocksBuSpec > { Lsi32kEnW :: new (self , 1) } # [doc = "Bits 6:9 - Поправочные коэффициенты LSI32К"]
# [inline (always)]
pub fn adj_lsi32k (& mut self) -> AdjLsi32kW < ClocksBuSpec > { AdjLsi32kW :: new (self , 6) } # [doc = "Bits 10:11 - Выбор приоритетного источника тактирования часов реального времени: 0x0 – автоматический выбор. При наличии обоих источников 32кГц выбирается внутренний LSI32K"]
# [inline (always)]
pub fn rtc_clk_mux (& mut self) -> RtcClkMuxW < ClocksBuSpec > { RtcClkMuxW :: new (self , 10) } # [doc = "Bit 14 - Режим повышенного потребления, активный уровень “0” для OSC32K"]
# [inline (always)]
pub fn osc32k_sm (& mut self) -> Osc32kSmW < ClocksBuSpec > { Osc32kSmW :: new (self , 14) } } # [doc = "Регистр управления тактированием батарейного домена\n\nYou can [`read`](crate::Reg::read) this register and get [`clocks_bu::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clocks_bu::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClocksBuSpec ; impl crate :: RegisterSpec for ClocksBuSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`clocks_bu::R`](R) reader structure"]
impl crate :: Readable for ClocksBuSpec { } # [doc = "`write(|w| ..)` method takes [`clocks_bu::W`](W) writer structure"]
impl crate :: Writable for ClocksBuSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLOCKS_BU to value 0x0200"]
impl crate :: Resettable for ClocksBuSpec { const RESET_VALUE : u32 = 0x0200 ; } } # [doc = "CLOCKS_SYS (rw) register accessor: Регистр управления тактированием системного домена\n\nYou can [`read`](crate::Reg::read) this register and get [`clocks_sys::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clocks_sys::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clocks_sys`]
module"]
# [doc (alias = "CLOCKS_SYS")]
pub type ClocksSys = crate :: Reg < clocks_sys :: ClocksSysSpec > ; # [doc = "Регистр управления тактированием системного домена"]
pub mod clocks_sys { # [doc = "Register `CLOCKS_SYS` reader"]
pub type R = crate :: R < ClocksSysSpec > ; # [doc = "Register `CLOCKS_SYS` writer"]
pub type W = crate :: W < ClocksSysSpec > ; # [doc = "Включение/отключение внешнего осциллятора на 32 МГц\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Osc32mEn { # [doc = "0: Включение OSC32M"]
Enable = 0 , # [doc = "1: Отключение OSC32M"]
Disable = 1 , } impl From < Osc32mEn > for bool { # [inline (always)]
fn from (variant : Osc32mEn) -> Self { variant as u8 != 0 } } # [doc = "Field `OSC32M_EN` reader - Включение/отключение внешнего осциллятора на 32 МГц"]
pub type Osc32mEnR = crate :: BitReader < Osc32mEn > ; impl Osc32mEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Osc32mEn { match self . bits { false => Osc32mEn :: Enable , true => Osc32mEn :: Disable , } } # [doc = "Включение OSC32M"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Osc32mEn :: Enable } # [doc = "Отключение OSC32M"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Osc32mEn :: Disable } } # [doc = "Field `OSC32M_EN` writer - Включение/отключение внешнего осциллятора на 32 МГц"]
pub type Osc32mEnW < 'a , REG > = crate :: BitWriter < 'a , REG , Osc32mEn > ; impl < 'a , REG > Osc32mEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Включение OSC32M"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Osc32mEn :: Enable) } # [doc = "Отключение OSC32M"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Osc32mEn :: Disable) } } # [doc = "Включение/отключение HSI32M\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Hsi32mEn { # [doc = "0: Включение HSI32M"]
Enable = 0 , # [doc = "1: Отключение HSI32M"]
Disable = 1 , } impl From < Hsi32mEn > for bool { # [inline (always)]
fn from (variant : Hsi32mEn) -> Self { variant as u8 != 0 } } # [doc = "Field `HSI32M_EN` reader - Включение/отключение HSI32M"]
pub type Hsi32mEnR = crate :: BitReader < Hsi32mEn > ; impl Hsi32mEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Hsi32mEn { match self . bits { false => Hsi32mEn :: Enable , true => Hsi32mEn :: Disable , } } # [doc = "Включение HSI32M"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Hsi32mEn :: Enable } # [doc = "Отключение HSI32M"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Hsi32mEn :: Disable } } # [doc = "Field `HSI32M_EN` writer - Включение/отключение HSI32M"]
pub type Hsi32mEnW < 'a , REG > = crate :: BitWriter < 'a , REG , Hsi32mEn > ; impl < 'a , REG > Hsi32mEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Включение HSI32M"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Hsi32mEn :: Enable) } # [doc = "Отключение HSI32M"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Hsi32mEn :: Disable) } } # [doc = "Field `ADJ_HSI32M` reader - Поправочные коэффициенты HSI32M"]
pub type AdjHsi32mR = crate :: FieldReader ; # [doc = "Field `ADJ_HSI32M` writer - Поправочные коэффициенты HSI32M"]
pub type AdjHsi32mW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Принудительное переключение на опорный источник для монитора частоты\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Force32kClk { # [doc = "0: Автоматический выбор"]
Automatic = 0 , # [doc = "1: Принудительно выбран LSI32K"]
Lsi32k = 1 , # [doc = "2: Принудительно выбран OSC32K"]
Osc32k = 2 , # [doc = "3: Автоматический выбор"]
Automatic = 3 , } impl From < Force32kClk > for u8 { # [inline (always)]
fn from (variant : Force32kClk) -> Self { variant as _ } } impl crate :: FieldSpec for Force32kClk { type Ux = u8 ; } impl crate :: IsEnum for Force32kClk { } # [doc = "Field `FORCE_32K_CLK` reader - Принудительное переключение на опорный источник для монитора частоты"]
pub type Force32kClkR = crate :: FieldReader < Force32kClk > ; impl Force32kClkR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Force32kClk { match self . bits { 0 => Force32kClk :: Automatic , 1 => Force32kClk :: Lsi32k , 2 => Force32kClk :: Osc32k , 3 => Force32kClk :: Automatic , _ => unreachable ! () , } } # [doc = "Автоматический выбор"]
# [inline (always)]
pub fn is_automatic (& self) -> bool { * self == Force32kClk :: Automatic } # [doc = "Принудительно выбран LSI32K"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == Force32kClk :: Lsi32k } # [doc = "Принудительно выбран OSC32K"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == Force32kClk :: Osc32k } # [doc = "Автоматический выбор"]
# [inline (always)]
pub fn is_automatic (& self) -> bool { * self == Force32kClk :: Automatic } } # [doc = "Field `FORCE_32K_CLK` writer - Принудительное переключение на опорный источник для монитора частоты"]
pub type Force32kClkW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Force32kClk , crate :: Safe > ; impl < 'a , REG > Force32kClkW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Автоматический выбор"]
# [inline (always)]
pub fn automatic (self) -> & 'a mut crate :: W < REG > { self . variant (Force32kClk :: Automatic) } # [doc = "Принудительно выбран LSI32K"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (Force32kClk :: Lsi32k) } # [doc = "Принудительно выбран OSC32K"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (Force32kClk :: Osc32k) } # [doc = "Автоматический выбор"]
# [inline (always)]
pub fn automatic (self) -> & 'a mut crate :: W < REG > { self . variant (Force32kClk :: Automatic) } } impl R { # [doc = "Bit 0 - Включение/отключение внешнего осциллятора на 32 МГц"]
# [inline (always)]
pub fn osc32m_en (& self) -> Osc32mEnR { Osc32mEnR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Включение/отключение HSI32M"]
# [inline (always)]
pub fn hsi32m_en (& self) -> Hsi32mEnR { Hsi32mEnR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:9 - Поправочные коэффициенты HSI32M"]
# [inline (always)]
pub fn adj_hsi32m (& self) -> AdjHsi32mR { AdjHsi32mR :: new (((self . bits >> 2) & 0xff) as u8) } # [doc = "Bits 10:11 - Принудительное переключение на опорный источник для монитора частоты"]
# [inline (always)]
pub fn force_32k_clk (& self) -> Force32kClkR { Force32kClkR :: new (((self . bits >> 10) & 3) as u8) } } impl W { # [doc = "Bit 0 - Включение/отключение внешнего осциллятора на 32 МГц"]
# [inline (always)]
pub fn osc32m_en (& mut self) -> Osc32mEnW < ClocksSysSpec > { Osc32mEnW :: new (self , 0) } # [doc = "Bit 1 - Включение/отключение HSI32M"]
# [inline (always)]
pub fn hsi32m_en (& mut self) -> Hsi32mEnW < ClocksSysSpec > { Hsi32mEnW :: new (self , 1) } # [doc = "Bits 2:9 - Поправочные коэффициенты HSI32M"]
# [inline (always)]
pub fn adj_hsi32m (& mut self) -> AdjHsi32mW < ClocksSysSpec > { AdjHsi32mW :: new (self , 2) } # [doc = "Bits 10:11 - Принудительное переключение на опорный источник для монитора частоты"]
# [inline (always)]
pub fn force_32k_clk (& mut self) -> Force32kClkW < ClocksSysSpec > { Force32kClkW :: new (self , 10) } } # [doc = "Регистр управления тактированием системного домена\n\nYou can [`read`](crate::Reg::read) this register and get [`clocks_sys::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clocks_sys::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClocksSysSpec ; impl crate :: RegisterSpec for ClocksSysSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`clocks_sys::R`](R) reader structure"]
impl crate :: Readable for ClocksSysSpec { } # [doc = "`write(|w| ..)` method takes [`clocks_sys::W`](W) writer structure"]
impl crate :: Writable for ClocksSysSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLOCKS_SYS to value 0x0200"]
impl crate :: Resettable for ClocksSysSpec { const RESET_VALUE : u32 = 0x0200 ; } } # [doc = "RTC_CONTROL (w) register accessor: Сброс RTC происходит при записи “1”\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_control::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rtc_control`]
module"]
# [doc (alias = "RTC_CONTROL")]
pub type RtcControl = crate :: Reg < rtc_control :: RtcControlSpec > ; # [doc = "Сброс RTC происходит при записи “1”"]
pub mod rtc_control { # [doc = "Register `RTC_CONTROL` writer"]
pub type W = crate :: W < RtcControlSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < RtcControlSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Сброс RTC происходит при записи “1”\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rtc_control::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RtcControlSpec ; impl crate :: RegisterSpec for RtcControlSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`rtc_control::W`](W) writer structure"]
impl crate :: Writable for RtcControlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RTC_CONTROL to value 0"]
impl crate :: Resettable for RtcControlSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "STOP (w) register accessor: Переход в режим “Стоп”. Осуществляется записью “1” Отключает тактирования системной шины.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stop::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@stop`]
module"]
# [doc (alias = "STOP")]
pub type Stop = crate :: Reg < stop :: StopSpec > ; # [doc = "Переход в режим “Стоп”. Осуществляется записью “1” Отключает тактирования системной шины."]
pub mod stop { # [doc = "Register `STOP` writer"]
pub type W = crate :: W < StopSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < StopSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Переход в режим “Стоп”. Осуществляется записью “1” Отключает тактирования системной шины.\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stop::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StopSpec ; impl crate :: RegisterSpec for StopSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`stop::W`](W) writer structure"]
impl crate :: Writable for StopSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets STOP to value 0"]
impl crate :: Resettable for StopSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Часы реального времени"]
pub struct Rtc { _marker : PhantomData < * const () > } unsafe impl Send for Rtc { } impl Rtc { # [doc = r"Pointer to the register block"]
pub const PTR : * const rtc :: RegisterBlock = 0x0006_0400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const rtc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Rtc { type Target = rtc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Rtc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Rtc") . finish () } } # [doc = "Часы реального времени"]
pub mod rtc { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { rrtc_time : RrtcTime , rrtc_date : RrtcDate , rrtc_talrm : RrtcTalrm , rrtc_dalrm : RrtcDalrm , rrtc_ctrl : RrtcCtrl , _reserved5 : [u8 ; 0x0c]
, rrtc_reg0 : RrtcReg0 , rrtc_reg1 : RrtcReg1 , rrtc_reg2 : RrtcReg2 , rrtc_reg3 : RrtcReg3 , rrtc_reg4 : RrtcReg4 , rrtc_reg5 : RrtcReg5 , rrtc_reg6 : RrtcReg6 , rrtc_reg7 : RrtcReg7 , rrtc_reg8 : RrtcReg8 , rrtc_reg9 : RrtcReg9 , rrtc_reg10 : RrtcReg10 , rrtc_reg11 : RrtcReg11 , rrtc_reg12 : RrtcReg12 , rrtc_reg13 : RrtcReg13 , rrtc_reg14 : RrtcReg14 , rrtc_reg15 : RrtcReg15 , } impl RegisterBlock { # [doc = "0x00 - Регистр установки времени. Используется BCD-кодировка"]
# [inline (always)]
pub const fn rrtc_time (& self) -> & RrtcTime { & self . rrtc_time } # [doc = "0x04 - Регистр установки даты. Используется BCD-кодировка"]
# [inline (always)]
pub const fn rrtc_date (& self) -> & RrtcDate { & self . rrtc_date } # [doc = "0x08 - регистр хранит время, при совпадении которого со значением регистра RRTC_TIME, будет сгенерировано соответствующее прерывание"]
# [inline (always)]
pub const fn rrtc_talrm (& self) -> & RrtcTalrm { & self . rrtc_talrm } # [doc = "0x0c - регистр хранит время, при совпадении которого со значением регистра RRTC_TIME, будет сгенерировано соответствующее прерывание."]
# [inline (always)]
pub const fn rrtc_dalrm (& self) -> & RrtcDalrm { & self . rrtc_dalrm } # [doc = "0x10 - регистр управления модулем"]
# [inline (always)]
pub const fn rrtc_ctrl (& self) -> & RrtcCtrl { & self . rrtc_ctrl } # [doc = "0x20 - Регистры общего назначения REG0"]
# [inline (always)]
pub const fn rrtc_reg0 (& self) -> & RrtcReg0 { & self . rrtc_reg0 } # [doc = "0x24 - Регистры общего назначения REG1"]
# [inline (always)]
pub const fn rrtc_reg1 (& self) -> & RrtcReg1 { & self . rrtc_reg1 } # [doc = "0x28 - Регистры общего назначения REG2"]
# [inline (always)]
pub const fn rrtc_reg2 (& self) -> & RrtcReg2 { & self . rrtc_reg2 } # [doc = "0x2c - Регистры общего назначения REG3"]
# [inline (always)]
pub const fn rrtc_reg3 (& self) -> & RrtcReg3 { & self . rrtc_reg3 } # [doc = "0x30 - Регистры общего назначения REG4"]
# [inline (always)]
pub const fn rrtc_reg4 (& self) -> & RrtcReg4 { & self . rrtc_reg4 } # [doc = "0x34 - Регистры общего назначения REG5"]
# [inline (always)]
pub const fn rrtc_reg5 (& self) -> & RrtcReg5 { & self . rrtc_reg5 } # [doc = "0x38 - Регистры общего назначения REG6"]
# [inline (always)]
pub const fn rrtc_reg6 (& self) -> & RrtcReg6 { & self . rrtc_reg6 } # [doc = "0x3c - Регистры общего назначения REG7"]
# [inline (always)]
pub const fn rrtc_reg7 (& self) -> & RrtcReg7 { & self . rrtc_reg7 } # [doc = "0x40 - Регистры общего назначения REG8"]
# [inline (always)]
pub const fn rrtc_reg8 (& self) -> & RrtcReg8 { & self . rrtc_reg8 } # [doc = "0x44 - Регистры общего назначения REG9"]
# [inline (always)]
pub const fn rrtc_reg9 (& self) -> & RrtcReg9 { & self . rrtc_reg9 } # [doc = "0x48 - Регистры общего назначения REG10"]
# [inline (always)]
pub const fn rrtc_reg10 (& self) -> & RrtcReg10 { & self . rrtc_reg10 } # [doc = "0x4c - Регистры общего назначения REG11"]
# [inline (always)]
pub const fn rrtc_reg11 (& self) -> & RrtcReg11 { & self . rrtc_reg11 } # [doc = "0x50 - Регистры общего назначения REG12"]
# [inline (always)]
pub const fn rrtc_reg12 (& self) -> & RrtcReg12 { & self . rrtc_reg12 } # [doc = "0x54 - Регистры общего назначения REG13"]
# [inline (always)]
pub const fn rrtc_reg13 (& self) -> & RrtcReg13 { & self . rrtc_reg13 } # [doc = "0x58 - Регистры общего назначения REG14"]
# [inline (always)]
pub const fn rrtc_reg14 (& self) -> & RrtcReg14 { & self . rrtc_reg14 } # [doc = "0x5c - Регистры общего назначения REG14"]
# [inline (always)]
pub const fn rrtc_reg15 (& self) -> & RrtcReg15 { & self . rrtc_reg15 } } # [doc = "RRTC_TIME (rw) register accessor: Регистр установки времени. Используется BCD-кодировка\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_time::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_time::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_time`]
module"]
# [doc (alias = "RRTC_TIME")]
pub type RrtcTime = crate :: Reg < rrtc_time :: RrtcTimeSpec > ; # [doc = "Регистр установки времени. Используется BCD-кодировка"]
pub mod rrtc_time { # [doc = "Register `RRTC_TIME` reader"]
pub type R = crate :: R < RrtcTimeSpec > ; # [doc = "Register `RRTC_TIME` writer"]
pub type W = crate :: W < RrtcTimeSpec > ; # [doc = "Field `S` reader - Поле единиц секунд. Допустимые значения от 0 до 9"]
pub type SR = crate :: FieldReader ; # [doc = "Field `S` writer - Поле единиц секунд. Допустимые значения от 0 до 9"]
pub type SW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `TS` reader - Поле десятков секунд. Допустимые значения от 0 до 5"]
pub type TsR = crate :: FieldReader ; # [doc = "Field `TS` writer - Поле десятков секунд. Допустимые значения от 0 до 5"]
pub type TsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `M` reader - Поле единиц минут. Допустимые значения от 0 до 9"]
pub type MR = crate :: FieldReader ; # [doc = "Field `M` writer - Поле единиц минут. Допустимые значения от 0 до 9"]
pub type MW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `TM` reader - Поле десятков минут. Допустимые значения от 0 до 5"]
pub type TmR = crate :: FieldReader ; # [doc = "Field `TM` writer - Поле десятков минут. Допустимые значения от 0 до 5"]
pub type TmW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `H` reader - Поле единиц часов. Допустимые значения: - TH = 0 - От 0 до 9; - TH = 2 - От 0 до 3"]
pub type HR = crate :: FieldReader ; # [doc = "Field `H` writer - Поле единиц часов. Допустимые значения: - TH = 0 - От 0 до 9; - TH = 2 - От 0 до 3"]
pub type HW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `TH` reader - Поле десятков часов. Доступные значения от 0 до 2"]
pub type ThR = crate :: FieldReader ; # [doc = "Field `TH` writer - Поле десятков часов. Доступные значения от 0 до 2"]
pub type ThW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; # [doc = "День недели\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum DayOfWeek { # [doc = "1: Понедельник"]
Monday = 1 , # [doc = "2: Вторник"]
Tuesday = 2 , # [doc = "3: Среда"]
Wednesday = 3 , # [doc = "4: Четверг"]
Thursday = 4 , # [doc = "5: Пятница"]
Friday = 5 , # [doc = "6: Суббота"]
Saturday = 6 , # [doc = "7: Воскресенье"]
Sunday = 7 , } impl From < DayOfWeek > for u8 { # [inline (always)]
fn from (variant : DayOfWeek) -> Self { variant as _ } } impl crate :: FieldSpec for DayOfWeek { type Ux = u8 ; } impl crate :: IsEnum for DayOfWeek { } # [doc = "Field `DOW` reader - День недели"]
pub type DowR = crate :: FieldReader < DayOfWeek > ; impl DowR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < DayOfWeek > { match self . bits { 1 => Some (DayOfWeek :: Monday) , 2 => Some (DayOfWeek :: Tuesday) , 3 => Some (DayOfWeek :: Wednesday) , 4 => Some (DayOfWeek :: Thursday) , 5 => Some (DayOfWeek :: Friday) , 6 => Some (DayOfWeek :: Saturday) , 7 => Some (DayOfWeek :: Sunday) , _ => None , } } # [doc = "Понедельник"]
# [inline (always)]
pub fn is_monday (& self) -> bool { * self == DayOfWeek :: Monday } # [doc = "Вторник"]
# [inline (always)]
pub fn is_tuesday (& self) -> bool { * self == DayOfWeek :: Tuesday } # [doc = "Среда"]
# [inline (always)]
pub fn is_wednesday (& self) -> bool { * self == DayOfWeek :: Wednesday } # [doc = "Четверг"]
# [inline (always)]
pub fn is_thursday (& self) -> bool { * self == DayOfWeek :: Thursday } # [doc = "Пятница"]
# [inline (always)]
pub fn is_friday (& self) -> bool { * self == DayOfWeek :: Friday } # [doc = "Суббота"]
# [inline (always)]
pub fn is_saturday (& self) -> bool { * self == DayOfWeek :: Saturday } # [doc = "Воскресенье"]
# [inline (always)]
pub fn is_sunday (& self) -> bool { * self == DayOfWeek :: Sunday } } # [doc = "Field `DOW` writer - День недели"]
pub type DowW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , DayOfWeek > ; impl < 'a , REG > DowW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Понедельник"]
# [inline (always)]
pub fn monday (self) -> & 'a mut crate :: W < REG > { self . variant (DayOfWeek :: Monday) } # [doc = "Вторник"]
# [inline (always)]
pub fn tuesday (self) -> & 'a mut crate :: W < REG > { self . variant (DayOfWeek :: Tuesday) } # [doc = "Среда"]
# [inline (always)]
pub fn wednesday (self) -> & 'a mut crate :: W < REG > { self . variant (DayOfWeek :: Wednesday) } # [doc = "Четверг"]
# [inline (always)]
pub fn thursday (self) -> & 'a mut crate :: W < REG > { self . variant (DayOfWeek :: Thursday) } # [doc = "Пятница"]
# [inline (always)]
pub fn friday (self) -> & 'a mut crate :: W < REG > { self . variant (DayOfWeek :: Friday) } # [doc = "Суббота"]
# [inline (always)]
pub fn saturday (self) -> & 'a mut crate :: W < REG > { self . variant (DayOfWeek :: Saturday) } # [doc = "Воскресенье"]
# [inline (always)]
pub fn sunday (self) -> & 'a mut crate :: W < REG > { self . variant (DayOfWeek :: Sunday) } } impl R { # [doc = "Bits 4:7 - Поле единиц секунд. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn s (& self) -> SR { SR :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bits 8:10 - Поле десятков секунд. Допустимые значения от 0 до 5"]
# [inline (always)]
pub fn ts (& self) -> TsR { TsR :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bits 11:14 - Поле единиц минут. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn m (& self) -> MR { MR :: new (((self . bits >> 11) & 0x0f) as u8) } # [doc = "Bits 15:17 - Поле десятков минут. Допустимые значения от 0 до 5"]
# [inline (always)]
pub fn tm (& self) -> TmR { TmR :: new (((self . bits >> 15) & 7) as u8) } # [doc = "Bits 18:21 - Поле единиц часов. Допустимые значения: - TH = 0 - От 0 до 9; - TH = 2 - От 0 до 3"]
# [inline (always)]
pub fn h (& self) -> HR { HR :: new (((self . bits >> 18) & 0x0f) as u8) } # [doc = "Bits 22:23 - Поле десятков часов. Доступные значения от 0 до 2"]
# [inline (always)]
pub fn th (& self) -> ThR { ThR :: new (((self . bits >> 22) & 3) as u8) } # [doc = "Bits 24:26 - День недели"]
# [inline (always)]
pub fn dow (& self) -> DowR { DowR :: new (((self . bits >> 24) & 7) as u8) } } impl W { # [doc = "Bits 4:7 - Поле единиц секунд. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn s (& mut self) -> SW < RrtcTimeSpec > { SW :: new (self , 4) } # [doc = "Bits 8:10 - Поле десятков секунд. Допустимые значения от 0 до 5"]
# [inline (always)]
pub fn ts (& mut self) -> TsW < RrtcTimeSpec > { TsW :: new (self , 8) } # [doc = "Bits 11:14 - Поле единиц минут. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn m (& mut self) -> MW < RrtcTimeSpec > { MW :: new (self , 11) } # [doc = "Bits 15:17 - Поле десятков минут. Допустимые значения от 0 до 5"]
# [inline (always)]
pub fn tm (& mut self) -> TmW < RrtcTimeSpec > { TmW :: new (self , 15) } # [doc = "Bits 18:21 - Поле единиц часов. Допустимые значения: - TH = 0 - От 0 до 9; - TH = 2 - От 0 до 3"]
# [inline (always)]
pub fn h (& mut self) -> HW < RrtcTimeSpec > { HW :: new (self , 18) } # [doc = "Bits 22:23 - Поле десятков часов. Доступные значения от 0 до 2"]
# [inline (always)]
pub fn th (& mut self) -> ThW < RrtcTimeSpec > { ThW :: new (self , 22) } # [doc = "Bits 24:26 - День недели"]
# [inline (always)]
pub fn dow (& mut self) -> DowW < RrtcTimeSpec > { DowW :: new (self , 24) } } # [doc = "Регистр установки времени. Используется BCD-кодировка\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_time::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_time::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcTimeSpec ; impl crate :: RegisterSpec for RrtcTimeSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_time::R`](R) reader structure"]
impl crate :: Readable for RrtcTimeSpec { } # [doc = "`write(|w| ..)` method takes [`rrtc_time::W`](W) writer structure"]
impl crate :: Writable for RrtcTimeSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_TIME to value 0"]
impl crate :: Resettable for RrtcTimeSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_DATE (rw) register accessor: Регистр установки даты. Используется BCD-кодировка\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_date::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_date::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_date`]
module"]
# [doc (alias = "RRTC_DATE")]
pub type RrtcDate = crate :: Reg < rrtc_date :: RrtcDateSpec > ; # [doc = "Регистр установки даты. Используется BCD-кодировка"]
pub mod rrtc_date { # [doc = "Register `RRTC_DATE` reader"]
pub type R = crate :: R < RrtcDateSpec > ; # [doc = "Register `RRTC_DATE` writer"]
pub type W = crate :: W < RrtcDateSpec > ; # [doc = "Field `D` reader - Поле единиц дней. Допустимые значения: - TD = 2 - от 0 до 3; - TD = 3 - от 0 до 1"]
pub type DR = crate :: FieldReader ; # [doc = "Field `D` writer - Поле единиц дней. Допустимые значения: - TD = 2 - от 0 до 3; - TD = 3 - от 0 до 1"]
pub type DW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `TD` reader - Поле десятков дней. Допустимые значения: - {TM,M} != 03 - от 0 до 3; - {TM,M} == 03 - от 0 до 2"]
pub type TdR = crate :: FieldReader ; # [doc = "Field `TD` writer - Поле десятков дней. Допустимые значения: - {TM,M} != 03 - от 0 до 3; - {TM,M} == 03 - от 0 до 2"]
pub type TdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , u8 , crate :: Safe > ; # [doc = "Field `M` reader - Поле единиц месяцев. Допустимые значения: - TM = 0 - от 0 до 9; - TM = 1 - от 0 до 2"]
pub type MR = crate :: FieldReader ; # [doc = "Field `M` writer - Поле единиц месяцев. Допустимые значения: - TM = 0 - от 0 до 9; - TM = 1 - от 0 до 2"]
pub type MW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `TM` reader - Поле десятков месяцев. Допустимые значения от 0 до 1"]
pub type TmR = crate :: BitReader ; # [doc = "Field `TM` writer - Поле десятков месяцев. Допустимые значения от 0 до 1"]
pub type TmW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `Y` reader - Поле единиц годов. Допустимые значения от 0 до 9"]
pub type YR = crate :: FieldReader ; # [doc = "Field `Y` writer - Поле единиц годов. Допустимые значения от 0 до 9"]
pub type YW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `TC` reader - Поле десятков веков. Допустимые значения от 0 до 9"]
pub type TcR = crate :: FieldReader < u16 > ; # [doc = "Field `TC` writer - Поле десятков веков. Допустимые значения от 0 до 9"]
pub type TcW < 'a , REG > = crate :: FieldWriter < 'a , REG , 14 , u16 > ; # [doc = "Field `TY` reader - Поле десятков годов. Допустимые значения от 0 до 9"]
pub type TyR = crate :: FieldReader ; # [doc = "Field `TY` writer - Поле десятков годов. Допустимые значения от 0 до 9"]
pub type TyW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `C` reader - Поле единиц веков. Допустимые значения от 0 до 9"]
pub type CR = crate :: FieldReader ; # [doc = "Field `C` writer - Поле единиц веков. Допустимые значения от 0 до 9"]
pub type CW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R { # [doc = "Bits 0:3 - Поле единиц дней. Допустимые значения: - TD = 2 - от 0 до 3; - TD = 3 - от 0 до 1"]
# [inline (always)]
pub fn d (& self) -> DR { DR :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:5 - Поле десятков дней. Допустимые значения: - {TM,M} != 03 - от 0 до 3; - {TM,M} == 03 - от 0 до 2"]
# [inline (always)]
pub fn td (& self) -> TdR { TdR :: new (((self . bits >> 4) & 3) as u8) } # [doc = "Bits 6:9 - Поле единиц месяцев. Допустимые значения: - TM = 0 - от 0 до 9; - TM = 1 - от 0 до 2"]
# [inline (always)]
pub fn m (& self) -> MR { MR :: new (((self . bits >> 6) & 0x0f) as u8) } # [doc = "Bit 10 - Поле десятков месяцев. Допустимые значения от 0 до 1"]
# [inline (always)]
pub fn tm (& self) -> TmR { TmR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bits 11:14 - Поле единиц годов. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn y (& self) -> YR { YR :: new (((self . bits >> 11) & 0x0f) as u8) } # [doc = "Bits 13:26 - Поле десятков веков. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn tc (& self) -> TcR { TcR :: new (((self . bits >> 13) & 0x3fff) as u16) } # [doc = "Bits 15:18 - Поле десятков годов. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn ty (& self) -> TyR { TyR :: new (((self . bits >> 15) & 0x0f) as u8) } # [doc = "Bits 19:22 - Поле единиц веков. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn c (& self) -> CR { CR :: new (((self . bits >> 19) & 0x0f) as u8) } } impl W { # [doc = "Bits 0:3 - Поле единиц дней. Допустимые значения: - TD = 2 - от 0 до 3; - TD = 3 - от 0 до 1"]
# [inline (always)]
pub fn d (& mut self) -> DW < RrtcDateSpec > { DW :: new (self , 0) } # [doc = "Bits 4:5 - Поле десятков дней. Допустимые значения: - {TM,M} != 03 - от 0 до 3; - {TM,M} == 03 - от 0 до 2"]
# [inline (always)]
pub fn td (& mut self) -> TdW < RrtcDateSpec > { TdW :: new (self , 4) } # [doc = "Bits 6:9 - Поле единиц месяцев. Допустимые значения: - TM = 0 - от 0 до 9; - TM = 1 - от 0 до 2"]
# [inline (always)]
pub fn m (& mut self) -> MW < RrtcDateSpec > { MW :: new (self , 6) } # [doc = "Bit 10 - Поле десятков месяцев. Допустимые значения от 0 до 1"]
# [inline (always)]
pub fn tm (& mut self) -> TmW < RrtcDateSpec > { TmW :: new (self , 10) } # [doc = "Bits 11:14 - Поле единиц годов. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn y (& mut self) -> YW < RrtcDateSpec > { YW :: new (self , 11) } # [doc = "Bits 13:26 - Поле десятков веков. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn tc (& mut self) -> TcW < RrtcDateSpec > { TcW :: new (self , 13) } # [doc = "Bits 15:18 - Поле десятков годов. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn ty (& mut self) -> TyW < RrtcDateSpec > { TyW :: new (self , 15) } # [doc = "Bits 19:22 - Поле единиц веков. Допустимые значения от 0 до 9"]
# [inline (always)]
pub fn c (& mut self) -> CW < RrtcDateSpec > { CW :: new (self , 19) } } # [doc = "Регистр установки даты. Используется BCD-кодировка\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_date::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_date::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcDateSpec ; impl crate :: RegisterSpec for RrtcDateSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_date::R`](R) reader structure"]
impl crate :: Readable for RrtcDateSpec { } # [doc = "`write(|w| ..)` method takes [`rrtc_date::W`](W) writer structure"]
impl crate :: Writable for RrtcDateSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_DATE to value 0"]
impl crate :: Resettable for RrtcDateSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_TALRM (rw) register accessor: регистр хранит время, при совпадении которого со значением регистра RRTC_TIME, будет сгенерировано соответствующее прерывание\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_talrm::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_talrm::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_talrm`]
module"]
# [doc (alias = "RRTC_TALRM")]
pub type RrtcTalrm = crate :: Reg < rrtc_talrm :: RrtcTalrmSpec > ; # [doc = "регистр хранит время, при совпадении которого со значением регистра RRTC_TIME, будет сгенерировано соответствующее прерывание"]
pub mod rrtc_talrm { # [doc = "Register `RRTC_TALRM` reader"]
pub type R = crate :: R < RrtcTalrmSpec > ; # [doc = "Register `RRTC_TALRM` writer"]
pub type W = crate :: W < RrtcTalrmSpec > ; # [doc = "Разрешает сравнения секунд, когда установлен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cs { # [doc = "0: Сравнение секунд отключено"]
Disabled = 0 , # [doc = "1: Сравнение секунд включено"]
Enable = 1 , } impl From < Cs > for bool { # [inline (always)]
fn from (variant : Cs) -> Self { variant as u8 != 0 } } # [doc = "Field `CS` reader - Разрешает сравнения секунд, когда установлен"]
pub type CsR = crate :: BitReader < Cs > ; impl CsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cs { match self . bits { false => Cs :: Disabled , true => Cs :: Enable , } } # [doc = "Сравнение секунд отключено"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == Cs :: Disabled } # [doc = "Сравнение секунд включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cs :: Enable } } # [doc = "Field `CS` writer - Разрешает сравнения секунд, когда установлен"]
pub type CsW < 'a , REG > = crate :: BitWriter < 'a , REG , Cs > ; impl < 'a , REG > CsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сравнение секунд отключено"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: Disabled) } # [doc = "Сравнение секунд включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: Enable) } } # [doc = "Разрешает сравнения минут, когда установлен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cm { # [doc = "0: Сравнение минут отключено"]
Disabled = 0 , # [doc = "1: Сравнение минут включено"]
Enable = 1 , } impl From < Cm > for bool { # [inline (always)]
fn from (variant : Cm) -> Self { variant as u8 != 0 } } # [doc = "Field `CM` reader - Разрешает сравнения минут, когда установлен"]
pub type CmR = crate :: BitReader < Cm > ; impl CmR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cm { match self . bits { false => Cm :: Disabled , true => Cm :: Enable , } } # [doc = "Сравнение минут отключено"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == Cm :: Disabled } # [doc = "Сравнение минут включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cm :: Enable } } # [doc = "Field `CM` writer - Разрешает сравнения минут, когда установлен"]
pub type CmW < 'a , REG > = crate :: BitWriter < 'a , REG , Cm > ; impl < 'a , REG > CmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сравнение минут отключено"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cm :: Disabled) } # [doc = "Сравнение минут включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cm :: Enable) } } # [doc = "Разрешает сравнения часов, когда установлен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ch { # [doc = "0: Сравнение часов отключено"]
Disabled = 0 , # [doc = "1: Сравнение часов включено"]
Enable = 1 , } impl From < Ch > for bool { # [inline (always)]
fn from (variant : Ch) -> Self { variant as u8 != 0 } } # [doc = "Field `CH` reader - Разрешает сравнения часов, когда установлен"]
pub type ChR = crate :: BitReader < Ch > ; impl ChR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ch { match self . bits { false => Ch :: Disabled , true => Ch :: Enable , } } # [doc = "Сравнение часов отключено"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == Ch :: Disabled } # [doc = "Сравнение часов включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Ch :: Enable } } # [doc = "Field `CH` writer - Разрешает сравнения часов, когда установлен"]
pub type ChW < 'a , REG > = crate :: BitWriter < 'a , REG , Ch > ; impl < 'a , REG > ChW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сравнение часов отключено"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Ch :: Disabled) } # [doc = "Сравнение часов включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Ch :: Enable) } } # [doc = "Разрешает сравнения дней недели, когда установлен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cdow { # [doc = "0: Сравнение дней недели отключено"]
Disabled = 0 , # [doc = "1: Сравнение дней недели включено"]
Enable = 1 , } impl From < Cdow > for bool { # [inline (always)]
fn from (variant : Cdow) -> Self { variant as u8 != 0 } } # [doc = "Field `CDOW` reader - Разрешает сравнения дней недели, когда установлен"]
pub type CdowR = crate :: BitReader < Cdow > ; impl CdowR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cdow { match self . bits { false => Cdow :: Disabled , true => Cdow :: Enable , } } # [doc = "Сравнение дней недели отключено"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == Cdow :: Disabled } # [doc = "Сравнение дней недели включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cdow :: Enable } } # [doc = "Field `CDOW` writer - Разрешает сравнения дней недели, когда установлен"]
pub type CdowW < 'a , REG > = crate :: BitWriter < 'a , REG , Cdow > ; impl < 'a , REG > CdowW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сравнение дней недели отключено"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cdow :: Disabled) } # [doc = "Сравнение дней недели включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cdow :: Enable) } } impl R { # [doc = "Bit 28 - Разрешает сравнения секунд, когда установлен"]
# [inline (always)]
pub fn cs (& self) -> CsR { CsR :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Разрешает сравнения минут, когда установлен"]
# [inline (always)]
pub fn cm (& self) -> CmR { CmR :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Разрешает сравнения часов, когда установлен"]
# [inline (always)]
pub fn ch (& self) -> ChR { ChR :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - Разрешает сравнения дней недели, когда установлен"]
# [inline (always)]
pub fn cdow (& self) -> CdowR { CdowR :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bit 28 - Разрешает сравнения секунд, когда установлен"]
# [inline (always)]
pub fn cs (& mut self) -> CsW < RrtcTalrmSpec > { CsW :: new (self , 28) } # [doc = "Bit 29 - Разрешает сравнения минут, когда установлен"]
# [inline (always)]
pub fn cm (& mut self) -> CmW < RrtcTalrmSpec > { CmW :: new (self , 29) } # [doc = "Bit 30 - Разрешает сравнения часов, когда установлен"]
# [inline (always)]
pub fn ch (& mut self) -> ChW < RrtcTalrmSpec > { ChW :: new (self , 30) } # [doc = "Bit 31 - Разрешает сравнения дней недели, когда установлен"]
# [inline (always)]
pub fn cdow (& mut self) -> CdowW < RrtcTalrmSpec > { CdowW :: new (self , 31) } } # [doc = "регистр хранит время, при совпадении которого со значением регистра RRTC_TIME, будет сгенерировано соответствующее прерывание\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_talrm::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_talrm::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcTalrmSpec ; impl crate :: RegisterSpec for RrtcTalrmSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_talrm::R`](R) reader structure"]
impl crate :: Readable for RrtcTalrmSpec { } # [doc = "`write(|w| ..)` method takes [`rrtc_talrm::W`](W) writer structure"]
impl crate :: Writable for RrtcTalrmSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_TALRM to value 0"]
impl crate :: Resettable for RrtcTalrmSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_DALRM (rw) register accessor: регистр хранит время, при совпадении которого со значением регистра RRTC_TIME, будет сгенерировано соответствующее прерывание.\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_dalrm::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_dalrm::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_dalrm`]
module"]
# [doc (alias = "RRTC_DALRM")]
pub type RrtcDalrm = crate :: Reg < rrtc_dalrm :: RrtcDalrmSpec > ; # [doc = "регистр хранит время, при совпадении которого со значением регистра RRTC_TIME, будет сгенерировано соответствующее прерывание."]
pub mod rrtc_dalrm { # [doc = "Register `RRTC_DALRM` reader"]
pub type R = crate :: R < RrtcDalrmSpec > ; # [doc = "Register `RRTC_DALRM` writer"]
pub type W = crate :: W < RrtcDalrmSpec > ; # [doc = "Разрешает сравнения дней, когда установлен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cd { # [doc = "0: Сравнение дней отключено"]
Disabled = 0 , # [doc = "1: Сравнение дней включено"]
Enable = 1 , } impl From < Cd > for bool { # [inline (always)]
fn from (variant : Cd) -> Self { variant as u8 != 0 } } # [doc = "Field `CD` reader - Разрешает сравнения дней, когда установлен"]
pub type CdR = crate :: BitReader < Cd > ; impl CdR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cd { match self . bits { false => Cd :: Disabled , true => Cd :: Enable , } } # [doc = "Сравнение дней отключено"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == Cd :: Disabled } # [doc = "Сравнение дней включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cd :: Enable } } # [doc = "Field `CD` writer - Разрешает сравнения дней, когда установлен"]
pub type CdW < 'a , REG > = crate :: BitWriter < 'a , REG , Cd > ; impl < 'a , REG > CdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сравнение дней отключено"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cd :: Disabled) } # [doc = "Сравнение дней включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cd :: Enable) } } # [doc = "Разрешает сравнения месяцев, когда установлен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cm { # [doc = "0: Сравнение месяцев отключено"]
Disabled = 0 , # [doc = "1: Сравнение месяцев включено"]
Enable = 1 , } impl From < Cm > for bool { # [inline (always)]
fn from (variant : Cm) -> Self { variant as u8 != 0 } } # [doc = "Field `CM` reader - Разрешает сравнения месяцев, когда установлен"]
pub type CmR = crate :: BitReader < Cm > ; impl CmR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cm { match self . bits { false => Cm :: Disabled , true => Cm :: Enable , } } # [doc = "Сравнение месяцев отключено"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == Cm :: Disabled } # [doc = "Сравнение месяцев включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cm :: Enable } } # [doc = "Field `CM` writer - Разрешает сравнения месяцев, когда установлен"]
pub type CmW < 'a , REG > = crate :: BitWriter < 'a , REG , Cm > ; impl < 'a , REG > CmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сравнение месяцев отключено"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cm :: Disabled) } # [doc = "Сравнение месяцев включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cm :: Enable) } } # [doc = "Разрешает сравнения годов, когда установлен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cy { # [doc = "0: Сравнение годов отключено"]
Disabled = 0 , # [doc = "1: Сравнение годов включено"]
Enable = 1 , } impl From < Cy > for bool { # [inline (always)]
fn from (variant : Cy) -> Self { variant as u8 != 0 } } # [doc = "Field `CY` reader - Разрешает сравнения годов, когда установлен"]
pub type CyR = crate :: BitReader < Cy > ; impl CyR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cy { match self . bits { false => Cy :: Disabled , true => Cy :: Enable , } } # [doc = "Сравнение годов отключено"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == Cy :: Disabled } # [doc = "Сравнение годов включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cy :: Enable } } # [doc = "Field `CY` writer - Разрешает сравнения годов, когда установлен"]
pub type CyW < 'a , REG > = crate :: BitWriter < 'a , REG , Cy > ; impl < 'a , REG > CyW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сравнение годов отключено"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cy :: Disabled) } # [doc = "Сравнение годов включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cy :: Enable) } } # [doc = "Рразрешает сравнения веков, когда установлен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cc { # [doc = "0: Сравнение веков отключено"]
Disabled = 0 , # [doc = "1: Сравнение веков включено"]
Enable = 1 , } impl From < Cc > for bool { # [inline (always)]
fn from (variant : Cc) -> Self { variant as u8 != 0 } } # [doc = "Field `CC` reader - Рразрешает сравнения веков, когда установлен"]
pub type CcR = crate :: BitReader < Cc > ; impl CcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cc { match self . bits { false => Cc :: Disabled , true => Cc :: Enable , } } # [doc = "Сравнение веков отключено"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == Cc :: Disabled } # [doc = "Сравнение веков включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cc :: Enable } } # [doc = "Field `CC` writer - Рразрешает сравнения веков, когда установлен"]
pub type CcW < 'a , REG > = crate :: BitWriter < 'a , REG , Cc > ; impl < 'a , REG > CcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сравнение веков отключено"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Cc :: Disabled) } # [doc = "Сравнение веков включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cc :: Enable) } } impl R { # [doc = "Bit 27 - Разрешает сравнения дней, когда установлен"]
# [inline (always)]
pub fn cd (& self) -> CdR { CdR :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 28 - Разрешает сравнения месяцев, когда установлен"]
# [inline (always)]
pub fn cm (& self) -> CmR { CmR :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Разрешает сравнения годов, когда установлен"]
# [inline (always)]
pub fn cy (& self) -> CyR { CyR :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Рразрешает сравнения веков, когда установлен"]
# [inline (always)]
pub fn cc (& self) -> CcR { CcR :: new (((self . bits >> 30) & 1) != 0) } } impl W { # [doc = "Bit 27 - Разрешает сравнения дней, когда установлен"]
# [inline (always)]
pub fn cd (& mut self) -> CdW < RrtcDalrmSpec > { CdW :: new (self , 27) } # [doc = "Bit 28 - Разрешает сравнения месяцев, когда установлен"]
# [inline (always)]
pub fn cm (& mut self) -> CmW < RrtcDalrmSpec > { CmW :: new (self , 28) } # [doc = "Bit 29 - Разрешает сравнения годов, когда установлен"]
# [inline (always)]
pub fn cy (& mut self) -> CyW < RrtcDalrmSpec > { CyW :: new (self , 29) } # [doc = "Bit 30 - Рразрешает сравнения веков, когда установлен"]
# [inline (always)]
pub fn cc (& mut self) -> CcW < RrtcDalrmSpec > { CcW :: new (self , 30) } } # [doc = "регистр хранит время, при совпадении которого со значением регистра RRTC_TIME, будет сгенерировано соответствующее прерывание.\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_dalrm::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_dalrm::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcDalrmSpec ; impl crate :: RegisterSpec for RrtcDalrmSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_dalrm::R`](R) reader structure"]
impl crate :: Readable for RrtcDalrmSpec { } # [doc = "`write(|w| ..)` method takes [`rrtc_dalrm::W`](W) writer structure"]
impl crate :: Writable for RrtcDalrmSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_DALRM to value 0"]
impl crate :: Resettable for RrtcDalrmSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_CTRL (rw) register accessor: регистр управления модулем\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_ctrl`]
module"]
# [doc (alias = "RRTC_CTRL")]
pub type RrtcCtrl = crate :: Reg < rrtc_ctrl :: RrtcCtrlSpec > ; # [doc = "регистр управления модулем"]
pub mod rrtc_ctrl { # [doc = "Register `RRTC_CTRL` reader"]
pub type R = crate :: R < RrtcCtrlSpec > ; # [doc = "Register `RRTC_CTRL` writer"]
pub type W = crate :: W < RrtcCtrlSpec > ; # [doc = "Запись “1” – сброс признака установки активного уровня ALARM_PAD\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum AlrmPad { # [doc = "1: Cброс признака установки активного уровня ALARM_PAD"]
AlarmReset = 1 , } impl From < AlrmPad > for bool { # [inline (always)]
fn from (variant : AlrmPad) -> Self { variant as u8 != 0 } } # [doc = "Field `ALRM_PAD` writer - Запись “1” – сброс признака установки активного уровня ALARM_PAD"]
pub type AlrmPadW < 'a , REG > = crate :: BitWriter < 'a , REG , AlrmPad > ; impl < 'a , REG > AlrmPadW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Cброс признака установки активного уровня ALARM_PAD"]
# [inline (always)]
pub fn alarm_reset (self) -> & 'a mut crate :: W < REG > { self . variant (AlrmPad :: AlarmReset) } } # [doc = "Сигнал проведения синхронизации между тактовыми доменами. После записи в любой регистр и пока данный бит читается равным «1», запрещено выполнять любую новую запись\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Flag { # [doc = "0: Запись в регистры разрешена"]
Ready = 0 , # [doc = "1: Выполняется синхронизация, запись в регистры запрещена"]
Synchronization = 1 , } impl From < Flag > for bool { # [inline (always)]
fn from (variant : Flag) -> Self { variant as u8 != 0 } } # [doc = "Field `FLAG` reader - Сигнал проведения синхронизации между тактовыми доменами. После записи в любой регистр и пока данный бит читается равным «1», запрещено выполнять любую новую запись"]
pub type FlagR = crate :: BitReader < Flag > ; impl FlagR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Flag { match self . bits { false => Flag :: Ready , true => Flag :: Synchronization , } } # [doc = "Запись в регистры разрешена"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Flag :: Ready } # [doc = "Выполняется синхронизация, запись в регистры запрещена"]
# [inline (always)]
pub fn is_synchronization (& self) -> bool { * self == Flag :: Synchronization } } # [doc = "Бит разрешения прерывания на выходах irq и irq_async. Прерывания появляются при наличии установленного бита ALRM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Inte { # [doc = "0: Прерывания блока запрещены"]
Disabled = 0 , # [doc = "1: Прерывания блока разрешены"]
Enable = 1 , } impl From < Inte > for bool { # [inline (always)]
fn from (variant : Inte) -> Self { variant as u8 != 0 } } # [doc = "Field `INTE` reader - Бит разрешения прерывания на выходах irq и irq_async. Прерывания появляются при наличии установленного бита ALRM"]
pub type InteR = crate :: BitReader < Inte > ; impl InteR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Inte { match self . bits { false => Inte :: Disabled , true => Inte :: Enable , } } # [doc = "Прерывания блока запрещены"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == Inte :: Disabled } # [doc = "Прерывания блока разрешены"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Inte :: Enable } } # [doc = "Field `INTE` writer - Бит разрешения прерывания на выходах irq и irq_async. Прерывания появляются при наличии установленного бита ALRM"]
pub type InteW < 'a , REG > = crate :: BitWriter < 'a , REG , Inte > ; impl < 'a , REG > InteW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывания блока запрещены"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Inte :: Disabled) } # [doc = "Прерывания блока разрешены"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Inte :: Enable) } } # [doc = "Установленный бит свидетельствует о совпадении одного разрешенного или всех разрешённых полей будильника. Бит необходимо сбрасывать при помощи управляющего ПО\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Alrm { # [doc = "0: Будильник не сработал"]
Inactive = 0 , # [doc = "1: Будильник сработал"]
Active = 1 , } impl From < Alrm > for bool { # [inline (always)]
fn from (variant : Alrm) -> Self { variant as u8 != 0 } } # [doc = "Field `ALRM` reader - Установленный бит свидетельствует о совпадении одного разрешенного или всех разрешённых полей будильника. Бит необходимо сбрасывать при помощи управляющего ПО"]
pub type AlrmR = crate :: BitReader < Alrm > ; impl AlrmR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Alrm { match self . bits { false => Alrm :: Inactive , true => Alrm :: Active , } } # [doc = "Будильник не сработал"]
# [inline (always)]
pub fn is_inactive (& self) -> bool { * self == Alrm :: Inactive } # [doc = "Будильник сработал"]
# [inline (always)]
pub fn is_active (& self) -> bool { * self == Alrm :: Active } } # [doc = "Field `ALRM` writer - Установленный бит свидетельствует о совпадении одного разрешенного или всех разрешённых полей будильника. Бит необходимо сбрасывать при помощи управляющего ПО"]
pub type AlrmW < 'a , REG > = crate :: BitWriter < 'a , REG , Alrm > ; impl < 'a , REG > AlrmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Будильник не сработал"]
# [inline (always)]
pub fn inactive (self) -> & 'a mut crate :: W < REG > { self . variant (Alrm :: Inactive) } # [doc = "Будильник сработал"]
# [inline (always)]
pub fn active (self) -> & 'a mut crate :: W < REG > { self . variant (Alrm :: Active) } } # [doc = "Модуль включён и производит отсчёт времени, когда установлен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum En { # [doc = "0: Модуль отключен"]
Disabled = 0 , # [doc = "1: Модуль включен"]
Enable = 1 , } impl From < En > for bool { # [inline (always)]
fn from (variant : En) -> Self { variant as u8 != 0 } } # [doc = "Field `EN` reader - Модуль включён и производит отсчёт времени, когда установлен"]
pub type EnR = crate :: BitReader < En > ; impl EnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> En { match self . bits { false => En :: Disabled , true => En :: Enable , } } # [doc = "Модуль отключен"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == En :: Disabled } # [doc = "Модуль включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == En :: Enable } } # [doc = "Field `EN` writer - Модуль включён и производит отсчёт времени, когда установлен"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG , En > ; impl < 'a , REG > EnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Модуль отключен"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Disabled) } # [doc = "Модуль включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Enable) } } impl R { # [doc = "Bit 28 - Сигнал проведения синхронизации между тактовыми доменами. После записи в любой регистр и пока данный бит читается равным «1», запрещено выполнять любую новую запись"]
# [inline (always)]
pub fn flag (& self) -> FlagR { FlagR :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Бит разрешения прерывания на выходах irq и irq_async. Прерывания появляются при наличии установленного бита ALRM"]
# [inline (always)]
pub fn inte (& self) -> InteR { InteR :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Установленный бит свидетельствует о совпадении одного разрешенного или всех разрешённых полей будильника. Бит необходимо сбрасывать при помощи управляющего ПО"]
# [inline (always)]
pub fn alrm (& self) -> AlrmR { AlrmR :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - Модуль включён и производит отсчёт времени, когда установлен"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bit 27 - Запись “1” – сброс признака установки активного уровня ALARM_PAD"]
# [inline (always)]
pub fn alrm_pad (& mut self) -> AlrmPadW < RrtcCtrlSpec > { AlrmPadW :: new (self , 27) } # [doc = "Bit 29 - Бит разрешения прерывания на выходах irq и irq_async. Прерывания появляются при наличии установленного бита ALRM"]
# [inline (always)]
pub fn inte (& mut self) -> InteW < RrtcCtrlSpec > { InteW :: new (self , 29) } # [doc = "Bit 30 - Установленный бит свидетельствует о совпадении одного разрешенного или всех разрешённых полей будильника. Бит необходимо сбрасывать при помощи управляющего ПО"]
# [inline (always)]
pub fn alrm (& mut self) -> AlrmW < RrtcCtrlSpec > { AlrmW :: new (self , 30) } # [doc = "Bit 31 - Модуль включён и производит отсчёт времени, когда установлен"]
# [inline (always)]
pub fn en (& mut self) -> EnW < RrtcCtrlSpec > { EnW :: new (self , 31) } } # [doc = "регистр управления модулем\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcCtrlSpec ; impl crate :: RegisterSpec for RrtcCtrlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_ctrl::R`](R) reader structure"]
impl crate :: Readable for RrtcCtrlSpec { } # [doc = "`write(|w| ..)` method takes [`rrtc_ctrl::W`](W) writer structure"]
impl crate :: Writable for RrtcCtrlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_CTRL to value 0"]
impl crate :: Resettable for RrtcCtrlSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG0 (rw) register accessor: Регистры общего назначения REG0\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg0::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg0::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg0`]
module"]
# [doc (alias = "RRTC_REG0")]
pub type RrtcReg0 = crate :: Reg < rrtc_reg0 :: RrtcReg0Spec > ; # [doc = "Регистры общего назначения REG0"]
pub mod rrtc_reg0 { # [doc = "Register `RRTC_REG0` reader"]
pub type R = crate :: R < RrtcReg0Spec > ; # [doc = "Register `RRTC_REG0` writer"]
pub type W = crate :: W < RrtcReg0Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG0\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg0::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg0::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg0Spec ; impl crate :: RegisterSpec for RrtcReg0Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg0::R`](R) reader structure"]
impl crate :: Readable for RrtcReg0Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg0::W`](W) writer structure"]
impl crate :: Writable for RrtcReg0Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG0 to value 0"]
impl crate :: Resettable for RrtcReg0Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG1 (rw) register accessor: Регистры общего назначения REG1\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg1`]
module"]
# [doc (alias = "RRTC_REG1")]
pub type RrtcReg1 = crate :: Reg < rrtc_reg1 :: RrtcReg1Spec > ; # [doc = "Регистры общего назначения REG1"]
pub mod rrtc_reg1 { # [doc = "Register `RRTC_REG1` reader"]
pub type R = crate :: R < RrtcReg1Spec > ; # [doc = "Register `RRTC_REG1` writer"]
pub type W = crate :: W < RrtcReg1Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG1\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg1Spec ; impl crate :: RegisterSpec for RrtcReg1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg1::R`](R) reader structure"]
impl crate :: Readable for RrtcReg1Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg1::W`](W) writer structure"]
impl crate :: Writable for RrtcReg1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG1 to value 0"]
impl crate :: Resettable for RrtcReg1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG2 (rw) register accessor: Регистры общего назначения REG2\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg2`]
module"]
# [doc (alias = "RRTC_REG2")]
pub type RrtcReg2 = crate :: Reg < rrtc_reg2 :: RrtcReg2Spec > ; # [doc = "Регистры общего назначения REG2"]
pub mod rrtc_reg2 { # [doc = "Register `RRTC_REG2` reader"]
pub type R = crate :: R < RrtcReg2Spec > ; # [doc = "Register `RRTC_REG2` writer"]
pub type W = crate :: W < RrtcReg2Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG2\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg2Spec ; impl crate :: RegisterSpec for RrtcReg2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg2::R`](R) reader structure"]
impl crate :: Readable for RrtcReg2Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg2::W`](W) writer structure"]
impl crate :: Writable for RrtcReg2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG2 to value 0"]
impl crate :: Resettable for RrtcReg2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG3 (rw) register accessor: Регистры общего назначения REG3\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg3`]
module"]
# [doc (alias = "RRTC_REG3")]
pub type RrtcReg3 = crate :: Reg < rrtc_reg3 :: RrtcReg3Spec > ; # [doc = "Регистры общего назначения REG3"]
pub mod rrtc_reg3 { # [doc = "Register `RRTC_REG3` reader"]
pub type R = crate :: R < RrtcReg3Spec > ; # [doc = "Register `RRTC_REG3` writer"]
pub type W = crate :: W < RrtcReg3Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG3\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg3Spec ; impl crate :: RegisterSpec for RrtcReg3Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg3::R`](R) reader structure"]
impl crate :: Readable for RrtcReg3Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg3::W`](W) writer structure"]
impl crate :: Writable for RrtcReg3Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG3 to value 0"]
impl crate :: Resettable for RrtcReg3Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG4 (rw) register accessor: Регистры общего назначения REG4\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg4::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg4::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg4`]
module"]
# [doc (alias = "RRTC_REG4")]
pub type RrtcReg4 = crate :: Reg < rrtc_reg4 :: RrtcReg4Spec > ; # [doc = "Регистры общего назначения REG4"]
pub mod rrtc_reg4 { # [doc = "Register `RRTC_REG4` reader"]
pub type R = crate :: R < RrtcReg4Spec > ; # [doc = "Register `RRTC_REG4` writer"]
pub type W = crate :: W < RrtcReg4Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG4\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg4::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg4::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg4Spec ; impl crate :: RegisterSpec for RrtcReg4Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg4::R`](R) reader structure"]
impl crate :: Readable for RrtcReg4Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg4::W`](W) writer structure"]
impl crate :: Writable for RrtcReg4Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG4 to value 0"]
impl crate :: Resettable for RrtcReg4Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG5 (rw) register accessor: Регистры общего назначения REG5\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg5::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg5::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg5`]
module"]
# [doc (alias = "RRTC_REG5")]
pub type RrtcReg5 = crate :: Reg < rrtc_reg5 :: RrtcReg5Spec > ; # [doc = "Регистры общего назначения REG5"]
pub mod rrtc_reg5 { # [doc = "Register `RRTC_REG5` reader"]
pub type R = crate :: R < RrtcReg5Spec > ; # [doc = "Register `RRTC_REG5` writer"]
pub type W = crate :: W < RrtcReg5Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG5\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg5::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg5::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg5Spec ; impl crate :: RegisterSpec for RrtcReg5Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg5::R`](R) reader structure"]
impl crate :: Readable for RrtcReg5Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg5::W`](W) writer structure"]
impl crate :: Writable for RrtcReg5Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG5 to value 0"]
impl crate :: Resettable for RrtcReg5Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG6 (rw) register accessor: Регистры общего назначения REG6\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg6::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg6::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg6`]
module"]
# [doc (alias = "RRTC_REG6")]
pub type RrtcReg6 = crate :: Reg < rrtc_reg6 :: RrtcReg6Spec > ; # [doc = "Регистры общего назначения REG6"]
pub mod rrtc_reg6 { # [doc = "Register `RRTC_REG6` reader"]
pub type R = crate :: R < RrtcReg6Spec > ; # [doc = "Register `RRTC_REG6` writer"]
pub type W = crate :: W < RrtcReg6Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG6\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg6::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg6::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg6Spec ; impl crate :: RegisterSpec for RrtcReg6Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg6::R`](R) reader structure"]
impl crate :: Readable for RrtcReg6Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg6::W`](W) writer structure"]
impl crate :: Writable for RrtcReg6Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG6 to value 0"]
impl crate :: Resettable for RrtcReg6Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG7 (rw) register accessor: Регистры общего назначения REG7\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg7::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg7::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg7`]
module"]
# [doc (alias = "RRTC_REG7")]
pub type RrtcReg7 = crate :: Reg < rrtc_reg7 :: RrtcReg7Spec > ; # [doc = "Регистры общего назначения REG7"]
pub mod rrtc_reg7 { # [doc = "Register `RRTC_REG7` reader"]
pub type R = crate :: R < RrtcReg7Spec > ; # [doc = "Register `RRTC_REG7` writer"]
pub type W = crate :: W < RrtcReg7Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG7\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg7::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg7::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg7Spec ; impl crate :: RegisterSpec for RrtcReg7Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg7::R`](R) reader structure"]
impl crate :: Readable for RrtcReg7Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg7::W`](W) writer structure"]
impl crate :: Writable for RrtcReg7Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG7 to value 0"]
impl crate :: Resettable for RrtcReg7Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG8 (rw) register accessor: Регистры общего назначения REG8\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg8::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg8::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg8`]
module"]
# [doc (alias = "RRTC_REG8")]
pub type RrtcReg8 = crate :: Reg < rrtc_reg8 :: RrtcReg8Spec > ; # [doc = "Регистры общего назначения REG8"]
pub mod rrtc_reg8 { # [doc = "Register `RRTC_REG8` reader"]
pub type R = crate :: R < RrtcReg8Spec > ; # [doc = "Register `RRTC_REG8` writer"]
pub type W = crate :: W < RrtcReg8Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG8\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg8::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg8::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg8Spec ; impl crate :: RegisterSpec for RrtcReg8Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg8::R`](R) reader structure"]
impl crate :: Readable for RrtcReg8Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg8::W`](W) writer structure"]
impl crate :: Writable for RrtcReg8Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG8 to value 0"]
impl crate :: Resettable for RrtcReg8Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG9 (rw) register accessor: Регистры общего назначения REG9\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg9::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg9::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg9`]
module"]
# [doc (alias = "RRTC_REG9")]
pub type RrtcReg9 = crate :: Reg < rrtc_reg9 :: RrtcReg9Spec > ; # [doc = "Регистры общего назначения REG9"]
pub mod rrtc_reg9 { # [doc = "Register `RRTC_REG9` reader"]
pub type R = crate :: R < RrtcReg9Spec > ; # [doc = "Register `RRTC_REG9` writer"]
pub type W = crate :: W < RrtcReg9Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG9\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg9::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg9::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg9Spec ; impl crate :: RegisterSpec for RrtcReg9Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg9::R`](R) reader structure"]
impl crate :: Readable for RrtcReg9Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg9::W`](W) writer structure"]
impl crate :: Writable for RrtcReg9Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG9 to value 0"]
impl crate :: Resettable for RrtcReg9Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG10 (rw) register accessor: Регистры общего назначения REG10\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg10::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg10::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg10`]
module"]
# [doc (alias = "RRTC_REG10")]
pub type RrtcReg10 = crate :: Reg < rrtc_reg10 :: RrtcReg10Spec > ; # [doc = "Регистры общего назначения REG10"]
pub mod rrtc_reg10 { # [doc = "Register `RRTC_REG10` reader"]
pub type R = crate :: R < RrtcReg10Spec > ; # [doc = "Register `RRTC_REG10` writer"]
pub type W = crate :: W < RrtcReg10Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG10\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg10::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg10::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg10Spec ; impl crate :: RegisterSpec for RrtcReg10Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg10::R`](R) reader structure"]
impl crate :: Readable for RrtcReg10Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg10::W`](W) writer structure"]
impl crate :: Writable for RrtcReg10Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG10 to value 0"]
impl crate :: Resettable for RrtcReg10Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG11 (rw) register accessor: Регистры общего назначения REG11\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg11::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg11::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg11`]
module"]
# [doc (alias = "RRTC_REG11")]
pub type RrtcReg11 = crate :: Reg < rrtc_reg11 :: RrtcReg11Spec > ; # [doc = "Регистры общего назначения REG11"]
pub mod rrtc_reg11 { # [doc = "Register `RRTC_REG11` reader"]
pub type R = crate :: R < RrtcReg11Spec > ; # [doc = "Register `RRTC_REG11` writer"]
pub type W = crate :: W < RrtcReg11Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG11\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg11::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg11::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg11Spec ; impl crate :: RegisterSpec for RrtcReg11Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg11::R`](R) reader structure"]
impl crate :: Readable for RrtcReg11Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg11::W`](W) writer structure"]
impl crate :: Writable for RrtcReg11Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG11 to value 0"]
impl crate :: Resettable for RrtcReg11Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG12 (rw) register accessor: Регистры общего назначения REG12\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg12::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg12::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg12`]
module"]
# [doc (alias = "RRTC_REG12")]
pub type RrtcReg12 = crate :: Reg < rrtc_reg12 :: RrtcReg12Spec > ; # [doc = "Регистры общего назначения REG12"]
pub mod rrtc_reg12 { # [doc = "Register `RRTC_REG12` reader"]
pub type R = crate :: R < RrtcReg12Spec > ; # [doc = "Register `RRTC_REG12` writer"]
pub type W = crate :: W < RrtcReg12Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG12\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg12::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg12::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg12Spec ; impl crate :: RegisterSpec for RrtcReg12Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg12::R`](R) reader structure"]
impl crate :: Readable for RrtcReg12Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg12::W`](W) writer structure"]
impl crate :: Writable for RrtcReg12Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG12 to value 0"]
impl crate :: Resettable for RrtcReg12Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG13 (rw) register accessor: Регистры общего назначения REG13\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg13::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg13::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg13`]
module"]
# [doc (alias = "RRTC_REG13")]
pub type RrtcReg13 = crate :: Reg < rrtc_reg13 :: RrtcReg13Spec > ; # [doc = "Регистры общего назначения REG13"]
pub mod rrtc_reg13 { # [doc = "Register `RRTC_REG13` reader"]
pub type R = crate :: R < RrtcReg13Spec > ; # [doc = "Register `RRTC_REG13` writer"]
pub type W = crate :: W < RrtcReg13Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG13\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg13::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg13::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg13Spec ; impl crate :: RegisterSpec for RrtcReg13Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg13::R`](R) reader structure"]
impl crate :: Readable for RrtcReg13Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg13::W`](W) writer structure"]
impl crate :: Writable for RrtcReg13Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG13 to value 0"]
impl crate :: Resettable for RrtcReg13Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG14 (rw) register accessor: Регистры общего назначения REG14\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg14::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg14::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg14`]
module"]
# [doc (alias = "RRTC_REG14")]
pub type RrtcReg14 = crate :: Reg < rrtc_reg14 :: RrtcReg14Spec > ; # [doc = "Регистры общего назначения REG14"]
pub mod rrtc_reg14 { # [doc = "Register `RRTC_REG14` reader"]
pub type R = crate :: R < RrtcReg14Spec > ; # [doc = "Register `RRTC_REG14` writer"]
pub type W = crate :: W < RrtcReg14Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG14\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg14::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg14::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg14Spec ; impl crate :: RegisterSpec for RrtcReg14Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg14::R`](R) reader structure"]
impl crate :: Readable for RrtcReg14Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg14::W`](W) writer structure"]
impl crate :: Writable for RrtcReg14Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG14 to value 0"]
impl crate :: Resettable for RrtcReg14Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RRTC_REG15 (rw) register accessor: Регистры общего назначения REG14\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg15::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg15::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rrtc_reg15`]
module"]
# [doc (alias = "RRTC_REG15")]
pub type RrtcReg15 = crate :: Reg < rrtc_reg15 :: RrtcReg15Spec > ; # [doc = "Регистры общего назначения REG14"]
pub mod rrtc_reg15 { # [doc = "Register `RRTC_REG15` reader"]
pub type R = crate :: R < RrtcReg15Spec > ; # [doc = "Register `RRTC_REG15` writer"]
pub type W = crate :: W < RrtcReg15Spec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистры общего назначения REG14\n\nYou can [`read`](crate::Reg::read) this register and get [`rrtc_reg15::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`rrtc_reg15::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RrtcReg15Spec ; impl crate :: RegisterSpec for RrtcReg15Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`rrtc_reg15::R`](R) reader structure"]
impl crate :: Readable for RrtcReg15Spec { } # [doc = "`write(|w| ..)` method takes [`rrtc_reg15::W`](W) writer structure"]
impl crate :: Writable for RrtcReg15Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets RRTC_REG15 to value 0"]
impl crate :: Resettable for RrtcReg15Spec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Блок управления режимом загрузки"]
pub struct BootManager { _marker : PhantomData < * const () > } unsafe impl Send for BootManager { } impl BootManager { # [doc = r"Pointer to the register block"]
pub const PTR : * const boot_manager :: RegisterBlock = 0x0006_0800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const boot_manager :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for BootManager { type Target = boot_manager :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for BootManager { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("BootManager") . finish () } } # [doc = "Блок управления режимом загрузки"]
pub mod boot_manager { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { boot : Boot , } impl RegisterBlock { # [doc = "0x00 - Регистр режима загрузки"]
# [inline (always)]
pub const fn boot (& self) -> & Boot { & self . boot } } # [doc = "BOOT (rw) register accessor: Регистр режима загрузки\n\nYou can [`read`](crate::Reg::read) this register and get [`boot::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`boot::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@boot`]
module"]
# [doc (alias = "BOOT")]
pub type Boot = crate :: Reg < boot :: BootSpec > ; # [doc = "Регистр режима загрузки"]
pub mod boot { # [doc = "Register `BOOT` reader"]
pub type R = crate :: R < BootSpec > ; # [doc = "Register `BOOT` writer"]
pub type W = crate :: W < BootSpec > ; # [doc = "Регистр режима загрузки. При чтении, возвращает режим, который будет использоваться для следующего сброса системного домена. При записи – установка нового режима загрузки.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BootMode { # [doc = "0: Старт из встроенной памяти EEPROM"]
Eeprom = 0 , # [doc = "1: Старт из системного ОЗУ"]
Ram = 1 , # [doc = "2: Старт из внешней памяти с использованием контроллера SPIFI"]
Spifi = 2 , } impl From < BootMode > for u8 { # [inline (always)]
fn from (variant : BootMode) -> Self { variant as _ } } impl crate :: FieldSpec for BootMode { type Ux = u8 ; } impl crate :: IsEnum for BootMode { } # [doc = "Field `BOOT_MODE` reader - Регистр режима загрузки. При чтении, возвращает режим, который будет использоваться для следующего сброса системного домена. При записи – установка нового режима загрузки."]
pub type BootModeR = crate :: FieldReader < BootMode > ; impl BootModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < BootMode > { match self . bits { 0 => Some (BootMode :: Eeprom) , 1 => Some (BootMode :: Ram) , 2 => Some (BootMode :: Spifi) , _ => None , } } # [doc = "Старт из встроенной памяти EEPROM"]
# [inline (always)]
pub fn is_eeprom (& self) -> bool { * self == BootMode :: Eeprom } # [doc = "Старт из системного ОЗУ"]
# [inline (always)]
pub fn is_ram (& self) -> bool { * self == BootMode :: Ram } # [doc = "Старт из внешней памяти с использованием контроллера SPIFI"]
# [inline (always)]
pub fn is_spifi (& self) -> bool { * self == BootMode :: Spifi } } # [doc = "Field `BOOT_MODE` writer - Регистр режима загрузки. При чтении, возвращает режим, который будет использоваться для следующего сброса системного домена. При записи – установка нового режима загрузки."]
pub type BootModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , BootMode > ; impl < 'a , REG > BootModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Старт из встроенной памяти EEPROM"]
# [inline (always)]
pub fn eeprom (self) -> & 'a mut crate :: W < REG > { self . variant (BootMode :: Eeprom) } # [doc = "Старт из системного ОЗУ"]
# [inline (always)]
pub fn ram (self) -> & 'a mut crate :: W < REG > { self . variant (BootMode :: Ram) } # [doc = "Старт из внешней памяти с использованием контроллера SPIFI"]
# [inline (always)]
pub fn spifi (self) -> & 'a mut crate :: W < REG > { self . variant (BootMode :: Spifi) } } impl R { # [doc = "Bits 0:1 - Регистр режима загрузки. При чтении, возвращает режим, который будет использоваться для следующего сброса системного домена. При записи – установка нового режима загрузки."]
# [inline (always)]
pub fn boot_mode (& self) -> BootModeR { BootModeR :: new ((self . bits & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Регистр режима загрузки. При чтении, возвращает режим, который будет использоваться для следующего сброса системного домена. При записи – установка нового режима загрузки."]
# [inline (always)]
pub fn boot_mode (& mut self) -> BootModeW < BootSpec > { BootModeW :: new (self , 0) } } # [doc = "Регистр режима загрузки\n\nYou can [`read`](crate::Reg::read) this register and get [`boot::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`boot::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BootSpec ; impl crate :: RegisterSpec for BootSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`boot::R`](R) reader structure"]
impl crate :: Readable for BootSpec { } # [doc = "`write(|w| ..)` method takes [`boot::W`](W) writer structure"]
impl crate :: Writable for BootSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets BOOT to value 0"]
impl crate :: Resettable for BootSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Контроллер SPIFI"]
pub struct SpifiConfig { _marker : PhantomData < * const () > } unsafe impl Send for SpifiConfig { } impl SpifiConfig { # [doc = r"Pointer to the register block"]
pub const PTR : * const spifi_config :: RegisterBlock = 0x0007_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spifi_config :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for SpifiConfig { type Target = spifi_config :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for SpifiConfig { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("SpifiConfig") . finish () } } # [doc = "Контроллер SPIFI"]
pub mod spifi_config { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { ctrl : Ctrl , cmd : Cmd , address : Address , idata : Idata , climit : Climit , data : Data , mcmd : Mcmd , stat : Stat , } impl RegisterBlock { # [doc = "0x00 - SPIFI регистр управления"]
# [inline (always)]
pub const fn ctrl (& self) -> & Ctrl { & self . ctrl } # [doc = "0x04 - SPIFI регистр команд. Этот регистр может быть записан только тогда, когда биты CMD и MCINIT равны нулю"]
# [inline (always)]
pub const fn cmd (& self) -> & Cmd { & self . cmd } # [doc = "0x08 - SPIFI регистр адреса. Данный регистр должен быть настроен перед инициализацией любой команды. При выполнении команды первым выводится старший бит адреса"]
# [inline (always)]
pub const fn address (& self) -> & Address { & self . address } # [doc = "0x0c - SPIFI регистр промежуточных данных. Данный регистр должен быть настроен перед инициализацией команды, в которой используются промежуточные данные. При выполнении команды первым выводится младший бит слова"]
# [inline (always)]
pub const fn idata (& self) -> & Idata { & self . idata } # [doc = "0x10 - SPIFI регистр верхней границы адреса кеширования"]
# [inline (always)]
pub const fn climit (& self) -> & Climit { & self . climit } # [doc = "0x14 - SPIFI регистр данных. Если выходной буфер чтения пуст или входной буфер записи полон, то при отправке запроса по шине AHB будет вызвано исключение (код 5 “Load access fault”)."]
# [inline (always)]
pub const fn data (& self) -> & Data { & self . data } # [doc = "0x18 - SPIFI регистр команд памяти"]
# [inline (always)]
pub const fn mcmd (& self) -> & Mcmd { & self . mcmd } # [doc = "0x1c - SPIFI регистр статуса"]
# [inline (always)]
pub const fn stat (& self) -> & Stat { & self . stat } } # [doc = "CTRL (rw) register accessor: SPIFI регистр управления\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`]
module"]
# [doc (alias = "CTRL")]
pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ; # [doc = "SPIFI регистр управления"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub type R = crate :: R < CtrlSpec > ; # [doc = "Register `CTRL` writer"]
pub type W = crate :: W < CtrlSpec > ; # [doc = "Field `TIMEOUT` reader - Количество периодов сигнала SPIFI_SCK без чтения данных в режиме работы с памятью, которое вызывает завершение выполнения команды установкой сигнала SPIFI_CS в состояние «1» и сбросом бита CMD"]
pub type TimeoutR = crate :: FieldReader < u16 > ; # [doc = "Field `TIMEOUT` writer - Количество периодов сигнала SPIFI_SCK без чтения данных в режиме работы с памятью, которое вызывает завершение выполнения команды установкой сигнала SPIFI_CS в состояние «1» и сбросом бита CMD"]
pub type TimeoutW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; # [doc = "Field `CSHIGH` reader - Количество периодов сигнала SPIFI_SCK минус один, в течение которых сигнал SPIFI_CS остается в неактивном состоянии перед началом выполнения команды"]
pub type CshighR = crate :: FieldReader ; # [doc = "Field `CSHIGH` writer - Количество периодов сигнала SPIFI_SCK минус один, в течение которых сигнал SPIFI_CS остается в неактивном состоянии перед началом выполнения команды"]
pub type CshighW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Бит разрешения кэширования\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CacheEn { # [doc = "0: Кэширование отключено"]
Disable = 0 , # [doc = "1: Кэширование включено"]
Enable = 1 , } impl From < CacheEn > for bool { # [inline (always)]
fn from (variant : CacheEn) -> Self { variant as u8 != 0 } } # [doc = "Field `CACHE_EN` reader - Бит разрешения кэширования"]
pub type CacheEnR = crate :: BitReader < CacheEn > ; impl CacheEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> CacheEn { match self . bits { false => CacheEn :: Disable , true => CacheEn :: Enable , } } # [doc = "Кэширование отключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == CacheEn :: Disable } # [doc = "Кэширование включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == CacheEn :: Enable } } # [doc = "Field `CACHE_EN` writer - Бит разрешения кэширования"]
pub type CacheEnW < 'a , REG > = crate :: BitWriter < 'a , REG , CacheEn > ; impl < 'a , REG > CacheEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Кэширование отключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (CacheEn :: Disable) } # [doc = "Кэширование включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (CacheEn :: Enable) } } # [doc = "Бит запрещения кеширования данных (транзакций AHB, для которых сигнал HPROT\\[0:0\\]
= 1)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum DCacheDis { # [doc = "0: При разрешенном кэшировании кэширование данных выполняется"]
DataIsCached = 0 , # [doc = "1: Данные не кэшируются"]
DataIsNotCached = 1 , } impl From < DCacheDis > for bool { # [inline (always)]
fn from (variant : DCacheDis) -> Self { variant as u8 != 0 } } # [doc = "Field `D_CACHE_DIS` reader - Бит запрещения кеширования данных (транзакций AHB, для которых сигнал HPROT\\[0:0\\]
= 1)"]
pub type DCacheDisR = crate :: BitReader < DCacheDis > ; impl DCacheDisR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> DCacheDis { match self . bits { false => DCacheDis :: DataIsCached , true => DCacheDis :: DataIsNotCached , } } # [doc = "При разрешенном кэшировании кэширование данных выполняется"]
# [inline (always)]
pub fn is_data_is_cached (& self) -> bool { * self == DCacheDis :: DataIsCached } # [doc = "Данные не кэшируются"]
# [inline (always)]
pub fn is_data_is_not_cached (& self) -> bool { * self == DCacheDis :: DataIsNotCached } } # [doc = "Field `D_CACHE_DIS` writer - Бит запрещения кеширования данных (транзакций AHB, для которых сигнал HPROT\\[0:0\\]
= 1)"]
pub type DCacheDisW < 'a , REG > = crate :: BitWriter < 'a , REG , DCacheDis > ; impl < 'a , REG > DCacheDisW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "При разрешенном кэшировании кэширование данных выполняется"]
# [inline (always)]
pub fn data_is_cached (self) -> & 'a mut crate :: W < REG > { self . variant (DCacheDis :: DataIsCached) } # [doc = "Данные не кэшируются"]
# [inline (always)]
pub fn data_is_not_cached (self) -> & 'a mut crate :: W < REG > { self . variant (DCacheDis :: DataIsNotCached) } } # [doc = "Бит разрешения прерывания при завершении выполнения команды (если этот бит равен «1», то прерывание разрешено)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Inten { # [doc = "0: Прерывнаие запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Inten > for bool { # [inline (always)]
fn from (variant : Inten) -> Self { variant as u8 != 0 } } # [doc = "Field `INTEN` reader - Бит разрешения прерывания при завершении выполнения команды (если этот бит равен «1», то прерывание разрешено)"]
pub type IntenR = crate :: BitReader < Inten > ; impl IntenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Inten { match self . bits { false => Inten :: Disable , true => Inten :: Enable , } } # [doc = "Прерывнаие запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Inten :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Inten :: Enable } } # [doc = "Field `INTEN` writer - Бит разрешения прерывания при завершении выполнения команды (если этот бит равен «1», то прерывание разрешено)"]
pub type IntenW < 'a , REG > = crate :: BitWriter < 'a , REG , Inten > ; impl < 'a , REG > IntenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывнаие запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Inten :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Inten :: Enable) } } # [doc = "Бит режима 3\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Mode3 { # [doc = "0: Режим 0 (CPOL = 0, CPHA = 0). CPOL = 0 — исходное состояние сигнала синхронизации - низкий уровень CPHA = 0 — выборка данных производится по переднему фронту (переключению) сигнала синхронизации"]
Mode0 = 0 , # [doc = "1: Режим 3 (CPOL = 1, CPHA = 1). CPHA = 1 - исходное состояние сигнала синхронизации - высокий уровень CPOL = 1 - выборка данных производится по заднему фронту (переключению) сигнала синхронизации"]
Mode3 = 1 , } impl From < Mode3 > for bool { # [inline (always)]
fn from (variant : Mode3) -> Self { variant as u8 != 0 } } # [doc = "Field `MODE3` reader - Бит режима 3"]
pub type Mode3R = crate :: BitReader < Mode3 > ; impl Mode3R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Mode3 { match self . bits { false => Mode3 :: Mode0 , true => Mode3 :: Mode3 , } } # [doc = "Режим 0 (CPOL = 0, CPHA = 0). CPOL = 0 — исходное состояние сигнала синхронизации - низкий уровень CPHA = 0 — выборка данных производится по переднему фронту (переключению) сигнала синхронизации"]
# [inline (always)]
pub fn is_mode0 (& self) -> bool { * self == Mode3 :: Mode0 } # [doc = "Режим 3 (CPOL = 1, CPHA = 1). CPHA = 1 - исходное состояние сигнала синхронизации - высокий уровень CPOL = 1 - выборка данных производится по заднему фронту (переключению) сигнала синхронизации"]
# [inline (always)]
pub fn is_mode3 (& self) -> bool { * self == Mode3 :: Mode3 } } # [doc = "Field `MODE3` writer - Бит режима 3"]
pub type Mode3W < 'a , REG > = crate :: BitWriter < 'a , REG , Mode3 > ; impl < 'a , REG > Mode3W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Режим 0 (CPOL = 0, CPHA = 0). CPOL = 0 — исходное состояние сигнала синхронизации - низкий уровень CPHA = 0 — выборка данных производится по переднему фронту (переключению) сигнала синхронизации"]
# [inline (always)]
pub fn mode0 (self) -> & 'a mut crate :: W < REG > { self . variant (Mode3 :: Mode0) } # [doc = "Режим 3 (CPOL = 1, CPHA = 1). CPHA = 1 - исходное состояние сигнала синхронизации - высокий уровень CPOL = 1 - выборка данных производится по заднему фронту (переключению) сигнала синхронизации"]
# [inline (always)]
pub fn mode3 (self) -> & 'a mut crate :: W < REG > { self . variant (Mode3 :: Mode3) } } # [doc = "Field `SCK_DIV` reader - Делитель для получения тактового сигнала SPIFI_SCK из системного тактового сигнала HCLK. Частота рассчитывается по формуле: FSPIFI_SCK = FHCLK / 2^(SCK_DIV+1)"]
pub type SckDivR = crate :: FieldReader ; # [doc = "Field `SCK_DIV` writer - Делитель для получения тактового сигнала SPIFI_SCK из системного тактового сигнала HCLK. Частота рассчитывается по формуле: FSPIFI_SCK = FHCLK / 2^(SCK_DIV+1)"]
pub type SckDivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Бит разрешения упреждающих выборок кэш памяти «0» – выборки разрешены\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PrftchDis { # [doc = "0: Выборки разрешены"]
Enable = 0 , # [doc = "1: Выборки запрещены"]
Disable = 1 , } impl From < PrftchDis > for bool { # [inline (always)]
fn from (variant : PrftchDis) -> Self { variant as u8 != 0 } } # [doc = "Field `PRFTCH_DIS` reader - Бит разрешения упреждающих выборок кэш памяти «0» – выборки разрешены"]
pub type PrftchDisR = crate :: BitReader < PrftchDis > ; impl PrftchDisR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PrftchDis { match self . bits { false => PrftchDis :: Enable , true => PrftchDis :: Disable , } } # [doc = "Выборки разрешены"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PrftchDis :: Enable } # [doc = "Выборки запрещены"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PrftchDis :: Disable } } # [doc = "Field `PRFTCH_DIS` writer - Бит разрешения упреждающих выборок кэш памяти «0» – выборки разрешены"]
pub type PrftchDisW < 'a , REG > = crate :: BitWriter < 'a , REG , PrftchDis > ; impl < 'a , REG > PrftchDisW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Выборки разрешены"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (PrftchDis :: Enable) } # [doc = "Выборки запрещены"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (PrftchDis :: Disable) } } # [doc = "Бит выбора протокола: сигналы IO\\[3:0\\]
– (0–4) битовый протокол; сигналы IO\\[1:0\\]
– (1–2) битовый протокол\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dual { # [doc = "0: Сигналы IO\\[3:0\\]
– (0–4) битовый протокол"]
SingleOrQuad = 0 , # [doc = "1: Сигналы IO\\[1:0\\]
– (1–2) битовый протокол"]
Dual = 1 , } impl From < Dual > for bool { # [inline (always)]
fn from (variant : Dual) -> Self { variant as u8 != 0 } } # [doc = "Field `DUAL` reader - Бит выбора протокола: сигналы IO\\[3:0\\]
– (0–4) битовый протокол; сигналы IO\\[1:0\\]
– (1–2) битовый протокол"]
pub type DualR = crate :: BitReader < Dual > ; impl DualR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dual { match self . bits { false => Dual :: SingleOrQuad , true => Dual :: Dual , } } # [doc = "Сигналы IO\\[3:0\\]
– (0–4) битовый протокол"]
# [inline (always)]
pub fn is_single_or_quad (& self) -> bool { * self == Dual :: SingleOrQuad } # [doc = "Сигналы IO\\[1:0\\]
– (1–2) битовый протокол"]
# [inline (always)]
pub fn is_dual (& self) -> bool { * self == Dual :: Dual } } # [doc = "Field `DUAL` writer - Бит выбора протокола: сигналы IO\\[3:0\\]
– (0–4) битовый протокол; сигналы IO\\[1:0\\]
– (1–2) битовый протокол"]
pub type DualW < 'a , REG > = crate :: BitWriter < 'a , REG , Dual > ; impl < 'a , REG > DualW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сигналы IO\\[3:0\\]
– (0–4) битовый протокол"]
# [inline (always)]
pub fn single_or_quad (self) -> & 'a mut crate :: W < REG > { self . variant (Dual :: SingleOrQuad) } # [doc = "Сигналы IO\\[1:0\\]
– (1–2) битовый протокол"]
# [inline (always)]
pub fn dual (self) -> & 'a mut crate :: W < REG > { self . variant (Dual :: Dual) } } # [doc = "Бит выбора активного перепада сигнала для стробирования входных данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rfclk { # [doc = "0: Положительный перепад"]
RisingEdge = 0 , # [doc = "1: Отрицательный перепад"]
FallingEdge = 1 , } impl From < Rfclk > for bool { # [inline (always)]
fn from (variant : Rfclk) -> Self { variant as u8 != 0 } } # [doc = "Field `RFCLK` reader - Бит выбора активного перепада сигнала для стробирования входных данных"]
pub type RfclkR = crate :: BitReader < Rfclk > ; impl RfclkR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rfclk { match self . bits { false => Rfclk :: RisingEdge , true => Rfclk :: FallingEdge , } } # [doc = "Положительный перепад"]
# [inline (always)]
pub fn is_rising_edge (& self) -> bool { * self == Rfclk :: RisingEdge } # [doc = "Отрицательный перепад"]
# [inline (always)]
pub fn is_falling_edge (& self) -> bool { * self == Rfclk :: FallingEdge } } # [doc = "Field `RFCLK` writer - Бит выбора активного перепада сигнала для стробирования входных данных"]
pub type RfclkW < 'a , REG > = crate :: BitWriter < 'a , REG , Rfclk > ; impl < 'a , REG > RfclkW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Положительный перепад"]
# [inline (always)]
pub fn rising_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Rfclk :: RisingEdge) } # [doc = "Отрицательный перепад"]
# [inline (always)]
pub fn falling_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Rfclk :: FallingEdge) } } # [doc = "Бит выбора сигнала стробирования входных данных с выходного буфера тактового сигнала\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Fblk { # [doc = "0: Внутренний сигнал"]
InternalSignal = 0 , # [doc = "1: Внешний сигнал"]
ExternalSignal = 1 , } impl From < Fblk > for bool { # [inline (always)]
fn from (variant : Fblk) -> Self { variant as u8 != 0 } } # [doc = "Field `FBLK` reader - Бит выбора сигнала стробирования входных данных с выходного буфера тактового сигнала"]
pub type FblkR = crate :: BitReader < Fblk > ; impl FblkR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Fblk { match self . bits { false => Fblk :: InternalSignal , true => Fblk :: ExternalSignal , } } # [doc = "Внутренний сигнал"]
# [inline (always)]
pub fn is_internal_signal (& self) -> bool { * self == Fblk :: InternalSignal } # [doc = "Внешний сигнал"]
# [inline (always)]
pub fn is_external_signal (& self) -> bool { * self == Fblk :: ExternalSignal } } # [doc = "Field `FBLK` writer - Бит выбора сигнала стробирования входных данных с выходного буфера тактового сигнала"]
pub type FblkW < 'a , REG > = crate :: BitWriter < 'a , REG , Fblk > ; impl < 'a , REG > FblkW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Внутренний сигнал"]
# [inline (always)]
pub fn internal_signal (self) -> & 'a mut crate :: W < REG > { self . variant (Fblk :: InternalSignal) } # [doc = "Внешний сигнал"]
# [inline (always)]
pub fn external_signal (self) -> & 'a mut crate :: W < REG > { self . variant (Fblk :: ExternalSignal) } } # [doc = "Бит разрешения запросов DMA от контроллера SPIFI Устанавливать только в периферийном режиме\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dmaen { # [doc = "0: Запросы запрещены"]
Disable = 0 , # [doc = "1: Запросы разрешены"]
Enable = 1 , } impl From < Dmaen > for bool { # [inline (always)]
fn from (variant : Dmaen) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAEN` reader - Бит разрешения запросов DMA от контроллера SPIFI Устанавливать только в периферийном режиме"]
pub type DmaenR = crate :: BitReader < Dmaen > ; impl DmaenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dmaen { match self . bits { false => Dmaen :: Disable , true => Dmaen :: Enable , } } # [doc = "Запросы запрещены"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dmaen :: Disable } # [doc = "Запросы разрешены"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dmaen :: Enable } } # [doc = "Field `DMAEN` writer - Бит разрешения запросов DMA от контроллера SPIFI Устанавливать только в периферийном режиме"]
pub type DmaenW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmaen > ; impl < 'a , REG > DmaenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запросы запрещены"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen :: Disable) } # [doc = "Запросы разрешены"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dmaen :: Enable) } } impl R { # [doc = "Bits 0:15 - Количество периодов сигнала SPIFI_SCK без чтения данных в режиме работы с памятью, которое вызывает завершение выполнения команды установкой сигнала SPIFI_CS в состояние «1» и сбросом бита CMD"]
# [inline (always)]
pub fn timeout (& self) -> TimeoutR { TimeoutR :: new ((self . bits & 0xffff) as u16) } # [doc = "Bits 16:19 - Количество периодов сигнала SPIFI_SCK минус один, в течение которых сигнал SPIFI_CS остается в неактивном состоянии перед началом выполнения команды"]
# [inline (always)]
pub fn cshigh (& self) -> CshighR { CshighR :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bit 20 - Бит разрешения кэширования"]
# [inline (always)]
pub fn cache_en (& self) -> CacheEnR { CacheEnR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Бит запрещения кеширования данных (транзакций AHB, для которых сигнал HPROT\\[0:0\\]
= 1)"]
# [inline (always)]
pub fn d_cache_dis (& self) -> DCacheDisR { DCacheDisR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Бит разрешения прерывания при завершении выполнения команды (если этот бит равен «1», то прерывание разрешено)"]
# [inline (always)]
pub fn inten (& self) -> IntenR { IntenR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Бит режима 3"]
# [inline (always)]
pub fn mode3 (& self) -> Mode3R { Mode3R :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bits 24:26 - Делитель для получения тактового сигнала SPIFI_SCK из системного тактового сигнала HCLK. Частота рассчитывается по формуле: FSPIFI_SCK = FHCLK / 2^(SCK_DIV+1)"]
# [inline (always)]
pub fn sck_div (& self) -> SckDivR { SckDivR :: new (((self . bits >> 24) & 7) as u8) } # [doc = "Bit 27 - Бит разрешения упреждающих выборок кэш памяти «0» – выборки разрешены"]
# [inline (always)]
pub fn prftch_dis (& self) -> PrftchDisR { PrftchDisR :: new (((self . bits >> 27) & 1) != 0) } # [doc = "Bit 28 - Бит выбора протокола: сигналы IO\\[3:0\\]
– (0–4) битовый протокол; сигналы IO\\[1:0\\]
– (1–2) битовый протокол"]
# [inline (always)]
pub fn dual (& self) -> DualR { DualR :: new (((self . bits >> 28) & 1) != 0) } # [doc = "Bit 29 - Бит выбора активного перепада сигнала для стробирования входных данных"]
# [inline (always)]
pub fn rfclk (& self) -> RfclkR { RfclkR :: new (((self . bits >> 29) & 1) != 0) } # [doc = "Bit 30 - Бит выбора сигнала стробирования входных данных с выходного буфера тактового сигнала"]
# [inline (always)]
pub fn fblk (& self) -> FblkR { FblkR :: new (((self . bits >> 30) & 1) != 0) } # [doc = "Bit 31 - Бит разрешения запросов DMA от контроллера SPIFI Устанавливать только в периферийном режиме"]
# [inline (always)]
pub fn dmaen (& self) -> DmaenR { DmaenR :: new (((self . bits >> 31) & 1) != 0) } } impl W { # [doc = "Bits 0:15 - Количество периодов сигнала SPIFI_SCK без чтения данных в режиме работы с памятью, которое вызывает завершение выполнения команды установкой сигнала SPIFI_CS в состояние «1» и сбросом бита CMD"]
# [inline (always)]
pub fn timeout (& mut self) -> TimeoutW < CtrlSpec > { TimeoutW :: new (self , 0) } # [doc = "Bits 16:19 - Количество периодов сигнала SPIFI_SCK минус один, в течение которых сигнал SPIFI_CS остается в неактивном состоянии перед началом выполнения команды"]
# [inline (always)]
pub fn cshigh (& mut self) -> CshighW < CtrlSpec > { CshighW :: new (self , 16) } # [doc = "Bit 20 - Бит разрешения кэширования"]
# [inline (always)]
pub fn cache_en (& mut self) -> CacheEnW < CtrlSpec > { CacheEnW :: new (self , 20) } # [doc = "Bit 21 - Бит запрещения кеширования данных (транзакций AHB, для которых сигнал HPROT\\[0:0\\]
= 1)"]
# [inline (always)]
pub fn d_cache_dis (& mut self) -> DCacheDisW < CtrlSpec > { DCacheDisW :: new (self , 21) } # [doc = "Bit 22 - Бит разрешения прерывания при завершении выполнения команды (если этот бит равен «1», то прерывание разрешено)"]
# [inline (always)]
pub fn inten (& mut self) -> IntenW < CtrlSpec > { IntenW :: new (self , 22) } # [doc = "Bit 23 - Бит режима 3"]
# [inline (always)]
pub fn mode3 (& mut self) -> Mode3W < CtrlSpec > { Mode3W :: new (self , 23) } # [doc = "Bits 24:26 - Делитель для получения тактового сигнала SPIFI_SCK из системного тактового сигнала HCLK. Частота рассчитывается по формуле: FSPIFI_SCK = FHCLK / 2^(SCK_DIV+1)"]
# [inline (always)]
pub fn sck_div (& mut self) -> SckDivW < CtrlSpec > { SckDivW :: new (self , 24) } # [doc = "Bit 27 - Бит разрешения упреждающих выборок кэш памяти «0» – выборки разрешены"]
# [inline (always)]
pub fn prftch_dis (& mut self) -> PrftchDisW < CtrlSpec > { PrftchDisW :: new (self , 27) } # [doc = "Bit 28 - Бит выбора протокола: сигналы IO\\[3:0\\]
– (0–4) битовый протокол; сигналы IO\\[1:0\\]
– (1–2) битовый протокол"]
# [inline (always)]
pub fn dual (& mut self) -> DualW < CtrlSpec > { DualW :: new (self , 28) } # [doc = "Bit 29 - Бит выбора активного перепада сигнала для стробирования входных данных"]
# [inline (always)]
pub fn rfclk (& mut self) -> RfclkW < CtrlSpec > { RfclkW :: new (self , 29) } # [doc = "Bit 30 - Бит выбора сигнала стробирования входных данных с выходного буфера тактового сигнала"]
# [inline (always)]
pub fn fblk (& mut self) -> FblkW < CtrlSpec > { FblkW :: new (self , 30) } # [doc = "Bit 31 - Бит разрешения запросов DMA от контроллера SPIFI Устанавливать только в периферийном режиме"]
# [inline (always)]
pub fn dmaen (& mut self) -> DmaenW < CtrlSpec > { DmaenW :: new (self , 31) } } # [doc = "SPIFI регистр управления\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ctrl::R`](R) reader structure"]
impl crate :: Readable for CtrlSpec { } # [doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"]
impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CTRL to value 0x400f_ffff"]
impl crate :: Resettable for CtrlSpec { const RESET_VALUE : u32 = 0x400f_ffff ; } } # [doc = "CMD (rw) register accessor: SPIFI регистр команд. Этот регистр может быть записан только тогда, когда биты CMD и MCINIT равны нулю\n\nYou can [`read`](crate::Reg::read) this register and get [`cmd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmd`]
module"]
# [doc (alias = "CMD")]
pub type Cmd = crate :: Reg < cmd :: CmdSpec > ; # [doc = "SPIFI регистр команд. Этот регистр может быть записан только тогда, когда биты CMD и MCINIT равны нулю"]
pub mod cmd { # [doc = "Register `CMD` reader"]
pub type R = crate :: R < CmdSpec > ; # [doc = "Register `CMD` writer"]
pub type W = crate :: W < CmdSpec > ; # [doc = "Field `DATALEN` reader - В тех случаях, когда бит POLL равен «0», это поле определяет количество байт данных при выполнении команды. Если это поле равно «0», то выполняемая команда не содержит данных"]
pub type DatalenR = crate :: FieldReader < u16 > ; # [doc = "Field `DATALEN` writer - В тех случаях, когда бит POLL равен «0», это поле определяет количество байт данных при выполнении команды. Если это поле равно «0», то выполняемая команда не содержит данных"]
pub type DatalenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 14 , u16 > ; # [doc = "Бит должен быть установлен при выполнении команды, которая содержит входное поле данных и циклически запрашивает состояние бита входного потока битов из регистра статуса флэш-памяти. Номер проверяемого бита в байте статуса должен быть указан в битах DATALEN\\[2:0\\], а требуемое значение бита – в бите DATALEN\\[3\\]. Как только значения этих битов станут равны, контроллер завершает выполнение текущей команды, деактивируя сигнал SPIFI_CS, и формирует прерывание, если оно разрешено. После завершения процесса поллинга необходимо считать один байт из регистра DATA, так как в нем сохряняется последний принятый статус FLASH.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Poll { # [doc = "0: Режим поллинга выключен"]
Disable = 0 , # [doc = "1: Режим поллинга включен"]
Enable = 1 , } impl From < Poll > for bool { # [inline (always)]
fn from (variant : Poll) -> Self { variant as u8 != 0 } } # [doc = "Field `POLL` reader - Бит должен быть установлен при выполнении команды, которая содержит входное поле данных и циклически запрашивает состояние бита входного потока битов из регистра статуса флэш-памяти. Номер проверяемого бита в байте статуса должен быть указан в битах DATALEN\\[2:0\\], а требуемое значение бита – в бите DATALEN\\[3\\]. Как только значения этих битов станут равны, контроллер завершает выполнение текущей команды, деактивируя сигнал SPIFI_CS, и формирует прерывание, если оно разрешено. После завершения процесса поллинга необходимо считать один байт из регистра DATA, так как в нем сохряняется последний принятый статус FLASH."]
pub type PollR = crate :: BitReader < Poll > ; impl PollR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Poll { match self . bits { false => Poll :: Disable , true => Poll :: Enable , } } # [doc = "Режим поллинга выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Poll :: Disable } # [doc = "Режим поллинга включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Poll :: Enable } } # [doc = "Field `POLL` writer - Бит должен быть установлен при выполнении команды, которая содержит входное поле данных и циклически запрашивает состояние бита входного потока битов из регистра статуса флэш-памяти. Номер проверяемого бита в байте статуса должен быть указан в битах DATALEN\\[2:0\\], а требуемое значение бита – в бите DATALEN\\[3\\]. Как только значения этих битов станут равны, контроллер завершает выполнение текущей команды, деактивируя сигнал SPIFI_CS, и формирует прерывание, если оно разрешено. После завершения процесса поллинга необходимо считать один байт из регистра DATA, так как в нем сохряняется последний принятый статус FLASH."]
pub type PollW < 'a , REG > = crate :: BitWriter < 'a , REG , Poll > ; impl < 'a , REG > PollW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Режим поллинга выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Poll :: Disable) } # [doc = "Режим поллинга включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Poll :: Enable) } } # [doc = "Бит направления передачи данных. «0» – чтение из флэш\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dout { # [doc = "0: Чтение из флэш"]
Read = 0 , # [doc = "1: Запись во флэш"]
Write = 1 , } impl From < Dout > for bool { # [inline (always)]
fn from (variant : Dout) -> Self { variant as u8 != 0 } } # [doc = "Field `DOUT` reader - Бит направления передачи данных. «0» – чтение из флэш"]
pub type DoutR = crate :: BitReader < Dout > ; impl DoutR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dout { match self . bits { false => Dout :: Read , true => Dout :: Write , } } # [doc = "Чтение из флэш"]
# [inline (always)]
pub fn is_read (& self) -> bool { * self == Dout :: Read } # [doc = "Запись во флэш"]
# [inline (always)]
pub fn is_write (& self) -> bool { * self == Dout :: Write } } # [doc = "Field `DOUT` writer - Бит направления передачи данных. «0» – чтение из флэш"]
pub type DoutW < 'a , REG > = crate :: BitWriter < 'a , REG , Dout > ; impl < 'a , REG > DoutW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Чтение из флэш"]
# [inline (always)]
pub fn read (self) -> & 'a mut crate :: W < REG > { self . variant (Dout :: Read) } # [doc = "Запись во флэш"]
# [inline (always)]
pub fn write (self) -> & 'a mut crate :: W < REG > { self . variant (Dout :: Write) } } # [doc = "Field `INTLEN` reader - Количество байт промежуточных данных, которые хранятся в регистре IDATA. Если количество байт больше, чем может хранить регистр IDATA, то остаток добивается нулевыми значениями"]
pub type IntlenR = crate :: FieldReader ; # [doc = "Field `INTLEN` writer - Количество байт промежуточных данных, которые хранятся в регистре IDATA. Если количество байт больше, чем может хранить регистр IDATA, то остаток добивается нулевыми значениями"]
pub type IntlenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Формат вывода полей команды\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Fieldform { # [doc = "0: Все поля выводятся в последовательном режиме"]
AllSerial = 0 , # [doc = "1: Данные выводятся в четырех или двух битовом режиме, а остальные поля в последовательном режиме"]
DataParallel = 1 , # [doc = "2: Код операции выводится в последовательном режиме, а остальные в четырех или двух битовом"]
OpcodeSerial = 2 , # [doc = "3: Все поля в четырех или двух битовом режиме"]
AllParallel = 3 , } impl From < Fieldform > for u8 { # [inline (always)]
fn from (variant : Fieldform) -> Self { variant as _ } } impl crate :: FieldSpec for Fieldform { type Ux = u8 ; } impl crate :: IsEnum for Fieldform { } # [doc = "Field `FIELDFORM` reader - Формат вывода полей команды"]
pub type FieldformR = crate :: FieldReader < Fieldform > ; impl FieldformR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Fieldform { match self . bits { 0 => Fieldform :: AllSerial , 1 => Fieldform :: DataParallel , 2 => Fieldform :: OpcodeSerial , 3 => Fieldform :: AllParallel , _ => unreachable ! () , } } # [doc = "Все поля выводятся в последовательном режиме"]
# [inline (always)]
pub fn is_all_serial (& self) -> bool { * self == Fieldform :: AllSerial } # [doc = "Данные выводятся в четырех или двух битовом режиме, а остальные поля в последовательном режиме"]
# [inline (always)]
pub fn is_data_parallel (& self) -> bool { * self == Fieldform :: DataParallel } # [doc = "Код операции выводится в последовательном режиме, а остальные в четырех или двух битовом"]
# [inline (always)]
pub fn is_opcode_serial (& self) -> bool { * self == Fieldform :: OpcodeSerial } # [doc = "Все поля в четырех или двух битовом режиме"]
# [inline (always)]
pub fn is_all_parallel (& self) -> bool { * self == Fieldform :: AllParallel } } # [doc = "Field `FIELDFORM` writer - Формат вывода полей команды"]
pub type FieldformW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Fieldform , crate :: Safe > ; impl < 'a , REG > FieldformW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Все поля выводятся в последовательном режиме"]
# [inline (always)]
pub fn all_serial (self) -> & 'a mut crate :: W < REG > { self . variant (Fieldform :: AllSerial) } # [doc = "Данные выводятся в четырех или двух битовом режиме, а остальные поля в последовательном режиме"]
# [inline (always)]
pub fn data_parallel (self) -> & 'a mut crate :: W < REG > { self . variant (Fieldform :: DataParallel) } # [doc = "Код операции выводится в последовательном режиме, а остальные в четырех или двух битовом"]
# [inline (always)]
pub fn opcode_serial (self) -> & 'a mut crate :: W < REG > { self . variant (Fieldform :: OpcodeSerial) } # [doc = "Все поля в четырех или двух битовом режиме"]
# [inline (always)]
pub fn all_parallel (self) -> & 'a mut crate :: W < REG > { self . variant (Fieldform :: AllParallel) } } # [doc = "Бит управления полями кода операции и адреса команды\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Frameform { # [doc = "1: Выдается только код операции, адреса нет"]
OpcodeNoaddr = 1 , # [doc = "2: Код операции и младший байт адреса"]
Opcode1addr = 2 , # [doc = "3: Код операции и два младших байта адреса"]
Opcode2addr = 3 , # [doc = "4: Код операции и три младших байта адреса"]
Opcode3addr = 4 , # [doc = "5: Код операции и 4 байта адреса"]
Opcode4addr = 5 , # [doc = "6: Нет кода операции, три младших байта адреса"]
Noopcode3addr = 6 , # [doc = "7: Нет кода операции, 4 байта адреса"]
Noopcode4addr = 7 , } impl From < Frameform > for u8 { # [inline (always)]
fn from (variant : Frameform) -> Self { variant as _ } } impl crate :: FieldSpec for Frameform { type Ux = u8 ; } impl crate :: IsEnum for Frameform { } # [doc = "Field `FRAMEFORM` reader - Бит управления полями кода операции и адреса команды"]
pub type FrameformR = crate :: FieldReader < Frameform > ; impl FrameformR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Frameform > { match self . bits { 1 => Some (Frameform :: OpcodeNoaddr) , 2 => Some (Frameform :: Opcode1addr) , 3 => Some (Frameform :: Opcode2addr) , 4 => Some (Frameform :: Opcode3addr) , 5 => Some (Frameform :: Opcode4addr) , 6 => Some (Frameform :: Noopcode3addr) , 7 => Some (Frameform :: Noopcode4addr) , _ => None , } } # [doc = "Выдается только код операции, адреса нет"]
# [inline (always)]
pub fn is_opcode_noaddr (& self) -> bool { * self == Frameform :: OpcodeNoaddr } # [doc = "Код операции и младший байт адреса"]
# [inline (always)]
pub fn is_opcode_1addr (& self) -> bool { * self == Frameform :: Opcode1addr } # [doc = "Код операции и два младших байта адреса"]
# [inline (always)]
pub fn is_opcode_2addr (& self) -> bool { * self == Frameform :: Opcode2addr } # [doc = "Код операции и три младших байта адреса"]
# [inline (always)]
pub fn is_opcode_3addr (& self) -> bool { * self == Frameform :: Opcode3addr } # [doc = "Код операции и 4 байта адреса"]
# [inline (always)]
pub fn is_opcode_4addr (& self) -> bool { * self == Frameform :: Opcode4addr } # [doc = "Нет кода операции, три младших байта адреса"]
# [inline (always)]
pub fn is_noopcode_3addr (& self) -> bool { * self == Frameform :: Noopcode3addr } # [doc = "Нет кода операции, 4 байта адреса"]
# [inline (always)]
pub fn is_noopcode_4addr (& self) -> bool { * self == Frameform :: Noopcode4addr } } # [doc = "Field `FRAMEFORM` writer - Бит управления полями кода операции и адреса команды"]
pub type FrameformW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Frameform > ; impl < 'a , REG > FrameformW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Выдается только код операции, адреса нет"]
# [inline (always)]
pub fn opcode_noaddr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: OpcodeNoaddr) } # [doc = "Код операции и младший байт адреса"]
# [inline (always)]
pub fn opcode_1addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Opcode1addr) } # [doc = "Код операции и два младших байта адреса"]
# [inline (always)]
pub fn opcode_2addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Opcode2addr) } # [doc = "Код операции и три младших байта адреса"]
# [inline (always)]
pub fn opcode_3addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Opcode3addr) } # [doc = "Код операции и 4 байта адреса"]
# [inline (always)]
pub fn opcode_4addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Opcode4addr) } # [doc = "Нет кода операции, три младших байта адреса"]
# [inline (always)]
pub fn noopcode_3addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Noopcode3addr) } # [doc = "Нет кода операции, 4 байта адреса"]
# [inline (always)]
pub fn noopcode_4addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Noopcode4addr) } } # [doc = "Field `OPCODE` reader - Код операции (не используется для некоторых значений поля FRAMEFORM)"]
pub type OpcodeR = crate :: FieldReader ; # [doc = "Field `OPCODE` writer - Код операции (не используется для некоторых значений поля FRAMEFORM)"]
pub type OpcodeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:13 - В тех случаях, когда бит POLL равен «0», это поле определяет количество байт данных при выполнении команды. Если это поле равно «0», то выполняемая команда не содержит данных"]
# [inline (always)]
pub fn datalen (& self) -> DatalenR { DatalenR :: new ((self . bits & 0x3fff) as u16) } # [doc = "Bit 14 - Бит должен быть установлен при выполнении команды, которая содержит входное поле данных и циклически запрашивает состояние бита входного потока битов из регистра статуса флэш-памяти. Номер проверяемого бита в байте статуса должен быть указан в битах DATALEN\\[2:0\\], а требуемое значение бита – в бите DATALEN\\[3\\]. Как только значения этих битов станут равны, контроллер завершает выполнение текущей команды, деактивируя сигнал SPIFI_CS, и формирует прерывание, если оно разрешено. После завершения процесса поллинга необходимо считать один байт из регистра DATA, так как в нем сохряняется последний принятый статус FLASH."]
# [inline (always)]
pub fn poll (& self) -> PollR { PollR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Бит направления передачи данных. «0» – чтение из флэш"]
# [inline (always)]
pub fn dout (& self) -> DoutR { DoutR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:18 - Количество байт промежуточных данных, которые хранятся в регистре IDATA. Если количество байт больше, чем может хранить регистр IDATA, то остаток добивается нулевыми значениями"]
# [inline (always)]
pub fn intlen (& self) -> IntlenR { IntlenR :: new (((self . bits >> 16) & 7) as u8) } # [doc = "Bits 19:20 - Формат вывода полей команды"]
# [inline (always)]
pub fn fieldform (& self) -> FieldformR { FieldformR :: new (((self . bits >> 19) & 3) as u8) } # [doc = "Bits 21:23 - Бит управления полями кода операции и адреса команды"]
# [inline (always)]
pub fn frameform (& self) -> FrameformR { FrameformR :: new (((self . bits >> 21) & 7) as u8) } # [doc = "Bits 24:31 - Код операции (не используется для некоторых значений поля FRAMEFORM)"]
# [inline (always)]
pub fn opcode (& self) -> OpcodeR { OpcodeR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W { # [doc = "Bits 0:13 - В тех случаях, когда бит POLL равен «0», это поле определяет количество байт данных при выполнении команды. Если это поле равно «0», то выполняемая команда не содержит данных"]
# [inline (always)]
pub fn datalen (& mut self) -> DatalenW < CmdSpec > { DatalenW :: new (self , 0) } # [doc = "Bit 14 - Бит должен быть установлен при выполнении команды, которая содержит входное поле данных и циклически запрашивает состояние бита входного потока битов из регистра статуса флэш-памяти. Номер проверяемого бита в байте статуса должен быть указан в битах DATALEN\\[2:0\\], а требуемое значение бита – в бите DATALEN\\[3\\]. Как только значения этих битов станут равны, контроллер завершает выполнение текущей команды, деактивируя сигнал SPIFI_CS, и формирует прерывание, если оно разрешено. После завершения процесса поллинга необходимо считать один байт из регистра DATA, так как в нем сохряняется последний принятый статус FLASH."]
# [inline (always)]
pub fn poll (& mut self) -> PollW < CmdSpec > { PollW :: new (self , 14) } # [doc = "Bit 15 - Бит направления передачи данных. «0» – чтение из флэш"]
# [inline (always)]
pub fn dout (& mut self) -> DoutW < CmdSpec > { DoutW :: new (self , 15) } # [doc = "Bits 16:18 - Количество байт промежуточных данных, которые хранятся в регистре IDATA. Если количество байт больше, чем может хранить регистр IDATA, то остаток добивается нулевыми значениями"]
# [inline (always)]
pub fn intlen (& mut self) -> IntlenW < CmdSpec > { IntlenW :: new (self , 16) } # [doc = "Bits 19:20 - Формат вывода полей команды"]
# [inline (always)]
pub fn fieldform (& mut self) -> FieldformW < CmdSpec > { FieldformW :: new (self , 19) } # [doc = "Bits 21:23 - Бит управления полями кода операции и адреса команды"]
# [inline (always)]
pub fn frameform (& mut self) -> FrameformW < CmdSpec > { FrameformW :: new (self , 21) } # [doc = "Bits 24:31 - Код операции (не используется для некоторых значений поля FRAMEFORM)"]
# [inline (always)]
pub fn opcode (& mut self) -> OpcodeW < CmdSpec > { OpcodeW :: new (self , 24) } } # [doc = "SPIFI регистр команд. Этот регистр может быть записан только тогда, когда биты CMD и MCINIT равны нулю\n\nYou can [`read`](crate::Reg::read) this register and get [`cmd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CmdSpec ; impl crate :: RegisterSpec for CmdSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cmd::R`](R) reader structure"]
impl crate :: Readable for CmdSpec { } # [doc = "`write(|w| ..)` method takes [`cmd::W`](W) writer structure"]
impl crate :: Writable for CmdSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CMD to value 0"]
impl crate :: Resettable for CmdSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ADDRESS (rw) register accessor: SPIFI регистр адреса. Данный регистр должен быть настроен перед инициализацией любой команды. При выполнении команды первым выводится старший бит адреса\n\nYou can [`read`](crate::Reg::read) this register and get [`address::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`address::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@address`]
module"]
# [doc (alias = "ADDRESS")]
pub type Address = crate :: Reg < address :: AddressSpec > ; # [doc = "SPIFI регистр адреса. Данный регистр должен быть настроен перед инициализацией любой команды. При выполнении команды первым выводится старший бит адреса"]
pub mod address { # [doc = "Register `ADDRESS` reader"]
pub type R = crate :: R < AddressSpec > ; # [doc = "Register `ADDRESS` writer"]
pub type W = crate :: W < AddressSpec > ; # [doc = "Field `ADDRESS` reader - Исполнительный адрес команды"]
pub type AddressR = crate :: FieldReader < u32 > ; # [doc = "Field `ADDRESS` writer - Исполнительный адрес команды"]
pub type AddressW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Исполнительный адрес команды"]
# [inline (always)]
pub fn address (& self) -> AddressR { AddressR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Исполнительный адрес команды"]
# [inline (always)]
pub fn address (& mut self) -> AddressW < AddressSpec > { AddressW :: new (self , 0) } } # [doc = "SPIFI регистр адреса. Данный регистр должен быть настроен перед инициализацией любой команды. При выполнении команды первым выводится старший бит адреса\n\nYou can [`read`](crate::Reg::read) this register and get [`address::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`address::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AddressSpec ; impl crate :: RegisterSpec for AddressSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`address::R`](R) reader structure"]
impl crate :: Readable for AddressSpec { } # [doc = "`write(|w| ..)` method takes [`address::W`](W) writer structure"]
impl crate :: Writable for AddressSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ADDRESS to value 0"]
impl crate :: Resettable for AddressSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "IDATA (rw) register accessor: SPIFI регистр промежуточных данных. Данный регистр должен быть настроен перед инициализацией команды, в которой используются промежуточные данные. При выполнении команды первым выводится младший бит слова\n\nYou can [`read`](crate::Reg::read) this register and get [`idata::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idata::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@idata`]
module"]
# [doc (alias = "IDATA")]
pub type Idata = crate :: Reg < idata :: IdataSpec > ; # [doc = "SPIFI регистр промежуточных данных. Данный регистр должен быть настроен перед инициализацией команды, в которой используются промежуточные данные. При выполнении команды первым выводится младший бит слова"]
pub mod idata { # [doc = "Register `IDATA` reader"]
pub type R = crate :: R < IdataSpec > ; # [doc = "Register `IDATA` writer"]
pub type W = crate :: W < IdataSpec > ; # [doc = "Field `IDATA` reader - Промежуточные данные"]
pub type IdataR = crate :: FieldReader < u32 > ; # [doc = "Field `IDATA` writer - Промежуточные данные"]
pub type IdataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Промежуточные данные"]
# [inline (always)]
pub fn idata (& self) -> IdataR { IdataR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Промежуточные данные"]
# [inline (always)]
pub fn idata (& mut self) -> IdataW < IdataSpec > { IdataW :: new (self , 0) } } # [doc = "SPIFI регистр промежуточных данных. Данный регистр должен быть настроен перед инициализацией команды, в которой используются промежуточные данные. При выполнении команды первым выводится младший бит слова\n\nYou can [`read`](crate::Reg::read) this register and get [`idata::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`idata::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IdataSpec ; impl crate :: RegisterSpec for IdataSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`idata::R`](R) reader structure"]
impl crate :: Readable for IdataSpec { } # [doc = "`write(|w| ..)` method takes [`idata::W`](W) writer structure"]
impl crate :: Writable for IdataSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets IDATA to value 0"]
impl crate :: Resettable for IdataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CLIMIT (rw) register accessor: SPIFI регистр верхней границы адреса кеширования\n\nYou can [`read`](crate::Reg::read) this register and get [`climit::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`climit::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@climit`]
module"]
# [doc (alias = "CLIMIT")]
pub type Climit = crate :: Reg < climit :: ClimitSpec > ; # [doc = "SPIFI регистр верхней границы адреса кеширования"]
pub mod climit { # [doc = "Register `CLIMIT` reader"]
pub type R = crate :: R < ClimitSpec > ; # [doc = "Register `CLIMIT` writer"]
pub type W = crate :: W < ClimitSpec > ; # [doc = "Field `CLIMIT` reader - Верхний предел кэшируемой памяти"]
pub type ClimitR = crate :: FieldReader < u32 > ; # [doc = "Field `CLIMIT` writer - Верхний предел кэшируемой памяти"]
pub type ClimitW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Верхний предел кэшируемой памяти"]
# [inline (always)]
pub fn climit (& self) -> ClimitR { ClimitR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Верхний предел кэшируемой памяти"]
# [inline (always)]
pub fn climit (& mut self) -> ClimitW < ClimitSpec > { ClimitW :: new (self , 0) } } # [doc = "SPIFI регистр верхней границы адреса кеширования\n\nYou can [`read`](crate::Reg::read) this register and get [`climit::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`climit::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClimitSpec ; impl crate :: RegisterSpec for ClimitSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`climit::R`](R) reader structure"]
impl crate :: Readable for ClimitSpec { } # [doc = "`write(|w| ..)` method takes [`climit::W`](W) writer structure"]
impl crate :: Writable for ClimitSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLIMIT to value 0"]
impl crate :: Resettable for ClimitSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DATA (rw) register accessor: SPIFI регистр данных. Если выходной буфер чтения пуст или входной буфер записи полон, то при отправке запроса по шине AHB будет вызвано исключение (код 5 “Load access fault”).\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@data`]
module"]
# [doc (alias = "DATA")]
pub type Data = crate :: Reg < data :: DataSpec > ; # [doc = "SPIFI регистр данных. Если выходной буфер чтения пуст или входной буфер записи полон, то при отправке запроса по шине AHB будет вызвано исключение (код 5 “Load access fault”)."]
pub mod data { # [doc = "Register `DATA` reader"]
pub type R = crate :: R < DataSpec > ; # [doc = "Register `DATA` writer"]
pub type W = crate :: W < DataSpec > ; # [doc = "Field `DATA8` reader - Входные или выходные данные"]
pub type Data8R = crate :: FieldReader ; # [doc = "Field `DATA8` writer - Входные или выходные данные"]
pub type Data8W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `DATA16` reader - Входные или выходные данные"]
pub type Data16R = crate :: FieldReader < u16 > ; # [doc = "Field `DATA16` writer - Входные или выходные данные"]
pub type Data16W < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; # [doc = "Field `DATA32` reader - Входные или выходные данные"]
pub type Data32R = crate :: FieldReader < u32 > ; # [doc = "Field `DATA32` writer - Входные или выходные данные"]
pub type Data32W < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:7 - Входные или выходные данные"]
# [inline (always)]
pub fn data8 (& self) -> Data8R { Data8R :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 0:15 - Входные или выходные данные"]
# [inline (always)]
pub fn data16 (& self) -> Data16R { Data16R :: new ((self . bits & 0xffff) as u16) } # [doc = "Bits 0:31 - Входные или выходные данные"]
# [inline (always)]
pub fn data32 (& self) -> Data32R { Data32R :: new (self . bits) } } impl W { # [doc = "Bits 0:7 - Входные или выходные данные"]
# [inline (always)]
pub fn data8 (& mut self) -> Data8W < DataSpec > { Data8W :: new (self , 0) } # [doc = "Bits 0:15 - Входные или выходные данные"]
# [inline (always)]
pub fn data16 (& mut self) -> Data16W < DataSpec > { Data16W :: new (self , 0) } # [doc = "Bits 0:31 - Входные или выходные данные"]
# [inline (always)]
pub fn data32 (& mut self) -> Data32W < DataSpec > { Data32W :: new (self , 0) } } # [doc = "SPIFI регистр данных. Если выходной буфер чтения пуст или входной буфер записи полон, то при отправке запроса по шине AHB будет вызвано исключение (код 5 “Load access fault”).\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DataSpec ; impl crate :: RegisterSpec for DataSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`data::R`](R) reader structure"]
impl crate :: Readable for DataSpec { } # [doc = "`write(|w| ..)` method takes [`data::W`](W) writer structure"]
impl crate :: Writable for DataSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MCMD (rw) register accessor: SPIFI регистр команд памяти\n\nYou can [`read`](crate::Reg::read) this register and get [`mcmd::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcmd::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mcmd`]
module"]
# [doc (alias = "MCMD")]
pub type Mcmd = crate :: Reg < mcmd :: McmdSpec > ; # [doc = "SPIFI регистр команд памяти"]
pub mod mcmd { # [doc = "Register `MCMD` reader"]
pub type R = crate :: R < McmdSpec > ; # [doc = "Register `MCMD` writer"]
pub type W = crate :: W < McmdSpec > ; # [doc = "Бит должен быть установлен в «0»\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Poll { # [doc = "0: Режим поллинга выключен"]
Disable = 0 , } impl From < Poll > for bool { # [inline (always)]
fn from (variant : Poll) -> Self { variant as u8 != 0 } } # [doc = "Field `POLL` reader - Бит должен быть установлен в «0»"]
pub type PollR = crate :: BitReader < Poll > ; impl PollR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Poll > { match self . bits { false => Some (Poll :: Disable) , _ => None , } } # [doc = "Режим поллинга выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Poll :: Disable } } # [doc = "Field `POLL` writer - Бит должен быть установлен в «0»"]
pub type PollW < 'a , REG > = crate :: BitWriter < 'a , REG , Poll > ; impl < 'a , REG > PollW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Режим поллинга выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Poll :: Disable) } } # [doc = "Бит должен быть установлен в «0»\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dout { # [doc = "0: Чтение из флэш"]
Read = 0 , } impl From < Dout > for bool { # [inline (always)]
fn from (variant : Dout) -> Self { variant as u8 != 0 } } # [doc = "Field `DOUT` reader - Бит должен быть установлен в «0»"]
pub type DoutR = crate :: BitReader < Dout > ; impl DoutR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Dout > { match self . bits { false => Some (Dout :: Read) , _ => None , } } # [doc = "Чтение из флэш"]
# [inline (always)]
pub fn is_read (& self) -> bool { * self == Dout :: Read } } # [doc = "Field `DOUT` writer - Бит должен быть установлен в «0»"]
pub type DoutW < 'a , REG > = crate :: BitWriter < 'a , REG , Dout > ; impl < 'a , REG > DoutW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Чтение из флэш"]
# [inline (always)]
pub fn read (self) -> & 'a mut crate :: W < REG > { self . variant (Dout :: Read) } } # [doc = "Field `INTLEN` reader - Кол-во байт промежуточных данных (они хранятся в регистре IDATA). Если кол-во байт больше, чем может хранить регистр IDATA, остаток заполняется нулевыми значениями"]
pub type IntlenR = crate :: FieldReader ; # [doc = "Field `INTLEN` writer - Кол-во байт промежуточных данных (они хранятся в регистре IDATA). Если кол-во байт больше, чем может хранить регистр IDATA, остаток заполняется нулевыми значениями"]
pub type IntlenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Формат вывода полей команды\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Fieldform { # [doc = "0: Все поля выводятся в последовательном режиме"]
AllSerial = 0 , # [doc = "1: Данные выводятся в четырех или двух битовом режиме, а остальные поля в последовательном режиме"]
DataParallel = 1 , # [doc = "2: Код операции выводится в последовательном режиме, а остальные в четырех или двух битовом"]
OpcodeSerial = 2 , # [doc = "3: Все поля в четырех или двух битовом режиме"]
AllParallel = 3 , } impl From < Fieldform > for u8 { # [inline (always)]
fn from (variant : Fieldform) -> Self { variant as _ } } impl crate :: FieldSpec for Fieldform { type Ux = u8 ; } impl crate :: IsEnum for Fieldform { } # [doc = "Field `FIELDFORM` reader - Формат вывода полей команды"]
pub type FieldformR = crate :: FieldReader < Fieldform > ; impl FieldformR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Fieldform { match self . bits { 0 => Fieldform :: AllSerial , 1 => Fieldform :: DataParallel , 2 => Fieldform :: OpcodeSerial , 3 => Fieldform :: AllParallel , _ => unreachable ! () , } } # [doc = "Все поля выводятся в последовательном режиме"]
# [inline (always)]
pub fn is_all_serial (& self) -> bool { * self == Fieldform :: AllSerial } # [doc = "Данные выводятся в четырех или двух битовом режиме, а остальные поля в последовательном режиме"]
# [inline (always)]
pub fn is_data_parallel (& self) -> bool { * self == Fieldform :: DataParallel } # [doc = "Код операции выводится в последовательном режиме, а остальные в четырех или двух битовом"]
# [inline (always)]
pub fn is_opcode_serial (& self) -> bool { * self == Fieldform :: OpcodeSerial } # [doc = "Все поля в четырех или двух битовом режиме"]
# [inline (always)]
pub fn is_all_parallel (& self) -> bool { * self == Fieldform :: AllParallel } } # [doc = "Field `FIELDFORM` writer - Формат вывода полей команды"]
pub type FieldformW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Fieldform , crate :: Safe > ; impl < 'a , REG > FieldformW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Все поля выводятся в последовательном режиме"]
# [inline (always)]
pub fn all_serial (self) -> & 'a mut crate :: W < REG > { self . variant (Fieldform :: AllSerial) } # [doc = "Данные выводятся в четырех или двух битовом режиме, а остальные поля в последовательном режиме"]
# [inline (always)]
pub fn data_parallel (self) -> & 'a mut crate :: W < REG > { self . variant (Fieldform :: DataParallel) } # [doc = "Код операции выводится в последовательном режиме, а остальные в четырех или двух битовом"]
# [inline (always)]
pub fn opcode_serial (self) -> & 'a mut crate :: W < REG > { self . variant (Fieldform :: OpcodeSerial) } # [doc = "Все поля в четырех или двух битовом режиме"]
# [inline (always)]
pub fn all_parallel (self) -> & 'a mut crate :: W < REG > { self . variant (Fieldform :: AllParallel) } } # [doc = "Бит управления полями кода операции и адреса команды\n\nValue on reset: 4"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Frameform { # [doc = "1: Выдается только код операции, адреса нет"]
OpcodeNoaddr = 1 , # [doc = "2: Код операции и младший байт адреса"]
Opcode1addr = 2 , # [doc = "3: Код операции и два младших байта адреса"]
Opcode2addr = 3 , # [doc = "4: Код операции и три младших байта адреса"]
Opcode3addr = 4 , # [doc = "5: Код операции и 4 байта адреса"]
Opcode4addr = 5 , # [doc = "6: Нет кода операции, три младших байта адреса"]
Noopcode3addr = 6 , # [doc = "7: Нет кода операции, 4 байта адреса"]
Noopcode4addr = 7 , } impl From < Frameform > for u8 { # [inline (always)]
fn from (variant : Frameform) -> Self { variant as _ } } impl crate :: FieldSpec for Frameform { type Ux = u8 ; } impl crate :: IsEnum for Frameform { } # [doc = "Field `FRAMEFORM` reader - Бит управления полями кода операции и адреса команды"]
pub type FrameformR = crate :: FieldReader < Frameform > ; impl FrameformR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Frameform > { match self . bits { 1 => Some (Frameform :: OpcodeNoaddr) , 2 => Some (Frameform :: Opcode1addr) , 3 => Some (Frameform :: Opcode2addr) , 4 => Some (Frameform :: Opcode3addr) , 5 => Some (Frameform :: Opcode4addr) , 6 => Some (Frameform :: Noopcode3addr) , 7 => Some (Frameform :: Noopcode4addr) , _ => None , } } # [doc = "Выдается только код операции, адреса нет"]
# [inline (always)]
pub fn is_opcode_noaddr (& self) -> bool { * self == Frameform :: OpcodeNoaddr } # [doc = "Код операции и младший байт адреса"]
# [inline (always)]
pub fn is_opcode_1addr (& self) -> bool { * self == Frameform :: Opcode1addr } # [doc = "Код операции и два младших байта адреса"]
# [inline (always)]
pub fn is_opcode_2addr (& self) -> bool { * self == Frameform :: Opcode2addr } # [doc = "Код операции и три младших байта адреса"]
# [inline (always)]
pub fn is_opcode_3addr (& self) -> bool { * self == Frameform :: Opcode3addr } # [doc = "Код операции и 4 байта адреса"]
# [inline (always)]
pub fn is_opcode_4addr (& self) -> bool { * self == Frameform :: Opcode4addr } # [doc = "Нет кода операции, три младших байта адреса"]
# [inline (always)]
pub fn is_noopcode_3addr (& self) -> bool { * self == Frameform :: Noopcode3addr } # [doc = "Нет кода операции, 4 байта адреса"]
# [inline (always)]
pub fn is_noopcode_4addr (& self) -> bool { * self == Frameform :: Noopcode4addr } } # [doc = "Field `FRAMEFORM` writer - Бит управления полями кода операции и адреса команды"]
pub type FrameformW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Frameform > ; impl < 'a , REG > FrameformW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Выдается только код операции, адреса нет"]
# [inline (always)]
pub fn opcode_noaddr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: OpcodeNoaddr) } # [doc = "Код операции и младший байт адреса"]
# [inline (always)]
pub fn opcode_1addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Opcode1addr) } # [doc = "Код операции и два младших байта адреса"]
# [inline (always)]
pub fn opcode_2addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Opcode2addr) } # [doc = "Код операции и три младших байта адреса"]
# [inline (always)]
pub fn opcode_3addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Opcode3addr) } # [doc = "Код операции и 4 байта адреса"]
# [inline (always)]
pub fn opcode_4addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Opcode4addr) } # [doc = "Нет кода операции, три младших байта адреса"]
# [inline (always)]
pub fn noopcode_3addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Noopcode3addr) } # [doc = "Нет кода операции, 4 байта адреса"]
# [inline (always)]
pub fn noopcode_4addr (self) -> & 'a mut crate :: W < REG > { self . variant (Frameform :: Noopcode4addr) } } # [doc = "Field `OPCODE` reader - Код операции (не используется для некоторых значений поля FRAMEFORM)"]
pub type OpcodeR = crate :: FieldReader ; # [doc = "Field `OPCODE` writer - Код операции (не используется для некоторых значений поля FRAMEFORM)"]
pub type OpcodeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bit 14 - Бит должен быть установлен в «0»"]
# [inline (always)]
pub fn poll (& self) -> PollR { PollR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Бит должен быть установлен в «0»"]
# [inline (always)]
pub fn dout (& self) -> DoutR { DoutR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:18 - Кол-во байт промежуточных данных (они хранятся в регистре IDATA). Если кол-во байт больше, чем может хранить регистр IDATA, остаток заполняется нулевыми значениями"]
# [inline (always)]
pub fn intlen (& self) -> IntlenR { IntlenR :: new (((self . bits >> 16) & 7) as u8) } # [doc = "Bits 19:20 - Формат вывода полей команды"]
# [inline (always)]
pub fn fieldform (& self) -> FieldformR { FieldformR :: new (((self . bits >> 19) & 3) as u8) } # [doc = "Bits 21:23 - Бит управления полями кода операции и адреса команды"]
# [inline (always)]
pub fn frameform (& self) -> FrameformR { FrameformR :: new (((self . bits >> 21) & 7) as u8) } # [doc = "Bits 24:31 - Код операции (не используется для некоторых значений поля FRAMEFORM)"]
# [inline (always)]
pub fn opcode (& self) -> OpcodeR { OpcodeR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W { # [doc = "Bit 14 - Бит должен быть установлен в «0»"]
# [inline (always)]
pub fn poll (& mut self) -> PollW < McmdSpec > { PollW :: new (self , 14) } # [doc = "Bit 15 - Бит должен быть установлен в «0»"]
# [inline (always)]
pub fn dout (& mut self) -> DoutW < McmdSpec > { DoutW :: new (self , 15) } # [doc = "Bits 16:18 - Кол-во байт промежуточных данных (они хранятся в регистре IDATA). Если кол-во байт больше, чем может хранить регистр IDATA, остаток заполняется нулевыми значениями"]
# [inline (always)]
pub fn intlen (& mut self) -> IntlenW < McmdSpec > { IntlenW :: new (self , 16) } # [doc = "Bits 19:20 - Формат вывода полей команды"]
# [inline (always)]
pub fn fieldform (& mut self) -> FieldformW < McmdSpec > { FieldformW :: new (self , 19) } # [doc = "Bits 21:23 - Бит управления полями кода операции и адреса команды"]
# [inline (always)]
pub fn frameform (& mut self) -> FrameformW < McmdSpec > { FrameformW :: new (self , 21) } # [doc = "Bits 24:31 - Код операции (не используется для некоторых значений поля FRAMEFORM)"]
# [inline (always)]
pub fn opcode (& mut self) -> OpcodeW < McmdSpec > { OpcodeW :: new (self , 24) } } # [doc = "SPIFI регистр команд памяти\n\nYou can [`read`](crate::Reg::read) this register and get [`mcmd::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mcmd::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct McmdSpec ; impl crate :: RegisterSpec for McmdSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mcmd::R`](R) reader structure"]
impl crate :: Readable for McmdSpec { } # [doc = "`write(|w| ..)` method takes [`mcmd::W`](W) writer structure"]
impl crate :: Writable for McmdSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MCMD to value 0x0380_0000"]
impl crate :: Resettable for McmdSpec { const RESET_VALUE : u32 = 0x0380_0000 ; } } # [doc = "STAT (rw) register accessor: SPIFI регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`stat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@stat`]
module"]
# [doc (alias = "STAT")]
pub type Stat = crate :: Reg < stat :: StatSpec > ; # [doc = "SPIFI регистр статуса"]
pub mod stat { # [doc = "Register `STAT` reader"]
pub type R = crate :: R < StatSpec > ; # [doc = "Register `STAT` writer"]
pub type W = crate :: W < StatSpec > ; # [doc = "Бит устанавливается в «1», если программное обеспечение успешно записало регистр команд памяти. Сброс бита осуществляется аппаратным сбросом или установкой в «1» бита RESET\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Mcinit { # [doc = "0: Программное обеспечение не записало регистр команд памяти"]
Idle = 0 , # [doc = "1: Программное обеспечение успешно записало регистр команд памяти"]
Success = 1 , } impl From < Mcinit > for bool { # [inline (always)]
fn from (variant : Mcinit) -> Self { variant as u8 != 0 } } # [doc = "Field `MCINIT` reader - Бит устанавливается в «1», если программное обеспечение успешно записало регистр команд памяти. Сброс бита осуществляется аппаратным сбросом или установкой в «1» бита RESET"]
pub type McinitR = crate :: BitReader < Mcinit > ; impl McinitR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Mcinit { match self . bits { false => Mcinit :: Idle , true => Mcinit :: Success , } } # [doc = "Программное обеспечение не записало регистр команд памяти"]
# [inline (always)]
pub fn is_idle (& self) -> bool { * self == Mcinit :: Idle } # [doc = "Программное обеспечение успешно записало регистр команд памяти"]
# [inline (always)]
pub fn is_success (& self) -> bool { * self == Mcinit :: Success } } # [doc = "Бит устанавливается в «1», если программное обеспечение успешно записало регистр команд. Сброс этого бита осуществляется теми же сигналами, что и бит MCINIT. Также сброс бита CMD происходит при завершении выполнения команды, когда деактивируется сигнал SPIFI_CS\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cmd { # [doc = "0: Программное обеспечение не записало регистр команд"]
Idle = 0 , # [doc = "1: Программное обеспечение успешно записало регистр команд"]
Success = 1 , } impl From < Cmd > for bool { # [inline (always)]
fn from (variant : Cmd) -> Self { variant as u8 != 0 } } # [doc = "Field `CMD` reader - Бит устанавливается в «1», если программное обеспечение успешно записало регистр команд. Сброс этого бита осуществляется теми же сигналами, что и бит MCINIT. Также сброс бита CMD происходит при завершении выполнения команды, когда деактивируется сигнал SPIFI_CS"]
pub type CmdR = crate :: BitReader < Cmd > ; impl CmdR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cmd { match self . bits { false => Cmd :: Idle , true => Cmd :: Success , } } # [doc = "Программное обеспечение не записало регистр команд"]
# [inline (always)]
pub fn is_idle (& self) -> bool { * self == Cmd :: Idle } # [doc = "Программное обеспечение успешно записало регистр команд"]
# [inline (always)]
pub fn is_success (& self) -> bool { * self == Cmd :: Success } } # [doc = "Field `CMD` writer - Бит устанавливается в «1», если программное обеспечение успешно записало регистр команд. Сброс этого бита осуществляется теми же сигналами, что и бит MCINIT. Также сброс бита CMD происходит при завершении выполнения команды, когда деактивируется сигнал SPIFI_CS"]
pub type CmdW < 'a , REG > = crate :: BitWriter < 'a , REG , Cmd > ; impl < 'a , REG > CmdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Программное обеспечение не записало регистр команд"]
# [inline (always)]
pub fn idle (self) -> & 'a mut crate :: W < REG > { self . variant (Cmd :: Idle) } # [doc = "Программное обеспечение успешно записало регистр команд"]
# [inline (always)]
pub fn success (self) -> & 'a mut crate :: W < REG > { self . variant (Cmd :: Success) } } # [doc = "Бит предназначен для того, чтобы прервать текущую команду периферийного режима или режима памяти. Бит сбрасывается, когда контроллер готов к выполнению новой команды\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Reset { # [doc = "0: Контроллер готов к выполнению новой команды"]
Ready = 0 , # [doc = "1: Прервать текущую команду периферийного режима или режима памяти"]
Reset = 1 , } impl From < Reset > for bool { # [inline (always)]
fn from (variant : Reset) -> Self { variant as u8 != 0 } } # [doc = "Field `RESET` reader - Бит предназначен для того, чтобы прервать текущую команду периферийного режима или режима памяти. Бит сбрасывается, когда контроллер готов к выполнению новой команды"]
pub type ResetR = crate :: BitReader < Reset > ; impl ResetR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Reset { match self . bits { false => Reset :: Ready , true => Reset :: Reset , } } # [doc = "Контроллер готов к выполнению новой команды"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Reset :: Ready } # [doc = "Прервать текущую команду периферийного режима или режима памяти"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == Reset :: Reset } } # [doc = "Field `RESET` writer - Бит предназначен для того, чтобы прервать текущую команду периферийного режима или режима памяти. Бит сбрасывается, когда контроллер готов к выполнению новой команды"]
pub type ResetW < 'a , REG > = crate :: BitWriter < 'a , REG , Reset > ; impl < 'a , REG > ResetW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Контроллер готов к выполнению новой команды"]
# [inline (always)]
pub fn ready (self) -> & 'a mut crate :: W < REG > { self . variant (Reset :: Ready) } # [doc = "Прервать текущую команду периферийного режима или режима памяти"]
# [inline (always)]
pub fn reset (self) -> & 'a mut crate :: W < REG > { self . variant (Reset :: Reset) } } # [doc = "Запись «1» в бит сбрасывает запрос на прерывание от контроллера SPIFI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Intrq { # [doc = "1: Сбрость запрос на прерывание от контроллера SPIFI"]
ClearInterrupt = 1 , } impl From < Intrq > for bool { # [inline (always)]
fn from (variant : Intrq) -> Self { variant as u8 != 0 } } # [doc = "Field `INTRQ` reader - Запись «1» в бит сбрасывает запрос на прерывание от контроллера SPIFI"]
pub type IntrqR = crate :: BitReader < Intrq > ; impl IntrqR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Intrq > { match self . bits { true => Some (Intrq :: ClearInterrupt) , _ => None , } } # [doc = "Сбрость запрос на прерывание от контроллера SPIFI"]
# [inline (always)]
pub fn is_clear_interrupt (& self) -> bool { * self == Intrq :: ClearInterrupt } } # [doc = "Field `INTRQ` writer - Запись «1» в бит сбрасывает запрос на прерывание от контроллера SPIFI"]
pub type IntrqW < 'a , REG > = crate :: BitWriter < 'a , REG , Intrq > ; impl < 'a , REG > IntrqW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сбрость запрос на прерывание от контроллера SPIFI"]
# [inline (always)]
pub fn clear_interrupt (self) -> & 'a mut crate :: W < REG > { self . variant (Intrq :: ClearInterrupt) } } # [doc = "Field `VERSION` reader - Версия контроллера SPIFI (поле доступно только для чтения)"]
pub type VersionR = crate :: FieldReader ; # [doc = "Field `VERSION` writer - Версия контроллера SPIFI (поле доступно только для чтения)"]
pub type VersionW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bit 0 - Бит устанавливается в «1», если программное обеспечение успешно записало регистр команд памяти. Сброс бита осуществляется аппаратным сбросом или установкой в «1» бита RESET"]
# [inline (always)]
pub fn mcinit (& self) -> McinitR { McinitR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Бит устанавливается в «1», если программное обеспечение успешно записало регистр команд. Сброс этого бита осуществляется теми же сигналами, что и бит MCINIT. Также сброс бита CMD происходит при завершении выполнения команды, когда деактивируется сигнал SPIFI_CS"]
# [inline (always)]
pub fn cmd (& self) -> CmdR { CmdR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 4 - Бит предназначен для того, чтобы прервать текущую команду периферийного режима или режима памяти. Бит сбрасывается, когда контроллер готов к выполнению новой команды"]
# [inline (always)]
pub fn reset (& self) -> ResetR { ResetR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Запись «1» в бит сбрасывает запрос на прерывание от контроллера SPIFI"]
# [inline (always)]
pub fn intrq (& self) -> IntrqR { IntrqR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bits 24:31 - Версия контроллера SPIFI (поле доступно только для чтения)"]
# [inline (always)]
pub fn version (& self) -> VersionR { VersionR :: new (((self . bits >> 24) & 0xff) as u8) } } impl W { # [doc = "Bit 1 - Бит устанавливается в «1», если программное обеспечение успешно записало регистр команд. Сброс этого бита осуществляется теми же сигналами, что и бит MCINIT. Также сброс бита CMD происходит при завершении выполнения команды, когда деактивируется сигнал SPIFI_CS"]
# [inline (always)]
pub fn cmd (& mut self) -> CmdW < StatSpec > { CmdW :: new (self , 1) } # [doc = "Bit 4 - Бит предназначен для того, чтобы прервать текущую команду периферийного режима или режима памяти. Бит сбрасывается, когда контроллер готов к выполнению новой команды"]
# [inline (always)]
pub fn reset (& mut self) -> ResetW < StatSpec > { ResetW :: new (self , 4) } # [doc = "Bit 5 - Запись «1» в бит сбрасывает запрос на прерывание от контроллера SPIFI"]
# [inline (always)]
pub fn intrq (& mut self) -> IntrqW < StatSpec > { IntrqW :: new (self , 5) } # [doc = "Bits 24:31 - Версия контроллера SPIFI (поле доступно только для чтения)"]
# [inline (always)]
pub fn version (& mut self) -> VersionW < StatSpec > { VersionW :: new (self , 24) } } # [doc = "SPIFI регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`stat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`stat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StatSpec ; impl crate :: RegisterSpec for StatSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`stat::R`](R) reader structure"]
impl crate :: Readable for StatSpec { } # [doc = "`write(|w| ..)` method takes [`stat::W`](W) writer structure"]
impl crate :: Writable for StatSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets STAT to value 0x0200_0001"]
impl crate :: Resettable for StatSpec { const RESET_VALUE : u32 = 0x0200_0001 ; } } } # [doc = "Контроллер EEPROM (8Кб)"]
pub struct EepromRegs { _marker : PhantomData < * const () > } unsafe impl Send for EepromRegs { } impl EepromRegs { # [doc = r"Pointer to the register block"]
pub const PTR : * const eeprom_regs :: RegisterBlock = 0x0007_0400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const eeprom_regs :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for EepromRegs { type Target = eeprom_regs :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for EepromRegs { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("EepromRegs") . finish () } } # [doc = "Контроллер EEPROM (8Кб)"]
pub mod eeprom_regs { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { eedat : Eedat , eea : Eea , eecon : Eecon , eesta : Eesta , eerb : Eerb , eeadj : Eeadj , ncycrl : Ncycrl , ncycep1 : Ncycep1 , ncycep2 : Ncycep2 , } impl RegisterBlock { # [doc = "0x00 - Регистр чтения/записи данных"]
# [inline (always)]
pub const fn eedat (& self) -> & Eedat { & self . eedat } # [doc = "0x04 - Регистр адреса страницы"]
# [inline (always)]
pub const fn eea (& self) -> & Eea { & self . eea } # [doc = "0x08 - Регистр управления"]
# [inline (always)]
pub const fn eecon (& self) -> & Eecon { & self . eecon } # [doc = "0x0c - Регистр статуса"]
# [inline (always)]
pub const fn eesta (& self) -> & Eesta { & self . eesta } # [doc = "0x10 - Регистр бит коррекции прочитанного слова"]
# [inline (always)]
pub const fn eerb (& self) -> & Eerb { & self . eerb } # [doc = "0x14 - Регистр настроек"]
# [inline (always)]
pub const fn eeadj (& self) -> & Eeadj { & self . eeadj } # [doc = "0x18 - Регистр подстройки длительности процедур чтения и заполнения буфера записи"]
# [inline (always)]
pub const fn ncycrl (& self) -> & Ncycrl { & self . ncycrl } # [doc = "0x1c - Регистр 1 подстройки длительности процедур стирания и программирования"]
# [inline (always)]
pub const fn ncycep1 (& self) -> & Ncycep1 { & self . ncycep1 } # [doc = "0x20 - Регистр 2 подстройки длительности процедур стирания и программирования"]
# [inline (always)]
pub const fn ncycep2 (& self) -> & Ncycep2 { & self . ncycep2 } } # [doc = "EEDAT (rw) register accessor: Регистр чтения/записи данных\n\nYou can [`read`](crate::Reg::read) this register and get [`eedat::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eedat::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eedat`]
module"]
# [doc (alias = "EEDAT")]
pub type Eedat = crate :: Reg < eedat :: EedatSpec > ; # [doc = "Регистр чтения/записи данных"]
pub mod eedat { # [doc = "Register `EEDAT` reader"]
pub type R = crate :: R < EedatSpec > ; # [doc = "Register `EEDAT` writer"]
pub type W = crate :: W < EedatSpec > ; # [doc = "Field `DATA` reader - В процессе чтения/записи данного регистра производится автоматическое инкрементирование адреса (EEA)."]
pub type DataR = crate :: FieldReader < u32 > ; # [doc = "Field `DATA` writer - В процессе чтения/записи данного регистра производится автоматическое инкрементирование адреса (EEA)."]
pub type DataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - В процессе чтения/записи данного регистра производится автоматическое инкрементирование адреса (EEA)."]
# [inline (always)]
pub fn data (& self) -> DataR { DataR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - В процессе чтения/записи данного регистра производится автоматическое инкрементирование адреса (EEA)."]
# [inline (always)]
pub fn data (& mut self) -> DataW < EedatSpec > { DataW :: new (self , 0) } } # [doc = "Регистр чтения/записи данных\n\nYou can [`read`](crate::Reg::read) this register and get [`eedat::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eedat::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EedatSpec ; impl crate :: RegisterSpec for EedatSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`eedat::R`](R) reader structure"]
impl crate :: Readable for EedatSpec { } # [doc = "`write(|w| ..)` method takes [`eedat::W`](W) writer structure"]
impl crate :: Writable for EedatSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EEDAT to value 0"]
impl crate :: Resettable for EedatSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EEA (w) register accessor: Регистр адреса страницы\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eea::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eea`]
module"]
# [doc (alias = "EEA")]
pub type Eea = crate :: Reg < eea :: EeaSpec > ; # [doc = "Регистр адреса страницы"]
pub mod eea { # [doc = "Register `EEA` writer"]
pub type W = crate :: W < EeaSpec > ; # [doc = "Field `ADDR` writer - Адрес слова для выполнения стирания/програмирования /чтения. Если необходимо выполнить стирание или программирование, данный адрес должен использоваться в процедуре заполнения буфера записи"]
pub type AddrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ; impl W { # [doc = "Bits 2:12 - Адрес слова для выполнения стирания/програмирования /чтения. Если необходимо выполнить стирание или программирование, данный адрес должен использоваться в процедуре заполнения буфера записи"]
# [inline (always)]
pub fn addr (& mut self) -> AddrW < EeaSpec > { AddrW :: new (self , 2) } } # [doc = "Регистр адреса страницы\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eea::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EeaSpec ; impl crate :: RegisterSpec for EeaSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`eea::W`](W) writer structure"]
impl crate :: Writable for EeaSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EEA to value 0"]
impl crate :: Resettable for EeaSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EECON (w) register accessor: Регистр управления\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eecon::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eecon`]
module"]
# [doc (alias = "EECON")]
pub type Eecon = crate :: Reg < eecon :: EeconSpec > ; # [doc = "Регистр управления"]
pub mod eecon { # [doc = "Register `EECON` writer"]
pub type W = crate :: W < EeconSpec > ; # [doc = "Field `EX` writer - Запуск процедуры. Запись 1 в данный бит инициирует выпол-нение процедуры, процедура определяется битами OP"]
pub type ExW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Выбор процедуры\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Op { # [doc = "0: Чтение страницы"]
ReadPage = 0 , # [doc = "1: Стирание"]
Erase = 1 , # [doc = "2: Программирование"]
Programming = 2 , } impl From < Op > for u8 { # [inline (always)]
fn from (variant : Op) -> Self { variant as _ } } impl crate :: FieldSpec for Op { type Ux = u8 ; } impl crate :: IsEnum for Op { } # [doc = "Field `OP` writer - Выбор процедуры"]
pub type OpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Op > ; impl < 'a , REG > OpW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Чтение страницы"]
# [inline (always)]
pub fn read_page (self) -> & 'a mut crate :: W < REG > { self . variant (Op :: ReadPage) } # [doc = "Стирание"]
# [inline (always)]
pub fn erase (self) -> & 'a mut crate :: W < REG > { self . variant (Op :: Erase) } # [doc = "Программирование"]
# [inline (always)]
pub fn programming (self) -> & 'a mut crate :: W < REG > { self . variant (Op :: Programming) } } # [doc = "Поведение операции стирания/програмирования. Данные биты должны быть установлены перед операцией заполнения буфера записи перед операциями стирания и программирования\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Wrben { # [doc = "0: обычное стирание/програмирование одной страницы;"]
OnePage = 0 , # [doc = "1: стирание/програмирование всех четных страниц;"]
EvenPages = 1 , # [doc = "2: стирание/програмирование всех нечетных страниц;"]
OddPages = 2 , # [doc = "3: стирание/програмирование всех страниц."]
AllPages = 3 , } impl From < Wrben > for u8 { # [inline (always)]
fn from (variant : Wrben) -> Self { variant as _ } } impl crate :: FieldSpec for Wrben { type Ux = u8 ; } impl crate :: IsEnum for Wrben { } # [doc = "Field `WRBEN` writer - Поведение операции стирания/програмирования. Данные биты должны быть установлены перед операцией заполнения буфера записи перед операциями стирания и программирования"]
pub type WrbenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Wrben , crate :: Safe > ; impl < 'a , REG > WrbenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "обычное стирание/програмирование одной страницы;"]
# [inline (always)]
pub fn one_page (self) -> & 'a mut crate :: W < REG > { self . variant (Wrben :: OnePage) } # [doc = "стирание/програмирование всех четных страниц;"]
# [inline (always)]
pub fn even_pages (self) -> & 'a mut crate :: W < REG > { self . variant (Wrben :: EvenPages) } # [doc = "стирание/програмирование всех нечетных страниц;"]
# [inline (always)]
pub fn odd_pages (self) -> & 'a mut crate :: W < REG > { self . variant (Wrben :: OddPages) } # [doc = "стирание/програмирование всех страниц."]
# [inline (always)]
pub fn all_pages (self) -> & 'a mut crate :: W < REG > { self . variant (Wrben :: AllPages) } } # [doc = "Отключение вставки тактов ожидания в процессе обмена по APB при заполнении буфера записи (во время записи в EEDAT) и при записи адреса для процедуры чтения данных (EEA). Если такты ожидания отключены (APBNWS=1), то требуется производить опрос флага EESTA.BSY после этих операций до тех пор, пока EESTA.BSY не станет равным 0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Apbnws { # [doc = "0: Такты ожидания включены"]
Disable = 0 , # [doc = "1: Такты ожидания отключены"]
Enable = 1 , } impl From < Apbnws > for bool { # [inline (always)]
fn from (variant : Apbnws) -> Self { variant as u8 != 0 } } # [doc = "Field `APBNWS` writer - Отключение вставки тактов ожидания в процессе обмена по APB при заполнении буфера записи (во время записи в EEDAT) и при записи адреса для процедуры чтения данных (EEA). Если такты ожидания отключены (APBNWS=1), то требуется производить опрос флага EESTA.BSY после этих операций до тех пор, пока EESTA.BSY не станет равным 0"]
pub type ApbnwsW < 'a , REG > = crate :: BitWriter < 'a , REG , Apbnws > ; impl < 'a , REG > ApbnwsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Такты ожидания включены"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Apbnws :: Disable) } # [doc = "Такты ожидания отключены"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Apbnws :: Enable) } } # [doc = "Отключение схемы коррекции ошибок во время выполнения запрошенной процедуры. Отлючение производится записью «1» в этот бит. Если схема коррекции отключена, то при записи значение бит коррекции определяется шестью млад¬шими битами слова. Если схема коррекции включена, то при записи значение бит коррекции вычисляется схемой SEC32 - ENC. Если схема коррекции отключена, то при чтении не про¬изводится коррекция возможных ошибок в слове. Если схема коррекции включена, то при чтении данные корректируются схемой DEC32_ENC\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Disecc { # [doc = "0: Включение схемы коррекции ошибок во время выполнения запрошенной процедуры"]
Disable = 0 , # [doc = "1: Отключение схемы коррекции ошибок во время выполнения запрошенной процедуры"]
Enable = 1 , } impl From < Disecc > for bool { # [inline (always)]
fn from (variant : Disecc) -> Self { variant as u8 != 0 } } # [doc = "Field `DISECC` writer - Отключение схемы коррекции ошибок во время выполнения запрошенной процедуры. Отлючение производится записью «1» в этот бит. Если схема коррекции отключена, то при записи значение бит коррекции определяется шестью млад¬шими битами слова. Если схема коррекции включена, то при записи значение бит коррекции вычисляется схемой SEC32 - ENC. Если схема коррекции отключена, то при чтении не про¬изводится коррекция возможных ошибок в слове. Если схема коррекции включена, то при чтении данные корректируются схемой DEC32_ENC"]
pub type DiseccW < 'a , REG > = crate :: BitWriter < 'a , REG , Disecc > ; impl < 'a , REG > DiseccW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Включение схемы коррекции ошибок во время выполнения запрошенной процедуры"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Disecc :: Disable) } # [doc = "Отключение схемы коррекции ошибок во время выполнения запрошенной процедуры"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Disecc :: Enable) } } # [doc = "Field `BWE` writer - Разрешение записи в буфер. Данный бит следует устанавливать в «1» перед операцией заполнения буфера записи перед операциями стирания и программирования. После операций стирания и программирования данный бит автоматически очищается (то есть для последующей записи в буфер следует повторно выполнить запись «1» в этот бит)"]
pub type BweW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Разрешение запроса прерывания при поднятии флага SERR\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum IeseraR { # [doc = "0: Запрос не поступает"]
Disable = 0 , # [doc = "1: Запрос поступает"]
Enable = 1 , } impl From < IeseraR > for bool { # [inline (always)]
fn from (variant : IeseraR) -> Self { variant as u8 != 0 } } # [doc = "Field `IESERaR` writer - Разрешение запроса прерывания при поднятии флага SERR"]
pub type IeseraRW < 'a , REG > = crate :: BitWriter < 'a , REG , IeseraR > ; impl < 'a , REG > IeseraRW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Запрос не поступает"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (IeseraR :: Disable) } # [doc = "Запрос поступает"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (IeseraR :: Enable) } } impl W { # [doc = "Bit 0 - Запуск процедуры. Запись 1 в данный бит инициирует выпол-нение процедуры, процедура определяется битами OP"]
# [inline (always)]
pub fn ex (& mut self) -> ExW < EeconSpec > { ExW :: new (self , 0) } # [doc = "Bits 1:2 - Выбор процедуры"]
# [inline (always)]
pub fn op (& mut self) -> OpW < EeconSpec > { OpW :: new (self , 1) } # [doc = "Bits 3:4 - Поведение операции стирания/програмирования. Данные биты должны быть установлены перед операцией заполнения буфера записи перед операциями стирания и программирования"]
# [inline (always)]
pub fn wrben (& mut self) -> WrbenW < EeconSpec > { WrbenW :: new (self , 3) } # [doc = "Bit 5 - Отключение вставки тактов ожидания в процессе обмена по APB при заполнении буфера записи (во время записи в EEDAT) и при записи адреса для процедуры чтения данных (EEA). Если такты ожидания отключены (APBNWS=1), то требуется производить опрос флага EESTA.BSY после этих операций до тех пор, пока EESTA.BSY не станет равным 0"]
# [inline (always)]
pub fn apbnws (& mut self) -> ApbnwsW < EeconSpec > { ApbnwsW :: new (self , 5) } # [doc = "Bit 6 - Отключение схемы коррекции ошибок во время выполнения запрошенной процедуры. Отлючение производится записью «1» в этот бит. Если схема коррекции отключена, то при записи значение бит коррекции определяется шестью млад¬шими битами слова. Если схема коррекции включена, то при записи значение бит коррекции вычисляется схемой SEC32 - ENC. Если схема коррекции отключена, то при чтении не про¬изводится коррекция возможных ошибок в слове. Если схема коррекции включена, то при чтении данные корректируются схемой DEC32_ENC"]
# [inline (always)]
pub fn disecc (& mut self) -> DiseccW < EeconSpec > { DiseccW :: new (self , 6) } # [doc = "Bit 7 - Разрешение записи в буфер. Данный бит следует устанавливать в «1» перед операцией заполнения буфера записи перед операциями стирания и программирования. После операций стирания и программирования данный бит автоматически очищается (то есть для последующей записи в буфер следует повторно выполнить запись «1» в этот бит)"]
# [inline (always)]
pub fn bwe (& mut self) -> BweW < EeconSpec > { BweW :: new (self , 7) } # [doc = "Bit 8 - Разрешение запроса прерывания при поднятии флага SERR"]
# [inline (always)]
pub fn iesera_r (& mut self) -> IeseraRW < EeconSpec > { IeseraRW :: new (self , 8) } } # [doc = "Регистр управления\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eecon::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EeconSpec ; impl crate :: RegisterSpec for EeconSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`eecon::W`](W) writer structure"]
impl crate :: Writable for EeconSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EECON to value 0"]
impl crate :: Resettable for EeconSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EESTA (rw) register accessor: Регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`eesta::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eesta::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eesta`]
module"]
# [doc (alias = "EESTA")]
pub type Eesta = crate :: Reg < eesta :: EestaSpec > ; # [doc = "Регистр статуса"]
pub mod eesta { # [doc = "Register `EESTA` reader"]
pub type R = crate :: R < EestaSpec > ; # [doc = "Register `EESTA` writer"]
pub type W = crate :: W < EestaSpec > ; # [doc = "Блок занят (выполняется запрошенная операция)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Bsy { # [doc = "0: Блок готов"]
Ready = 0 , # [doc = "1: Блок занят (выполняется запрошенная операция)"]
Busy = 1 , } impl From < Bsy > for bool { # [inline (always)]
fn from (variant : Bsy) -> Self { variant as u8 != 0 } } # [doc = "Field `BSY` reader - Блок занят (выполняется запрошенная операция)"]
pub type BsyR = crate :: BitReader < Bsy > ; impl BsyR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Bsy { match self . bits { false => Bsy :: Ready , true => Bsy :: Busy , } } # [doc = "Блок готов"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Bsy :: Ready } # [doc = "Блок занят (выполняется запрошенная операция)"]
# [inline (always)]
pub fn is_busy (& self) -> bool { * self == Bsy :: Busy } } # [doc = "Field `SERR` writer - Индикатор одиночной (исправимой) ошибки. Аппаратно может быть только поднят, т.е. если после слова с ошибкой считано слово без ошибки, флаг не очистится. Может быть очищен программно путем записи 0"]
pub type SerrW < 'a , REG > = crate :: BitWriter0C < 'a , REG > ; impl R { # [doc = "Bit 0 - Блок занят (выполняется запрошенная операция)"]
# [inline (always)]
pub fn bsy (& self) -> BsyR { BsyR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 1 - Индикатор одиночной (исправимой) ошибки. Аппаратно может быть только поднят, т.е. если после слова с ошибкой считано слово без ошибки, флаг не очистится. Может быть очищен программно путем записи 0"]
# [inline (always)]
pub fn serr (& mut self) -> SerrW < EestaSpec > { SerrW :: new (self , 1) } } # [doc = "Регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`eesta::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eesta::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EestaSpec ; impl crate :: RegisterSpec for EestaSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`eesta::R`](R) reader structure"]
impl crate :: Readable for EestaSpec { } # [doc = "`write(|w| ..)` method takes [`eesta::W`](W) writer structure"]
impl crate :: Writable for EestaSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0x02 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EESTA to value 0"]
impl crate :: Resettable for EestaSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EERB (r) register accessor: Регистр бит коррекции прочитанного слова\n\nYou can [`read`](crate::Reg::read) this register and get [`eerb::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eerb`]
module"]
# [doc (alias = "EERB")]
pub type Eerb = crate :: Reg < eerb :: EerbSpec > ; # [doc = "Регистр бит коррекции прочитанного слова"]
pub mod eerb { # [doc = "Register `EERB` reader"]
pub type R = crate :: R < EerbSpec > ; # [doc = "Field `CORRECT` reader - Содержит 6 бит коррекции последнего считанного слова"]
pub type CorrectR = crate :: FieldReader ; impl R { # [doc = "Bits 0:5 - Содержит 6 бит коррекции последнего считанного слова"]
# [inline (always)]
pub fn correct (& self) -> CorrectR { CorrectR :: new ((self . bits & 0x3f) as u8) } } # [doc = "Регистр бит коррекции прочитанного слова\n\nYou can [`read`](crate::Reg::read) this register and get [`eerb::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EerbSpec ; impl crate :: RegisterSpec for EerbSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`eerb::R`](R) reader structure"]
impl crate :: Readable for EerbSpec { } # [doc = "`reset()` method sets EERB to value 0"]
impl crate :: Resettable for EerbSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EEADJ (rw) register accessor: Регистр настроек\n\nYou can [`read`](crate::Reg::read) this register and get [`eeadj::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eeadj::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@eeadj`]
module"]
# [doc (alias = "EEADJ")]
pub type Eeadj = crate :: Reg < eeadj :: EeadjSpec > ; # [doc = "Регистр настроек"]
pub mod eeadj { # [doc = "Register `EEADJ` reader"]
pub type R = crate :: R < EeadjSpec > ; # [doc = "Register `EEADJ` writer"]
pub type W = crate :: W < EeadjSpec > ; # [doc = "Field `OSCX2` reader - Увеличение частоты тактового сигнала, поступающего на устройство с зарядовой накачкой, в два раза. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type Oscx2R = crate :: BitReader ; # [doc = "Field `OSCX2` writer - Увеличение частоты тактового сигнала, поступающего на устройство с зарядовой накачкой, в два раза. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type Oscx2W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `HivCtl` reader - Подстройка уровня внутреннего сигнала HIV. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type HivCtlR = crate :: FieldReader ; # [doc = "Field `HivCtl` writer - Подстройка уровня внутреннего сигнала HIV. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type HivCtlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `PlusImix` reader - Сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type PlusImixR = crate :: BitReader ; # [doc = "Field `PlusImix` writer - Сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type PlusImixW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `VboostCtl` reader - Старший разряд - подстройка внутреннего сигнала Vboost, младший разряд - сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type VboostCtlR = crate :: FieldReader ; # [doc = "Field `VboostCtl` writer - Старший разряд - подстройка внутреннего сигнала Vboost, младший разряд - сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type VboostCtlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; # [doc = "Field `MinusImix` reader - Сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type MinusImixR = crate :: BitReader ; # [doc = "Field `MinusImix` writer - Сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type MinusImixW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `DummyCtl` reader - Подстройка момента захвата выдаваемых данных. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type DummyCtlR = crate :: FieldReader ; # [doc = "Field `DummyCtl` writer - Подстройка момента захвата выдаваемых данных. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type DummyCtlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; # [doc = "Field `VbgCtl` reader - Подстройка опорного напряжения bandgap. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type VbgCtlR = crate :: FieldReader ; # [doc = "Field `VbgCtl` writer - Подстройка опорного напряжения bandgap. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type VbgCtlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `RefCtl` reader - Подстройка тока, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type RefCtlR = crate :: FieldReader ; # [doc = "Field `RefCtl` writer - Подстройка тока, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type RefCtlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `VcgCtl` reader - Подстройка напряжения, подаваемого на управляющие затворы при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type VcgCtlR = crate :: FieldReader ; # [doc = "Field `VcgCtl` writer - Подстройка напряжения, подаваемого на управляющие затворы при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type VcgCtlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `CGSTRICT` reader - Включение режима точной подстройки напряжения, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type CgstrictR = crate :: BitReader ; # [doc = "Field `CGSTRICT` writer - Включение режима точной подстройки напряжения, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type CgstrictW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `VppCtl` reader - Подстройка времени нарастания высокого напряжения. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type VppCtlR = crate :: FieldReader ; # [doc = "Field `VppCtl` writer - Подстройка времени нарастания высокого напряжения. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type VppCtlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 > ; # [doc = "Field `StrictCtl` reader - Точная подстройка тока, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type StrictCtlR = crate :: FieldReader ; # [doc = "Field `StrictCtl` writer - Точная подстройка тока, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type StrictCtlW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `StopEe` reader - Перевод Hard IP в режим пониженного энергопотребления"]
pub type StopEeR = crate :: BitReader ; # [doc = "Field `StopEe` writer - Перевод Hard IP в режим пониженного энергопотребления"]
pub type StopEeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IddqEn` reader - Перевод Hard IP в состояние бездействия (quiescent) для Iddq тестирования. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type IddqEnR = crate :: BitReader ; # [doc = "Field `IddqEn` writer - Перевод Hard IP в состояние бездействия (quiescent) для Iddq тестирования. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
pub type IddqEnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Увеличение частоты тактового сигнала, поступающего на устройство с зарядовой накачкой, в два раза. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn oscx2 (& self) -> Oscx2R { Oscx2R :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:3 - Подстройка уровня внутреннего сигнала HIV. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn hiv_ctl (& self) -> HivCtlR { HivCtlR :: new (((self . bits >> 1) & 7) as u8) } # [doc = "Bit 4 - Сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn plus_imix (& self) -> PlusImixR { PlusImixR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Старший разряд - подстройка внутреннего сигнала Vboost, младший разряд - сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn vboost_ctl (& self) -> VboostCtlR { VboostCtlR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn minus_imix (& self) -> MinusImixR { MinusImixR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:9 - Подстройка момента захвата выдаваемых данных. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn dummy_ctl (& self) -> DummyCtlR { DummyCtlR :: new (((self . bits >> 8) & 3) as u8) } # [doc = "Bits 10:12 - Подстройка опорного напряжения bandgap. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn vbg_ctl (& self) -> VbgCtlR { VbgCtlR :: new (((self . bits >> 10) & 7) as u8) } # [doc = "Bits 13:15 - Подстройка тока, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn ref_ctl (& self) -> RefCtlR { RefCtlR :: new (((self . bits >> 13) & 7) as u8) } # [doc = "Bits 16:18 - Подстройка напряжения, подаваемого на управляющие затворы при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn vcg_ctl (& self) -> VcgCtlR { VcgCtlR :: new (((self . bits >> 16) & 7) as u8) } # [doc = "Bit 19 - Включение режима точной подстройки напряжения, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn cgstrict (& self) -> CgstrictR { CgstrictR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bits 20:21 - Подстройка времени нарастания высокого напряжения. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn vpp_ctl (& self) -> VppCtlR { VppCtlR :: new (((self . bits >> 20) & 3) as u8) } # [doc = "Bits 22:24 - Точная подстройка тока, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn strict_ctl (& self) -> StrictCtlR { StrictCtlR :: new (((self . bits >> 22) & 7) as u8) } # [doc = "Bit 25 - Перевод Hard IP в режим пониженного энергопотребления"]
# [inline (always)]
pub fn stop_ee (& self) -> StopEeR { StopEeR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 26 - Перевод Hard IP в состояние бездействия (quiescent) для Iddq тестирования. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn iddq_en (& self) -> IddqEnR { IddqEnR :: new (((self . bits >> 26) & 1) != 0) } } impl W { # [doc = "Bit 0 - Увеличение частоты тактового сигнала, поступающего на устройство с зарядовой накачкой, в два раза. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn oscx2 (& mut self) -> Oscx2W < EeadjSpec > { Oscx2W :: new (self , 0) } # [doc = "Bits 1:3 - Подстройка уровня внутреннего сигнала HIV. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn hiv_ctl (& mut self) -> HivCtlW < EeadjSpec > { HivCtlW :: new (self , 1) } # [doc = "Bit 4 - Сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn plus_imix (& mut self) -> PlusImixW < EeadjSpec > { PlusImixW :: new (self , 4) } # [doc = "Bits 5:6 - Старший разряд - подстройка внутреннего сигнала Vboost, младший разряд - сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn vboost_ctl (& mut self) -> VboostCtlW < EeadjSpec > { VboostCtlW :: new (self , 5) } # [doc = "Bit 7 - Сигнал управления блоком мониторинга аналоговых сигналов. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn minus_imix (& mut self) -> MinusImixW < EeadjSpec > { MinusImixW :: new (self , 7) } # [doc = "Bits 8:9 - Подстройка момента захвата выдаваемых данных. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn dummy_ctl (& mut self) -> DummyCtlW < EeadjSpec > { DummyCtlW :: new (self , 8) } # [doc = "Bits 10:12 - Подстройка опорного напряжения bandgap. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn vbg_ctl (& mut self) -> VbgCtlW < EeadjSpec > { VbgCtlW :: new (self , 10) } # [doc = "Bits 13:15 - Подстройка тока, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn ref_ctl (& mut self) -> RefCtlW < EeadjSpec > { RefCtlW :: new (self , 13) } # [doc = "Bits 16:18 - Подстройка напряжения, подаваемого на управляющие затворы при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn vcg_ctl (& mut self) -> VcgCtlW < EeadjSpec > { VcgCtlW :: new (self , 16) } # [doc = "Bit 19 - Включение режима точной подстройки напряжения, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn cgstrict (& mut self) -> CgstrictW < EeadjSpec > { CgstrictW :: new (self , 19) } # [doc = "Bits 20:21 - Подстройка времени нарастания высокого напряжения. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn vpp_ctl (& mut self) -> VppCtlW < EeadjSpec > { VppCtlW :: new (self , 20) } # [doc = "Bits 22:24 - Точная подстройка тока, используемого при чтении. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn strict_ctl (& mut self) -> StrictCtlW < EeadjSpec > { StrictCtlW :: new (self , 22) } # [doc = "Bit 25 - Перевод Hard IP в режим пониженного энергопотребления"]
# [inline (always)]
pub fn stop_ee (& mut self) -> StopEeW < EeadjSpec > { StopEeW :: new (self , 25) } # [doc = "Bit 26 - Перевод Hard IP в состояние бездействия (quiescent) для Iddq тестирования. Поле предназначено для тонкой настройки блока и выполнения процедуры тестирование. Не гарантируется работа блока при использовании не рекомендованных производителем значений."]
# [inline (always)]
pub fn iddq_en (& mut self) -> IddqEnW < EeadjSpec > { IddqEnW :: new (self , 26) } } # [doc = "Регистр настроек\n\nYou can [`read`](crate::Reg::read) this register and get [`eeadj::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`eeadj::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EeadjSpec ; impl crate :: RegisterSpec for EeadjSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`eeadj::R`](R) reader structure"]
impl crate :: Readable for EeadjSpec { } # [doc = "`write(|w| ..)` method takes [`eeadj::W`](W) writer structure"]
impl crate :: Writable for EeadjSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EEADJ to value 0x0032_9000"]
impl crate :: Resettable for EeadjSpec { const RESET_VALUE : u32 = 0x0032_9000 ; } } # [doc = "NCYCRL (rw) register accessor: Регистр подстройки длительности процедур чтения и заполнения буфера записи\n\nYou can [`read`](crate::Reg::read) this register and get [`ncycrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ncycrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ncycrl`]
module"]
# [doc (alias = "NCYCRL")]
pub type Ncycrl = crate :: Reg < ncycrl :: NcycrlSpec > ; # [doc = "Регистр подстройки длительности процедур чтения и заполнения буфера записи"]
pub mod ncycrl { # [doc = "Register `NCYCRL` reader"]
pub type R = crate :: R < NcycrlSpec > ; # [doc = "Register `NCYCRL` writer"]
pub type W = crate :: W < NcycrlSpec > ; # [doc = "Field `N_LD` reader - Количество тактов между передними и задними фронтами сигналов Hard IP Phi1Ee и Phi1ShiftEe и задержка от нача¬ла обращения по шине до первого фронта Phi1Ee. Рекомен¬дуемое значение при любых частотах clk 1 такт. Запрещено устанавливать равным 0"]
pub type NLdR = crate :: FieldReader ; # [doc = "Field `N_LD` writer - Количество тактов между передними и задними фронтами сигналов Hard IP Phi1Ee и Phi1ShiftEe и задержка от нача¬ла обращения по шине до первого фронта Phi1Ee. Рекомен¬дуемое значение при любых частотах clk 1 такт. Запрещено устанавливать равным 0"]
pub type NLdW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `N_R_1` reader - Количество тактов, в течение которого Phi1ShiftEe имеет вы¬сокий уровень в процедуре чтения. Рекомендуемое значение N RA = ceil(51/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округления до ближайшего большего целого числа. Запрещено устанавливать равным 0"]
pub type NR1R = crate :: FieldReader ; # [doc = "Field `N_R_1` writer - Количество тактов, в течение которого Phi1ShiftEe имеет вы¬сокий уровень в процедуре чтения. Рекомендуемое значение N RA = ceil(51/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округления до ближайшего большего целого числа. Запрещено устанавливать равным 0"]
pub type NR1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `N_R_2` reader - Количество тактов, требуемое для завершения процедуры чте¬ния (перевода OkSelEe на высокий уровень после процедуры чтения). Рекомендуемое значение при любых частотах clk 1 такт. Запрещено устанавливать равным 0"]
pub type NR2R = crate :: FieldReader ; # [doc = "Field `N_R_2` writer - Количество тактов, требуемое для завершения процедуры чте¬ния (перевода OkSelEe на высокий уровень после процедуры чтения). Рекомендуемое значение при любых частотах clk 1 такт. Запрещено устанавливать равным 0"]
pub type NR2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7 - Количество тактов между передними и задними фронтами сигналов Hard IP Phi1Ee и Phi1ShiftEe и задержка от нача¬ла обращения по шине до первого фронта Phi1Ee. Рекомен¬дуемое значение при любых частотах clk 1 такт. Запрещено устанавливать равным 0"]
# [inline (always)]
pub fn n_ld (& self) -> NLdR { NLdR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - Количество тактов, в течение которого Phi1ShiftEe имеет вы¬сокий уровень в процедуре чтения. Рекомендуемое значение N RA = ceil(51/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округления до ближайшего большего целого числа. Запрещено устанавливать равным 0"]
# [inline (always)]
pub fn n_r_1 (& self) -> NR1R { NR1R :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:23 - Количество тактов, требуемое для завершения процедуры чте¬ния (перевода OkSelEe на высокий уровень после процедуры чтения). Рекомендуемое значение при любых частотах clk 1 такт. Запрещено устанавливать равным 0"]
# [inline (always)]
pub fn n_r_2 (& self) -> NR2R { NR2R :: new (((self . bits >> 16) & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - Количество тактов между передними и задними фронтами сигналов Hard IP Phi1Ee и Phi1ShiftEe и задержка от нача¬ла обращения по шине до первого фронта Phi1Ee. Рекомен¬дуемое значение при любых частотах clk 1 такт. Запрещено устанавливать равным 0"]
# [inline (always)]
pub fn n_ld (& mut self) -> NLdW < NcycrlSpec > { NLdW :: new (self , 0) } # [doc = "Bits 8:15 - Количество тактов, в течение которого Phi1ShiftEe имеет вы¬сокий уровень в процедуре чтения. Рекомендуемое значение N RA = ceil(51/Pclk), где Pclk – период тактового сигнала в нс, ceil – функция округления до ближайшего большего целого числа. Запрещено устанавливать равным 0"]
# [inline (always)]
pub fn n_r_1 (& mut self) -> NR1W < NcycrlSpec > { NR1W :: new (self , 8) } # [doc = "Bits 16:23 - Количество тактов, требуемое для завершения процедуры чте¬ния (перевода OkSelEe на высокий уровень после процедуры чтения). Рекомендуемое значение при любых частотах clk 1 такт. Запрещено устанавливать равным 0"]
# [inline (always)]
pub fn n_r_2 (& mut self) -> NR2W < NcycrlSpec > { NR2W :: new (self , 16) } } # [doc = "Регистр подстройки длительности процедур чтения и заполнения буфера записи\n\nYou can [`read`](crate::Reg::read) this register and get [`ncycrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ncycrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct NcycrlSpec ; impl crate :: RegisterSpec for NcycrlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ncycrl::R`](R) reader structure"]
impl crate :: Readable for NcycrlSpec { } # [doc = "`write(|w| ..)` method takes [`ncycrl::W`](W) writer structure"]
impl crate :: Writable for NcycrlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets NCYCRL to value 0x0001_0201"]
impl crate :: Resettable for NcycrlSpec { const RESET_VALUE : u32 = 0x0001_0201 ; } } # [doc = "NCYCEP1 (rw) register accessor: Регистр 1 подстройки длительности процедур стирания и программирования\n\nYou can [`read`](crate::Reg::read) this register and get [`ncycep1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ncycep1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ncycep1`]
module"]
# [doc (alias = "NCYCEP1")]
pub type Ncycep1 = crate :: Reg < ncycep1 :: Ncycep1Spec > ; # [doc = "Регистр 1 подстройки длительности процедур стирания и программирования"]
pub mod ncycep1 { # [doc = "Register `NCYCEP1` reader"]
pub type R = crate :: R < Ncycep1Spec > ; # [doc = "Register `NCYCEP1` writer"]
pub type W = crate :: W < Ncycep1Spec > ; # [doc = "Field `N_EP_1` reader - Длительность высокого уровня сигнала BUSY (вход Hard IP) в тактах. Рекомендуемое значение N RA = 2000000 нс / Pclk, где Pclk – период тактового сигнала в нс. Пример – 66667 так¬тов для частоты Fclk = 33,3 МГц. Запрещено устанавливать равным 0"]
pub type NEp1R = crate :: FieldReader < u32 > ; # [doc = "Field `N_EP_1` writer - Длительность высокого уровня сигнала BUSY (вход Hard IP) в тактах. Рекомендуемое значение N RA = 2000000 нс / Pclk, где Pclk – период тактового сигнала в нс. Пример – 66667 так¬тов для частоты Fclk = 33,3 МГц. Запрещено устанавливать равным 0"]
pub type NEp1W < 'a , REG > = crate :: FieldWriter < 'a , REG , 18 , u32 > ; impl R { # [doc = "Bits 0:17 - Длительность высокого уровня сигнала BUSY (вход Hard IP) в тактах. Рекомендуемое значение N RA = 2000000 нс / Pclk, где Pclk – период тактового сигнала в нс. Пример – 66667 так¬тов для частоты Fclk = 33,3 МГц. Запрещено устанавливать равным 0"]
# [inline (always)]
pub fn n_ep_1 (& self) -> NEp1R { NEp1R :: new (self . bits & 0x0003_ffff) } } impl W { # [doc = "Bits 0:17 - Длительность высокого уровня сигнала BUSY (вход Hard IP) в тактах. Рекомендуемое значение N RA = 2000000 нс / Pclk, где Pclk – период тактового сигнала в нс. Пример – 66667 так¬тов для частоты Fclk = 33,3 МГц. Запрещено устанавливать равным 0"]
# [inline (always)]
pub fn n_ep_1 (& mut self) -> NEp1W < Ncycep1Spec > { NEp1W :: new (self , 0) } } # [doc = "Регистр 1 подстройки длительности процедур стирания и программирования\n\nYou can [`read`](crate::Reg::read) this register and get [`ncycep1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ncycep1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ncycep1Spec ; impl crate :: RegisterSpec for Ncycep1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`ncycep1::R`](R) reader structure"]
impl crate :: Readable for Ncycep1Spec { } # [doc = "`write(|w| ..)` method takes [`ncycep1::W`](W) writer structure"]
impl crate :: Writable for Ncycep1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets NCYCEP1 to value 0x0001_046b"]
impl crate :: Resettable for Ncycep1Spec { const RESET_VALUE : u32 = 0x0001_046b ; } } # [doc = "NCYCEP2 (rw) register accessor: Регистр 2 подстройки длительности процедур стирания и программирования\n\nYou can [`read`](crate::Reg::read) this register and get [`ncycep2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ncycep2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ncycep2`]
module"]
# [doc (alias = "NCYCEP2")]
pub type Ncycep2 = crate :: Reg < ncycep2 :: Ncycep2Spec > ; # [doc = "Регистр 2 подстройки длительности процедур стирания и программирования"]
pub mod ncycep2 { # [doc = "Register `NCYCEP2` reader"]
pub type R = crate :: R < Ncycep2Spec > ; # [doc = "Register `NCYCEP2` writer"]
pub type W = crate :: W < Ncycep2Spec > ; # [doc = "Field `N_EP_2` reader - Задержка между задними фронтами BUSY и HvonValid (входы Hard IP) в тактах. Рекомендуемое значение N RA = 15000 нс / Pclk, где Pclk – период тактового сигнала в нс. Пример – 500 тактов для частоты Fclk = 33,3 МГц. Запрещено устанавливать равным 0"]
pub type NEp2R = crate :: FieldReader < u16 > ; # [doc = "Field `N_EP_2` writer - Задержка между задними фронтами BUSY и HvonValid (входы Hard IP) в тактах. Рекомендуемое значение N RA = 15000 нс / Pclk, где Pclk – период тактового сигнала в нс. Пример – 500 тактов для частоты Fclk = 33,3 МГц. Запрещено устанавливать равным 0"]
pub type NEp2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 11 , u16 > ; impl R { # [doc = "Bits 0:10 - Задержка между задними фронтами BUSY и HvonValid (входы Hard IP) в тактах. Рекомендуемое значение N RA = 15000 нс / Pclk, где Pclk – период тактового сигнала в нс. Пример – 500 тактов для частоты Fclk = 33,3 МГц. Запрещено устанавливать равным 0"]
# [inline (always)]
pub fn n_ep_2 (& self) -> NEp2R { NEp2R :: new ((self . bits & 0x07ff) as u16) } } impl W { # [doc = "Bits 0:10 - Задержка между задними фронтами BUSY и HvonValid (входы Hard IP) в тактах. Рекомендуемое значение N RA = 15000 нс / Pclk, где Pclk – период тактового сигнала в нс. Пример – 500 тактов для частоты Fclk = 33,3 МГц. Запрещено устанавливать равным 0"]
# [inline (always)]
pub fn n_ep_2 (& mut self) -> NEp2W < Ncycep2Spec > { NEp2W :: new (self , 0) } } # [doc = "Регистр 2 подстройки длительности процедур стирания и программирования\n\nYou can [`read`](crate::Reg::read) this register and get [`ncycep2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ncycep2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ncycep2Spec ; impl crate :: RegisterSpec for Ncycep2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`ncycep2::R`](R) reader structure"]
impl crate :: Readable for Ncycep2Spec { } # [doc = "`write(|w| ..)` method takes [`ncycep2::W`](W) writer structure"]
impl crate :: Writable for Ncycep2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets NCYCEP2 to value 0x32"]
impl crate :: Resettable for Ncycep2Spec { const RESET_VALUE : u32 = 0x32 ; } } } # [doc = "Крипто-блок"]
pub struct Crypto { _marker : PhantomData < * const () > } unsafe impl Send for Crypto { } impl Crypto { # [doc = r"Pointer to the register block"]
pub const PTR : * const crypto :: RegisterBlock = 0x0008_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const crypto :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Crypto { type Target = crypto :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Crypto { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Crypto") . finish () } } # [doc = "Крипто-блок"]
pub mod crypto { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { block : Block , key : Key , init : Init , config : Config , } impl RegisterBlock { # [doc = "0x00 - Буфер данных для шифрования"]
# [inline (always)]
pub const fn block (& self) -> & Block { & self . block } # [doc = "0x04 - Буфер данных ключа"]
# [inline (always)]
pub const fn key (& self) -> & Key { & self . key } # [doc = "0x08 - Буфер данных вектора инициализации"]
# [inline (always)]
pub const fn init (& self) -> & Init { & self . init } # [doc = "0x0c - Регистр конфигурации"]
# [inline (always)]
pub const fn config (& self) -> & Config { & self . config } } # [doc = "BLOCK (rw) register accessor: Буфер данных для шифрования\n\nYou can [`read`](crate::Reg::read) this register and get [`block::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`block::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@block`]
module"]
# [doc (alias = "BLOCK")]
pub type Block = crate :: Reg < block :: BlockSpec > ; # [doc = "Буфер данных для шифрования"]
pub mod block { # [doc = "Register `BLOCK` reader"]
pub type R = crate :: R < BlockSpec > ; # [doc = "Register `BLOCK` writer"]
pub type W = crate :: W < BlockSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Буфер данных для шифрования\n\nYou can [`read`](crate::Reg::read) this register and get [`block::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`block::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct BlockSpec ; impl crate :: RegisterSpec for BlockSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`block::R`](R) reader structure"]
impl crate :: Readable for BlockSpec { } # [doc = "`write(|w| ..)` method takes [`block::W`](W) writer structure"]
impl crate :: Writable for BlockSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets BLOCK to value 0"]
impl crate :: Resettable for BlockSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "KEY (w) register accessor: Буфер данных ключа\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`key::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@key`]
module"]
# [doc (alias = "KEY")]
pub type Key = crate :: Reg < key :: KeySpec > ; # [doc = "Буфер данных ключа"]
pub mod key { # [doc = "Register `KEY` writer"]
pub type W = crate :: W < KeySpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < KeySpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Буфер данных ключа\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`key::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct KeySpec ; impl crate :: RegisterSpec for KeySpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`key::W`](W) writer structure"]
impl crate :: Writable for KeySpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets KEY to value 0"]
impl crate :: Resettable for KeySpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INIT (w) register accessor: Буфер данных вектора инициализации\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`init::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@init`]
module"]
# [doc (alias = "INIT")]
pub type Init = crate :: Reg < init :: InitSpec > ; # [doc = "Буфер данных вектора инициализации"]
pub mod init { # [doc = "Register `INIT` writer"]
pub type W = crate :: W < InitSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < InitSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Буфер данных вектора инициализации\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`init::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct InitSpec ; impl crate :: RegisterSpec for InitSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`init::W`](W) writer structure"]
impl crate :: Writable for InitSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INIT to value 0"]
impl crate :: Resettable for InitSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONFIG (rw) register accessor: Регистр конфигурации\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@config`]
module"]
# [doc (alias = "CONFIG")]
pub type Config = crate :: Reg < config :: ConfigSpec > ; # [doc = "Регистр конфигурации"]
pub mod config { # [doc = "Register `CONFIG` reader"]
pub type R = crate :: R < ConfigSpec > ; # [doc = "Register `CONFIG` writer"]
pub type W = crate :: W < ConfigSpec > ; # [doc = "Задаёт режим хода вычислительного ядра\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Decode { # [doc = "0: Прямой ход (шифрование)"]
Encode = 0 , # [doc = "1: Обратный ход (расшифровка)"]
Decode = 1 , } impl From < Decode > for bool { # [inline (always)]
fn from (variant : Decode) -> Self { variant as u8 != 0 } } # [doc = "Field `DECODE` reader - Задаёт режим хода вычислительного ядра"]
pub type DecodeR = crate :: BitReader < Decode > ; impl DecodeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Decode { match self . bits { false => Decode :: Encode , true => Decode :: Decode , } } # [doc = "Прямой ход (шифрование)"]
# [inline (always)]
pub fn is_encode (& self) -> bool { * self == Decode :: Encode } # [doc = "Обратный ход (расшифровка)"]
# [inline (always)]
pub fn is_decode (& self) -> bool { * self == Decode :: Decode } } # [doc = "Field `DECODE` writer - Задаёт режим хода вычислительного ядра"]
pub type DecodeW < 'a , REG > = crate :: BitWriter < 'a , REG , Decode > ; impl < 'a , REG > DecodeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прямой ход (шифрование)"]
# [inline (always)]
pub fn encode (self) -> & 'a mut crate :: W < REG > { self . variant (Decode :: Encode) } # [doc = "Обратный ход (расшифровка)"]
# [inline (always)]
pub fn decode (self) -> & 'a mut crate :: W < REG > { self . variant (Decode :: Decode) } } # [doc = "Регистр выбора алгоритма шифрования\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CoreSel { # [doc = "0: «Кузнечик»"]
Kuznechik = 0 , # [doc = "1: «Магма»"]
Magma = 1 , # [doc = "2: «AES»"]
Aes = 2 , } impl From < CoreSel > for u8 { # [inline (always)]
fn from (variant : CoreSel) -> Self { variant as _ } } impl crate :: FieldSpec for CoreSel { type Ux = u8 ; } impl crate :: IsEnum for CoreSel { } # [doc = "Field `CORE_SEL` reader - Регистр выбора алгоритма шифрования"]
pub type CoreSelR = crate :: FieldReader < CoreSel > ; impl CoreSelR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < CoreSel > { match self . bits { 0 => Some (CoreSel :: Kuznechik) , 1 => Some (CoreSel :: Magma) , 2 => Some (CoreSel :: Aes) , _ => None , } } # [doc = "«Кузнечик»"]
# [inline (always)]
pub fn is_kuznechik (& self) -> bool { * self == CoreSel :: Kuznechik } # [doc = "«Магма»"]
# [inline (always)]
pub fn is_magma (& self) -> bool { * self == CoreSel :: Magma } # [doc = "«AES»"]
# [inline (always)]
pub fn is_aes (& self) -> bool { * self == CoreSel :: Aes } } # [doc = "Field `CORE_SEL` writer - Регистр выбора алгоритма шифрования"]
pub type CoreSelW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , CoreSel > ; impl < 'a , REG > CoreSelW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "«Кузнечик»"]
# [inline (always)]
pub fn kuznechik (self) -> & 'a mut crate :: W < REG > { self . variant (CoreSel :: Kuznechik) } # [doc = "«Магма»"]
# [inline (always)]
pub fn magma (self) -> & 'a mut crate :: W < REG > { self . variant (CoreSel :: Magma) } # [doc = "«AES»"]
# [inline (always)]
pub fn aes (self) -> & 'a mut crate :: W < REG > { self . variant (CoreSel :: Aes) } } # [doc = "Регистр выбора режима шифрования\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ModeSel { # [doc = "0: Режиме простой замены (ECB)"]
Ecb = 0 , # [doc = "1: Режим сцепления блоков (CBC)"]
Cbc = 1 , # [doc = "2: Режим гаммирования (CTR)"]
Ctr = 2 , } impl From < ModeSel > for u8 { # [inline (always)]
fn from (variant : ModeSel) -> Self { variant as _ } } impl crate :: FieldSpec for ModeSel { type Ux = u8 ; } impl crate :: IsEnum for ModeSel { } # [doc = "Field `MODE_SEL` reader - Регистр выбора режима шифрования"]
pub type ModeSelR = crate :: FieldReader < ModeSel > ; impl ModeSelR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < ModeSel > { match self . bits { 0 => Some (ModeSel :: Ecb) , 1 => Some (ModeSel :: Cbc) , 2 => Some (ModeSel :: Ctr) , _ => None , } } # [doc = "Режиме простой замены (ECB)"]
# [inline (always)]
pub fn is_ecb (& self) -> bool { * self == ModeSel :: Ecb } # [doc = "Режим сцепления блоков (CBC)"]
# [inline (always)]
pub fn is_cbc (& self) -> bool { * self == ModeSel :: Cbc } # [doc = "Режим гаммирования (CTR)"]
# [inline (always)]
pub fn is_ctr (& self) -> bool { * self == ModeSel :: Ctr } } # [doc = "Field `MODE_SEL` writer - Регистр выбора режима шифрования"]
pub type ModeSelW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , ModeSel > ; impl < 'a , REG > ModeSelW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Режиме простой замены (ECB)"]
# [inline (always)]
pub fn ecb (self) -> & 'a mut crate :: W < REG > { self . variant (ModeSel :: Ecb) } # [doc = "Режим сцепления блоков (CBC)"]
# [inline (always)]
pub fn cbc (self) -> & 'a mut crate :: W < REG > { self . variant (ModeSel :: Cbc) } # [doc = "Режим гаммирования (CTR)"]
# [inline (always)]
pub fn ctr (self) -> & 'a mut crate :: W < REG > { self . variant (ModeSel :: Ctr) } } # [doc = "Регистр выбора режима перестановки слова\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum SwapMode { # [doc = "0: Нет перестановки"]
None = 0 , # [doc = "1: Перестановка по полуслову"]
HalfWord = 1 , # [doc = "2: Перестановки по байтам"]
Byte = 2 , # [doc = "3: Перестановка по битам"]
Bit = 3 , } impl From < SwapMode > for u8 { # [inline (always)]
fn from (variant : SwapMode) -> Self { variant as _ } } impl crate :: FieldSpec for SwapMode { type Ux = u8 ; } impl crate :: IsEnum for SwapMode { } # [doc = "Field `SWAP_MODE` reader - Регистр выбора режима перестановки слова"]
pub type SwapModeR = crate :: FieldReader < SwapMode > ; impl SwapModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> SwapMode { match self . bits { 0 => SwapMode :: None , 1 => SwapMode :: HalfWord , 2 => SwapMode :: Byte , 3 => SwapMode :: Bit , _ => unreachable ! () , } } # [doc = "Нет перестановки"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == SwapMode :: None } # [doc = "Перестановка по полуслову"]
# [inline (always)]
pub fn is_half_word (& self) -> bool { * self == SwapMode :: HalfWord } # [doc = "Перестановки по байтам"]
# [inline (always)]
pub fn is_byte (& self) -> bool { * self == SwapMode :: Byte } # [doc = "Перестановка по битам"]
# [inline (always)]
pub fn is_bit (& self) -> bool { * self == SwapMode :: Bit } } # [doc = "Field `SWAP_MODE` writer - Регистр выбора режима перестановки слова"]
pub type SwapModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , SwapMode , crate :: Safe > ; impl < 'a , REG > SwapModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нет перестановки"]
# [inline (always)]
pub fn none (self) -> & 'a mut crate :: W < REG > { self . variant (SwapMode :: None) } # [doc = "Перестановка по полуслову"]
# [inline (always)]
pub fn half_word (self) -> & 'a mut crate :: W < REG > { self . variant (SwapMode :: HalfWord) } # [doc = "Перестановки по байтам"]
# [inline (always)]
pub fn byte (self) -> & 'a mut crate :: W < REG > { self . variant (SwapMode :: Byte) } # [doc = "Перестановка по битам"]
# [inline (always)]
pub fn bit_ (self) -> & 'a mut crate :: W < REG > { self . variant (SwapMode :: Bit) } } # [doc = "Выбор порядка загрузки/выгрузки\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum OrderMode { # [doc = "0: От младшего слова к старшему"]
Lsw = 0 , # [doc = "1: От старшего слова к младшему"]
Msw = 1 , } impl From < OrderMode > for bool { # [inline (always)]
fn from (variant : OrderMode) -> Self { variant as u8 != 0 } } # [doc = "Field `ORDER_MODE` reader - Выбор порядка загрузки/выгрузки"]
pub type OrderModeR = crate :: BitReader < OrderMode > ; impl OrderModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> OrderMode { match self . bits { false => OrderMode :: Lsw , true => OrderMode :: Msw , } } # [doc = "От младшего слова к старшему"]
# [inline (always)]
pub fn is_lsw (& self) -> bool { * self == OrderMode :: Lsw } # [doc = "От старшего слова к младшему"]
# [inline (always)]
pub fn is_msw (& self) -> bool { * self == OrderMode :: Msw } } # [doc = "Field `ORDER_MODE` writer - Выбор порядка загрузки/выгрузки"]
pub type OrderModeW < 'a , REG > = crate :: BitWriter < 'a , REG , OrderMode > ; impl < 'a , REG > OrderModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "От младшего слова к старшему"]
# [inline (always)]
pub fn lsw (self) -> & 'a mut crate :: W < REG > { self . variant (OrderMode :: Lsw) } # [doc = "От старшего слова к младшему"]
# [inline (always)]
pub fn msw (self) -> & 'a mut crate :: W < REG > { self . variant (OrderMode :: Msw) } } # [doc = "Field `C_RESET` reader - Сброс счётчиков загружаемых/выгружаемых данных"]
pub type CResetR = crate :: BitReader ; # [doc = "Field `C_RESET` writer - Сброс счётчиков загружаемых/выгружаемых данных"]
pub type CResetW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Состояние доступности модуля\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ready { # [doc = "0: Занято"]
Busy = 0 , # [doc = "1: Доступно"]
Available = 1 , } impl From < Ready > for bool { # [inline (always)]
fn from (variant : Ready) -> Self { variant as u8 != 0 } } # [doc = "Field `READY` reader - Состояние доступности модуля"]
pub type ReadyR = crate :: BitReader < Ready > ; impl ReadyR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ready { match self . bits { false => Ready :: Busy , true => Ready :: Available , } } # [doc = "Занято"]
# [inline (always)]
pub fn is_busy (& self) -> bool { * self == Ready :: Busy } # [doc = "Доступно"]
# [inline (always)]
pub fn is_available (& self) -> bool { * self == Ready :: Available } } # [doc = "Буфер данных доступен для записи\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum WriteStatus { # [doc = "0: Недоступно"]
Unavailable = 0 , # [doc = "1: Доступно"]
Available = 1 , } impl From < WriteStatus > for bool { # [inline (always)]
fn from (variant : WriteStatus) -> Self { variant as u8 != 0 } } # [doc = "Field `WRITE_STATUS` reader - Буфер данных доступен для записи"]
pub type WriteStatusR = crate :: BitReader < WriteStatus > ; impl WriteStatusR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> WriteStatus { match self . bits { false => WriteStatus :: Unavailable , true => WriteStatus :: Available , } } # [doc = "Недоступно"]
# [inline (always)]
pub fn is_unavailable (& self) -> bool { * self == WriteStatus :: Unavailable } # [doc = "Доступно"]
# [inline (always)]
pub fn is_available (& self) -> bool { * self == WriteStatus :: Available } } # [doc = "Буфер данных доступен для чтения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ReadStatus { # [doc = "0: Недоступно"]
Unavailable = 0 , # [doc = "1: Доступно"]
Available = 1 , } impl From < ReadStatus > for bool { # [inline (always)]
fn from (variant : ReadStatus) -> Self { variant as u8 != 0 } } # [doc = "Field `READ_STATUS` reader - Буфер данных доступен для чтения"]
pub type ReadStatusR = crate :: BitReader < ReadStatus > ; impl ReadStatusR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ReadStatus { match self . bits { false => ReadStatus :: Unavailable , true => ReadStatus :: Available , } } # [doc = "Недоступно"]
# [inline (always)]
pub fn is_unavailable (& self) -> bool { * self == ReadStatus :: Unavailable } # [doc = "Доступно"]
# [inline (always)]
pub fn is_available (& self) -> bool { * self == ReadStatus :: Available } } impl R { # [doc = "Bit 0 - Задаёт режим хода вычислительного ядра"]
# [inline (always)]
pub fn decode (& self) -> DecodeR { DecodeR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Регистр выбора алгоритма шифрования"]
# [inline (always)]
pub fn core_sel (& self) -> CoreSelR { CoreSelR :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bits 3:4 - Регистр выбора режима шифрования"]
# [inline (always)]
pub fn mode_sel (& self) -> ModeSelR { ModeSelR :: new (((self . bits >> 3) & 3) as u8) } # [doc = "Bits 5:6 - Регистр выбора режима перестановки слова"]
# [inline (always)]
pub fn swap_mode (& self) -> SwapModeR { SwapModeR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Выбор порядка загрузки/выгрузки"]
# [inline (always)]
pub fn order_mode (& self) -> OrderModeR { OrderModeR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Сброс счётчиков загружаемых/выгружаемых данных"]
# [inline (always)]
pub fn c_reset (& self) -> CResetR { CResetR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Состояние доступности модуля"]
# [inline (always)]
pub fn ready (& self) -> ReadyR { ReadyR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Буфер данных доступен для записи"]
# [inline (always)]
pub fn write_status (& self) -> WriteStatusR { WriteStatusR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Буфер данных доступен для чтения"]
# [inline (always)]
pub fn read_status (& self) -> ReadStatusR { ReadStatusR :: new (((self . bits >> 11) & 1) != 0) } } impl W { # [doc = "Bit 0 - Задаёт режим хода вычислительного ядра"]
# [inline (always)]
pub fn decode (& mut self) -> DecodeW < ConfigSpec > { DecodeW :: new (self , 0) } # [doc = "Bits 1:2 - Регистр выбора алгоритма шифрования"]
# [inline (always)]
pub fn core_sel (& mut self) -> CoreSelW < ConfigSpec > { CoreSelW :: new (self , 1) } # [doc = "Bits 3:4 - Регистр выбора режима шифрования"]
# [inline (always)]
pub fn mode_sel (& mut self) -> ModeSelW < ConfigSpec > { ModeSelW :: new (self , 3) } # [doc = "Bits 5:6 - Регистр выбора режима перестановки слова"]
# [inline (always)]
pub fn swap_mode (& mut self) -> SwapModeW < ConfigSpec > { SwapModeW :: new (self , 5) } # [doc = "Bit 7 - Выбор порядка загрузки/выгрузки"]
# [inline (always)]
pub fn order_mode (& mut self) -> OrderModeW < ConfigSpec > { OrderModeW :: new (self , 7) } # [doc = "Bit 8 - Сброс счётчиков загружаемых/выгружаемых данных"]
# [inline (always)]
pub fn c_reset (& mut self) -> CResetW < ConfigSpec > { CResetW :: new (self , 8) } } # [doc = "Регистр конфигурации\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ConfigSpec ; impl crate :: RegisterSpec for ConfigSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`config::R`](R) reader structure"]
impl crate :: Readable for ConfigSpec { } # [doc = "`write(|w| ..)` method takes [`config::W`](W) writer structure"]
impl crate :: Writable for ConfigSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONFIG to value 0"]
impl crate :: Resettable for ConfigSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Блок вычисления контрольных сумм"]
pub struct Crc { _marker : PhantomData < * const () > } unsafe impl Send for Crc { } impl Crc { # [doc = r"Pointer to the register block"]
pub const PTR : * const crc :: RegisterBlock = 0x0008_0400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const crc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Crc { type Target = crc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Crc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Crc") . finish () } } # [doc = "Блок вычисления контрольных сумм"]
pub mod crc { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { data : Data , poly : Poly , ctrl : Ctrl , } impl RegisterBlock { # [doc = "0x00 - Регистр данных"]
# [inline (always)]
pub const fn data (& self) -> & Data { & self . data } # [doc = "0x04 - Регистр полинома"]
# [inline (always)]
pub const fn poly (& self) -> & Poly { & self . poly } # [doc = "0x08 - Регистр управления"]
# [inline (always)]
pub const fn ctrl (& self) -> & Ctrl { & self . ctrl } } # [doc = "DATA (rw) register accessor: Регистр данных\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@data`]
module"]
# [doc (alias = "DATA")]
pub type Data = crate :: Reg < data :: DataSpec > ; # [doc = "Регистр данных"]
pub mod data { # [doc = "Register `DATA` reader"]
pub type R = crate :: R < DataSpec > ; # [doc = "Register `DATA` writer"]
pub type W = crate :: W < DataSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр данных\n\nYou can [`read`](crate::Reg::read) this register and get [`data::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`data::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DataSpec ; impl crate :: RegisterSpec for DataSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`data::R`](R) reader structure"]
impl crate :: Readable for DataSpec { } # [doc = "`write(|w| ..)` method takes [`data::W`](W) writer structure"]
impl crate :: Writable for DataSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DATA to value 0"]
impl crate :: Resettable for DataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "POLY (rw) register accessor: Регистр полинома\n\nYou can [`read`](crate::Reg::read) this register and get [`poly::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`poly::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@poly`]
module"]
# [doc (alias = "POLY")]
pub type Poly = crate :: Reg < poly :: PolySpec > ; # [doc = "Регистр полинома"]
pub mod poly { # [doc = "Register `POLY` reader"]
pub type R = crate :: R < PolySpec > ; # [doc = "Register `POLY` writer"]
pub type W = crate :: W < PolySpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр полинома\n\nYou can [`read`](crate::Reg::read) this register and get [`poly::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`poly::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct PolySpec ; impl crate :: RegisterSpec for PolySpec { type Ux = u32 ; } # [doc = "`read()` method returns [`poly::R`](R) reader structure"]
impl crate :: Readable for PolySpec { } # [doc = "`write(|w| ..)` method takes [`poly::W`](W) writer structure"]
impl crate :: Writable for PolySpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets POLY to value 0"]
impl crate :: Resettable for PolySpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CTRL (rw) register accessor: Регистр управления\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ctrl`]
module"]
# [doc (alias = "CTRL")]
pub type Ctrl = crate :: Reg < ctrl :: CtrlSpec > ; # [doc = "Регистр управления"]
pub mod ctrl { # [doc = "Register `CTRL` reader"]
pub type R = crate :: R < CtrlSpec > ; # [doc = "Register `CTRL` writer"]
pub type W = crate :: W < CtrlSpec > ; # [doc = "Инверсия контрольной суммы. Некоторые протоколы подсчета контрольной суммы требуют инверсии вычисленного значения контрольной суммы (выполняется операция XOR со значением 0xFFFFFFFF)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Fxor { # [doc = "0: Инверсия выключена"]
InversionDisable = 0 , # [doc = "1: Инверсия включена (операция XOR выполняется)"]
InversionEnable = 1 , } impl From < Fxor > for u8 { # [inline (always)]
fn from (variant : Fxor) -> Self { variant as _ } } impl crate :: FieldSpec for Fxor { type Ux = u8 ; } impl crate :: IsEnum for Fxor { } # [doc = "Field `FXOR` reader - Инверсия контрольной суммы. Некоторые протоколы подсчета контрольной суммы требуют инверсии вычисленного значения контрольной суммы (выполняется операция XOR со значением 0xFFFFFFFF)"]
pub type FxorR = crate :: FieldReader < Fxor > ; impl FxorR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Fxor > { match self . bits { 0 => Some (Fxor :: InversionDisable) , 1 => Some (Fxor :: InversionEnable) , _ => None , } } # [doc = "Инверсия выключена"]
# [inline (always)]
pub fn is_inversion_disable (& self) -> bool { * self == Fxor :: InversionDisable } # [doc = "Инверсия включена (операция XOR выполняется)"]
# [inline (always)]
pub fn is_inversion_enable (& self) -> bool { * self == Fxor :: InversionEnable } } # [doc = "Field `FXOR` writer - Инверсия контрольной суммы. Некоторые протоколы подсчета контрольной суммы требуют инверсии вычисленного значения контрольной суммы (выполняется операция XOR со значением 0xFFFFFFFF)"]
pub type FxorW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Fxor > ; impl < 'a , REG > FxorW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Инверсия выключена"]
# [inline (always)]
pub fn inversion_disable (self) -> & 'a mut crate :: W < REG > { self . variant (Fxor :: InversionDisable) } # [doc = "Инверсия включена (операция XOR выполняется)"]
# [inline (always)]
pub fn inversion_enable (self) -> & 'a mut crate :: W < REG > { self . variant (Fxor :: InversionEnable) } } # [doc = "Назначение регистра данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Was { # [doc = "0: Записываем данные"]
Data = 0 , # [doc = "1: Записываем начальное значение"]
InitData = 1 , } impl From < Was > for bool { # [inline (always)]
fn from (variant : Was) -> Self { variant as u8 != 0 } } # [doc = "Field `WAS` reader - Назначение регистра данных"]
pub type WasR = crate :: BitReader < Was > ; impl WasR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Was { match self . bits { false => Was :: Data , true => Was :: InitData , } } # [doc = "Записываем данные"]
# [inline (always)]
pub fn is_data (& self) -> bool { * self == Was :: Data } # [doc = "Записываем начальное значение"]
# [inline (always)]
pub fn is_init_data (& self) -> bool { * self == Was :: InitData } } # [doc = "Field `WAS` writer - Назначение регистра данных"]
pub type WasW < 'a , REG > = crate :: BitWriter < 'a , REG , Was > ; impl < 'a , REG > WasW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Записываем данные"]
# [inline (always)]
pub fn data (self) -> & 'a mut crate :: W < REG > { self . variant (Was :: Data) } # [doc = "Записываем начальное значение"]
# [inline (always)]
pub fn init_data (self) -> & 'a mut crate :: W < REG > { self . variant (Was :: InitData) } } # [doc = "Бит занятости автомата. После записи в регистр данных слова для вычисления контрольной суммы бит занятости перейдет в состояние единицы через один такт после такта записи. То есть чтение регистра управления, идущее на шине AHB сразу на следующем такте после записи данных, вернет результат с нулевым (еще не обновленным) значением бита Busy\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Busy { # [doc = "0: Автомат закончил вычисления"]
Ready = 0 , # [doc = "1: Автомат занят"]
Busy = 1 , } impl From < Busy > for bool { # [inline (always)]
fn from (variant : Busy) -> Self { variant as u8 != 0 } } # [doc = "Field `Busy` reader - Бит занятости автомата. После записи в регистр данных слова для вычисления контрольной суммы бит занятости перейдет в состояние единицы через один такт после такта записи. То есть чтение регистра управления, идущее на шине AHB сразу на следующем такте после записи данных, вернет результат с нулевым (еще не обновленным) значением бита Busy"]
pub type BusyR = crate :: BitReader < Busy > ; impl BusyR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Busy { match self . bits { false => Busy :: Ready , true => Busy :: Busy , } } # [doc = "Автомат закончил вычисления"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Busy :: Ready } # [doc = "Автомат занят"]
# [inline (always)]
pub fn is_busy (& self) -> bool { * self == Busy :: Busy } } # [doc = "Перестановки битов/байтов выходных данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Totr { # [doc = "0: Перестановка выключена"]
None = 0 , # [doc = "1: Биты в байтах перестанавливаются (бит 7 с битом 0, бит 6 с битом 1 и т.д.; бит 15 c битом 8, бит 14 с битом 9 и т.д., с остальными байтами так же), байты НЕ перестанавливаются"]
Bits = 1 , # [doc = "2: Перестанавливаются и биты, и байты"]
BitsBytes = 2 , # [doc = "3: Биты в байтах НЕ перестанавливаются, байты перестанавливаются (меняются местами байты 3 и 0, 2 и 1);"]
Bytes = 3 , } impl From < Totr > for u8 { # [inline (always)]
fn from (variant : Totr) -> Self { variant as _ } } impl crate :: FieldSpec for Totr { type Ux = u8 ; } impl crate :: IsEnum for Totr { } # [doc = "Field `TOTR` reader - Перестановки битов/байтов выходных данных"]
pub type TotrR = crate :: FieldReader < Totr > ; impl TotrR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Totr { match self . bits { 0 => Totr :: None , 1 => Totr :: Bits , 2 => Totr :: BitsBytes , 3 => Totr :: Bytes , _ => unreachable ! () , } } # [doc = "Перестановка выключена"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == Totr :: None } # [doc = "Биты в байтах перестанавливаются (бит 7 с битом 0, бит 6 с битом 1 и т.д.; бит 15 c битом 8, бит 14 с битом 9 и т.д., с остальными байтами так же), байты НЕ перестанавливаются"]
# [inline (always)]
pub fn is_bits (& self) -> bool { * self == Totr :: Bits } # [doc = "Перестанавливаются и биты, и байты"]
# [inline (always)]
pub fn is_bits_bytes (& self) -> bool { * self == Totr :: BitsBytes } # [doc = "Биты в байтах НЕ перестанавливаются, байты перестанавливаются (меняются местами байты 3 и 0, 2 и 1);"]
# [inline (always)]
pub fn is_bytes (& self) -> bool { * self == Totr :: Bytes } } # [doc = "Field `TOTR` writer - Перестановки битов/байтов выходных данных"]
pub type TotrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Totr , crate :: Safe > ; impl < 'a , REG > TotrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Перестановка выключена"]
# [inline (always)]
pub fn none (self) -> & 'a mut crate :: W < REG > { self . variant (Totr :: None) } # [doc = "Биты в байтах перестанавливаются (бит 7 с битом 0, бит 6 с битом 1 и т.д.; бит 15 c битом 8, бит 14 с битом 9 и т.д., с остальными байтами так же), байты НЕ перестанавливаются"]
# [inline (always)]
pub fn bits_ (self) -> & 'a mut crate :: W < REG > { self . variant (Totr :: Bits) } # [doc = "Перестанавливаются и биты, и байты"]
# [inline (always)]
pub fn bits_bytes (self) -> & 'a mut crate :: W < REG > { self . variant (Totr :: BitsBytes) } # [doc = "Биты в байтах НЕ перестанавливаются, байты перестанавливаются (меняются местами байты 3 и 0, 2 и 1);"]
# [inline (always)]
pub fn bytes (self) -> & 'a mut crate :: W < REG > { self . variant (Totr :: Bytes) } } # [doc = "Перестановка битов/байтов входных данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Tot { # [doc = "0: Перестановка выключена"]
None = 0 , # [doc = "1: Биты в байтах перестанавливаются (бит 7 с битом 0, бит 15 с битом 8, с остальными байтами так же), байты НЕ перестанавливаются;"]
Bits = 1 , # [doc = "2: Перестанавливаются и биты, и байты"]
BitsBytes = 2 , # [doc = "3: Биты в байтах НЕ перестанавливаются, байты перестанавливаются (меняются местами байты 3 и 0, 2 и 1);"]
Bytes = 3 , } impl From < Tot > for u8 { # [inline (always)]
fn from (variant : Tot) -> Self { variant as _ } } impl crate :: FieldSpec for Tot { type Ux = u8 ; } impl crate :: IsEnum for Tot { } # [doc = "Field `TOT` reader - Перестановка битов/байтов входных данных"]
pub type TotR = crate :: FieldReader < Tot > ; impl TotR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Tot { match self . bits { 0 => Tot :: None , 1 => Tot :: Bits , 2 => Tot :: BitsBytes , 3 => Tot :: Bytes , _ => unreachable ! () , } } # [doc = "Перестановка выключена"]
# [inline (always)]
pub fn is_none (& self) -> bool { * self == Tot :: None } # [doc = "Биты в байтах перестанавливаются (бит 7 с битом 0, бит 15 с битом 8, с остальными байтами так же), байты НЕ перестанавливаются;"]
# [inline (always)]
pub fn is_bits (& self) -> bool { * self == Tot :: Bits } # [doc = "Перестанавливаются и биты, и байты"]
# [inline (always)]
pub fn is_bits_bytes (& self) -> bool { * self == Tot :: BitsBytes } # [doc = "Биты в байтах НЕ перестанавливаются, байты перестанавливаются (меняются местами байты 3 и 0, 2 и 1);"]
# [inline (always)]
pub fn is_bytes (& self) -> bool { * self == Tot :: Bytes } } # [doc = "Field `TOT` writer - Перестановка битов/байтов входных данных"]
pub type TotW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Tot , crate :: Safe > ; impl < 'a , REG > TotW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Перестановка выключена"]
# [inline (always)]
pub fn none (self) -> & 'a mut crate :: W < REG > { self . variant (Tot :: None) } # [doc = "Биты в байтах перестанавливаются (бит 7 с битом 0, бит 15 с битом 8, с остальными байтами так же), байты НЕ перестанавливаются;"]
# [inline (always)]
pub fn bits_ (self) -> & 'a mut crate :: W < REG > { self . variant (Tot :: Bits) } # [doc = "Перестанавливаются и биты, и байты"]
# [inline (always)]
pub fn bits_bytes (self) -> & 'a mut crate :: W < REG > { self . variant (Tot :: BitsBytes) } # [doc = "Биты в байтах НЕ перестанавливаются, байты перестанавливаются (меняются местами байты 3 и 0, 2 и 1);"]
# [inline (always)]
pub fn bytes (self) -> & 'a mut crate :: W < REG > { self . variant (Tot :: Bytes) } } impl R { # [doc = "Bits 1:2 - Инверсия контрольной суммы. Некоторые протоколы подсчета контрольной суммы требуют инверсии вычисленного значения контрольной суммы (выполняется операция XOR со значением 0xFFFFFFFF)"]
# [inline (always)]
pub fn fxor (& self) -> FxorR { FxorR :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bit 25 - Назначение регистра данных"]
# [inline (always)]
pub fn was (& self) -> WasR { WasR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bit 25 - Бит занятости автомата. После записи в регистр данных слова для вычисления контрольной суммы бит занятости перейдет в состояние единицы через один такт после такта записи. То есть чтение регистра управления, идущее на шине AHB сразу на следующем такте после записи данных, вернет результат с нулевым (еще не обновленным) значением бита Busy"]
# [inline (always)]
pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 25) & 1) != 0) } # [doc = "Bits 28:29 - Перестановки битов/байтов выходных данных"]
# [inline (always)]
pub fn totr (& self) -> TotrR { TotrR :: new (((self . bits >> 28) & 3) as u8) } # [doc = "Bits 30:31 - Перестановка битов/байтов входных данных"]
# [inline (always)]
pub fn tot (& self) -> TotR { TotR :: new (((self . bits >> 30) & 3) as u8) } } impl W { # [doc = "Bits 1:2 - Инверсия контрольной суммы. Некоторые протоколы подсчета контрольной суммы требуют инверсии вычисленного значения контрольной суммы (выполняется операция XOR со значением 0xFFFFFFFF)"]
# [inline (always)]
pub fn fxor (& mut self) -> FxorW < CtrlSpec > { FxorW :: new (self , 1) } # [doc = "Bit 25 - Назначение регистра данных"]
# [inline (always)]
pub fn was (& mut self) -> WasW < CtrlSpec > { WasW :: new (self , 25) } # [doc = "Bits 28:29 - Перестановки битов/байтов выходных данных"]
# [inline (always)]
pub fn totr (& mut self) -> TotrW < CtrlSpec > { TotrW :: new (self , 28) } # [doc = "Bits 30:31 - Перестановка битов/байтов входных данных"]
# [inline (always)]
pub fn tot (& mut self) -> TotW < CtrlSpec > { TotW :: new (self , 30) } } # [doc = "Регистр управления\n\nYou can [`read`](crate::Reg::read) this register and get [`ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CtrlSpec ; impl crate :: RegisterSpec for CtrlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ctrl::R`](R) reader structure"]
impl crate :: Readable for CtrlSpec { } # [doc = "`write(|w| ..)` method takes [`ctrl::W`](W) writer structure"]
impl crate :: Writable for CtrlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CTRL to value 0"]
impl crate :: Resettable for CtrlSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Сторожевой таймер"]
pub struct Wdt { _marker : PhantomData < * const () > } unsafe impl Send for Wdt { } impl Wdt { # [doc = r"Pointer to the register block"]
pub const PTR : * const wdt :: RegisterBlock = 0x0008_1000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const wdt :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Wdt { type Target = wdt :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Wdt { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Wdt") . finish () } } # [doc = "Сторожевой таймер"]
pub mod wdt { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { _reserved0 : [u8 ; 0x84]
, con : Con , _reserved1 : [u8 ; 0x14]
, _reserved_1_key : [u8 ; 0x04]
, } impl RegisterBlock { # [doc = "0x84 - Конфигурация"]
# [inline (always)]
pub const fn con (& self) -> & Con { & self . con } # [doc = "0x9c - Регистр состояния"]
# [inline (always)]
pub const fn sta (& self) -> & Sta { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (156) . cast () } } # [doc = "0x9c - Регистр ключа"]
# [inline (always)]
pub const fn key (& self) -> & Key { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (156) . cast () } } } # [doc = "CON (rw) register accessor: Конфигурация\n\nYou can [`read`](crate::Reg::read) this register and get [`con::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`con::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@con`]
module"]
# [doc (alias = "CON")]
pub type Con = crate :: Reg < con :: ConSpec > ; # [doc = "Конфигурация"]
pub mod con { # [doc = "Register `CON` reader"]
pub type R = crate :: R < ConSpec > ; # [doc = "Register `CON` writer"]
pub type W = crate :: W < ConSpec > ; # [doc = "Field `PRELOAD` reader - Начальное значение таймера при запуске или перезапуске (таймер считает в сторону увеличения значений)"]
pub type PreloadR = crate :: FieldReader < u16 > ; # [doc = "Field `PRELOAD` writer - Начальное значение таймера при запуске или перезапуске (таймер считает в сторону увеличения значений)"]
pub type PreloadW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; # [doc = "Делитель входной частоты (Fclk) для таймера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Prescale { # [doc = "0: Fclk / 1"]
_1 = 0 , # [doc = "1: Fclk / 2"]
_2 = 1 , # [doc = "2: Fclk / 4"]
_4 = 2 , # [doc = "3: Fclk / 16"]
_16 = 3 , # [doc = "4: Fclk / 64"]
_64 = 4 , # [doc = "5: Fclk / 256"]
_256 = 5 , # [doc = "6: Fclk / 1024"]
_1024 = 6 , # [doc = "7: Fclk / 4096"]
_4096 = 7 , } impl From < Prescale > for u8 { # [inline (always)]
fn from (variant : Prescale) -> Self { variant as _ } } impl crate :: FieldSpec for Prescale { type Ux = u8 ; } impl crate :: IsEnum for Prescale { } # [doc = "Field `PRESCALE` reader - Делитель входной частоты (Fclk) для таймера"]
pub type PrescaleR = crate :: FieldReader < Prescale > ; impl PrescaleR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Prescale { match self . bits { 0 => Prescale :: _1 , 1 => Prescale :: _2 , 2 => Prescale :: _4 , 3 => Prescale :: _16 , 4 => Prescale :: _64 , 5 => Prescale :: _256 , 6 => Prescale :: _1024 , 7 => Prescale :: _4096 , _ => unreachable ! () , } } # [doc = "Fclk / 1"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Prescale :: _1 } # [doc = "Fclk / 2"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == Prescale :: _2 } # [doc = "Fclk / 4"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == Prescale :: _4 } # [doc = "Fclk / 16"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == Prescale :: _16 } # [doc = "Fclk / 64"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == Prescale :: _64 } # [doc = "Fclk / 256"]
# [inline (always)]
pub fn is_256 (& self) -> bool { * self == Prescale :: _256 } # [doc = "Fclk / 1024"]
# [inline (always)]
pub fn is_1024 (& self) -> bool { * self == Prescale :: _1024 } # [doc = "Fclk / 4096"]
# [inline (always)]
pub fn is_4096 (& self) -> bool { * self == Prescale :: _4096 } } # [doc = "Field `PRESCALE` writer - Делитель входной частоты (Fclk) для таймера"]
pub type PrescaleW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Prescale , crate :: Safe > ; impl < 'a , REG > PrescaleW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Fclk / 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Prescale :: _1) } # [doc = "Fclk / 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut crate :: W < REG > { self . variant (Prescale :: _2) } # [doc = "Fclk / 4"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut crate :: W < REG > { self . variant (Prescale :: _4) } # [doc = "Fclk / 16"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut crate :: W < REG > { self . variant (Prescale :: _16) } # [doc = "Fclk / 64"]
# [inline (always)]
pub fn _64 (self) -> & 'a mut crate :: W < REG > { self . variant (Prescale :: _64) } # [doc = "Fclk / 256"]
# [inline (always)]
pub fn _256 (self) -> & 'a mut crate :: W < REG > { self . variant (Prescale :: _256) } # [doc = "Fclk / 1024"]
# [inline (always)]
pub fn _1024 (self) -> & 'a mut crate :: W < REG > { self . variant (Prescale :: _1024) } # [doc = "Fclk / 4096"]
# [inline (always)]
pub fn _4096 (self) -> & 'a mut crate :: W < REG > { self . variant (Prescale :: _4096) } } impl R { # [doc = "Bits 0:11 - Начальное значение таймера при запуске или перезапуске (таймер считает в сторону увеличения значений)"]
# [inline (always)]
pub fn preload (& self) -> PreloadR { PreloadR :: new ((self . bits & 0x0fff) as u16) } # [doc = "Bits 12:14 - Делитель входной частоты (Fclk) для таймера"]
# [inline (always)]
pub fn prescale (& self) -> PrescaleR { PrescaleR :: new (((self . bits >> 12) & 7) as u8) } } impl W { # [doc = "Bits 0:11 - Начальное значение таймера при запуске или перезапуске (таймер считает в сторону увеличения значений)"]
# [inline (always)]
pub fn preload (& mut self) -> PreloadW < ConSpec > { PreloadW :: new (self , 0) } # [doc = "Bits 12:14 - Делитель входной частоты (Fclk) для таймера"]
# [inline (always)]
pub fn prescale (& mut self) -> PrescaleW < ConSpec > { PrescaleW :: new (self , 12) } } # [doc = "Конфигурация\n\nYou can [`read`](crate::Reg::read) this register and get [`con::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`con::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ConSpec ; impl crate :: RegisterSpec for ConSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`con::R`](R) reader structure"]
impl crate :: Readable for ConSpec { } # [doc = "`write(|w| ..)` method takes [`con::W`](W) writer structure"]
impl crate :: Writable for ConSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CON to value 0"]
impl crate :: Resettable for ConSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "KEY (w) register accessor: Регистр ключа\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`key::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@key`]
module"]
# [doc (alias = "KEY")]
pub type Key = crate :: Reg < key :: KeySpec > ; # [doc = "Регистр ключа"]
pub mod key { # [doc = "Register `KEY` writer"]
pub type W = crate :: W < KeySpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < KeySpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Регистр ключа\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`key::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct KeySpec ; impl crate :: RegisterSpec for KeySpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`key::W`](W) writer structure"]
impl crate :: Writable for KeySpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets KEY to value 0"]
impl crate :: Resettable for KeySpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "STA (r) register accessor: Регистр состояния\n\nYou can [`read`](crate::Reg::read) this register and get [`sta::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sta`]
module"]
# [doc (alias = "STA")]
pub type Sta = crate :: Reg < sta :: StaSpec > ; # [doc = "Регистр состояния"]
pub mod sta { # [doc = "Register `STA` reader"]
pub type R = crate :: R < StaSpec > ; # [doc = "Бит активности таймера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timerenabled { # [doc = "0: Таймер остановлен"]
Disable = 0 , # [doc = "1: Таймер запущен"]
Enable = 1 , } impl From < Timerenabled > for bool { # [inline (always)]
fn from (variant : Timerenabled) -> Self { variant as u8 != 0 } } # [doc = "Field `TIMERENABLED` reader - Бит активности таймера"]
pub type TimerenabledR = crate :: BitReader < Timerenabled > ; impl TimerenabledR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timerenabled { match self . bits { false => Timerenabled :: Disable , true => Timerenabled :: Enable , } } # [doc = "Таймер остановлен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Timerenabled :: Disable } # [doc = "Таймер запущен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Timerenabled :: Enable } } # [doc = "Бит перезагрузки значения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timerloading { # [doc = "0: Перезагрузка значения таймера в данный момент не выполняется (завершена)"]
ReloadingComplete = 0 , # [doc = "1: Выполняется перезагрузка значения в таймере"]
Reloading = 1 , } impl From < Timerloading > for bool { # [inline (always)]
fn from (variant : Timerloading) -> Self { variant as u8 != 0 } } # [doc = "Field `TIMERLOADING` reader - Бит перезагрузки значения"]
pub type TimerloadingR = crate :: BitReader < Timerloading > ; impl TimerloadingR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timerloading { match self . bits { false => Timerloading :: ReloadingComplete , true => Timerloading :: Reloading , } } # [doc = "Перезагрузка значения таймера в данный момент не выполняется (завершена)"]
# [inline (always)]
pub fn is_reloading_complete (& self) -> bool { * self == Timerloading :: ReloadingComplete } # [doc = "Выполняется перезагрузка значения в таймере"]
# [inline (always)]
pub fn is_reloading (& self) -> bool { * self == Timerloading :: Reloading } } # [doc = "Field `WDT_RST_FLAG` reader - Флаг генерации сброса сторожевым таймером. Сбрасывается в 0 только при снятии и последующей подаче питания"]
pub type WdtRstFlagR = crate :: BitReader ; impl R { # [doc = "Bit 0 - Бит активности таймера"]
# [inline (always)]
pub fn timerenabled (& self) -> TimerenabledR { TimerenabledR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Бит перезагрузки значения"]
# [inline (always)]
pub fn timerloading (& self) -> TimerloadingR { TimerloadingR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 8 - Флаг генерации сброса сторожевым таймером. Сбрасывается в 0 только при снятии и последующей подаче питания"]
# [inline (always)]
pub fn wdt_rst_flag (& self) -> WdtRstFlagR { WdtRstFlagR :: new (((self . bits >> 8) & 1) != 0) } } # [doc = "Регистр состояния\n\nYou can [`read`](crate::Reg::read) this register and get [`sta::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StaSpec ; impl crate :: RegisterSpec for StaSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sta::R`](R) reader structure"]
impl crate :: Readable for StaSpec { } # [doc = "`reset()` method sets STA to value 0"]
impl crate :: Resettable for StaSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "приемо-передатчик"]
pub struct Usart0 { _marker : PhantomData < * const () > } unsafe impl Send for Usart0 { } impl Usart0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart_0 :: RegisterBlock = 0x0008_1400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart_0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Usart0 { type Target = usart_0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Usart0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usart0") . finish () } } # [doc = "приемо-передатчик"]
pub mod usart_0 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { control1 : Control1 , control2 : Control2 , control3 : Control3 , divider : Divider , _reserved4 : [u8 ; 0x0c]
, flags : Flags , _reserved5 : [u8 ; 0x04]
, rxdata : Rxdata , txdata : Txdata , modem : Modem , } impl RegisterBlock { # [doc = "0x00 - Регистр управления 1"]
# [inline (always)]
pub const fn control1 (& self) -> & Control1 { & self . control1 } # [doc = "0x04 - Регистр управления 2"]
# [inline (always)]
pub const fn control2 (& self) -> & Control2 { & self . control2 } # [doc = "0x08 - Регистр управления 3"]
# [inline (always)]
pub const fn control3 (& self) -> & Control3 { & self . control3 } # [doc = "0x0c - Регистр настройки делителя"]
# [inline (always)]
pub const fn divider (& self) -> & Divider { & self . divider } # [doc = "0x1c - Регистр прерываний"]
# [inline (always)]
pub const fn flags (& self) -> & Flags { & self . flags } # [doc = "0x24 - Регистр принятых данных"]
# [inline (always)]
pub const fn rxdata (& self) -> & Rxdata { & self . rxdata } # [doc = "0x28 - Регистр передаваемых данных"]
# [inline (always)]
pub const fn txdata (& self) -> & Txdata { & self . txdata } # [doc = "0x2c - Регистр управления модемом"]
# [inline (always)]
pub const fn modem (& self) -> & Modem { & self . modem } } # [doc = "CONTROL1 (rw) register accessor: Регистр управления 1\n\nYou can [`read`](crate::Reg::read) this register and get [`control1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control1`]
module"]
# [doc (alias = "CONTROL1")]
pub type Control1 = crate :: Reg < control1 :: Control1Spec > ; # [doc = "Регистр управления 1"]
pub mod control1 { # [doc = "Register `CONTROL1` reader"]
pub type R = crate :: R < Control1Spec > ; # [doc = "Register `CONTROL1` writer"]
pub type W = crate :: W < Control1Spec > ; # [doc = "Ресет USART. Отменяет все текущие операции. Не очищает регистры конфигурации, но сбрасывает флаги\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ue { # [doc = "0: USART выключен"]
Disable = 0 , # [doc = "1: USART включен"]
Enable = 1 , } impl From < Ue > for bool { # [inline (always)]
fn from (variant : Ue) -> Self { variant as u8 != 0 } } # [doc = "Field `UE` reader - Ресет USART. Отменяет все текущие операции. Не очищает регистры конфигурации, но сбрасывает флаги"]
pub type UeR = crate :: BitReader < Ue > ; impl UeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ue { match self . bits { false => Ue :: Disable , true => Ue :: Enable , } } # [doc = "USART выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Ue :: Disable } # [doc = "USART включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Ue :: Enable } } # [doc = "Field `UE` writer - Ресет USART. Отменяет все текущие операции. Не очищает регистры конфигурации, но сбрасывает флаги"]
pub type UeW < 'a , REG > = crate :: BitWriter < 'a , REG , Ue > ; impl < 'a , REG > UeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "USART выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Ue :: Disable) } # [doc = "USART включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Ue :: Enable) } } # [doc = "Управление приемником\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Re { # [doc = "0: Приемник выключен"]
Disable = 0 , # [doc = "1: Приемник включен"]
Enable = 1 , } impl From < Re > for bool { # [inline (always)]
fn from (variant : Re) -> Self { variant as u8 != 0 } } # [doc = "Field `RE` reader - Управление приемником"]
pub type ReR = crate :: BitReader < Re > ; impl ReR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Re { match self . bits { false => Re :: Disable , true => Re :: Enable , } } # [doc = "Приемник выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Re :: Disable } # [doc = "Приемник включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Re :: Enable } } # [doc = "Field `RE` writer - Управление приемником"]
pub type ReW < 'a , REG > = crate :: BitWriter < 'a , REG , Re > ; impl < 'a , REG > ReW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Приемник выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Re :: Disable) } # [doc = "Приемник включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Re :: Enable) } } # [doc = "Управление передатчиком\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Te { # [doc = "0: Передатчик выключен"]
Disable = 0 , # [doc = "1: Передатчик включен"]
Enable = 1 , } impl From < Te > for bool { # [inline (always)]
fn from (variant : Te) -> Self { variant as u8 != 0 } } # [doc = "Field `TE` reader - Управление передатчиком"]
pub type TeR = crate :: BitReader < Te > ; impl TeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Te { match self . bits { false => Te :: Disable , true => Te :: Enable , } } # [doc = "Передатчик выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Te :: Disable } # [doc = "Передатчик включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Te :: Enable } } # [doc = "Field `TE` writer - Управление передатчиком"]
pub type TeW < 'a , REG > = crate :: BitWriter < 'a , REG , Te > ; impl < 'a , REG > TeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Передатчик выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Te :: Disable) } # [doc = "Передатчик включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Te :: Enable) } } # [doc = "Управление прерыванием при отсутствии входных транзакций\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Idleie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Idleie > for bool { # [inline (always)]
fn from (variant : Idleie) -> Self { variant as u8 != 0 } } # [doc = "Field `IDLEIE` reader - Управление прерыванием при отсутствии входных транзакций"]
pub type IdleieR = crate :: BitReader < Idleie > ; impl IdleieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Idleie { match self . bits { false => Idleie :: Disable , true => Idleie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Idleie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Idleie :: Enable } } # [doc = "Field `IDLEIE` writer - Управление прерыванием при отсутствии входных транзакций"]
pub type IdleieW < 'a , REG > = crate :: BitWriter < 'a , REG , Idleie > ; impl < 'a , REG > IdleieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Idleie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Idleie :: Enable) } } # [doc = "Управление прерыванием при успешном приеме данных или перезаписи полученных данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rxneie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Rxneie > for bool { # [inline (always)]
fn from (variant : Rxneie) -> Self { variant as u8 != 0 } } # [doc = "Field `RXNEIE` reader - Управление прерыванием при успешном приеме данных или перезаписи полученных данных"]
pub type RxneieR = crate :: BitReader < Rxneie > ; impl RxneieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rxneie { match self . bits { false => Rxneie :: Disable , true => Rxneie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Rxneie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Rxneie :: Enable } } # [doc = "Field `RXNEIE` writer - Управление прерыванием при успешном приеме данных или перезаписи полученных данных"]
pub type RxneieW < 'a , REG > = crate :: BitWriter < 'a , REG , Rxneie > ; impl < 'a , REG > RxneieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxneie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxneie :: Enable) } } # [doc = "Управление прерыванием при успешной передаче данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Tcie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Tcie > for bool { # [inline (always)]
fn from (variant : Tcie) -> Self { variant as u8 != 0 } } # [doc = "Field `TCIE` reader - Управление прерыванием при успешной передаче данных"]
pub type TcieR = crate :: BitReader < Tcie > ; impl TcieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Tcie { match self . bits { false => Tcie :: Disable , true => Tcie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Tcie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Tcie :: Enable } } # [doc = "Field `TCIE` writer - Управление прерыванием при успешной передаче данных"]
pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG , Tcie > ; impl < 'a , REG > TcieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Enable) } } # [doc = "Управление прерыванием при передаче данных в момент записи данных в сдвиговый регистр\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Txeie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Txeie > for bool { # [inline (always)]
fn from (variant : Txeie) -> Self { variant as u8 != 0 } } # [doc = "Field `TXEIE` reader - Управление прерыванием при передаче данных в момент записи данных в сдвиговый регистр"]
pub type TxeieR = crate :: BitReader < Txeie > ; impl TxeieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Txeie { match self . bits { false => Txeie :: Disable , true => Txeie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Txeie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Txeie :: Enable } } # [doc = "Field `TXEIE` writer - Управление прерыванием при передаче данных в момент записи данных в сдвиговый регистр"]
pub type TxeieW < 'a , REG > = crate :: BitWriter < 'a , REG , Txeie > ; impl < 'a , REG > TxeieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Txeie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Txeie :: Enable) } } # [doc = "Управление прерыванием при ошибке в принятом бите четности\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Peie { # [doc = "0: Прерывание по ошибке в бите четности выключено"]
Disable = 0 , # [doc = "1: Прерывание по ошибке в бите четности включено"]
Enable = 1 , } impl From < Peie > for bool { # [inline (always)]
fn from (variant : Peie) -> Self { variant as u8 != 0 } } # [doc = "Field `PEIE` reader - Управление прерыванием при ошибке в принятом бите четности"]
pub type PeieR = crate :: BitReader < Peie > ; impl PeieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Peie { match self . bits { false => Peie :: Disable , true => Peie :: Enable , } } # [doc = "Прерывание по ошибке в бите четности выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Peie :: Disable } # [doc = "Прерывание по ошибке в бите четности включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Peie :: Enable } } # [doc = "Field `PEIE` writer - Управление прерыванием при ошибке в принятом бите четности"]
pub type PeieW < 'a , REG > = crate :: BitWriter < 'a , REG , Peie > ; impl < 'a , REG > PeieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по ошибке в бите четности выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Peie :: Disable) } # [doc = "Прерывание по ошибке в бите четности включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Peie :: Enable) } } # [doc = "Выбор способа формирования бита четности. Примечание: Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ps { # [doc = "0: Бит четности"]
Parity = 0 , # [doc = "1: Бит нечетности"]
Odd = 1 , } impl From < Ps > for bool { # [inline (always)]
fn from (variant : Ps) -> Self { variant as u8 != 0 } } # [doc = "Field `PS` reader - Выбор способа формирования бита четности. Примечание: Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type PsR = crate :: BitReader < Ps > ; impl PsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ps { match self . bits { false => Ps :: Parity , true => Ps :: Odd , } } # [doc = "Бит четности"]
# [inline (always)]
pub fn is_parity (& self) -> bool { * self == Ps :: Parity } # [doc = "Бит нечетности"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == Ps :: Odd } } # [doc = "Field `PS` writer - Выбор способа формирования бита четности. Примечание: Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type PsW < 'a , REG > = crate :: BitWriter < 'a , REG , Ps > ; impl < 'a , REG > PsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Бит четности"]
# [inline (always)]
pub fn parity (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Parity) } # [doc = "Бит нечетности"]
# [inline (always)]
pub fn odd (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Odd) } } # [doc = "Контроль четности. Примечание: Этот бит может быть изме-нен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pce { # [doc = "0: Контроль четности выключен"]
Disable = 0 , # [doc = "1: Контроль четности включен"]
Enable = 1 , } impl From < Pce > for bool { # [inline (always)]
fn from (variant : Pce) -> Self { variant as u8 != 0 } } # [doc = "Field `PCE` reader - Контроль четности. Примечание: Этот бит может быть изме-нен только при остановке работы (UE=0)"]
pub type PceR = crate :: BitReader < Pce > ; impl PceR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pce { match self . bits { false => Pce :: Disable , true => Pce :: Enable , } } # [doc = "Контроль четности выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Pce :: Disable } # [doc = "Контроль четности включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Pce :: Enable } } # [doc = "Field `PCE` writer - Контроль четности. Примечание: Этот бит может быть изме-нен только при остановке работы (UE=0)"]
pub type PceW < 'a , REG > = crate :: BitWriter < 'a , REG , Pce > ; impl < 'a , REG > PceW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Контроль четности выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Pce :: Disable) } # [doc = "Контроль четности включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Pce :: Enable) } } # [doc = "M1\\[28\\]
и M0\\[12\\]
управляют длиной кадра. Примечание: Эти биты можгут быть изменены только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u32)]
pub enum M { # [doc = "0: 8 бит данных"]
_8bits = 0 , # [doc = "1: 9 бит данных"]
_9bits = 1 , # [doc = "65536: 7 бит данных"]
_7bits = 65536 , } impl From < M > for u32 { # [inline (always)]
fn from (variant : M) -> Self { variant as _ } } impl crate :: FieldSpec for M { type Ux = u32 ; } impl crate :: IsEnum for M { } # [doc = "Field `M` reader - M1\\[28\\]
и M0\\[12\\]
управляют длиной кадра. Примечание: Эти биты можгут быть изменены только при остановке работы (UE=0)"]
pub type MR = crate :: FieldReader < M > ; impl MR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < M > { match self . bits { 0 => Some (M :: _8bits) , 1 => Some (M :: _9bits) , 65536 => Some (M :: _7bits) , _ => None , } } # [doc = "8 бит данных"]
# [inline (always)]
pub fn is_8bits (& self) -> bool { * self == M :: _8bits } # [doc = "9 бит данных"]
# [inline (always)]
pub fn is_9bits (& self) -> bool { * self == M :: _9bits } # [doc = "7 бит данных"]
# [inline (always)]
pub fn is_7bits (& self) -> bool { * self == M :: _7bits } } # [doc = "Field `M` writer - M1\\[28\\]
и M0\\[12\\]
управляют длиной кадра. Примечание: Эти биты можгут быть изменены только при остановке работы (UE=0)"]
pub type MW < 'a , REG > = crate :: FieldWriter < 'a , REG , 17 , M > ; impl < 'a , REG > MW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u32 > { # [doc = "8 бит данных"]
# [inline (always)]
pub fn _8bits (self) -> & 'a mut crate :: W < REG > { self . variant (M :: _8bits) } # [doc = "9 бит данных"]
# [inline (always)]
pub fn _9bits (self) -> & 'a mut crate :: W < REG > { self . variant (M :: _9bits) } # [doc = "7 бит данных"]
# [inline (always)]
pub fn _7bits (self) -> & 'a mut crate :: W < REG > { self . variant (M :: _7bits) } } impl R { # [doc = "Bit 0 - Ресет USART. Отменяет все текущие операции. Не очищает регистры конфигурации, но сбрасывает флаги"]
# [inline (always)]
pub fn ue (& self) -> UeR { UeR :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Управление приемником"]
# [inline (always)]
pub fn re (& self) -> ReR { ReR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Управление передатчиком"]
# [inline (always)]
pub fn te (& self) -> TeR { TeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Управление прерыванием при отсутствии входных транзакций"]
# [inline (always)]
pub fn idleie (& self) -> IdleieR { IdleieR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Управление прерыванием при успешном приеме данных или перезаписи полученных данных"]
# [inline (always)]
pub fn rxneie (& self) -> RxneieR { RxneieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Управление прерыванием при успешной передаче данных"]
# [inline (always)]
pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Управление прерыванием при передаче данных в момент записи данных в сдвиговый регистр"]
# [inline (always)]
pub fn txeie (& self) -> TxeieR { TxeieR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Управление прерыванием при ошибке в принятом бите четности"]
# [inline (always)]
pub fn peie (& self) -> PeieR { PeieR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Выбор способа формирования бита четности. Примечание: Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ps (& self) -> PsR { PsR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Контроль четности. Примечание: Этот бит может быть изме-нен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn pce (& self) -> PceR { PceR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bits 12:28 - M1\\[28\\]
и M0\\[12\\]
управляют длиной кадра. Примечание: Эти биты можгут быть изменены только при остановке работы (UE=0)"]
# [inline (always)]
pub fn m (& self) -> MR { MR :: new ((self . bits >> 12) & 0x0001_ffff) } } impl W { # [doc = "Bit 0 - Ресет USART. Отменяет все текущие операции. Не очищает регистры конфигурации, но сбрасывает флаги"]
# [inline (always)]
pub fn ue (& mut self) -> UeW < Control1Spec > { UeW :: new (self , 0) } # [doc = "Bit 2 - Управление приемником"]
# [inline (always)]
pub fn re (& mut self) -> ReW < Control1Spec > { ReW :: new (self , 2) } # [doc = "Bit 3 - Управление передатчиком"]
# [inline (always)]
pub fn te (& mut self) -> TeW < Control1Spec > { TeW :: new (self , 3) } # [doc = "Bit 4 - Управление прерыванием при отсутствии входных транзакций"]
# [inline (always)]
pub fn idleie (& mut self) -> IdleieW < Control1Spec > { IdleieW :: new (self , 4) } # [doc = "Bit 5 - Управление прерыванием при успешном приеме данных или перезаписи полученных данных"]
# [inline (always)]
pub fn rxneie (& mut self) -> RxneieW < Control1Spec > { RxneieW :: new (self , 5) } # [doc = "Bit 6 - Управление прерыванием при успешной передаче данных"]
# [inline (always)]
pub fn tcie (& mut self) -> TcieW < Control1Spec > { TcieW :: new (self , 6) } # [doc = "Bit 7 - Управление прерыванием при передаче данных в момент записи данных в сдвиговый регистр"]
# [inline (always)]
pub fn txeie (& mut self) -> TxeieW < Control1Spec > { TxeieW :: new (self , 7) } # [doc = "Bit 8 - Управление прерыванием при ошибке в принятом бите четности"]
# [inline (always)]
pub fn peie (& mut self) -> PeieW < Control1Spec > { PeieW :: new (self , 8) } # [doc = "Bit 9 - Выбор способа формирования бита четности. Примечание: Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ps (& mut self) -> PsW < Control1Spec > { PsW :: new (self , 9) } # [doc = "Bit 10 - Контроль четности. Примечание: Этот бит может быть изме-нен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn pce (& mut self) -> PceW < Control1Spec > { PceW :: new (self , 10) } # [doc = "Bits 12:28 - M1\\[28\\]
и M0\\[12\\]
управляют длиной кадра. Примечание: Эти биты можгут быть изменены только при остановке работы (UE=0)"]
# [inline (always)]
pub fn m (& mut self) -> MW < Control1Spec > { MW :: new (self , 12) } } # [doc = "Регистр управления 1\n\nYou can [`read`](crate::Reg::read) this register and get [`control1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Control1Spec ; impl crate :: RegisterSpec for Control1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`control1::R`](R) reader structure"]
impl crate :: Readable for Control1Spec { } # [doc = "`write(|w| ..)` method takes [`control1::W`](W) writer structure"]
impl crate :: Writable for Control1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL1 to value 0"]
impl crate :: Resettable for Control1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONTROL2 (rw) register accessor: Регистр управления 2\n\nYou can [`read`](crate::Reg::read) this register and get [`control2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control2`]
module"]
# [doc (alias = "CONTROL2")]
pub type Control2 = crate :: Reg < control2 :: Control2Spec > ; # [doc = "Регистр управления 2"]
pub mod control2 { # [doc = "Register `CONTROL2` reader"]
pub type R = crate :: R < Control2Spec > ; # [doc = "Register `CONTROL2` writer"]
pub type W = crate :: W < Control2Spec > ; # [doc = "Управление прерыванием при обнаружении break состояния на RX линии\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Lbdie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Lbdie > for bool { # [inline (always)]
fn from (variant : Lbdie) -> Self { variant as u8 != 0 } } # [doc = "Field `LBDIE` reader - Управление прерыванием при обнаружении break состояния на RX линии"]
pub type LbdieR = crate :: BitReader < Lbdie > ; impl LbdieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Lbdie { match self . bits { false => Lbdie :: Disable , true => Lbdie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Lbdie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Lbdie :: Enable } } # [doc = "Field `LBDIE` writer - Управление прерыванием при обнаружении break состояния на RX линии"]
pub type LbdieW < 'a , REG > = crate :: BitWriter < 'a , REG , Lbdie > ; impl < 'a , REG > LbdieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Lbdie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Lbdie :: Enable) } } # [doc = "Управление последним тактовым импульсом. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Lbcl { # [doc = "0: Последний тактовый импульс отсутствует"]
_0 = 0 , # [doc = "1: Последний тактовый импульс присутствует."]
_1 = 1 , } impl From < Lbcl > for bool { # [inline (always)]
fn from (variant : Lbcl) -> Self { variant as u8 != 0 } } # [doc = "Field `LBCL` reader - Управление последним тактовым импульсом. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type LbclR = crate :: BitReader < Lbcl > ; impl LbclR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Lbcl { match self . bits { false => Lbcl :: _0 , true => Lbcl :: _1 , } } # [doc = "Последний тактовый импульс отсутствует"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Lbcl :: _0 } # [doc = "Последний тактовый импульс присутствует."]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Lbcl :: _1 } } # [doc = "Field `LBCL` writer - Управление последним тактовым импульсом. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type LbclW < 'a , REG > = crate :: BitWriter < 'a , REG , Lbcl > ; impl < 'a , REG > LbclW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Последний тактовый импульс отсутствует"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Lbcl :: _0) } # [doc = "Последний тактовый импульс присутствует."]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Lbcl :: _1) } } # [doc = "Управление фазой выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cpha { # [doc = "0: Первое изменение тактового сигнала – фронт"]
_0 = 0 , # [doc = "1: Первое изменение тактового сигнала – срез (обратный фронт)."]
_1 = 1 , } impl From < Cpha > for bool { # [inline (always)]
fn from (variant : Cpha) -> Self { variant as u8 != 0 } } # [doc = "Field `CPHA` reader - Управление фазой выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type CphaR = crate :: BitReader < Cpha > ; impl CphaR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cpha { match self . bits { false => Cpha :: _0 , true => Cpha :: _1 , } } # [doc = "Первое изменение тактового сигнала – фронт"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Cpha :: _0 } # [doc = "Первое изменение тактового сигнала – срез (обратный фронт)."]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Cpha :: _1 } } # [doc = "Field `CPHA` writer - Управление фазой выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type CphaW < 'a , REG > = crate :: BitWriter < 'a , REG , Cpha > ; impl < 'a , REG > CphaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Первое изменение тактового сигнала – фронт"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpha :: _0) } # [doc = "Первое изменение тактового сигнала – срез (обратный фронт)."]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpha :: _1) } } # [doc = "Управление полярностью выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cpol { # [doc = "0: Логический «0» вне транзакции"]
_0 = 0 , # [doc = "1: Логическая «1» вне транзакции"]
_1 = 1 , } impl From < Cpol > for bool { # [inline (always)]
fn from (variant : Cpol) -> Self { variant as u8 != 0 } } # [doc = "Field `CPOL` reader - Управление полярностью выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type CpolR = crate :: BitReader < Cpol > ; impl CpolR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cpol { match self . bits { false => Cpol :: _0 , true => Cpol :: _1 , } } # [doc = "Логический «0» вне транзакции"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Cpol :: _0 } # [doc = "Логическая «1» вне транзакции"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Cpol :: _1 } } # [doc = "Field `CPOL` writer - Управление полярностью выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type CpolW < 'a , REG > = crate :: BitWriter < 'a , REG , Cpol > ; impl < 'a , REG > CpolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Логический «0» вне транзакции"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpol :: _0) } # [doc = "Логическая «1» вне транзакции"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpol :: _1) } } # [doc = "Управление синхронным режимом. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Clken { # [doc = "0: Синхронный режим выключен"]
Asynchronous = 0 , # [doc = "1: Синхронный режим включен"]
Synchronous = 1 , } impl From < Clken > for bool { # [inline (always)]
fn from (variant : Clken) -> Self { variant as u8 != 0 } } # [doc = "Field `CLKEN` reader - Управление синхронным режимом. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type ClkenR = crate :: BitReader < Clken > ; impl ClkenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Clken { match self . bits { false => Clken :: Asynchronous , true => Clken :: Synchronous , } } # [doc = "Синхронный режим выключен"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == Clken :: Asynchronous } # [doc = "Синхронный режим включен"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == Clken :: Synchronous } } # [doc = "Field `CLKEN` writer - Управление синхронным режимом. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type ClkenW < 'a , REG > = crate :: BitWriter < 'a , REG , Clken > ; impl < 'a , REG > ClkenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Синхронный режим выключен"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut crate :: W < REG > { self . variant (Clken :: Asynchronous) } # [doc = "Синхронный режим включен"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut crate :: W < REG > { self . variant (Clken :: Synchronous) } } # [doc = "Количество стоп битов для приемника и передатчика. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Stop1 { # [doc = "0: 1 стоп бит"]
_1bit = 0 , # [doc = "1: 2 стоп бита"]
_2bits = 1 , } impl From < Stop1 > for bool { # [inline (always)]
fn from (variant : Stop1) -> Self { variant as u8 != 0 } } # [doc = "Field `STOP_1` reader - Количество стоп битов для приемника и передатчика. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type Stop1R = crate :: BitReader < Stop1 > ; impl Stop1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Stop1 { match self . bits { false => Stop1 :: _1bit , true => Stop1 :: _2bits , } } # [doc = "1 стоп бит"]
# [inline (always)]
pub fn is_1bit (& self) -> bool { * self == Stop1 :: _1bit } # [doc = "2 стоп бита"]
# [inline (always)]
pub fn is_2bits (& self) -> bool { * self == Stop1 :: _2bits } } # [doc = "Field `STOP_1` writer - Количество стоп битов для приемника и передатчика. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type Stop1W < 'a , REG > = crate :: BitWriter < 'a , REG , Stop1 > ; impl < 'a , REG > Stop1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "1 стоп бит"]
# [inline (always)]
pub fn _1bit (self) -> & 'a mut crate :: W < REG > { self . variant (Stop1 :: _1bit) } # [doc = "2 стоп бита"]
# [inline (always)]
pub fn _2bits (self) -> & 'a mut crate :: W < REG > { self . variant (Stop1 :: _2bits) } } # [doc = "Регистр режима обратной внутренней петли. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Lbm { # [doc = "0: Обычное функционирование"]
Normal = 0 , # [doc = "1: Сигналы TX и RTS подаются внутрь блока в обход входов RX и CTS. При этом TX = 1 и RTS = 1, входы RX и CTS не активны"]
Loopback = 1 , } impl From < Lbm > for bool { # [inline (always)]
fn from (variant : Lbm) -> Self { variant as u8 != 0 } } # [doc = "Field `LBM` reader - Регистр режима обратной внутренней петли. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type LbmR = crate :: BitReader < Lbm > ; impl LbmR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Lbm { match self . bits { false => Lbm :: Normal , true => Lbm :: Loopback , } } # [doc = "Обычное функционирование"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == Lbm :: Normal } # [doc = "Сигналы TX и RTS подаются внутрь блока в обход входов RX и CTS. При этом TX = 1 и RTS = 1, входы RX и CTS не активны"]
# [inline (always)]
pub fn is_loopback (& self) -> bool { * self == Lbm :: Loopback } } # [doc = "Field `LBM` writer - Регистр режима обратной внутренней петли. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type LbmW < 'a , REG > = crate :: BitWriter < 'a , REG , Lbm > ; impl < 'a , REG > LbmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычное функционирование"]
# [inline (always)]
pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Lbm :: Normal) } # [doc = "Сигналы TX и RTS подаются внутрь блока в обход входов RX и CTS. При этом TX = 1 и RTS = 1, входы RX и CTS не активны"]
# [inline (always)]
pub fn loopback (self) -> & 'a mut crate :: W < REG > { self . variant (Lbm :: Loopback) } } # [doc = "Обмен функциями TX выхода и RX входа. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Swap { # [doc = "0: Обычное функционирование"]
Normal = 0 , # [doc = "1: Обмен функциями (TX = RX и RX = TX)."]
Swap = 1 , } impl From < Swap > for bool { # [inline (always)]
fn from (variant : Swap) -> Self { variant as u8 != 0 } } # [doc = "Field `SWAP` reader - Обмен функциями TX выхода и RX входа. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type SwapR = crate :: BitReader < Swap > ; impl SwapR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Swap { match self . bits { false => Swap :: Normal , true => Swap :: Swap , } } # [doc = "Обычное функционирование"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == Swap :: Normal } # [doc = "Обмен функциями (TX = RX и RX = TX)."]
# [inline (always)]
pub fn is_swap (& self) -> bool { * self == Swap :: Swap } } # [doc = "Field `SWAP` writer - Обмен функциями TX выхода и RX входа. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type SwapW < 'a , REG > = crate :: BitWriter < 'a , REG , Swap > ; impl < 'a , REG > SwapW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычное функционирование"]
# [inline (always)]
pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Swap :: Normal) } # [doc = "Обмен функциями (TX = RX и RX = TX)."]
# [inline (always)]
pub fn swap (self) -> & 'a mut crate :: W < REG > { self . variant (Swap :: Swap) } } # [doc = "Управление полярностью RX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rxinv { # [doc = "0: Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
Direct = 0 , # [doc = "1: Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
Inverted = 1 , } impl From < Rxinv > for bool { # [inline (always)]
fn from (variant : Rxinv) -> Self { variant as u8 != 0 } } # [doc = "Field `RXINV` reader - Управление полярностью RX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type RxinvR = crate :: BitReader < Rxinv > ; impl RxinvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rxinv { match self . bits { false => Rxinv :: Direct , true => Rxinv :: Inverted , } } # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == Rxinv :: Direct } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == Rxinv :: Inverted } } # [doc = "Field `RXINV` writer - Управление полярностью RX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type RxinvW < 'a , REG > = crate :: BitWriter < 'a , REG , Rxinv > ; impl < 'a , REG > RxinvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (Rxinv :: Direct) } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (Rxinv :: Inverted) } } # [doc = "Управление полярностью TX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Txinv { # [doc = "0: Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
Direct = 0 , # [doc = "1: Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
Inverted = 1 , } impl From < Txinv > for bool { # [inline (always)]
fn from (variant : Txinv) -> Self { variant as u8 != 0 } } # [doc = "Field `TXINV` reader - Управление полярностью TX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type TxinvR = crate :: BitReader < Txinv > ; impl TxinvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Txinv { match self . bits { false => Txinv :: Direct , true => Txinv :: Inverted , } } # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == Txinv :: Direct } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == Txinv :: Inverted } } # [doc = "Field `TXINV` writer - Управление полярностью TX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type TxinvW < 'a , REG > = crate :: BitWriter < 'a , REG , Txinv > ; impl < 'a , REG > TxinvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (Txinv :: Direct) } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (Txinv :: Inverted) } } # [doc = "Управление полярностью принимаемых и передаваемых данных. Изменение полярности не влияет на бит четности. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Datainv { # [doc = "0: Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
Direct = 0 , # [doc = "1: Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
Inverted = 1 , } impl From < Datainv > for bool { # [inline (always)]
fn from (variant : Datainv) -> Self { variant as u8 != 0 } } # [doc = "Field `DATAINV` reader - Управление полярностью принимаемых и передаваемых данных. Изменение полярности не влияет на бит четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type DatainvR = crate :: BitReader < Datainv > ; impl DatainvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Datainv { match self . bits { false => Datainv :: Direct , true => Datainv :: Inverted , } } # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == Datainv :: Direct } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == Datainv :: Inverted } } # [doc = "Field `DATAINV` writer - Управление полярностью принимаемых и передаваемых данных. Изменение полярности не влияет на бит четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type DatainvW < 'a , REG > = crate :: BitWriter < 'a , REG , Datainv > ; impl < 'a , REG > DatainvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (Datainv :: Direct) } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (Datainv :: Inverted) } } # [doc = "Управление очередностью приема и передачи данных. Этот бит не влияет на передачу и прием бита четности. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Msbfirst { # [doc = "0: Начинать с 0 бита"]
Lsb = 0 , # [doc = "1: Начинать с 9, 8 или 7 в зависимости от настроек длины посылки."]
Msb = 1 , } impl From < Msbfirst > for bool { # [inline (always)]
fn from (variant : Msbfirst) -> Self { variant as u8 != 0 } } # [doc = "Field `MSBFIRST` reader - Управление очередностью приема и передачи данных. Этот бит не влияет на передачу и прием бита четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type MsbfirstR = crate :: BitReader < Msbfirst > ; impl MsbfirstR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Msbfirst { match self . bits { false => Msbfirst :: Lsb , true => Msbfirst :: Msb , } } # [doc = "Начинать с 0 бита"]
# [inline (always)]
pub fn is_lsb (& self) -> bool { * self == Msbfirst :: Lsb } # [doc = "Начинать с 9, 8 или 7 в зависимости от настроек длины посылки."]
# [inline (always)]
pub fn is_msb (& self) -> bool { * self == Msbfirst :: Msb } } # [doc = "Field `MSBFIRST` writer - Управление очередностью приема и передачи данных. Этот бит не влияет на передачу и прием бита четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type MsbfirstW < 'a , REG > = crate :: BitWriter < 'a , REG , Msbfirst > ; impl < 'a , REG > MsbfirstW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Начинать с 0 бита"]
# [inline (always)]
pub fn lsb (self) -> & 'a mut crate :: W < REG > { self . variant (Msbfirst :: Lsb) } # [doc = "Начинать с 9, 8 или 7 в зависимости от настроек длины посылки."]
# [inline (always)]
pub fn msb (self) -> & 'a mut crate :: W < REG > { self . variant (Msbfirst :: Msb) } } impl R { # [doc = "Bit 6 - Управление прерыванием при обнаружении break состояния на RX линии"]
# [inline (always)]
pub fn lbdie (& self) -> LbdieR { LbdieR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 8 - Управление последним тактовым импульсом. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn lbcl (& self) -> LbclR { LbclR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Управление фазой выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn cpha (& self) -> CphaR { CphaR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Управление полярностью выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn cpol (& self) -> CpolR { CpolR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Управление синхронным режимом. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn clken (& self) -> ClkenR { ClkenR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 13 - Количество стоп битов для приемника и передатчика. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn stop_1 (& self) -> Stop1R { Stop1R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Регистр режима обратной внутренней петли. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn lbm (& self) -> LbmR { LbmR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Обмен функциями TX выхода и RX входа. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn swap (& self) -> SwapR { SwapR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Управление полярностью RX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn rxinv (& self) -> RxinvR { RxinvR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Управление полярностью TX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn txinv (& self) -> TxinvR { TxinvR :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Управление полярностью принимаемых и передаваемых данных. Изменение полярности не влияет на бит четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn datainv (& self) -> DatainvR { DatainvR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Управление очередностью приема и передачи данных. Этот бит не влияет на передачу и прием бита четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn msbfirst (& self) -> MsbfirstR { MsbfirstR :: new (((self . bits >> 19) & 1) != 0) } } impl W { # [doc = "Bit 6 - Управление прерыванием при обнаружении break состояния на RX линии"]
# [inline (always)]
pub fn lbdie (& mut self) -> LbdieW < Control2Spec > { LbdieW :: new (self , 6) } # [doc = "Bit 8 - Управление последним тактовым импульсом. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn lbcl (& mut self) -> LbclW < Control2Spec > { LbclW :: new (self , 8) } # [doc = "Bit 9 - Управление фазой выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn cpha (& mut self) -> CphaW < Control2Spec > { CphaW :: new (self , 9) } # [doc = "Bit 10 - Управление полярностью выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn cpol (& mut self) -> CpolW < Control2Spec > { CpolW :: new (self , 10) } # [doc = "Bit 11 - Управление синхронным режимом. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn clken (& mut self) -> ClkenW < Control2Spec > { ClkenW :: new (self , 11) } # [doc = "Bit 13 - Количество стоп битов для приемника и передатчика. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn stop_1 (& mut self) -> Stop1W < Control2Spec > { Stop1W :: new (self , 13) } # [doc = "Bit 14 - Регистр режима обратной внутренней петли. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn lbm (& mut self) -> LbmW < Control2Spec > { LbmW :: new (self , 14) } # [doc = "Bit 15 - Обмен функциями TX выхода и RX входа. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn swap (& mut self) -> SwapW < Control2Spec > { SwapW :: new (self , 15) } # [doc = "Bit 16 - Управление полярностью RX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn rxinv (& mut self) -> RxinvW < Control2Spec > { RxinvW :: new (self , 16) } # [doc = "Bit 17 - Управление полярностью TX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn txinv (& mut self) -> TxinvW < Control2Spec > { TxinvW :: new (self , 17) } # [doc = "Bit 18 - Управление полярностью принимаемых и передаваемых данных. Изменение полярности не влияет на бит четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn datainv (& mut self) -> DatainvW < Control2Spec > { DatainvW :: new (self , 18) } # [doc = "Bit 19 - Управление очередностью приема и передачи данных. Этот бит не влияет на передачу и прием бита четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn msbfirst (& mut self) -> MsbfirstW < Control2Spec > { MsbfirstW :: new (self , 19) } } # [doc = "Регистр управления 2\n\nYou can [`read`](crate::Reg::read) this register and get [`control2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Control2Spec ; impl crate :: RegisterSpec for Control2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`control2::R`](R) reader structure"]
impl crate :: Readable for Control2Spec { } # [doc = "`write(|w| ..)` method takes [`control2::W`](W) writer structure"]
impl crate :: Writable for Control2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL2 to value 0"]
impl crate :: Resettable for Control2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONTROL3 (rw) register accessor: Регистр управления 3\n\nYou can [`read`](crate::Reg::read) this register and get [`control3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control3`]
module"]
# [doc (alias = "CONTROL3")]
pub type Control3 = crate :: Reg < control3 :: Control3Spec > ; # [doc = "Регистр управления 3"]
pub mod control3 { # [doc = "Register `CONTROL3` reader"]
pub type R = crate :: R < Control3Spec > ; # [doc = "Register `CONTROL3` writer"]
pub type W = crate :: W < Control3Spec > ; # [doc = "Управление прерыванием при обнаружении ошибок приема данных (FE, ORE, NF)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Eie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Eie > for bool { # [inline (always)]
fn from (variant : Eie) -> Self { variant as u8 != 0 } } # [doc = "Field `EIE` reader - Управление прерыванием при обнаружении ошибок приема данных (FE, ORE, NF)"]
pub type EieR = crate :: BitReader < Eie > ; impl EieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Eie { match self . bits { false => Eie :: Disable , true => Eie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Eie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Eie :: Enable } } # [doc = "Field `EIE` writer - Управление прерыванием при обнаружении ошибок приема данных (FE, ORE, NF)"]
pub type EieW < 'a , REG > = crate :: BitWriter < 'a , REG , Eie > ; impl < 'a , REG > EieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Eie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Eie :: Enable) } } # [doc = "Переход передатчика в break состояние\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Sbkrq { # [doc = "0: Обычный режим работы"]
Normal = 0 , # [doc = "1: Состояние break на линии TX"]
BreakTx = 1 , } impl From < Sbkrq > for bool { # [inline (always)]
fn from (variant : Sbkrq) -> Self { variant as u8 != 0 } } # [doc = "Field `SBKRQ` reader - Переход передатчика в break состояние"]
pub type SbkrqR = crate :: BitReader < Sbkrq > ; impl SbkrqR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Sbkrq { match self . bits { false => Sbkrq :: Normal , true => Sbkrq :: BreakTx , } } # [doc = "Обычный режим работы"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == Sbkrq :: Normal } # [doc = "Состояние break на линии TX"]
# [inline (always)]
pub fn is_break_tx (& self) -> bool { * self == Sbkrq :: BreakTx } } # [doc = "Field `SBKRQ` writer - Переход передатчика в break состояние"]
pub type SbkrqW < 'a , REG > = crate :: BitWriter < 'a , REG , Sbkrq > ; impl < 'a , REG > SbkrqW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычный режим работы"]
# [inline (always)]
pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Sbkrq :: Normal) } # [doc = "Состояние break на линии TX"]
# [inline (always)]
pub fn break_tx (self) -> & 'a mut crate :: W < REG > { self . variant (Sbkrq :: BreakTx) } } # [doc = "Выбор между полудуплексным и дуплексным режимами работы. В полудуплексном режиме RX не используется, все данные передаются и принимаются через TX. При наличии данных на передачу происходит отправка данных в остальное время прием. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Hdsel { # [doc = "0: Дуплексный режим работы"]
Duplex = 0 , # [doc = "1: Полудуплексный режим работы"]
HalfDuplex = 1 , } impl From < Hdsel > for bool { # [inline (always)]
fn from (variant : Hdsel) -> Self { variant as u8 != 0 } } # [doc = "Field `HDSEL` reader - Выбор между полудуплексным и дуплексным режимами работы. В полудуплексном режиме RX не используется, все данные передаются и принимаются через TX. При наличии данных на передачу происходит отправка данных в остальное время прием. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type HdselR = crate :: BitReader < Hdsel > ; impl HdselR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Hdsel { match self . bits { false => Hdsel :: Duplex , true => Hdsel :: HalfDuplex , } } # [doc = "Дуплексный режим работы"]
# [inline (always)]
pub fn is_duplex (& self) -> bool { * self == Hdsel :: Duplex } # [doc = "Полудуплексный режим работы"]
# [inline (always)]
pub fn is_half_duplex (& self) -> bool { * self == Hdsel :: HalfDuplex } } # [doc = "Field `HDSEL` writer - Выбор между полудуплексным и дуплексным режимами работы. В полудуплексном режиме RX не используется, все данные передаются и принимаются через TX. При наличии данных на передачу происходит отправка данных в остальное время прием. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type HdselW < 'a , REG > = crate :: BitWriter < 'a , REG , Hdsel > ; impl < 'a , REG > HdselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Дуплексный режим работы"]
# [inline (always)]
pub fn duplex (self) -> & 'a mut crate :: W < REG > { self . variant (Hdsel :: Duplex) } # [doc = "Полудуплексный режим работы"]
# [inline (always)]
pub fn half_duplex (self) -> & 'a mut crate :: W < REG > { self . variant (Hdsel :: HalfDuplex) } } # [doc = "Управление работой сигна-ла dma_rrq\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dmar { # [doc = "0: Сигнал выключен"]
Disable = 0 , # [doc = "1: Сигнал включен"]
Enable = 1 , } impl From < Dmar > for bool { # [inline (always)]
fn from (variant : Dmar) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAR` reader - Управление работой сигна-ла dma_rrq"]
pub type DmarR = crate :: BitReader < Dmar > ; impl DmarR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dmar { match self . bits { false => Dmar :: Disable , true => Dmar :: Enable , } } # [doc = "Сигнал выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dmar :: Disable } # [doc = "Сигнал включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dmar :: Enable } } # [doc = "Field `DMAR` writer - Управление работой сигна-ла dma_rrq"]
pub type DmarW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmar > ; impl < 'a , REG > DmarW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сигнал выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dmar :: Disable) } # [doc = "Сигнал включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dmar :: Enable) } } # [doc = "Управление работой сигнала dma_trq\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dmat { # [doc = "0: Сигнал выключен"]
Disable = 0 , # [doc = "1: Сигнал включен"]
Enable = 1 , } impl From < Dmat > for bool { # [inline (always)]
fn from (variant : Dmat) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAT` reader - Управление работой сигнала dma_trq"]
pub type DmatR = crate :: BitReader < Dmat > ; impl DmatR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dmat { match self . bits { false => Dmat :: Disable , true => Dmat :: Enable , } } # [doc = "Сигнал выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dmat :: Disable } # [doc = "Сигнал включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dmat :: Enable } } # [doc = "Field `DMAT` writer - Управление работой сигнала dma_trq"]
pub type DmatW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmat > ; impl < 'a , REG > DmatW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сигнал выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dmat :: Disable) } # [doc = "Сигнал включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dmat :: Enable) } } # [doc = "Управление выходным сигналом RTS. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rtse { # [doc = "0: Сигнал всегда в разрешающем состоянии (RTS = 0)"]
_0 = 0 , # [doc = "1: Сигнал находится в разрешающем состоянии (RTS = 0), только когда приемник готов принять данные"]
_1 = 1 , } impl From < Rtse > for bool { # [inline (always)]
fn from (variant : Rtse) -> Self { variant as u8 != 0 } } # [doc = "Field `RTSE` reader - Управление выходным сигналом RTS. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type RtseR = crate :: BitReader < Rtse > ; impl RtseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rtse { match self . bits { false => Rtse :: _0 , true => Rtse :: _1 , } } # [doc = "Сигнал всегда в разрешающем состоянии (RTS = 0)"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Rtse :: _0 } # [doc = "Сигнал находится в разрешающем состоянии (RTS = 0), только когда приемник готов принять данные"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Rtse :: _1 } } # [doc = "Field `RTSE` writer - Управление выходным сигналом RTS. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type RtseW < 'a , REG > = crate :: BitWriter < 'a , REG , Rtse > ; impl < 'a , REG > RtseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сигнал всегда в разрешающем состоянии (RTS = 0)"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Rtse :: _0) } # [doc = "Сигнал находится в разрешающем состоянии (RTS = 0), только когда приемник готов принять данные"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Rtse :: _1) } } # [doc = "Выбор реакции на входной сигнал CTS. Этот бит может быть изме-нен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ctse { # [doc = "0: Сигнал игнорируется"]
Ignored = 0 , # [doc = "1: сигнал управляет передачей данных трансмиттером. Передача разрешена при (CTS = 0)"]
Control = 1 , } impl From < Ctse > for bool { # [inline (always)]
fn from (variant : Ctse) -> Self { variant as u8 != 0 } } # [doc = "Field `CTSE` reader - Выбор реакции на входной сигнал CTS. Этот бит может быть изме-нен только при остановке работы (UE=0)"]
pub type CtseR = crate :: BitReader < Ctse > ; impl CtseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ctse { match self . bits { false => Ctse :: Ignored , true => Ctse :: Control , } } # [doc = "Сигнал игнорируется"]
# [inline (always)]
pub fn is_ignored (& self) -> bool { * self == Ctse :: Ignored } # [doc = "сигнал управляет передачей данных трансмиттером. Передача разрешена при (CTS = 0)"]
# [inline (always)]
pub fn is_control (& self) -> bool { * self == Ctse :: Control } } # [doc = "Field `CTSE` writer - Выбор реакции на входной сигнал CTS. Этот бит может быть изме-нен только при остановке работы (UE=0)"]
pub type CtseW < 'a , REG > = crate :: BitWriter < 'a , REG , Ctse > ; impl < 'a , REG > CtseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сигнал игнорируется"]
# [inline (always)]
pub fn ignored (self) -> & 'a mut crate :: W < REG > { self . variant (Ctse :: Ignored) } # [doc = "сигнал управляет передачей данных трансмиттером. Передача разрешена при (CTS = 0)"]
# [inline (always)]
pub fn control (self) -> & 'a mut crate :: W < REG > { self . variant (Ctse :: Control) } } # [doc = "Управление прерыванием при обнаружении измене-ния CTS\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ctsie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Ctsie > for bool { # [inline (always)]
fn from (variant : Ctsie) -> Self { variant as u8 != 0 } } # [doc = "Field `CTSIE` reader - Управление прерыванием при обнаружении измене-ния CTS"]
pub type CtsieR = crate :: BitReader < Ctsie > ; impl CtsieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ctsie { match self . bits { false => Ctsie :: Disable , true => Ctsie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Ctsie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Ctsie :: Enable } } # [doc = "Field `CTSIE` writer - Управление прерыванием при обнаружении измене-ния CTS"]
pub type CtsieW < 'a , REG > = crate :: BitWriter < 'a , REG , Ctsie > ; impl < 'a , REG > CtsieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Ctsie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Ctsie :: Enable) } } # [doc = "Выбор реакции на переполнение. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ovrdis { # [doc = "0: При переполнении взводится флаг ошибки (ORE), новые данные не записываются"]
_0 = 0 , # [doc = "1: флаг переполнения не взводится, данные перезаписываются"]
_1 = 1 , } impl From < Ovrdis > for bool { # [inline (always)]
fn from (variant : Ovrdis) -> Self { variant as u8 != 0 } } # [doc = "Field `OVRDIS` reader - Выбор реакции на переполнение. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type OvrdisR = crate :: BitReader < Ovrdis > ; impl OvrdisR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ovrdis { match self . bits { false => Ovrdis :: _0 , true => Ovrdis :: _1 , } } # [doc = "При переполнении взводится флаг ошибки (ORE), новые данные не записываются"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Ovrdis :: _0 } # [doc = "флаг переполнения не взводится, данные перезаписываются"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Ovrdis :: _1 } } # [doc = "Field `OVRDIS` writer - Выбор реакции на переполнение. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type OvrdisW < 'a , REG > = crate :: BitWriter < 'a , REG , Ovrdis > ; impl < 'a , REG > OvrdisW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "При переполнении взводится флаг ошибки (ORE), новые данные не записываются"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ovrdis :: _0) } # [doc = "флаг переполнения не взводится, данные перезаписываются"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ovrdis :: _1) } } impl R { # [doc = "Bit 0 - Управление прерыванием при обнаружении ошибок приема данных (FE, ORE, NF)"]
# [inline (always)]
pub fn eie (& self) -> EieR { EieR :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Переход передатчика в break состояние"]
# [inline (always)]
pub fn sbkrq (& self) -> SbkrqR { SbkrqR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Выбор между полудуплексным и дуплексным режимами работы. В полудуплексном режиме RX не используется, все данные передаются и принимаются через TX. При наличии данных на передачу происходит отправка данных в остальное время прием. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn hdsel (& self) -> HdselR { HdselR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 6 - Управление работой сигна-ла dma_rrq"]
# [inline (always)]
pub fn dmar (& self) -> DmarR { DmarR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Управление работой сигнала dma_trq"]
# [inline (always)]
pub fn dmat (& self) -> DmatR { DmatR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Управление выходным сигналом RTS. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn rtse (& self) -> RtseR { RtseR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Выбор реакции на входной сигнал CTS. Этот бит может быть изме-нен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ctse (& self) -> CtseR { CtseR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Управление прерыванием при обнаружении измене-ния CTS"]
# [inline (always)]
pub fn ctsie (& self) -> CtsieR { CtsieR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 12 - Выбор реакции на переполнение. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ovrdis (& self) -> OvrdisR { OvrdisR :: new (((self . bits >> 12) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление прерыванием при обнаружении ошибок приема данных (FE, ORE, NF)"]
# [inline (always)]
pub fn eie (& mut self) -> EieW < Control3Spec > { EieW :: new (self , 0) } # [doc = "Bit 2 - Переход передатчика в break состояние"]
# [inline (always)]
pub fn sbkrq (& mut self) -> SbkrqW < Control3Spec > { SbkrqW :: new (self , 2) } # [doc = "Bit 3 - Выбор между полудуплексным и дуплексным режимами работы. В полудуплексном режиме RX не используется, все данные передаются и принимаются через TX. При наличии данных на передачу происходит отправка данных в остальное время прием. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn hdsel (& mut self) -> HdselW < Control3Spec > { HdselW :: new (self , 3) } # [doc = "Bit 6 - Управление работой сигна-ла dma_rrq"]
# [inline (always)]
pub fn dmar (& mut self) -> DmarW < Control3Spec > { DmarW :: new (self , 6) } # [doc = "Bit 7 - Управление работой сигнала dma_trq"]
# [inline (always)]
pub fn dmat (& mut self) -> DmatW < Control3Spec > { DmatW :: new (self , 7) } # [doc = "Bit 8 - Управление выходным сигналом RTS. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn rtse (& mut self) -> RtseW < Control3Spec > { RtseW :: new (self , 8) } # [doc = "Bit 9 - Выбор реакции на входной сигнал CTS. Этот бит может быть изме-нен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ctse (& mut self) -> CtseW < Control3Spec > { CtseW :: new (self , 9) } # [doc = "Bit 10 - Управление прерыванием при обнаружении измене-ния CTS"]
# [inline (always)]
pub fn ctsie (& mut self) -> CtsieW < Control3Spec > { CtsieW :: new (self , 10) } # [doc = "Bit 12 - Выбор реакции на переполнение. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ovrdis (& mut self) -> OvrdisW < Control3Spec > { OvrdisW :: new (self , 12) } } # [doc = "Регистр управления 3\n\nYou can [`read`](crate::Reg::read) this register and get [`control3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Control3Spec ; impl crate :: RegisterSpec for Control3Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`control3::R`](R) reader structure"]
impl crate :: Readable for Control3Spec { } # [doc = "`write(|w| ..)` method takes [`control3::W`](W) writer structure"]
impl crate :: Writable for Control3Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL3 to value 0"]
impl crate :: Resettable for Control3Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DIVIDER (rw) register accessor: Регистр настройки делителя\n\nYou can [`read`](crate::Reg::read) this register and get [`divider::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`divider::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@divider`]
module"]
# [doc (alias = "DIVIDER")]
pub type Divider = crate :: Reg < divider :: DividerSpec > ; # [doc = "Регистр настройки делителя"]
pub mod divider { # [doc = "Register `DIVIDER` reader"]
pub type R = crate :: R < DividerSpec > ; # [doc = "Register `DIVIDER` writer"]
pub type W = crate :: W < DividerSpec > ; # [doc = "Field `BRR` reader - Значение делителя входного тактового сигнала (clk_in). При BRR < 16 USART не активен Бодрейт рассчитывается по следующей формуле: BR = F/BRR, где BR - бодрейт, F - значение частоты входного тактового сигнала Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type BrrR = crate :: FieldReader < u16 > ; # [doc = "Field `BRR` writer - Значение делителя входного тактового сигнала (clk_in). При BRR < 16 USART не активен Бодрейт рассчитывается по следующей формуле: BR = F/BRR, где BR - бодрейт, F - значение частоты входного тактового сигнала Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type BrrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - Значение делителя входного тактового сигнала (clk_in). При BRR < 16 USART не активен Бодрейт рассчитывается по следующей формуле: BR = F/BRR, где BR - бодрейт, F - значение частоты входного тактового сигнала Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn brr (& self) -> BrrR { BrrR :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15 - Значение делителя входного тактового сигнала (clk_in). При BRR < 16 USART не активен Бодрейт рассчитывается по следующей формуле: BR = F/BRR, где BR - бодрейт, F - значение частоты входного тактового сигнала Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn brr (& mut self) -> BrrW < DividerSpec > { BrrW :: new (self , 0) } } # [doc = "Регистр настройки делителя\n\nYou can [`read`](crate::Reg::read) this register and get [`divider::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`divider::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DividerSpec ; impl crate :: RegisterSpec for DividerSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`divider::R`](R) reader structure"]
impl crate :: Readable for DividerSpec { } # [doc = "`write(|w| ..)` method takes [`divider::W`](W) writer structure"]
impl crate :: Writable for DividerSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DIVIDER to value 0"]
impl crate :: Resettable for DividerSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "FLAGS (rw) register accessor: Регистр прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`flags::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flags::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@flags`]
module"]
# [doc (alias = "FLAGS")]
pub type Flags = crate :: Reg < flags :: FlagsSpec > ; # [doc = "Регистр прерываний"]
pub mod flags { # [doc = "Register `FLAGS` reader"]
pub type R = crate :: R < FlagsSpec > ; # [doc = "Register `FLAGS` writer"]
pub type W = crate :: W < FlagsSpec > ; # [doc = "Флаг обнаружения оши-бочного бита четности. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pe { # [doc = "0: Ошибок в битах четности не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Ошибка в бите четности обнаружена с момента сброса флага"]
_1 = 1 , } impl From < Pe > for bool { # [inline (always)]
fn from (variant : Pe) -> Self { variant as u8 != 0 } } # [doc = "Field `PE` reader - Флаг обнаружения оши-бочного бита четности. Флаг сбрасывается записью 1"]
pub type PeR = crate :: BitReader < Pe > ; impl PeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pe { match self . bits { false => Pe :: _0 , true => Pe :: _1 , } } # [doc = "Ошибок в битах четности не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Pe :: _0 } # [doc = "Ошибка в бите четности обнаружена с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Pe :: _1 } } # [doc = "Field `PE` writer - Флаг обнаружения оши-бочного бита четности. Флаг сбрасывается записью 1"]
pub type PeW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Pe > ; impl < 'a , REG > PeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Ошибок в битах четности не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pe :: _0) } # [doc = "Ошибка в бите четности обнаружена с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pe :: _1) } } # [doc = "Флаг взводится при обнаружении ошибок в стоп би-те или битах. Флаг сбрасы-вается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Fe { # [doc = "0: Ошибок приема не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Ошибка приема обнаружена с момента сброса флага"]
_1 = 1 , } impl From < Fe > for bool { # [inline (always)]
fn from (variant : Fe) -> Self { variant as u8 != 0 } } # [doc = "Field `FE` reader - Флаг взводится при обнаружении ошибок в стоп би-те или битах. Флаг сбрасы-вается записью 1"]
pub type FeR = crate :: BitReader < Fe > ; impl FeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Fe { match self . bits { false => Fe :: _0 , true => Fe :: _1 , } } # [doc = "Ошибок приема не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Fe :: _0 } # [doc = "Ошибка приема обнаружена с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Fe :: _1 } } # [doc = "Field `FE` writer - Флаг взводится при обнаружении ошибок в стоп би-те или битах. Флаг сбрасы-вается записью 1"]
pub type FeW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Fe > ; impl < 'a , REG > FeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Ошибок приема не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Fe :: _0) } # [doc = "Ошибка приема обнаружена с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Fe :: _1) } } # [doc = "Флаг обнаружения ложных переключений на линии RX. Флаг сбрасывается за-писью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nf { # [doc = "0: Помех не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Помехи обнаружены с момента сброса флага"]
_1 = 1 , } impl From < Nf > for bool { # [inline (always)]
fn from (variant : Nf) -> Self { variant as u8 != 0 } } # [doc = "Field `NF` reader - Флаг обнаружения ложных переключений на линии RX. Флаг сбрасывается за-писью 1"]
pub type NfR = crate :: BitReader < Nf > ; impl NfR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nf { match self . bits { false => Nf :: _0 , true => Nf :: _1 , } } # [doc = "Помех не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Nf :: _0 } # [doc = "Помехи обнаружены с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Nf :: _1 } } # [doc = "Field `NF` writer - Флаг обнаружения ложных переключений на линии RX. Флаг сбрасывается за-писью 1"]
pub type NfW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Nf > ; impl < 'a , REG > NfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Помех не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Nf :: _0) } # [doc = "Помехи обнаружены с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Nf :: _1) } } # [doc = "Флаг взводится при попытке перезаписи RDR. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ore { # [doc = "0: Попыток перезаписи не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Попытка перезаписи обнаружена с момента сброса флага"]
_1 = 1 , } impl From < Ore > for bool { # [inline (always)]
fn from (variant : Ore) -> Self { variant as u8 != 0 } } # [doc = "Field `ORE` reader - Флаг взводится при попытке перезаписи RDR. Флаг сбрасывается записью 1"]
pub type OreR = crate :: BitReader < Ore > ; impl OreR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ore { match self . bits { false => Ore :: _0 , true => Ore :: _1 , } } # [doc = "Попыток перезаписи не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Ore :: _0 } # [doc = "Попытка перезаписи обнаружена с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Ore :: _1 } } # [doc = "Field `ORE` writer - Флаг взводится при попытке перезаписи RDR. Флаг сбрасывается записью 1"]
pub type OreW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Ore > ; impl < 'a , REG > OreW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Попыток перезаписи не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ore :: _0) } # [doc = "Попытка перезаписи обнаружена с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ore :: _1) } } # [doc = "Флаг взводится при отсутствии активности на линии RX в течении 8 битовых тактов при взведенном флаге RXNE. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Idle { # [doc = "0: Состояние idle не обнаружено после сброса флага"]
_0 = 0 , # [doc = "1: Состояние idle обнаружено после сброса флага"]
_1 = 1 , } impl From < Idle > for bool { # [inline (always)]
fn from (variant : Idle) -> Self { variant as u8 != 0 } } # [doc = "Field `IDLE` reader - Флаг взводится при отсутствии активности на линии RX в течении 8 битовых тактов при взведенном флаге RXNE. Флаг сбрасывается записью 1"]
pub type IdleR = crate :: BitReader < Idle > ; impl IdleR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Idle { match self . bits { false => Idle :: _0 , true => Idle :: _1 , } } # [doc = "Состояние idle не обнаружено после сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Idle :: _0 } # [doc = "Состояние idle обнаружено после сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Idle :: _1 } } # [doc = "Field `IDLE` writer - Флаг взводится при отсутствии активности на линии RX в течении 8 битовых тактов при взведенном флаге RXNE. Флаг сбрасывается записью 1"]
pub type IdleW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Idle > ; impl < 'a , REG > IdleW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Состояние idle не обнаружено после сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Idle :: _0) } # [doc = "Состояние idle обнаружено после сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Idle :: _1) } } # [doc = "Флаг взводится при записи принятых данных в регистр RDR из сдвигового реги-стра. Флаг сбрасывается записью 1 или чтением ре-гистра RDR\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rxne { # [doc = "0: Данные не принимались после сброса флага"]
_0 = 0 , # [doc = "1: Данные принимались после сброса флага"]
_1 = 1 , } impl From < Rxne > for bool { # [inline (always)]
fn from (variant : Rxne) -> Self { variant as u8 != 0 } } # [doc = "Field `RXNE` reader - Флаг взводится при записи принятых данных в регистр RDR из сдвигового реги-стра. Флаг сбрасывается записью 1 или чтением ре-гистра RDR"]
pub type RxneR = crate :: BitReader < Rxne > ; impl RxneR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rxne { match self . bits { false => Rxne :: _0 , true => Rxne :: _1 , } } # [doc = "Данные не принимались после сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Rxne :: _0 } # [doc = "Данные принимались после сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Rxne :: _1 } } # [doc = "Field `RXNE` writer - Флаг взводится при записи принятых данных в регистр RDR из сдвигового реги-стра. Флаг сбрасывается записью 1 или чтением ре-гистра RDR"]
pub type RxneW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Rxne > ; impl < 'a , REG > RxneW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Данные не принимались после сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Rxne :: _0) } # [doc = "Данные принимались после сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Rxne :: _1) } } # [doc = "Флаг взводится при переда-че данных в момент от-правки последнего стоп би-та. Флаг сбрасывается за-писью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Tc { # [doc = "0: Данные не отправлялись с момента сброса флага"]
_0 = 0 , # [doc = "1: Данные отправлялись с момента сброса флага"]
_1 = 1 , } impl From < Tc > for bool { # [inline (always)]
fn from (variant : Tc) -> Self { variant as u8 != 0 } } # [doc = "Field `TC` reader - Флаг взводится при переда-че данных в момент от-правки последнего стоп би-та. Флаг сбрасывается за-писью 1"]
pub type TcR = crate :: BitReader < Tc > ; impl TcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Tc { match self . bits { false => Tc :: _0 , true => Tc :: _1 , } } # [doc = "Данные не отправлялись с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Tc :: _0 } # [doc = "Данные отправлялись с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Tc :: _1 } } # [doc = "Field `TC` writer - Флаг взводится при переда-че данных в момент от-правки последнего стоп би-та. Флаг сбрасывается за-писью 1"]
pub type TcW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Tc > ; impl < 'a , REG > TcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Данные не отправлялись с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Tc :: _0) } # [doc = "Данные отправлялись с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Tc :: _1) } } # [doc = "Флаг взводится при передаче данных в момент записи данных в сдвиговый регистр. Флаг сбрасывается записью данных в регистр TDR или записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Txe { # [doc = "0: Данные не записывались в сдвиговый регистр с момента сброса флага"]
_0 = 0 , # [doc = "1: Данные записывались в сдвиговый регистр"]
_1 = 1 , } impl From < Txe > for bool { # [inline (always)]
fn from (variant : Txe) -> Self { variant as u8 != 0 } } # [doc = "Field `TXE` reader - Флаг взводится при передаче данных в момент записи данных в сдвиговый регистр. Флаг сбрасывается записью данных в регистр TDR или записью 1"]
pub type TxeR = crate :: BitReader < Txe > ; impl TxeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Txe { match self . bits { false => Txe :: _0 , true => Txe :: _1 , } } # [doc = "Данные не записывались в сдвиговый регистр с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Txe :: _0 } # [doc = "Данные записывались в сдвиговый регистр"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Txe :: _1 } } # [doc = "Field `TXE` writer - Флаг взводится при передаче данных в момент записи данных в сдвиговый регистр. Флаг сбрасывается записью данных в регистр TDR или записью 1"]
pub type TxeW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Txe > ; impl < 'a , REG > TxeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Данные не записывались в сдвиговый регистр с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Txe :: _0) } # [doc = "Данные записывались в сдвиговый регистр"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Txe :: _1) } } # [doc = "Флаг обнаружения break состояния на линии RX. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Lbdf { # [doc = "0: Состояние break не обнаружено с момента сброса флага"]
NotDetected = 0 , # [doc = "1: Состояние break обнаружено с момента сброса флага"]
Detected = 1 , } impl From < Lbdf > for bool { # [inline (always)]
fn from (variant : Lbdf) -> Self { variant as u8 != 0 } } # [doc = "Field `LBDF` reader - Флаг обнаружения break состояния на линии RX. Флаг сбрасывается записью 1"]
pub type LbdfR = crate :: BitReader < Lbdf > ; impl LbdfR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Lbdf { match self . bits { false => Lbdf :: NotDetected , true => Lbdf :: Detected , } } # [doc = "Состояние break не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_not_detected (& self) -> bool { * self == Lbdf :: NotDetected } # [doc = "Состояние break обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_detected (& self) -> bool { * self == Lbdf :: Detected } } # [doc = "Field `LBDF` writer - Флаг обнаружения break состояния на линии RX. Флаг сбрасывается записью 1"]
pub type LbdfW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Lbdf > ; impl < 'a , REG > LbdfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Состояние break не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn not_detected (self) -> & 'a mut crate :: W < REG > { self . variant (Lbdf :: NotDetected) } # [doc = "Состояние break обнаружено с момента сброса флага"]
# [inline (always)]
pub fn detected (self) -> & 'a mut crate :: W < REG > { self . variant (Lbdf :: Detected) } } # [doc = "Флаг взводится при изме-нении значения сигнала CTS. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ctsif { # [doc = "0: Состояние CTS не менялось с момента сброса флага"]
_0 = 0 , # [doc = "1: Состояние CTS менялось с момента сброса флага"]
_1 = 1 , } impl From < Ctsif > for bool { # [inline (always)]
fn from (variant : Ctsif) -> Self { variant as u8 != 0 } } # [doc = "Field `CTSIF` reader - Флаг взводится при изме-нении значения сигнала CTS. Флаг сбрасывается записью 1"]
pub type CtsifR = crate :: BitReader < Ctsif > ; impl CtsifR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ctsif { match self . bits { false => Ctsif :: _0 , true => Ctsif :: _1 , } } # [doc = "Состояние CTS не менялось с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Ctsif :: _0 } # [doc = "Состояние CTS менялось с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Ctsif :: _1 } } # [doc = "Field `CTSIF` writer - Флаг взводится при изме-нении значения сигнала CTS. Флаг сбрасывается записью 1"]
pub type CtsifW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Ctsif > ; impl < 'a , REG > CtsifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Состояние CTS не менялось с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ctsif :: _0) } # [doc = "Состояние CTS менялось с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ctsif :: _1) } } # [doc = "Флаг отображает текущее значение сигнала CTS\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cts { # [doc = "0: CTS = 0"]
_0 = 0 , # [doc = "1: CTS = 1"]
_1 = 1 , } impl From < Cts > for bool { # [inline (always)]
fn from (variant : Cts) -> Self { variant as u8 != 0 } } # [doc = "Field `CTS` reader - Флаг отображает текущее значение сигнала CTS"]
pub type CtsR = crate :: BitReader < Cts > ; impl CtsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cts { match self . bits { false => Cts :: _0 , true => Cts :: _1 , } } # [doc = "CTS = 0"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Cts :: _0 } # [doc = "CTS = 1"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Cts :: _1 } } # [doc = "Флаг активности на линии RX\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Busy { # [doc = "0: Нет активности на линии RX"]
Inactive = 0 , # [doc = "1: Идет передача данных или break состояние"]
Active = 1 , } impl From < Busy > for bool { # [inline (always)]
fn from (variant : Busy) -> Self { variant as u8 != 0 } } # [doc = "Field `BUSY` reader - Флаг активности на линии RX"]
pub type BusyR = crate :: BitReader < Busy > ; impl BusyR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Busy { match self . bits { false => Busy :: Inactive , true => Busy :: Active , } } # [doc = "Нет активности на линии RX"]
# [inline (always)]
pub fn is_inactive (& self) -> bool { * self == Busy :: Inactive } # [doc = "Идет передача данных или break состояние"]
# [inline (always)]
pub fn is_active (& self) -> bool { * self == Busy :: Active } } # [doc = "Флаг готовности передатчика к работе после снятия сброса (UE и TE)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Teack { # [doc = "0: Ресет UE и TE активен"]
Unready = 0 , # [doc = "1: Ресет UE и TE снят"]
Ready = 1 , } impl From < Teack > for bool { # [inline (always)]
fn from (variant : Teack) -> Self { variant as u8 != 0 } } # [doc = "Field `TEACK` reader - Флаг готовности передатчика к работе после снятия сброса (UE и TE)"]
pub type TeackR = crate :: BitReader < Teack > ; impl TeackR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Teack { match self . bits { false => Teack :: Unready , true => Teack :: Ready , } } # [doc = "Ресет UE и TE активен"]
# [inline (always)]
pub fn is_unready (& self) -> bool { * self == Teack :: Unready } # [doc = "Ресет UE и TE снят"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Teack :: Ready } } # [doc = "Флаг готовности приемника к работе после снятия сброса (UE и RE)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Reack { # [doc = "0: Ресет UE и RE активен"]
Unready = 0 , # [doc = "1: Ресет UE и RE снят"]
Ready = 1 , } impl From < Reack > for bool { # [inline (always)]
fn from (variant : Reack) -> Self { variant as u8 != 0 } } # [doc = "Field `REACK` reader - Флаг готовности приемника к работе после снятия сброса (UE и RE)"]
pub type ReackR = crate :: BitReader < Reack > ; impl ReackR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Reack { match self . bits { false => Reack :: Unready , true => Reack :: Ready , } } # [doc = "Ресет UE и RE активен"]
# [inline (always)]
pub fn is_unready (& self) -> bool { * self == Reack :: Unready } # [doc = "Ресет UE и RE снят"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Reack :: Ready } } impl R { # [doc = "Bit 0 - Флаг обнаружения оши-бочного бита четности. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Флаг взводится при обнаружении ошибок в стоп би-те или битах. Флаг сбрасы-вается записью 1"]
# [inline (always)]
pub fn fe (& self) -> FeR { FeR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Флаг обнаружения ложных переключений на линии RX. Флаг сбрасывается за-писью 1"]
# [inline (always)]
pub fn nf (& self) -> NfR { NfR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Флаг взводится при попытке перезаписи RDR. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn ore (& self) -> OreR { OreR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Флаг взводится при отсутствии активности на линии RX в течении 8 битовых тактов при взведенном флаге RXNE. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn idle (& self) -> IdleR { IdleR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Флаг взводится при записи принятых данных в регистр RDR из сдвигового реги-стра. Флаг сбрасывается записью 1 или чтением ре-гистра RDR"]
# [inline (always)]
pub fn rxne (& self) -> RxneR { RxneR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Флаг взводится при переда-че данных в момент от-правки последнего стоп би-та. Флаг сбрасывается за-писью 1"]
# [inline (always)]
pub fn tc (& self) -> TcR { TcR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Флаг взводится при передаче данных в момент записи данных в сдвиговый регистр. Флаг сбрасывается записью данных в регистр TDR или записью 1"]
# [inline (always)]
pub fn txe (& self) -> TxeR { TxeR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Флаг обнаружения break состояния на линии RX. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn lbdf (& self) -> LbdfR { LbdfR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Флаг взводится при изме-нении значения сигнала CTS. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn ctsif (& self) -> CtsifR { CtsifR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Флаг отображает текущее значение сигнала CTS"]
# [inline (always)]
pub fn cts (& self) -> CtsR { CtsR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 16 - Флаг активности на линии RX"]
# [inline (always)]
pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 21 - Флаг готовности передатчика к работе после снятия сброса (UE и TE)"]
# [inline (always)]
pub fn teack (& self) -> TeackR { TeackR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Флаг готовности приемника к работе после снятия сброса (UE и RE)"]
# [inline (always)]
pub fn reack (& self) -> ReackR { ReackR :: new (((self . bits >> 22) & 1) != 0) } } impl W { # [doc = "Bit 0 - Флаг обнаружения оши-бочного бита четности. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn pe (& mut self) -> PeW < FlagsSpec > { PeW :: new (self , 0) } # [doc = "Bit 1 - Флаг взводится при обнаружении ошибок в стоп би-те или битах. Флаг сбрасы-вается записью 1"]
# [inline (always)]
pub fn fe (& mut self) -> FeW < FlagsSpec > { FeW :: new (self , 1) } # [doc = "Bit 2 - Флаг обнаружения ложных переключений на линии RX. Флаг сбрасывается за-писью 1"]
# [inline (always)]
pub fn nf (& mut self) -> NfW < FlagsSpec > { NfW :: new (self , 2) } # [doc = "Bit 3 - Флаг взводится при попытке перезаписи RDR. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn ore (& mut self) -> OreW < FlagsSpec > { OreW :: new (self , 3) } # [doc = "Bit 4 - Флаг взводится при отсутствии активности на линии RX в течении 8 битовых тактов при взведенном флаге RXNE. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn idle (& mut self) -> IdleW < FlagsSpec > { IdleW :: new (self , 4) } # [doc = "Bit 5 - Флаг взводится при записи принятых данных в регистр RDR из сдвигового реги-стра. Флаг сбрасывается записью 1 или чтением ре-гистра RDR"]
# [inline (always)]
pub fn rxne (& mut self) -> RxneW < FlagsSpec > { RxneW :: new (self , 5) } # [doc = "Bit 6 - Флаг взводится при переда-че данных в момент от-правки последнего стоп би-та. Флаг сбрасывается за-писью 1"]
# [inline (always)]
pub fn tc (& mut self) -> TcW < FlagsSpec > { TcW :: new (self , 6) } # [doc = "Bit 7 - Флаг взводится при передаче данных в момент записи данных в сдвиговый регистр. Флаг сбрасывается записью данных в регистр TDR или записью 1"]
# [inline (always)]
pub fn txe (& mut self) -> TxeW < FlagsSpec > { TxeW :: new (self , 7) } # [doc = "Bit 8 - Флаг обнаружения break состояния на линии RX. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn lbdf (& mut self) -> LbdfW < FlagsSpec > { LbdfW :: new (self , 8) } # [doc = "Bit 9 - Флаг взводится при изме-нении значения сигнала CTS. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn ctsif (& mut self) -> CtsifW < FlagsSpec > { CtsifW :: new (self , 9) } } # [doc = "Регистр прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`flags::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flags::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct FlagsSpec ; impl crate :: RegisterSpec for FlagsSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`flags::R`](R) reader structure"]
impl crate :: Readable for FlagsSpec { } # [doc = "`write(|w| ..)` method takes [`flags::W`](W) writer structure"]
impl crate :: Writable for FlagsSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0x03ff ; } # [doc = "`reset()` method sets FLAGS to value 0"]
impl crate :: Resettable for FlagsSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RXDATA (r) register accessor: Регистр принятых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdata::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxdata`]
module"]
# [doc (alias = "RXDATA")]
pub type Rxdata = crate :: Reg < rxdata :: RxdataSpec > ; # [doc = "Регистр принятых данных"]
pub mod rxdata { # [doc = "Register `RXDATA` reader"]
pub type R = crate :: R < RxdataSpec > ; # [doc = "Field `RDR` reader - Принятые данные"]
pub type RdrR = crate :: FieldReader < u16 > ; impl R { # [doc = "Bits 0:8 - Принятые данные"]
# [inline (always)]
pub fn rdr (& self) -> RdrR { RdrR :: new ((self . bits & 0x01ff) as u16) } } # [doc = "Регистр принятых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdata::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxdataSpec ; impl crate :: RegisterSpec for RxdataSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rxdata::R`](R) reader structure"]
impl crate :: Readable for RxdataSpec { } # [doc = "`reset()` method sets RXDATA to value 0"]
impl crate :: Resettable for RxdataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TXDATA (rw) register accessor: Регистр передаваемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`txdata::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdata::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txdata`]
module"]
# [doc (alias = "TXDATA")]
pub type Txdata = crate :: Reg < txdata :: TxdataSpec > ; # [doc = "Регистр передаваемых данных"]
pub mod txdata { # [doc = "Register `TXDATA` reader"]
pub type R = crate :: R < TxdataSpec > ; # [doc = "Register `TXDATA` writer"]
pub type W = crate :: W < TxdataSpec > ; # [doc = "Field `TDR` reader - Передаваемые данные"]
pub type TdrR = crate :: FieldReader < u16 > ; # [doc = "Field `TDR` writer - Передаваемые данные"]
pub type TdrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ; impl R { # [doc = "Bits 0:8 - Передаваемые данные"]
# [inline (always)]
pub fn tdr (& self) -> TdrR { TdrR :: new ((self . bits & 0x01ff) as u16) } } impl W { # [doc = "Bits 0:8 - Передаваемые данные"]
# [inline (always)]
pub fn tdr (& mut self) -> TdrW < TxdataSpec > { TdrW :: new (self , 0) } } # [doc = "Регистр передаваемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`txdata::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdata::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxdataSpec ; impl crate :: RegisterSpec for TxdataSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`txdata::R`](R) reader structure"]
impl crate :: Readable for TxdataSpec { } # [doc = "`write(|w| ..)` method takes [`txdata::W`](W) writer structure"]
impl crate :: Writable for TxdataSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TXDATA to value 0"]
impl crate :: Resettable for TxdataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MODEM (rw) register accessor: Регистр управления модемом\n\nYou can [`read`](crate::Reg::read) this register and get [`modem::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`modem::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@modem`]
module"]
# [doc (alias = "MODEM")]
pub type Modem = crate :: Reg < modem :: ModemSpec > ; # [doc = "Регистр управления модемом"]
pub mod modem { # [doc = "Register `MODEM` reader"]
pub type R = crate :: R < ModemSpec > ; # [doc = "Register `MODEM` writer"]
pub type W = crate :: W < ModemSpec > ; # [doc = "Флаг взводится при изме-нении входного сигнала DSR. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dsrif { # [doc = "0: Изменений сигнала не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Сигнал изменен с момента сброса флага"]
_1 = 1 , } impl From < Dsrif > for bool { # [inline (always)]
fn from (variant : Dsrif) -> Self { variant as u8 != 0 } } # [doc = "Field `DSRIF` reader - Флаг взводится при изме-нении входного сигнала DSR. Флаг сбрасывается записью 1"]
pub type DsrifR = crate :: BitReader < Dsrif > ; impl DsrifR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dsrif { match self . bits { false => Dsrif :: _0 , true => Dsrif :: _1 , } } # [doc = "Изменений сигнала не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Dsrif :: _0 } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Dsrif :: _1 } } # [doc = "Field `DSRIF` writer - Флаг взводится при изме-нении входного сигнала DSR. Флаг сбрасывается записью 1"]
pub type DsrifW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Dsrif > ; impl < 'a , REG > DsrifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Изменений сигнала не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dsrif :: _0) } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dsrif :: _1) } } # [doc = "Флаг взводится при изме-нении входного сигнала RI с 0 на 1. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Riif { # [doc = "0: Изменений сигнала с 0 на 1 не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Сигнал изменен с момента сброса флага"]
_1 = 1 , } impl From < Riif > for bool { # [inline (always)]
fn from (variant : Riif) -> Self { variant as u8 != 0 } } # [doc = "Field `RIIF` reader - Флаг взводится при изме-нении входного сигнала RI с 0 на 1. Флаг сбрасывается записью 1"]
pub type RiifR = crate :: BitReader < Riif > ; impl RiifR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Riif { match self . bits { false => Riif :: _0 , true => Riif :: _1 , } } # [doc = "Изменений сигнала с 0 на 1 не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Riif :: _0 } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Riif :: _1 } } # [doc = "Field `RIIF` writer - Флаг взводится при изме-нении входного сигнала RI с 0 на 1. Флаг сбрасывается записью 1"]
pub type RiifW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Riif > ; impl < 'a , REG > RiifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Изменений сигнала с 0 на 1 не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Riif :: _0) } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Riif :: _1) } } # [doc = "Флаг взводится при изменении входного сигнала DCD. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dcdif { # [doc = "0: Изменений сигнала не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Сигнал изменен с момента сброса флага"]
_1 = 1 , } impl From < Dcdif > for bool { # [inline (always)]
fn from (variant : Dcdif) -> Self { variant as u8 != 0 } } # [doc = "Field `DCDIF` reader - Флаг взводится при изменении входного сигнала DCD. Флаг сбрасывается записью 1"]
pub type DcdifR = crate :: BitReader < Dcdif > ; impl DcdifR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dcdif { match self . bits { false => Dcdif :: _0 , true => Dcdif :: _1 , } } # [doc = "Изменений сигнала не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Dcdif :: _0 } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Dcdif :: _1 } } # [doc = "Field `DCDIF` writer - Флаг взводится при изменении входного сигнала DCD. Флаг сбрасывается записью 1"]
pub type DcdifW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Dcdif > ; impl < 'a , REG > DcdifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Изменений сигнала не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dcdif :: _0) } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dcdif :: _1) } } # [doc = "Регистр содержит текущее значение сигнала DSR\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dsr { # [doc = "0: Источник данных не готов"]
Unready = 0 , # [doc = "1: Источник данных готов"]
Ready = 1 , } impl From < Dsr > for bool { # [inline (always)]
fn from (variant : Dsr) -> Self { variant as u8 != 0 } } # [doc = "Field `DSR` reader - Регистр содержит текущее значение сигнала DSR"]
pub type DsrR = crate :: BitReader < Dsr > ; impl DsrR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dsr { match self . bits { false => Dsr :: Unready , true => Dsr :: Ready , } } # [doc = "Источник данных не готов"]
# [inline (always)]
pub fn is_unready (& self) -> bool { * self == Dsr :: Unready } # [doc = "Источник данных готов"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Dsr :: Ready } } # [doc = "Регистр содержит текущее значение сигнала RI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ri { # [doc = "0: Отсутствие звонка"]
_0 = 0 , # [doc = "1: Звонок (вызов) на телефон-ной линии"]
_1 = 1 , } impl From < Ri > for bool { # [inline (always)]
fn from (variant : Ri) -> Self { variant as u8 != 0 } } # [doc = "Field `RI` reader - Регистр содержит текущее значение сигнала RI"]
pub type RiR = crate :: BitReader < Ri > ; impl RiR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ri { match self . bits { false => Ri :: _0 , true => Ri :: _1 , } } # [doc = "Отсутствие звонка"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Ri :: _0 } # [doc = "Звонок (вызов) на телефон-ной линии"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Ri :: _1 } } # [doc = "Регистр содержит текущее значение сигнала DCD\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dcd { # [doc = "0: Отсутствие несущей"]
_0 = 0 , # [doc = "1: Обнаружение несущей"]
_1 = 1 , } impl From < Dcd > for bool { # [inline (always)]
fn from (variant : Dcd) -> Self { variant as u8 != 0 } } # [doc = "Field `DCD` reader - Регистр содержит текущее значение сигнала DCD"]
pub type DcdR = crate :: BitReader < Dcd > ; impl DcdR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dcd { match self . bits { false => Dcd :: _0 , true => Dcd :: _1 , } } # [doc = "Отсутствие несущей"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Dcd :: _0 } # [doc = "Обнаружение несущей"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Dcd :: _1 } } # [doc = "Регистр управления сигналом DTR\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dtr { # [doc = "0: Отсутствие сигнала готов-ности"]
Unready = 0 , # [doc = "1: Готовность к приему дан-ных"]
Ready = 1 , } impl From < Dtr > for bool { # [inline (always)]
fn from (variant : Dtr) -> Self { variant as u8 != 0 } } # [doc = "Field `DTR` reader - Регистр управления сигналом DTR"]
pub type DtrR = crate :: BitReader < Dtr > ; impl DtrR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dtr { match self . bits { false => Dtr :: Unready , true => Dtr :: Ready , } } # [doc = "Отсутствие сигнала готов-ности"]
# [inline (always)]
pub fn is_unready (& self) -> bool { * self == Dtr :: Unready } # [doc = "Готовность к приему дан-ных"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Dtr :: Ready } } # [doc = "Field `DTR` writer - Регистр управления сигналом DTR"]
pub type DtrW < 'a , REG > = crate :: BitWriter < 'a , REG , Dtr > ; impl < 'a , REG > DtrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Отсутствие сигнала готов-ности"]
# [inline (always)]
pub fn unready (self) -> & 'a mut crate :: W < REG > { self . variant (Dtr :: Unready) } # [doc = "Готовность к приему дан-ных"]
# [inline (always)]
pub fn ready (self) -> & 'a mut crate :: W < REG > { self . variant (Dtr :: Ready) } } impl R { # [doc = "Bit 1 - Флаг взводится при изме-нении входного сигнала DSR. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn dsrif (& self) -> DsrifR { DsrifR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Флаг взводится при изме-нении входного сигнала RI с 0 на 1. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn riif (& self) -> RiifR { RiifR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Флаг взводится при изменении входного сигнала DCD. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn dcdif (& self) -> DcdifR { DcdifR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Регистр содержит текущее значение сигнала DSR"]
# [inline (always)]
pub fn dsr (& self) -> DsrR { DsrR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Регистр содержит текущее значение сигнала RI"]
# [inline (always)]
pub fn ri (& self) -> RiR { RiR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Регистр содержит текущее значение сигнала DCD"]
# [inline (always)]
pub fn dcd (& self) -> DcdR { DcdR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 12 - Регистр управления сигналом DTR"]
# [inline (always)]
pub fn dtr (& self) -> DtrR { DtrR :: new (((self . bits >> 12) & 1) != 0) } } impl W { # [doc = "Bit 1 - Флаг взводится при изме-нении входного сигнала DSR. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn dsrif (& mut self) -> DsrifW < ModemSpec > { DsrifW :: new (self , 1) } # [doc = "Bit 2 - Флаг взводится при изме-нении входного сигнала RI с 0 на 1. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn riif (& mut self) -> RiifW < ModemSpec > { RiifW :: new (self , 2) } # [doc = "Bit 3 - Флаг взводится при изменении входного сигнала DCD. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn dcdif (& mut self) -> DcdifW < ModemSpec > { DcdifW :: new (self , 3) } # [doc = "Bit 12 - Регистр управления сигналом DTR"]
# [inline (always)]
pub fn dtr (& mut self) -> DtrW < ModemSpec > { DtrW :: new (self , 12) } } # [doc = "Регистр управления модемом\n\nYou can [`read`](crate::Reg::read) this register and get [`modem::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`modem::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ModemSpec ; impl crate :: RegisterSpec for ModemSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`modem::R`](R) reader structure"]
impl crate :: Readable for ModemSpec { } # [doc = "`write(|w| ..)` method takes [`modem::W`](W) writer structure"]
impl crate :: Writable for ModemSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0x0e ; } # [doc = "`reset()` method sets MODEM to value 0"]
impl crate :: Resettable for ModemSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "приемо-передатчик"]
pub struct Usart1 { _marker : PhantomData < * const () > } unsafe impl Send for Usart1 { } impl Usart1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const usart_1 :: RegisterBlock = 0x0008_1800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const usart_1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Usart1 { type Target = usart_1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Usart1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Usart1") . finish () } } # [doc = "приемо-передатчик"]
pub mod usart_1 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { control1 : Control1 , control2 : Control2 , control3 : Control3 , divider : Divider , _reserved4 : [u8 ; 0x0c]
, flags : Flags , _reserved5 : [u8 ; 0x04]
, rxdata : Rxdata , txdata : Txdata , modem : Modem , } impl RegisterBlock { # [doc = "0x00 - Регистр управления 1"]
# [inline (always)]
pub const fn control1 (& self) -> & Control1 { & self . control1 } # [doc = "0x04 - Регистр управления 2"]
# [inline (always)]
pub const fn control2 (& self) -> & Control2 { & self . control2 } # [doc = "0x08 - Регистр управления 3"]
# [inline (always)]
pub const fn control3 (& self) -> & Control3 { & self . control3 } # [doc = "0x0c - Регистр настройки делителя"]
# [inline (always)]
pub const fn divider (& self) -> & Divider { & self . divider } # [doc = "0x1c - Регистр прерываний"]
# [inline (always)]
pub const fn flags (& self) -> & Flags { & self . flags } # [doc = "0x24 - Регистр принятых данных"]
# [inline (always)]
pub const fn rxdata (& self) -> & Rxdata { & self . rxdata } # [doc = "0x28 - Регистр передаваемых данных"]
# [inline (always)]
pub const fn txdata (& self) -> & Txdata { & self . txdata } # [doc = "0x2c - Регистр управления модемом"]
# [inline (always)]
pub const fn modem (& self) -> & Modem { & self . modem } } # [doc = "CONTROL1 (rw) register accessor: Регистр управления 1\n\nYou can [`read`](crate::Reg::read) this register and get [`control1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control1`]
module"]
# [doc (alias = "CONTROL1")]
pub type Control1 = crate :: Reg < control1 :: Control1Spec > ; # [doc = "Регистр управления 1"]
pub mod control1 { # [doc = "Register `CONTROL1` reader"]
pub type R = crate :: R < Control1Spec > ; # [doc = "Register `CONTROL1` writer"]
pub type W = crate :: W < Control1Spec > ; # [doc = "Ресет USART. Отменяет все текущие операции. Не очищает регистры конфигурации, но сбрасывает флаги\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ue { # [doc = "0: USART выключен"]
Disable = 0 , # [doc = "1: USART включен"]
Enable = 1 , } impl From < Ue > for bool { # [inline (always)]
fn from (variant : Ue) -> Self { variant as u8 != 0 } } # [doc = "Field `UE` reader - Ресет USART. Отменяет все текущие операции. Не очищает регистры конфигурации, но сбрасывает флаги"]
pub type UeR = crate :: BitReader < Ue > ; impl UeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ue { match self . bits { false => Ue :: Disable , true => Ue :: Enable , } } # [doc = "USART выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Ue :: Disable } # [doc = "USART включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Ue :: Enable } } # [doc = "Field `UE` writer - Ресет USART. Отменяет все текущие операции. Не очищает регистры конфигурации, но сбрасывает флаги"]
pub type UeW < 'a , REG > = crate :: BitWriter < 'a , REG , Ue > ; impl < 'a , REG > UeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "USART выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Ue :: Disable) } # [doc = "USART включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Ue :: Enable) } } # [doc = "Управление приемником\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Re { # [doc = "0: Приемник выключен"]
Disable = 0 , # [doc = "1: Приемник включен"]
Enable = 1 , } impl From < Re > for bool { # [inline (always)]
fn from (variant : Re) -> Self { variant as u8 != 0 } } # [doc = "Field `RE` reader - Управление приемником"]
pub type ReR = crate :: BitReader < Re > ; impl ReR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Re { match self . bits { false => Re :: Disable , true => Re :: Enable , } } # [doc = "Приемник выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Re :: Disable } # [doc = "Приемник включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Re :: Enable } } # [doc = "Field `RE` writer - Управление приемником"]
pub type ReW < 'a , REG > = crate :: BitWriter < 'a , REG , Re > ; impl < 'a , REG > ReW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Приемник выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Re :: Disable) } # [doc = "Приемник включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Re :: Enable) } } # [doc = "Управление передатчиком\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Te { # [doc = "0: Передатчик выключен"]
Disable = 0 , # [doc = "1: Передатчик включен"]
Enable = 1 , } impl From < Te > for bool { # [inline (always)]
fn from (variant : Te) -> Self { variant as u8 != 0 } } # [doc = "Field `TE` reader - Управление передатчиком"]
pub type TeR = crate :: BitReader < Te > ; impl TeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Te { match self . bits { false => Te :: Disable , true => Te :: Enable , } } # [doc = "Передатчик выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Te :: Disable } # [doc = "Передатчик включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Te :: Enable } } # [doc = "Field `TE` writer - Управление передатчиком"]
pub type TeW < 'a , REG > = crate :: BitWriter < 'a , REG , Te > ; impl < 'a , REG > TeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Передатчик выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Te :: Disable) } # [doc = "Передатчик включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Te :: Enable) } } # [doc = "Управление прерыванием при отсутствии входных транзакций\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Idleie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Idleie > for bool { # [inline (always)]
fn from (variant : Idleie) -> Self { variant as u8 != 0 } } # [doc = "Field `IDLEIE` reader - Управление прерыванием при отсутствии входных транзакций"]
pub type IdleieR = crate :: BitReader < Idleie > ; impl IdleieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Idleie { match self . bits { false => Idleie :: Disable , true => Idleie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Idleie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Idleie :: Enable } } # [doc = "Field `IDLEIE` writer - Управление прерыванием при отсутствии входных транзакций"]
pub type IdleieW < 'a , REG > = crate :: BitWriter < 'a , REG , Idleie > ; impl < 'a , REG > IdleieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Idleie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Idleie :: Enable) } } # [doc = "Управление прерыванием при успешном приеме данных или перезаписи полученных данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rxneie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Rxneie > for bool { # [inline (always)]
fn from (variant : Rxneie) -> Self { variant as u8 != 0 } } # [doc = "Field `RXNEIE` reader - Управление прерыванием при успешном приеме данных или перезаписи полученных данных"]
pub type RxneieR = crate :: BitReader < Rxneie > ; impl RxneieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rxneie { match self . bits { false => Rxneie :: Disable , true => Rxneie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Rxneie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Rxneie :: Enable } } # [doc = "Field `RXNEIE` writer - Управление прерыванием при успешном приеме данных или перезаписи полученных данных"]
pub type RxneieW < 'a , REG > = crate :: BitWriter < 'a , REG , Rxneie > ; impl < 'a , REG > RxneieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxneie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxneie :: Enable) } } # [doc = "Управление прерыванием при успешной передаче данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Tcie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Tcie > for bool { # [inline (always)]
fn from (variant : Tcie) -> Self { variant as u8 != 0 } } # [doc = "Field `TCIE` reader - Управление прерыванием при успешной передаче данных"]
pub type TcieR = crate :: BitReader < Tcie > ; impl TcieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Tcie { match self . bits { false => Tcie :: Disable , true => Tcie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Tcie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Tcie :: Enable } } # [doc = "Field `TCIE` writer - Управление прерыванием при успешной передаче данных"]
pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG , Tcie > ; impl < 'a , REG > TcieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Enable) } } # [doc = "Управление прерыванием при передаче данных в момент записи данных в сдвиговый регистр\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Txeie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Txeie > for bool { # [inline (always)]
fn from (variant : Txeie) -> Self { variant as u8 != 0 } } # [doc = "Field `TXEIE` reader - Управление прерыванием при передаче данных в момент записи данных в сдвиговый регистр"]
pub type TxeieR = crate :: BitReader < Txeie > ; impl TxeieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Txeie { match self . bits { false => Txeie :: Disable , true => Txeie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Txeie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Txeie :: Enable } } # [doc = "Field `TXEIE` writer - Управление прерыванием при передаче данных в момент записи данных в сдвиговый регистр"]
pub type TxeieW < 'a , REG > = crate :: BitWriter < 'a , REG , Txeie > ; impl < 'a , REG > TxeieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Txeie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Txeie :: Enable) } } # [doc = "Управление прерыванием при ошибке в принятом бите четности\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Peie { # [doc = "0: Прерывание по ошибке в бите четности выключено"]
Disable = 0 , # [doc = "1: Прерывание по ошибке в бите четности включено"]
Enable = 1 , } impl From < Peie > for bool { # [inline (always)]
fn from (variant : Peie) -> Self { variant as u8 != 0 } } # [doc = "Field `PEIE` reader - Управление прерыванием при ошибке в принятом бите четности"]
pub type PeieR = crate :: BitReader < Peie > ; impl PeieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Peie { match self . bits { false => Peie :: Disable , true => Peie :: Enable , } } # [doc = "Прерывание по ошибке в бите четности выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Peie :: Disable } # [doc = "Прерывание по ошибке в бите четности включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Peie :: Enable } } # [doc = "Field `PEIE` writer - Управление прерыванием при ошибке в принятом бите четности"]
pub type PeieW < 'a , REG > = crate :: BitWriter < 'a , REG , Peie > ; impl < 'a , REG > PeieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание по ошибке в бите четности выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Peie :: Disable) } # [doc = "Прерывание по ошибке в бите четности включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Peie :: Enable) } } # [doc = "Выбор способа формирования бита четности. Примечание: Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ps { # [doc = "0: Бит четности"]
Parity = 0 , # [doc = "1: Бит нечетности"]
Odd = 1 , } impl From < Ps > for bool { # [inline (always)]
fn from (variant : Ps) -> Self { variant as u8 != 0 } } # [doc = "Field `PS` reader - Выбор способа формирования бита четности. Примечание: Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type PsR = crate :: BitReader < Ps > ; impl PsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ps { match self . bits { false => Ps :: Parity , true => Ps :: Odd , } } # [doc = "Бит четности"]
# [inline (always)]
pub fn is_parity (& self) -> bool { * self == Ps :: Parity } # [doc = "Бит нечетности"]
# [inline (always)]
pub fn is_odd (& self) -> bool { * self == Ps :: Odd } } # [doc = "Field `PS` writer - Выбор способа формирования бита четности. Примечание: Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type PsW < 'a , REG > = crate :: BitWriter < 'a , REG , Ps > ; impl < 'a , REG > PsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Бит четности"]
# [inline (always)]
pub fn parity (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Parity) } # [doc = "Бит нечетности"]
# [inline (always)]
pub fn odd (self) -> & 'a mut crate :: W < REG > { self . variant (Ps :: Odd) } } # [doc = "Контроль четности. Примечание: Этот бит может быть изме-нен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pce { # [doc = "0: Контроль четности выключен"]
Disable = 0 , # [doc = "1: Контроль четности включен"]
Enable = 1 , } impl From < Pce > for bool { # [inline (always)]
fn from (variant : Pce) -> Self { variant as u8 != 0 } } # [doc = "Field `PCE` reader - Контроль четности. Примечание: Этот бит может быть изме-нен только при остановке работы (UE=0)"]
pub type PceR = crate :: BitReader < Pce > ; impl PceR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pce { match self . bits { false => Pce :: Disable , true => Pce :: Enable , } } # [doc = "Контроль четности выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Pce :: Disable } # [doc = "Контроль четности включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Pce :: Enable } } # [doc = "Field `PCE` writer - Контроль четности. Примечание: Этот бит может быть изме-нен только при остановке работы (UE=0)"]
pub type PceW < 'a , REG > = crate :: BitWriter < 'a , REG , Pce > ; impl < 'a , REG > PceW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Контроль четности выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Pce :: Disable) } # [doc = "Контроль четности включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Pce :: Enable) } } # [doc = "M1\\[28\\]
и M0\\[12\\]
управляют длиной кадра. Примечание: Эти биты можгут быть изменены только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u32)]
pub enum M { # [doc = "0: 8 бит данных"]
_8bits = 0 , # [doc = "1: 9 бит данных"]
_9bits = 1 , # [doc = "65536: 7 бит данных"]
_7bits = 65536 , } impl From < M > for u32 { # [inline (always)]
fn from (variant : M) -> Self { variant as _ } } impl crate :: FieldSpec for M { type Ux = u32 ; } impl crate :: IsEnum for M { } # [doc = "Field `M` reader - M1\\[28\\]
и M0\\[12\\]
управляют длиной кадра. Примечание: Эти биты можгут быть изменены только при остановке работы (UE=0)"]
pub type MR = crate :: FieldReader < M > ; impl MR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < M > { match self . bits { 0 => Some (M :: _8bits) , 1 => Some (M :: _9bits) , 65536 => Some (M :: _7bits) , _ => None , } } # [doc = "8 бит данных"]
# [inline (always)]
pub fn is_8bits (& self) -> bool { * self == M :: _8bits } # [doc = "9 бит данных"]
# [inline (always)]
pub fn is_9bits (& self) -> bool { * self == M :: _9bits } # [doc = "7 бит данных"]
# [inline (always)]
pub fn is_7bits (& self) -> bool { * self == M :: _7bits } } # [doc = "Field `M` writer - M1\\[28\\]
и M0\\[12\\]
управляют длиной кадра. Примечание: Эти биты можгут быть изменены только при остановке работы (UE=0)"]
pub type MW < 'a , REG > = crate :: FieldWriter < 'a , REG , 17 , M > ; impl < 'a , REG > MW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u32 > { # [doc = "8 бит данных"]
# [inline (always)]
pub fn _8bits (self) -> & 'a mut crate :: W < REG > { self . variant (M :: _8bits) } # [doc = "9 бит данных"]
# [inline (always)]
pub fn _9bits (self) -> & 'a mut crate :: W < REG > { self . variant (M :: _9bits) } # [doc = "7 бит данных"]
# [inline (always)]
pub fn _7bits (self) -> & 'a mut crate :: W < REG > { self . variant (M :: _7bits) } } impl R { # [doc = "Bit 0 - Ресет USART. Отменяет все текущие операции. Не очищает регистры конфигурации, но сбрасывает флаги"]
# [inline (always)]
pub fn ue (& self) -> UeR { UeR :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Управление приемником"]
# [inline (always)]
pub fn re (& self) -> ReR { ReR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Управление передатчиком"]
# [inline (always)]
pub fn te (& self) -> TeR { TeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Управление прерыванием при отсутствии входных транзакций"]
# [inline (always)]
pub fn idleie (& self) -> IdleieR { IdleieR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Управление прерыванием при успешном приеме данных или перезаписи полученных данных"]
# [inline (always)]
pub fn rxneie (& self) -> RxneieR { RxneieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Управление прерыванием при успешной передаче данных"]
# [inline (always)]
pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Управление прерыванием при передаче данных в момент записи данных в сдвиговый регистр"]
# [inline (always)]
pub fn txeie (& self) -> TxeieR { TxeieR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Управление прерыванием при ошибке в принятом бите четности"]
# [inline (always)]
pub fn peie (& self) -> PeieR { PeieR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Выбор способа формирования бита четности. Примечание: Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ps (& self) -> PsR { PsR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Контроль четности. Примечание: Этот бит может быть изме-нен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn pce (& self) -> PceR { PceR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bits 12:28 - M1\\[28\\]
и M0\\[12\\]
управляют длиной кадра. Примечание: Эти биты можгут быть изменены только при остановке работы (UE=0)"]
# [inline (always)]
pub fn m (& self) -> MR { MR :: new ((self . bits >> 12) & 0x0001_ffff) } } impl W { # [doc = "Bit 0 - Ресет USART. Отменяет все текущие операции. Не очищает регистры конфигурации, но сбрасывает флаги"]
# [inline (always)]
pub fn ue (& mut self) -> UeW < Control1Spec > { UeW :: new (self , 0) } # [doc = "Bit 2 - Управление приемником"]
# [inline (always)]
pub fn re (& mut self) -> ReW < Control1Spec > { ReW :: new (self , 2) } # [doc = "Bit 3 - Управление передатчиком"]
# [inline (always)]
pub fn te (& mut self) -> TeW < Control1Spec > { TeW :: new (self , 3) } # [doc = "Bit 4 - Управление прерыванием при отсутствии входных транзакций"]
# [inline (always)]
pub fn idleie (& mut self) -> IdleieW < Control1Spec > { IdleieW :: new (self , 4) } # [doc = "Bit 5 - Управление прерыванием при успешном приеме данных или перезаписи полученных данных"]
# [inline (always)]
pub fn rxneie (& mut self) -> RxneieW < Control1Spec > { RxneieW :: new (self , 5) } # [doc = "Bit 6 - Управление прерыванием при успешной передаче данных"]
# [inline (always)]
pub fn tcie (& mut self) -> TcieW < Control1Spec > { TcieW :: new (self , 6) } # [doc = "Bit 7 - Управление прерыванием при передаче данных в момент записи данных в сдвиговый регистр"]
# [inline (always)]
pub fn txeie (& mut self) -> TxeieW < Control1Spec > { TxeieW :: new (self , 7) } # [doc = "Bit 8 - Управление прерыванием при ошибке в принятом бите четности"]
# [inline (always)]
pub fn peie (& mut self) -> PeieW < Control1Spec > { PeieW :: new (self , 8) } # [doc = "Bit 9 - Выбор способа формирования бита четности. Примечание: Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ps (& mut self) -> PsW < Control1Spec > { PsW :: new (self , 9) } # [doc = "Bit 10 - Контроль четности. Примечание: Этот бит может быть изме-нен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn pce (& mut self) -> PceW < Control1Spec > { PceW :: new (self , 10) } # [doc = "Bits 12:28 - M1\\[28\\]
и M0\\[12\\]
управляют длиной кадра. Примечание: Эти биты можгут быть изменены только при остановке работы (UE=0)"]
# [inline (always)]
pub fn m (& mut self) -> MW < Control1Spec > { MW :: new (self , 12) } } # [doc = "Регистр управления 1\n\nYou can [`read`](crate::Reg::read) this register and get [`control1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Control1Spec ; impl crate :: RegisterSpec for Control1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`control1::R`](R) reader structure"]
impl crate :: Readable for Control1Spec { } # [doc = "`write(|w| ..)` method takes [`control1::W`](W) writer structure"]
impl crate :: Writable for Control1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL1 to value 0"]
impl crate :: Resettable for Control1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONTROL2 (rw) register accessor: Регистр управления 2\n\nYou can [`read`](crate::Reg::read) this register and get [`control2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control2`]
module"]
# [doc (alias = "CONTROL2")]
pub type Control2 = crate :: Reg < control2 :: Control2Spec > ; # [doc = "Регистр управления 2"]
pub mod control2 { # [doc = "Register `CONTROL2` reader"]
pub type R = crate :: R < Control2Spec > ; # [doc = "Register `CONTROL2` writer"]
pub type W = crate :: W < Control2Spec > ; # [doc = "Управление прерыванием при обнаружении break состояния на RX линии\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Lbdie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Lbdie > for bool { # [inline (always)]
fn from (variant : Lbdie) -> Self { variant as u8 != 0 } } # [doc = "Field `LBDIE` reader - Управление прерыванием при обнаружении break состояния на RX линии"]
pub type LbdieR = crate :: BitReader < Lbdie > ; impl LbdieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Lbdie { match self . bits { false => Lbdie :: Disable , true => Lbdie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Lbdie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Lbdie :: Enable } } # [doc = "Field `LBDIE` writer - Управление прерыванием при обнаружении break состояния на RX линии"]
pub type LbdieW < 'a , REG > = crate :: BitWriter < 'a , REG , Lbdie > ; impl < 'a , REG > LbdieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Lbdie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Lbdie :: Enable) } } # [doc = "Управление последним тактовым импульсом. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Lbcl { # [doc = "0: Последний тактовый импульс отсутствует"]
_0 = 0 , # [doc = "1: Последний тактовый импульс присутствует."]
_1 = 1 , } impl From < Lbcl > for bool { # [inline (always)]
fn from (variant : Lbcl) -> Self { variant as u8 != 0 } } # [doc = "Field `LBCL` reader - Управление последним тактовым импульсом. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type LbclR = crate :: BitReader < Lbcl > ; impl LbclR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Lbcl { match self . bits { false => Lbcl :: _0 , true => Lbcl :: _1 , } } # [doc = "Последний тактовый импульс отсутствует"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Lbcl :: _0 } # [doc = "Последний тактовый импульс присутствует."]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Lbcl :: _1 } } # [doc = "Field `LBCL` writer - Управление последним тактовым импульсом. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type LbclW < 'a , REG > = crate :: BitWriter < 'a , REG , Lbcl > ; impl < 'a , REG > LbclW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Последний тактовый импульс отсутствует"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Lbcl :: _0) } # [doc = "Последний тактовый импульс присутствует."]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Lbcl :: _1) } } # [doc = "Управление фазой выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cpha { # [doc = "0: Первое изменение тактового сигнала – фронт"]
_0 = 0 , # [doc = "1: Первое изменение тактового сигнала – срез (обратный фронт)."]
_1 = 1 , } impl From < Cpha > for bool { # [inline (always)]
fn from (variant : Cpha) -> Self { variant as u8 != 0 } } # [doc = "Field `CPHA` reader - Управление фазой выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type CphaR = crate :: BitReader < Cpha > ; impl CphaR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cpha { match self . bits { false => Cpha :: _0 , true => Cpha :: _1 , } } # [doc = "Первое изменение тактового сигнала – фронт"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Cpha :: _0 } # [doc = "Первое изменение тактового сигнала – срез (обратный фронт)."]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Cpha :: _1 } } # [doc = "Field `CPHA` writer - Управление фазой выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type CphaW < 'a , REG > = crate :: BitWriter < 'a , REG , Cpha > ; impl < 'a , REG > CphaW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Первое изменение тактового сигнала – фронт"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpha :: _0) } # [doc = "Первое изменение тактового сигнала – срез (обратный фронт)."]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpha :: _1) } } # [doc = "Управление полярностью выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cpol { # [doc = "0: Логический «0» вне транзакции"]
_0 = 0 , # [doc = "1: Логическая «1» вне транзакции"]
_1 = 1 , } impl From < Cpol > for bool { # [inline (always)]
fn from (variant : Cpol) -> Self { variant as u8 != 0 } } # [doc = "Field `CPOL` reader - Управление полярностью выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type CpolR = crate :: BitReader < Cpol > ; impl CpolR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cpol { match self . bits { false => Cpol :: _0 , true => Cpol :: _1 , } } # [doc = "Логический «0» вне транзакции"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Cpol :: _0 } # [doc = "Логическая «1» вне транзакции"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Cpol :: _1 } } # [doc = "Field `CPOL` writer - Управление полярностью выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type CpolW < 'a , REG > = crate :: BitWriter < 'a , REG , Cpol > ; impl < 'a , REG > CpolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Логический «0» вне транзакции"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpol :: _0) } # [doc = "Логическая «1» вне транзакции"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Cpol :: _1) } } # [doc = "Управление синхронным режимом. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Clken { # [doc = "0: Синхронный режим выключен"]
Asynchronous = 0 , # [doc = "1: Синхронный режим включен"]
Synchronous = 1 , } impl From < Clken > for bool { # [inline (always)]
fn from (variant : Clken) -> Self { variant as u8 != 0 } } # [doc = "Field `CLKEN` reader - Управление синхронным режимом. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type ClkenR = crate :: BitReader < Clken > ; impl ClkenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Clken { match self . bits { false => Clken :: Asynchronous , true => Clken :: Synchronous , } } # [doc = "Синхронный режим выключен"]
# [inline (always)]
pub fn is_asynchronous (& self) -> bool { * self == Clken :: Asynchronous } # [doc = "Синхронный режим включен"]
# [inline (always)]
pub fn is_synchronous (& self) -> bool { * self == Clken :: Synchronous } } # [doc = "Field `CLKEN` writer - Управление синхронным режимом. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type ClkenW < 'a , REG > = crate :: BitWriter < 'a , REG , Clken > ; impl < 'a , REG > ClkenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Синхронный режим выключен"]
# [inline (always)]
pub fn asynchronous (self) -> & 'a mut crate :: W < REG > { self . variant (Clken :: Asynchronous) } # [doc = "Синхронный режим включен"]
# [inline (always)]
pub fn synchronous (self) -> & 'a mut crate :: W < REG > { self . variant (Clken :: Synchronous) } } # [doc = "Количество стоп битов для приемника и передатчика. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Stop1 { # [doc = "0: 1 стоп бит"]
_1bit = 0 , # [doc = "1: 2 стоп бита"]
_2bits = 1 , } impl From < Stop1 > for bool { # [inline (always)]
fn from (variant : Stop1) -> Self { variant as u8 != 0 } } # [doc = "Field `STOP_1` reader - Количество стоп битов для приемника и передатчика. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type Stop1R = crate :: BitReader < Stop1 > ; impl Stop1R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Stop1 { match self . bits { false => Stop1 :: _1bit , true => Stop1 :: _2bits , } } # [doc = "1 стоп бит"]
# [inline (always)]
pub fn is_1bit (& self) -> bool { * self == Stop1 :: _1bit } # [doc = "2 стоп бита"]
# [inline (always)]
pub fn is_2bits (& self) -> bool { * self == Stop1 :: _2bits } } # [doc = "Field `STOP_1` writer - Количество стоп битов для приемника и передатчика. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type Stop1W < 'a , REG > = crate :: BitWriter < 'a , REG , Stop1 > ; impl < 'a , REG > Stop1W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "1 стоп бит"]
# [inline (always)]
pub fn _1bit (self) -> & 'a mut crate :: W < REG > { self . variant (Stop1 :: _1bit) } # [doc = "2 стоп бита"]
# [inline (always)]
pub fn _2bits (self) -> & 'a mut crate :: W < REG > { self . variant (Stop1 :: _2bits) } } # [doc = "Регистр режима обратной внутренней петли. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Lbm { # [doc = "0: Обычное функционирование"]
Normal = 0 , # [doc = "1: Сигналы TX и RTS подаются внутрь блока в обход входов RX и CTS. При этом TX = 1 и RTS = 1, входы RX и CTS не активны"]
Loopback = 1 , } impl From < Lbm > for bool { # [inline (always)]
fn from (variant : Lbm) -> Self { variant as u8 != 0 } } # [doc = "Field `LBM` reader - Регистр режима обратной внутренней петли. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type LbmR = crate :: BitReader < Lbm > ; impl LbmR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Lbm { match self . bits { false => Lbm :: Normal , true => Lbm :: Loopback , } } # [doc = "Обычное функционирование"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == Lbm :: Normal } # [doc = "Сигналы TX и RTS подаются внутрь блока в обход входов RX и CTS. При этом TX = 1 и RTS = 1, входы RX и CTS не активны"]
# [inline (always)]
pub fn is_loopback (& self) -> bool { * self == Lbm :: Loopback } } # [doc = "Field `LBM` writer - Регистр режима обратной внутренней петли. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type LbmW < 'a , REG > = crate :: BitWriter < 'a , REG , Lbm > ; impl < 'a , REG > LbmW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычное функционирование"]
# [inline (always)]
pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Lbm :: Normal) } # [doc = "Сигналы TX и RTS подаются внутрь блока в обход входов RX и CTS. При этом TX = 1 и RTS = 1, входы RX и CTS не активны"]
# [inline (always)]
pub fn loopback (self) -> & 'a mut crate :: W < REG > { self . variant (Lbm :: Loopback) } } # [doc = "Обмен функциями TX выхода и RX входа. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Swap { # [doc = "0: Обычное функционирование"]
Normal = 0 , # [doc = "1: Обмен функциями (TX = RX и RX = TX)."]
Swap = 1 , } impl From < Swap > for bool { # [inline (always)]
fn from (variant : Swap) -> Self { variant as u8 != 0 } } # [doc = "Field `SWAP` reader - Обмен функциями TX выхода и RX входа. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type SwapR = crate :: BitReader < Swap > ; impl SwapR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Swap { match self . bits { false => Swap :: Normal , true => Swap :: Swap , } } # [doc = "Обычное функционирование"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == Swap :: Normal } # [doc = "Обмен функциями (TX = RX и RX = TX)."]
# [inline (always)]
pub fn is_swap (& self) -> bool { * self == Swap :: Swap } } # [doc = "Field `SWAP` writer - Обмен функциями TX выхода и RX входа. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type SwapW < 'a , REG > = crate :: BitWriter < 'a , REG , Swap > ; impl < 'a , REG > SwapW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычное функционирование"]
# [inline (always)]
pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Swap :: Normal) } # [doc = "Обмен функциями (TX = RX и RX = TX)."]
# [inline (always)]
pub fn swap (self) -> & 'a mut crate :: W < REG > { self . variant (Swap :: Swap) } } # [doc = "Управление полярностью RX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rxinv { # [doc = "0: Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
Direct = 0 , # [doc = "1: Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
Inverted = 1 , } impl From < Rxinv > for bool { # [inline (always)]
fn from (variant : Rxinv) -> Self { variant as u8 != 0 } } # [doc = "Field `RXINV` reader - Управление полярностью RX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type RxinvR = crate :: BitReader < Rxinv > ; impl RxinvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rxinv { match self . bits { false => Rxinv :: Direct , true => Rxinv :: Inverted , } } # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == Rxinv :: Direct } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == Rxinv :: Inverted } } # [doc = "Field `RXINV` writer - Управление полярностью RX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type RxinvW < 'a , REG > = crate :: BitWriter < 'a , REG , Rxinv > ; impl < 'a , REG > RxinvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (Rxinv :: Direct) } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (Rxinv :: Inverted) } } # [doc = "Управление полярностью TX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Txinv { # [doc = "0: Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
Direct = 0 , # [doc = "1: Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
Inverted = 1 , } impl From < Txinv > for bool { # [inline (always)]
fn from (variant : Txinv) -> Self { variant as u8 != 0 } } # [doc = "Field `TXINV` reader - Управление полярностью TX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type TxinvR = crate :: BitReader < Txinv > ; impl TxinvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Txinv { match self . bits { false => Txinv :: Direct , true => Txinv :: Inverted , } } # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == Txinv :: Direct } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == Txinv :: Inverted } } # [doc = "Field `TXINV` writer - Управление полярностью TX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type TxinvW < 'a , REG > = crate :: BitWriter < 'a , REG , Txinv > ; impl < 'a , REG > TxinvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (Txinv :: Direct) } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (Txinv :: Inverted) } } # [doc = "Управление полярностью принимаемых и передаваемых данных. Изменение полярности не влияет на бит четности. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Datainv { # [doc = "0: Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
Direct = 0 , # [doc = "1: Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
Inverted = 1 , } impl From < Datainv > for bool { # [inline (always)]
fn from (variant : Datainv) -> Self { variant as u8 != 0 } } # [doc = "Field `DATAINV` reader - Управление полярностью принимаемых и передаваемых данных. Изменение полярности не влияет на бит четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type DatainvR = crate :: BitReader < Datainv > ; impl DatainvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Datainv { match self . bits { false => Datainv :: Direct , true => Datainv :: Inverted , } } # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == Datainv :: Direct } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == Datainv :: Inverted } } # [doc = "Field `DATAINV` writer - Управление полярностью принимаемых и передаваемых данных. Изменение полярности не влияет на бит четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type DatainvW < 'a , REG > = crate :: BitWriter < 'a , REG , Datainv > ; impl < 'a , REG > DatainvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычная полярность. 0 - низкий уровень, 1 - высокий уровень"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (Datainv :: Direct) } # [doc = "Обратная полярность. 1 - низкий уровень, 0 - высокий уровень"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (Datainv :: Inverted) } } # [doc = "Управление очередностью приема и передачи данных. Этот бит не влияет на передачу и прием бита четности. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Msbfirst { # [doc = "0: Начинать с 0 бита"]
Lsb = 0 , # [doc = "1: Начинать с 9, 8 или 7 в зависимости от настроек длины посылки."]
Msb = 1 , } impl From < Msbfirst > for bool { # [inline (always)]
fn from (variant : Msbfirst) -> Self { variant as u8 != 0 } } # [doc = "Field `MSBFIRST` reader - Управление очередностью приема и передачи данных. Этот бит не влияет на передачу и прием бита четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type MsbfirstR = crate :: BitReader < Msbfirst > ; impl MsbfirstR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Msbfirst { match self . bits { false => Msbfirst :: Lsb , true => Msbfirst :: Msb , } } # [doc = "Начинать с 0 бита"]
# [inline (always)]
pub fn is_lsb (& self) -> bool { * self == Msbfirst :: Lsb } # [doc = "Начинать с 9, 8 или 7 в зависимости от настроек длины посылки."]
# [inline (always)]
pub fn is_msb (& self) -> bool { * self == Msbfirst :: Msb } } # [doc = "Field `MSBFIRST` writer - Управление очередностью приема и передачи данных. Этот бит не влияет на передачу и прием бита четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type MsbfirstW < 'a , REG > = crate :: BitWriter < 'a , REG , Msbfirst > ; impl < 'a , REG > MsbfirstW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Начинать с 0 бита"]
# [inline (always)]
pub fn lsb (self) -> & 'a mut crate :: W < REG > { self . variant (Msbfirst :: Lsb) } # [doc = "Начинать с 9, 8 или 7 в зависимости от настроек длины посылки."]
# [inline (always)]
pub fn msb (self) -> & 'a mut crate :: W < REG > { self . variant (Msbfirst :: Msb) } } impl R { # [doc = "Bit 6 - Управление прерыванием при обнаружении break состояния на RX линии"]
# [inline (always)]
pub fn lbdie (& self) -> LbdieR { LbdieR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 8 - Управление последним тактовым импульсом. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn lbcl (& self) -> LbclR { LbclR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Управление фазой выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn cpha (& self) -> CphaR { CphaR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Управление полярностью выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn cpol (& self) -> CpolR { CpolR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Управление синхронным режимом. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn clken (& self) -> ClkenR { ClkenR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 13 - Количество стоп битов для приемника и передатчика. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn stop_1 (& self) -> Stop1R { Stop1R :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Регистр режима обратной внутренней петли. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn lbm (& self) -> LbmR { LbmR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Обмен функциями TX выхода и RX входа. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn swap (& self) -> SwapR { SwapR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Управление полярностью RX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn rxinv (& self) -> RxinvR { RxinvR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Управление полярностью TX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn txinv (& self) -> TxinvR { TxinvR :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 18 - Управление полярностью принимаемых и передаваемых данных. Изменение полярности не влияет на бит четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn datainv (& self) -> DatainvR { DatainvR :: new (((self . bits >> 18) & 1) != 0) } # [doc = "Bit 19 - Управление очередностью приема и передачи данных. Этот бит не влияет на передачу и прием бита четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn msbfirst (& self) -> MsbfirstR { MsbfirstR :: new (((self . bits >> 19) & 1) != 0) } } impl W { # [doc = "Bit 6 - Управление прерыванием при обнаружении break состояния на RX линии"]
# [inline (always)]
pub fn lbdie (& mut self) -> LbdieW < Control2Spec > { LbdieW :: new (self , 6) } # [doc = "Bit 8 - Управление последним тактовым импульсом. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn lbcl (& mut self) -> LbclW < Control2Spec > { LbclW :: new (self , 8) } # [doc = "Bit 9 - Управление фазой выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn cpha (& mut self) -> CphaW < Control2Spec > { CphaW :: new (self , 9) } # [doc = "Bit 10 - Управление полярностью выходного тактового сигнала CK. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn cpol (& mut self) -> CpolW < Control2Spec > { CpolW :: new (self , 10) } # [doc = "Bit 11 - Управление синхронным режимом. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn clken (& mut self) -> ClkenW < Control2Spec > { ClkenW :: new (self , 11) } # [doc = "Bit 13 - Количество стоп битов для приемника и передатчика. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn stop_1 (& mut self) -> Stop1W < Control2Spec > { Stop1W :: new (self , 13) } # [doc = "Bit 14 - Регистр режима обратной внутренней петли. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn lbm (& mut self) -> LbmW < Control2Spec > { LbmW :: new (self , 14) } # [doc = "Bit 15 - Обмен функциями TX выхода и RX входа. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn swap (& mut self) -> SwapW < Control2Spec > { SwapW :: new (self , 15) } # [doc = "Bit 16 - Управление полярностью RX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn rxinv (& mut self) -> RxinvW < Control2Spec > { RxinvW :: new (self , 16) } # [doc = "Bit 17 - Управление полярностью TX выхода. Регистр влияет не только на данные, но и на стоп биты, старт биты и тд. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn txinv (& mut self) -> TxinvW < Control2Spec > { TxinvW :: new (self , 17) } # [doc = "Bit 18 - Управление полярностью принимаемых и передаваемых данных. Изменение полярности не влияет на бит четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn datainv (& mut self) -> DatainvW < Control2Spec > { DatainvW :: new (self , 18) } # [doc = "Bit 19 - Управление очередностью приема и передачи данных. Этот бит не влияет на передачу и прием бита четности. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn msbfirst (& mut self) -> MsbfirstW < Control2Spec > { MsbfirstW :: new (self , 19) } } # [doc = "Регистр управления 2\n\nYou can [`read`](crate::Reg::read) this register and get [`control2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Control2Spec ; impl crate :: RegisterSpec for Control2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`control2::R`](R) reader structure"]
impl crate :: Readable for Control2Spec { } # [doc = "`write(|w| ..)` method takes [`control2::W`](W) writer structure"]
impl crate :: Writable for Control2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL2 to value 0"]
impl crate :: Resettable for Control2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONTROL3 (rw) register accessor: Регистр управления 3\n\nYou can [`read`](crate::Reg::read) this register and get [`control3::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control3::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control3`]
module"]
# [doc (alias = "CONTROL3")]
pub type Control3 = crate :: Reg < control3 :: Control3Spec > ; # [doc = "Регистр управления 3"]
pub mod control3 { # [doc = "Register `CONTROL3` reader"]
pub type R = crate :: R < Control3Spec > ; # [doc = "Register `CONTROL3` writer"]
pub type W = crate :: W < Control3Spec > ; # [doc = "Управление прерыванием при обнаружении ошибок приема данных (FE, ORE, NF)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Eie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Eie > for bool { # [inline (always)]
fn from (variant : Eie) -> Self { variant as u8 != 0 } } # [doc = "Field `EIE` reader - Управление прерыванием при обнаружении ошибок приема данных (FE, ORE, NF)"]
pub type EieR = crate :: BitReader < Eie > ; impl EieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Eie { match self . bits { false => Eie :: Disable , true => Eie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Eie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Eie :: Enable } } # [doc = "Field `EIE` writer - Управление прерыванием при обнаружении ошибок приема данных (FE, ORE, NF)"]
pub type EieW < 'a , REG > = crate :: BitWriter < 'a , REG , Eie > ; impl < 'a , REG > EieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Eie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Eie :: Enable) } } # [doc = "Переход передатчика в break состояние\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Sbkrq { # [doc = "0: Обычный режим работы"]
Normal = 0 , # [doc = "1: Состояние break на линии TX"]
BreakTx = 1 , } impl From < Sbkrq > for bool { # [inline (always)]
fn from (variant : Sbkrq) -> Self { variant as u8 != 0 } } # [doc = "Field `SBKRQ` reader - Переход передатчика в break состояние"]
pub type SbkrqR = crate :: BitReader < Sbkrq > ; impl SbkrqR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Sbkrq { match self . bits { false => Sbkrq :: Normal , true => Sbkrq :: BreakTx , } } # [doc = "Обычный режим работы"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == Sbkrq :: Normal } # [doc = "Состояние break на линии TX"]
# [inline (always)]
pub fn is_break_tx (& self) -> bool { * self == Sbkrq :: BreakTx } } # [doc = "Field `SBKRQ` writer - Переход передатчика в break состояние"]
pub type SbkrqW < 'a , REG > = crate :: BitWriter < 'a , REG , Sbkrq > ; impl < 'a , REG > SbkrqW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Обычный режим работы"]
# [inline (always)]
pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Sbkrq :: Normal) } # [doc = "Состояние break на линии TX"]
# [inline (always)]
pub fn break_tx (self) -> & 'a mut crate :: W < REG > { self . variant (Sbkrq :: BreakTx) } } # [doc = "Выбор между полудуплексным и дуплексным режимами работы. В полудуплексном режиме RX не используется, все данные передаются и принимаются через TX. При наличии данных на передачу происходит отправка данных в остальное время прием. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Hdsel { # [doc = "0: Дуплексный режим работы"]
Duplex = 0 , # [doc = "1: Полудуплексный режим работы"]
HalfDuplex = 1 , } impl From < Hdsel > for bool { # [inline (always)]
fn from (variant : Hdsel) -> Self { variant as u8 != 0 } } # [doc = "Field `HDSEL` reader - Выбор между полудуплексным и дуплексным режимами работы. В полудуплексном режиме RX не используется, все данные передаются и принимаются через TX. При наличии данных на передачу происходит отправка данных в остальное время прием. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type HdselR = crate :: BitReader < Hdsel > ; impl HdselR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Hdsel { match self . bits { false => Hdsel :: Duplex , true => Hdsel :: HalfDuplex , } } # [doc = "Дуплексный режим работы"]
# [inline (always)]
pub fn is_duplex (& self) -> bool { * self == Hdsel :: Duplex } # [doc = "Полудуплексный режим работы"]
# [inline (always)]
pub fn is_half_duplex (& self) -> bool { * self == Hdsel :: HalfDuplex } } # [doc = "Field `HDSEL` writer - Выбор между полудуплексным и дуплексным режимами работы. В полудуплексном режиме RX не используется, все данные передаются и принимаются через TX. При наличии данных на передачу происходит отправка данных в остальное время прием. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type HdselW < 'a , REG > = crate :: BitWriter < 'a , REG , Hdsel > ; impl < 'a , REG > HdselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Дуплексный режим работы"]
# [inline (always)]
pub fn duplex (self) -> & 'a mut crate :: W < REG > { self . variant (Hdsel :: Duplex) } # [doc = "Полудуплексный режим работы"]
# [inline (always)]
pub fn half_duplex (self) -> & 'a mut crate :: W < REG > { self . variant (Hdsel :: HalfDuplex) } } # [doc = "Управление работой сигна-ла dma_rrq\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dmar { # [doc = "0: Сигнал выключен"]
Disable = 0 , # [doc = "1: Сигнал включен"]
Enable = 1 , } impl From < Dmar > for bool { # [inline (always)]
fn from (variant : Dmar) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAR` reader - Управление работой сигна-ла dma_rrq"]
pub type DmarR = crate :: BitReader < Dmar > ; impl DmarR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dmar { match self . bits { false => Dmar :: Disable , true => Dmar :: Enable , } } # [doc = "Сигнал выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dmar :: Disable } # [doc = "Сигнал включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dmar :: Enable } } # [doc = "Field `DMAR` writer - Управление работой сигна-ла dma_rrq"]
pub type DmarW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmar > ; impl < 'a , REG > DmarW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сигнал выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dmar :: Disable) } # [doc = "Сигнал включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dmar :: Enable) } } # [doc = "Управление работой сигнала dma_trq\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dmat { # [doc = "0: Сигнал выключен"]
Disable = 0 , # [doc = "1: Сигнал включен"]
Enable = 1 , } impl From < Dmat > for bool { # [inline (always)]
fn from (variant : Dmat) -> Self { variant as u8 != 0 } } # [doc = "Field `DMAT` reader - Управление работой сигнала dma_trq"]
pub type DmatR = crate :: BitReader < Dmat > ; impl DmatR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dmat { match self . bits { false => Dmat :: Disable , true => Dmat :: Enable , } } # [doc = "Сигнал выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dmat :: Disable } # [doc = "Сигнал включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Dmat :: Enable } } # [doc = "Field `DMAT` writer - Управление работой сигнала dma_trq"]
pub type DmatW < 'a , REG > = crate :: BitWriter < 'a , REG , Dmat > ; impl < 'a , REG > DmatW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сигнал выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dmat :: Disable) } # [doc = "Сигнал включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Dmat :: Enable) } } # [doc = "Управление выходным сигналом RTS. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rtse { # [doc = "0: Сигнал всегда в разрешающем состоянии (RTS = 0)"]
_0 = 0 , # [doc = "1: Сигнал находится в разрешающем состоянии (RTS = 0), только когда приемник готов принять данные"]
_1 = 1 , } impl From < Rtse > for bool { # [inline (always)]
fn from (variant : Rtse) -> Self { variant as u8 != 0 } } # [doc = "Field `RTSE` reader - Управление выходным сигналом RTS. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type RtseR = crate :: BitReader < Rtse > ; impl RtseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rtse { match self . bits { false => Rtse :: _0 , true => Rtse :: _1 , } } # [doc = "Сигнал всегда в разрешающем состоянии (RTS = 0)"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Rtse :: _0 } # [doc = "Сигнал находится в разрешающем состоянии (RTS = 0), только когда приемник готов принять данные"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Rtse :: _1 } } # [doc = "Field `RTSE` writer - Управление выходным сигналом RTS. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type RtseW < 'a , REG > = crate :: BitWriter < 'a , REG , Rtse > ; impl < 'a , REG > RtseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сигнал всегда в разрешающем состоянии (RTS = 0)"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Rtse :: _0) } # [doc = "Сигнал находится в разрешающем состоянии (RTS = 0), только когда приемник готов принять данные"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Rtse :: _1) } } # [doc = "Выбор реакции на входной сигнал CTS. Этот бит может быть изме-нен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ctse { # [doc = "0: Сигнал игнорируется"]
Ignored = 0 , # [doc = "1: сигнал управляет передачей данных трансмиттером. Передача разрешена при (CTS = 0)"]
Control = 1 , } impl From < Ctse > for bool { # [inline (always)]
fn from (variant : Ctse) -> Self { variant as u8 != 0 } } # [doc = "Field `CTSE` reader - Выбор реакции на входной сигнал CTS. Этот бит может быть изме-нен только при остановке работы (UE=0)"]
pub type CtseR = crate :: BitReader < Ctse > ; impl CtseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ctse { match self . bits { false => Ctse :: Ignored , true => Ctse :: Control , } } # [doc = "Сигнал игнорируется"]
# [inline (always)]
pub fn is_ignored (& self) -> bool { * self == Ctse :: Ignored } # [doc = "сигнал управляет передачей данных трансмиттером. Передача разрешена при (CTS = 0)"]
# [inline (always)]
pub fn is_control (& self) -> bool { * self == Ctse :: Control } } # [doc = "Field `CTSE` writer - Выбор реакции на входной сигнал CTS. Этот бит может быть изме-нен только при остановке работы (UE=0)"]
pub type CtseW < 'a , REG > = crate :: BitWriter < 'a , REG , Ctse > ; impl < 'a , REG > CtseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сигнал игнорируется"]
# [inline (always)]
pub fn ignored (self) -> & 'a mut crate :: W < REG > { self . variant (Ctse :: Ignored) } # [doc = "сигнал управляет передачей данных трансмиттером. Передача разрешена при (CTS = 0)"]
# [inline (always)]
pub fn control (self) -> & 'a mut crate :: W < REG > { self . variant (Ctse :: Control) } } # [doc = "Управление прерыванием при обнаружении измене-ния CTS\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ctsie { # [doc = "0: Прерывание выключено"]
Disable = 0 , # [doc = "1: Прерывание включено"]
Enable = 1 , } impl From < Ctsie > for bool { # [inline (always)]
fn from (variant : Ctsie) -> Self { variant as u8 != 0 } } # [doc = "Field `CTSIE` reader - Управление прерыванием при обнаружении измене-ния CTS"]
pub type CtsieR = crate :: BitReader < Ctsie > ; impl CtsieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ctsie { match self . bits { false => Ctsie :: Disable , true => Ctsie :: Enable , } } # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Ctsie :: Disable } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Ctsie :: Enable } } # [doc = "Field `CTSIE` writer - Управление прерыванием при обнаружении измене-ния CTS"]
pub type CtsieW < 'a , REG > = crate :: BitWriter < 'a , REG , Ctsie > ; impl < 'a , REG > CtsieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Ctsie :: Disable) } # [doc = "Прерывание включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Ctsie :: Enable) } } # [doc = "Выбор реакции на переполнение. Этот бит может быть изменен только при остановке работы (UE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ovrdis { # [doc = "0: При переполнении взводится флаг ошибки (ORE), новые данные не записываются"]
_0 = 0 , # [doc = "1: флаг переполнения не взводится, данные перезаписываются"]
_1 = 1 , } impl From < Ovrdis > for bool { # [inline (always)]
fn from (variant : Ovrdis) -> Self { variant as u8 != 0 } } # [doc = "Field `OVRDIS` reader - Выбор реакции на переполнение. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type OvrdisR = crate :: BitReader < Ovrdis > ; impl OvrdisR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ovrdis { match self . bits { false => Ovrdis :: _0 , true => Ovrdis :: _1 , } } # [doc = "При переполнении взводится флаг ошибки (ORE), новые данные не записываются"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Ovrdis :: _0 } # [doc = "флаг переполнения не взводится, данные перезаписываются"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Ovrdis :: _1 } } # [doc = "Field `OVRDIS` writer - Выбор реакции на переполнение. Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type OvrdisW < 'a , REG > = crate :: BitWriter < 'a , REG , Ovrdis > ; impl < 'a , REG > OvrdisW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "При переполнении взводится флаг ошибки (ORE), новые данные не записываются"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ovrdis :: _0) } # [doc = "флаг переполнения не взводится, данные перезаписываются"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ovrdis :: _1) } } impl R { # [doc = "Bit 0 - Управление прерыванием при обнаружении ошибок приема данных (FE, ORE, NF)"]
# [inline (always)]
pub fn eie (& self) -> EieR { EieR :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - Переход передатчика в break состояние"]
# [inline (always)]
pub fn sbkrq (& self) -> SbkrqR { SbkrqR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Выбор между полудуплексным и дуплексным режимами работы. В полудуплексном режиме RX не используется, все данные передаются и принимаются через TX. При наличии данных на передачу происходит отправка данных в остальное время прием. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn hdsel (& self) -> HdselR { HdselR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 6 - Управление работой сигна-ла dma_rrq"]
# [inline (always)]
pub fn dmar (& self) -> DmarR { DmarR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Управление работой сигнала dma_trq"]
# [inline (always)]
pub fn dmat (& self) -> DmatR { DmatR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Управление выходным сигналом RTS. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn rtse (& self) -> RtseR { RtseR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Выбор реакции на входной сигнал CTS. Этот бит может быть изме-нен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ctse (& self) -> CtseR { CtseR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Управление прерыванием при обнаружении измене-ния CTS"]
# [inline (always)]
pub fn ctsie (& self) -> CtsieR { CtsieR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 12 - Выбор реакции на переполнение. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ovrdis (& self) -> OvrdisR { OvrdisR :: new (((self . bits >> 12) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление прерыванием при обнаружении ошибок приема данных (FE, ORE, NF)"]
# [inline (always)]
pub fn eie (& mut self) -> EieW < Control3Spec > { EieW :: new (self , 0) } # [doc = "Bit 2 - Переход передатчика в break состояние"]
# [inline (always)]
pub fn sbkrq (& mut self) -> SbkrqW < Control3Spec > { SbkrqW :: new (self , 2) } # [doc = "Bit 3 - Выбор между полудуплексным и дуплексным режимами работы. В полудуплексном режиме RX не используется, все данные передаются и принимаются через TX. При наличии данных на передачу происходит отправка данных в остальное время прием. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn hdsel (& mut self) -> HdselW < Control3Spec > { HdselW :: new (self , 3) } # [doc = "Bit 6 - Управление работой сигна-ла dma_rrq"]
# [inline (always)]
pub fn dmar (& mut self) -> DmarW < Control3Spec > { DmarW :: new (self , 6) } # [doc = "Bit 7 - Управление работой сигнала dma_trq"]
# [inline (always)]
pub fn dmat (& mut self) -> DmatW < Control3Spec > { DmatW :: new (self , 7) } # [doc = "Bit 8 - Управление выходным сигналом RTS. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn rtse (& mut self) -> RtseW < Control3Spec > { RtseW :: new (self , 8) } # [doc = "Bit 9 - Выбор реакции на входной сигнал CTS. Этот бит может быть изме-нен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ctse (& mut self) -> CtseW < Control3Spec > { CtseW :: new (self , 9) } # [doc = "Bit 10 - Управление прерыванием при обнаружении измене-ния CTS"]
# [inline (always)]
pub fn ctsie (& mut self) -> CtsieW < Control3Spec > { CtsieW :: new (self , 10) } # [doc = "Bit 12 - Выбор реакции на переполнение. Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn ovrdis (& mut self) -> OvrdisW < Control3Spec > { OvrdisW :: new (self , 12) } } # [doc = "Регистр управления 3\n\nYou can [`read`](crate::Reg::read) this register and get [`control3::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control3::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Control3Spec ; impl crate :: RegisterSpec for Control3Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`control3::R`](R) reader structure"]
impl crate :: Readable for Control3Spec { } # [doc = "`write(|w| ..)` method takes [`control3::W`](W) writer structure"]
impl crate :: Writable for Control3Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL3 to value 0"]
impl crate :: Resettable for Control3Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DIVIDER (rw) register accessor: Регистр настройки делителя\n\nYou can [`read`](crate::Reg::read) this register and get [`divider::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`divider::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@divider`]
module"]
# [doc (alias = "DIVIDER")]
pub type Divider = crate :: Reg < divider :: DividerSpec > ; # [doc = "Регистр настройки делителя"]
pub mod divider { # [doc = "Register `DIVIDER` reader"]
pub type R = crate :: R < DividerSpec > ; # [doc = "Register `DIVIDER` writer"]
pub type W = crate :: W < DividerSpec > ; # [doc = "Field `BRR` reader - Значение делителя входного тактового сигнала (clk_in). При BRR < 16 USART не активен Бодрейт рассчитывается по следующей формуле: BR = F/BRR, где BR - бодрейт, F - значение частоты входного тактового сигнала Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type BrrR = crate :: FieldReader < u16 > ; # [doc = "Field `BRR` writer - Значение делителя входного тактового сигнала (clk_in). При BRR < 16 USART не активен Бодрейт рассчитывается по следующей формуле: BR = F/BRR, где BR - бодрейт, F - значение частоты входного тактового сигнала Этот бит может быть изменен только при остановке работы (UE=0)"]
pub type BrrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - Значение делителя входного тактового сигнала (clk_in). При BRR < 16 USART не активен Бодрейт рассчитывается по следующей формуле: BR = F/BRR, где BR - бодрейт, F - значение частоты входного тактового сигнала Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn brr (& self) -> BrrR { BrrR :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15 - Значение делителя входного тактового сигнала (clk_in). При BRR < 16 USART не активен Бодрейт рассчитывается по следующей формуле: BR = F/BRR, где BR - бодрейт, F - значение частоты входного тактового сигнала Этот бит может быть изменен только при остановке работы (UE=0)"]
# [inline (always)]
pub fn brr (& mut self) -> BrrW < DividerSpec > { BrrW :: new (self , 0) } } # [doc = "Регистр настройки делителя\n\nYou can [`read`](crate::Reg::read) this register and get [`divider::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`divider::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DividerSpec ; impl crate :: RegisterSpec for DividerSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`divider::R`](R) reader structure"]
impl crate :: Readable for DividerSpec { } # [doc = "`write(|w| ..)` method takes [`divider::W`](W) writer structure"]
impl crate :: Writable for DividerSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DIVIDER to value 0"]
impl crate :: Resettable for DividerSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "FLAGS (rw) register accessor: Регистр прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`flags::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flags::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@flags`]
module"]
# [doc (alias = "FLAGS")]
pub type Flags = crate :: Reg < flags :: FlagsSpec > ; # [doc = "Регистр прерываний"]
pub mod flags { # [doc = "Register `FLAGS` reader"]
pub type R = crate :: R < FlagsSpec > ; # [doc = "Register `FLAGS` writer"]
pub type W = crate :: W < FlagsSpec > ; # [doc = "Флаг обнаружения оши-бочного бита четности. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pe { # [doc = "0: Ошибок в битах четности не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Ошибка в бите четности обнаружена с момента сброса флага"]
_1 = 1 , } impl From < Pe > for bool { # [inline (always)]
fn from (variant : Pe) -> Self { variant as u8 != 0 } } # [doc = "Field `PE` reader - Флаг обнаружения оши-бочного бита четности. Флаг сбрасывается записью 1"]
pub type PeR = crate :: BitReader < Pe > ; impl PeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pe { match self . bits { false => Pe :: _0 , true => Pe :: _1 , } } # [doc = "Ошибок в битах четности не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Pe :: _0 } # [doc = "Ошибка в бите четности обнаружена с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Pe :: _1 } } # [doc = "Field `PE` writer - Флаг обнаружения оши-бочного бита четности. Флаг сбрасывается записью 1"]
pub type PeW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Pe > ; impl < 'a , REG > PeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Ошибок в битах четности не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Pe :: _0) } # [doc = "Ошибка в бите четности обнаружена с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Pe :: _1) } } # [doc = "Флаг взводится при обнаружении ошибок в стоп би-те или битах. Флаг сбрасы-вается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Fe { # [doc = "0: Ошибок приема не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Ошибка приема обнаружена с момента сброса флага"]
_1 = 1 , } impl From < Fe > for bool { # [inline (always)]
fn from (variant : Fe) -> Self { variant as u8 != 0 } } # [doc = "Field `FE` reader - Флаг взводится при обнаружении ошибок в стоп би-те или битах. Флаг сбрасы-вается записью 1"]
pub type FeR = crate :: BitReader < Fe > ; impl FeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Fe { match self . bits { false => Fe :: _0 , true => Fe :: _1 , } } # [doc = "Ошибок приема не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Fe :: _0 } # [doc = "Ошибка приема обнаружена с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Fe :: _1 } } # [doc = "Field `FE` writer - Флаг взводится при обнаружении ошибок в стоп би-те или битах. Флаг сбрасы-вается записью 1"]
pub type FeW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Fe > ; impl < 'a , REG > FeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Ошибок приема не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Fe :: _0) } # [doc = "Ошибка приема обнаружена с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Fe :: _1) } } # [doc = "Флаг обнаружения ложных переключений на линии RX. Флаг сбрасывается за-писью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nf { # [doc = "0: Помех не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Помехи обнаружены с момента сброса флага"]
_1 = 1 , } impl From < Nf > for bool { # [inline (always)]
fn from (variant : Nf) -> Self { variant as u8 != 0 } } # [doc = "Field `NF` reader - Флаг обнаружения ложных переключений на линии RX. Флаг сбрасывается за-писью 1"]
pub type NfR = crate :: BitReader < Nf > ; impl NfR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nf { match self . bits { false => Nf :: _0 , true => Nf :: _1 , } } # [doc = "Помех не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Nf :: _0 } # [doc = "Помехи обнаружены с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Nf :: _1 } } # [doc = "Field `NF` writer - Флаг обнаружения ложных переключений на линии RX. Флаг сбрасывается за-писью 1"]
pub type NfW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Nf > ; impl < 'a , REG > NfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Помех не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Nf :: _0) } # [doc = "Помехи обнаружены с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Nf :: _1) } } # [doc = "Флаг взводится при попытке перезаписи RDR. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ore { # [doc = "0: Попыток перезаписи не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Попытка перезаписи обнаружена с момента сброса флага"]
_1 = 1 , } impl From < Ore > for bool { # [inline (always)]
fn from (variant : Ore) -> Self { variant as u8 != 0 } } # [doc = "Field `ORE` reader - Флаг взводится при попытке перезаписи RDR. Флаг сбрасывается записью 1"]
pub type OreR = crate :: BitReader < Ore > ; impl OreR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ore { match self . bits { false => Ore :: _0 , true => Ore :: _1 , } } # [doc = "Попыток перезаписи не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Ore :: _0 } # [doc = "Попытка перезаписи обнаружена с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Ore :: _1 } } # [doc = "Field `ORE` writer - Флаг взводится при попытке перезаписи RDR. Флаг сбрасывается записью 1"]
pub type OreW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Ore > ; impl < 'a , REG > OreW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Попыток перезаписи не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ore :: _0) } # [doc = "Попытка перезаписи обнаружена с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ore :: _1) } } # [doc = "Флаг взводится при отсутствии активности на линии RX в течении 8 битовых тактов при взведенном флаге RXNE. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Idle { # [doc = "0: Состояние idle не обнаружено после сброса флага"]
_0 = 0 , # [doc = "1: Состояние idle обнаружено после сброса флага"]
_1 = 1 , } impl From < Idle > for bool { # [inline (always)]
fn from (variant : Idle) -> Self { variant as u8 != 0 } } # [doc = "Field `IDLE` reader - Флаг взводится при отсутствии активности на линии RX в течении 8 битовых тактов при взведенном флаге RXNE. Флаг сбрасывается записью 1"]
pub type IdleR = crate :: BitReader < Idle > ; impl IdleR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Idle { match self . bits { false => Idle :: _0 , true => Idle :: _1 , } } # [doc = "Состояние idle не обнаружено после сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Idle :: _0 } # [doc = "Состояние idle обнаружено после сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Idle :: _1 } } # [doc = "Field `IDLE` writer - Флаг взводится при отсутствии активности на линии RX в течении 8 битовых тактов при взведенном флаге RXNE. Флаг сбрасывается записью 1"]
pub type IdleW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Idle > ; impl < 'a , REG > IdleW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Состояние idle не обнаружено после сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Idle :: _0) } # [doc = "Состояние idle обнаружено после сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Idle :: _1) } } # [doc = "Флаг взводится при записи принятых данных в регистр RDR из сдвигового реги-стра. Флаг сбрасывается записью 1 или чтением ре-гистра RDR\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rxne { # [doc = "0: Данные не принимались после сброса флага"]
_0 = 0 , # [doc = "1: Данные принимались после сброса флага"]
_1 = 1 , } impl From < Rxne > for bool { # [inline (always)]
fn from (variant : Rxne) -> Self { variant as u8 != 0 } } # [doc = "Field `RXNE` reader - Флаг взводится при записи принятых данных в регистр RDR из сдвигового реги-стра. Флаг сбрасывается записью 1 или чтением ре-гистра RDR"]
pub type RxneR = crate :: BitReader < Rxne > ; impl RxneR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rxne { match self . bits { false => Rxne :: _0 , true => Rxne :: _1 , } } # [doc = "Данные не принимались после сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Rxne :: _0 } # [doc = "Данные принимались после сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Rxne :: _1 } } # [doc = "Field `RXNE` writer - Флаг взводится при записи принятых данных в регистр RDR из сдвигового реги-стра. Флаг сбрасывается записью 1 или чтением ре-гистра RDR"]
pub type RxneW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Rxne > ; impl < 'a , REG > RxneW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Данные не принимались после сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Rxne :: _0) } # [doc = "Данные принимались после сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Rxne :: _1) } } # [doc = "Флаг взводится при переда-че данных в момент от-правки последнего стоп би-та. Флаг сбрасывается за-писью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Tc { # [doc = "0: Данные не отправлялись с момента сброса флага"]
_0 = 0 , # [doc = "1: Данные отправлялись с момента сброса флага"]
_1 = 1 , } impl From < Tc > for bool { # [inline (always)]
fn from (variant : Tc) -> Self { variant as u8 != 0 } } # [doc = "Field `TC` reader - Флаг взводится при переда-че данных в момент от-правки последнего стоп би-та. Флаг сбрасывается за-писью 1"]
pub type TcR = crate :: BitReader < Tc > ; impl TcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Tc { match self . bits { false => Tc :: _0 , true => Tc :: _1 , } } # [doc = "Данные не отправлялись с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Tc :: _0 } # [doc = "Данные отправлялись с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Tc :: _1 } } # [doc = "Field `TC` writer - Флаг взводится при переда-че данных в момент от-правки последнего стоп би-та. Флаг сбрасывается за-писью 1"]
pub type TcW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Tc > ; impl < 'a , REG > TcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Данные не отправлялись с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Tc :: _0) } # [doc = "Данные отправлялись с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Tc :: _1) } } # [doc = "Флаг взводится при передаче данных в момент записи данных в сдвиговый регистр. Флаг сбрасывается записью данных в регистр TDR или записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Txe { # [doc = "0: Данные не записывались в сдвиговый регистр с момента сброса флага"]
_0 = 0 , # [doc = "1: Данные записывались в сдвиговый регистр"]
_1 = 1 , } impl From < Txe > for bool { # [inline (always)]
fn from (variant : Txe) -> Self { variant as u8 != 0 } } # [doc = "Field `TXE` reader - Флаг взводится при передаче данных в момент записи данных в сдвиговый регистр. Флаг сбрасывается записью данных в регистр TDR или записью 1"]
pub type TxeR = crate :: BitReader < Txe > ; impl TxeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Txe { match self . bits { false => Txe :: _0 , true => Txe :: _1 , } } # [doc = "Данные не записывались в сдвиговый регистр с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Txe :: _0 } # [doc = "Данные записывались в сдвиговый регистр"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Txe :: _1 } } # [doc = "Field `TXE` writer - Флаг взводится при передаче данных в момент записи данных в сдвиговый регистр. Флаг сбрасывается записью данных в регистр TDR или записью 1"]
pub type TxeW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Txe > ; impl < 'a , REG > TxeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Данные не записывались в сдвиговый регистр с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Txe :: _0) } # [doc = "Данные записывались в сдвиговый регистр"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Txe :: _1) } } # [doc = "Флаг обнаружения break состояния на линии RX. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Lbdf { # [doc = "0: Состояние break не обнаружено с момента сброса флага"]
NotDetected = 0 , # [doc = "1: Состояние break обнаружено с момента сброса флага"]
Detected = 1 , } impl From < Lbdf > for bool { # [inline (always)]
fn from (variant : Lbdf) -> Self { variant as u8 != 0 } } # [doc = "Field `LBDF` reader - Флаг обнаружения break состояния на линии RX. Флаг сбрасывается записью 1"]
pub type LbdfR = crate :: BitReader < Lbdf > ; impl LbdfR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Lbdf { match self . bits { false => Lbdf :: NotDetected , true => Lbdf :: Detected , } } # [doc = "Состояние break не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_not_detected (& self) -> bool { * self == Lbdf :: NotDetected } # [doc = "Состояние break обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_detected (& self) -> bool { * self == Lbdf :: Detected } } # [doc = "Field `LBDF` writer - Флаг обнаружения break состояния на линии RX. Флаг сбрасывается записью 1"]
pub type LbdfW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Lbdf > ; impl < 'a , REG > LbdfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Состояние break не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn not_detected (self) -> & 'a mut crate :: W < REG > { self . variant (Lbdf :: NotDetected) } # [doc = "Состояние break обнаружено с момента сброса флага"]
# [inline (always)]
pub fn detected (self) -> & 'a mut crate :: W < REG > { self . variant (Lbdf :: Detected) } } # [doc = "Флаг взводится при изме-нении значения сигнала CTS. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ctsif { # [doc = "0: Состояние CTS не менялось с момента сброса флага"]
_0 = 0 , # [doc = "1: Состояние CTS менялось с момента сброса флага"]
_1 = 1 , } impl From < Ctsif > for bool { # [inline (always)]
fn from (variant : Ctsif) -> Self { variant as u8 != 0 } } # [doc = "Field `CTSIF` reader - Флаг взводится при изме-нении значения сигнала CTS. Флаг сбрасывается записью 1"]
pub type CtsifR = crate :: BitReader < Ctsif > ; impl CtsifR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ctsif { match self . bits { false => Ctsif :: _0 , true => Ctsif :: _1 , } } # [doc = "Состояние CTS не менялось с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Ctsif :: _0 } # [doc = "Состояние CTS менялось с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Ctsif :: _1 } } # [doc = "Field `CTSIF` writer - Флаг взводится при изме-нении значения сигнала CTS. Флаг сбрасывается записью 1"]
pub type CtsifW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Ctsif > ; impl < 'a , REG > CtsifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Состояние CTS не менялось с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Ctsif :: _0) } # [doc = "Состояние CTS менялось с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Ctsif :: _1) } } # [doc = "Флаг отображает текущее значение сигнала CTS\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cts { # [doc = "0: CTS = 0"]
_0 = 0 , # [doc = "1: CTS = 1"]
_1 = 1 , } impl From < Cts > for bool { # [inline (always)]
fn from (variant : Cts) -> Self { variant as u8 != 0 } } # [doc = "Field `CTS` reader - Флаг отображает текущее значение сигнала CTS"]
pub type CtsR = crate :: BitReader < Cts > ; impl CtsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cts { match self . bits { false => Cts :: _0 , true => Cts :: _1 , } } # [doc = "CTS = 0"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Cts :: _0 } # [doc = "CTS = 1"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Cts :: _1 } } # [doc = "Флаг активности на линии RX\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Busy { # [doc = "0: Нет активности на линии RX"]
Inactive = 0 , # [doc = "1: Идет передача данных или break состояние"]
Active = 1 , } impl From < Busy > for bool { # [inline (always)]
fn from (variant : Busy) -> Self { variant as u8 != 0 } } # [doc = "Field `BUSY` reader - Флаг активности на линии RX"]
pub type BusyR = crate :: BitReader < Busy > ; impl BusyR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Busy { match self . bits { false => Busy :: Inactive , true => Busy :: Active , } } # [doc = "Нет активности на линии RX"]
# [inline (always)]
pub fn is_inactive (& self) -> bool { * self == Busy :: Inactive } # [doc = "Идет передача данных или break состояние"]
# [inline (always)]
pub fn is_active (& self) -> bool { * self == Busy :: Active } } # [doc = "Флаг готовности передатчика к работе после снятия сброса (UE и TE)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Teack { # [doc = "0: Ресет UE и TE активен"]
Unready = 0 , # [doc = "1: Ресет UE и TE снят"]
Ready = 1 , } impl From < Teack > for bool { # [inline (always)]
fn from (variant : Teack) -> Self { variant as u8 != 0 } } # [doc = "Field `TEACK` reader - Флаг готовности передатчика к работе после снятия сброса (UE и TE)"]
pub type TeackR = crate :: BitReader < Teack > ; impl TeackR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Teack { match self . bits { false => Teack :: Unready , true => Teack :: Ready , } } # [doc = "Ресет UE и TE активен"]
# [inline (always)]
pub fn is_unready (& self) -> bool { * self == Teack :: Unready } # [doc = "Ресет UE и TE снят"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Teack :: Ready } } # [doc = "Флаг готовности приемника к работе после снятия сброса (UE и RE)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Reack { # [doc = "0: Ресет UE и RE активен"]
Unready = 0 , # [doc = "1: Ресет UE и RE снят"]
Ready = 1 , } impl From < Reack > for bool { # [inline (always)]
fn from (variant : Reack) -> Self { variant as u8 != 0 } } # [doc = "Field `REACK` reader - Флаг готовности приемника к работе после снятия сброса (UE и RE)"]
pub type ReackR = crate :: BitReader < Reack > ; impl ReackR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Reack { match self . bits { false => Reack :: Unready , true => Reack :: Ready , } } # [doc = "Ресет UE и RE активен"]
# [inline (always)]
pub fn is_unready (& self) -> bool { * self == Reack :: Unready } # [doc = "Ресет UE и RE снят"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Reack :: Ready } } impl R { # [doc = "Bit 0 - Флаг обнаружения оши-бочного бита четности. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Флаг взводится при обнаружении ошибок в стоп би-те или битах. Флаг сбрасы-вается записью 1"]
# [inline (always)]
pub fn fe (& self) -> FeR { FeR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Флаг обнаружения ложных переключений на линии RX. Флаг сбрасывается за-писью 1"]
# [inline (always)]
pub fn nf (& self) -> NfR { NfR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Флаг взводится при попытке перезаписи RDR. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn ore (& self) -> OreR { OreR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Флаг взводится при отсутствии активности на линии RX в течении 8 битовых тактов при взведенном флаге RXNE. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn idle (& self) -> IdleR { IdleR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Флаг взводится при записи принятых данных в регистр RDR из сдвигового реги-стра. Флаг сбрасывается записью 1 или чтением ре-гистра RDR"]
# [inline (always)]
pub fn rxne (& self) -> RxneR { RxneR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Флаг взводится при переда-че данных в момент от-правки последнего стоп би-та. Флаг сбрасывается за-писью 1"]
# [inline (always)]
pub fn tc (& self) -> TcR { TcR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Флаг взводится при передаче данных в момент записи данных в сдвиговый регистр. Флаг сбрасывается записью данных в регистр TDR или записью 1"]
# [inline (always)]
pub fn txe (& self) -> TxeR { TxeR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Флаг обнаружения break состояния на линии RX. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn lbdf (& self) -> LbdfR { LbdfR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Флаг взводится при изме-нении значения сигнала CTS. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn ctsif (& self) -> CtsifR { CtsifR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Флаг отображает текущее значение сигнала CTS"]
# [inline (always)]
pub fn cts (& self) -> CtsR { CtsR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 16 - Флаг активности на линии RX"]
# [inline (always)]
pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 21 - Флаг готовности передатчика к работе после снятия сброса (UE и TE)"]
# [inline (always)]
pub fn teack (& self) -> TeackR { TeackR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Флаг готовности приемника к работе после снятия сброса (UE и RE)"]
# [inline (always)]
pub fn reack (& self) -> ReackR { ReackR :: new (((self . bits >> 22) & 1) != 0) } } impl W { # [doc = "Bit 0 - Флаг обнаружения оши-бочного бита четности. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn pe (& mut self) -> PeW < FlagsSpec > { PeW :: new (self , 0) } # [doc = "Bit 1 - Флаг взводится при обнаружении ошибок в стоп би-те или битах. Флаг сбрасы-вается записью 1"]
# [inline (always)]
pub fn fe (& mut self) -> FeW < FlagsSpec > { FeW :: new (self , 1) } # [doc = "Bit 2 - Флаг обнаружения ложных переключений на линии RX. Флаг сбрасывается за-писью 1"]
# [inline (always)]
pub fn nf (& mut self) -> NfW < FlagsSpec > { NfW :: new (self , 2) } # [doc = "Bit 3 - Флаг взводится при попытке перезаписи RDR. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn ore (& mut self) -> OreW < FlagsSpec > { OreW :: new (self , 3) } # [doc = "Bit 4 - Флаг взводится при отсутствии активности на линии RX в течении 8 битовых тактов при взведенном флаге RXNE. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn idle (& mut self) -> IdleW < FlagsSpec > { IdleW :: new (self , 4) } # [doc = "Bit 5 - Флаг взводится при записи принятых данных в регистр RDR из сдвигового реги-стра. Флаг сбрасывается записью 1 или чтением ре-гистра RDR"]
# [inline (always)]
pub fn rxne (& mut self) -> RxneW < FlagsSpec > { RxneW :: new (self , 5) } # [doc = "Bit 6 - Флаг взводится при переда-че данных в момент от-правки последнего стоп би-та. Флаг сбрасывается за-писью 1"]
# [inline (always)]
pub fn tc (& mut self) -> TcW < FlagsSpec > { TcW :: new (self , 6) } # [doc = "Bit 7 - Флаг взводится при передаче данных в момент записи данных в сдвиговый регистр. Флаг сбрасывается записью данных в регистр TDR или записью 1"]
# [inline (always)]
pub fn txe (& mut self) -> TxeW < FlagsSpec > { TxeW :: new (self , 7) } # [doc = "Bit 8 - Флаг обнаружения break состояния на линии RX. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn lbdf (& mut self) -> LbdfW < FlagsSpec > { LbdfW :: new (self , 8) } # [doc = "Bit 9 - Флаг взводится при изме-нении значения сигнала CTS. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn ctsif (& mut self) -> CtsifW < FlagsSpec > { CtsifW :: new (self , 9) } } # [doc = "Регистр прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`flags::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`flags::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct FlagsSpec ; impl crate :: RegisterSpec for FlagsSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`flags::R`](R) reader structure"]
impl crate :: Readable for FlagsSpec { } # [doc = "`write(|w| ..)` method takes [`flags::W`](W) writer structure"]
impl crate :: Writable for FlagsSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0x03ff ; } # [doc = "`reset()` method sets FLAGS to value 0"]
impl crate :: Resettable for FlagsSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RXDATA (r) register accessor: Регистр принятых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdata::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxdata`]
module"]
# [doc (alias = "RXDATA")]
pub type Rxdata = crate :: Reg < rxdata :: RxdataSpec > ; # [doc = "Регистр принятых данных"]
pub mod rxdata { # [doc = "Register `RXDATA` reader"]
pub type R = crate :: R < RxdataSpec > ; # [doc = "Field `RDR` reader - Принятые данные"]
pub type RdrR = crate :: FieldReader < u16 > ; impl R { # [doc = "Bits 0:8 - Принятые данные"]
# [inline (always)]
pub fn rdr (& self) -> RdrR { RdrR :: new ((self . bits & 0x01ff) as u16) } } # [doc = "Регистр принятых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdata::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxdataSpec ; impl crate :: RegisterSpec for RxdataSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rxdata::R`](R) reader structure"]
impl crate :: Readable for RxdataSpec { } # [doc = "`reset()` method sets RXDATA to value 0"]
impl crate :: Resettable for RxdataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TXDATA (rw) register accessor: Регистр передаваемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`txdata::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdata::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txdata`]
module"]
# [doc (alias = "TXDATA")]
pub type Txdata = crate :: Reg < txdata :: TxdataSpec > ; # [doc = "Регистр передаваемых данных"]
pub mod txdata { # [doc = "Register `TXDATA` reader"]
pub type R = crate :: R < TxdataSpec > ; # [doc = "Register `TXDATA` writer"]
pub type W = crate :: W < TxdataSpec > ; # [doc = "Field `TDR` reader - Передаваемые данные"]
pub type TdrR = crate :: FieldReader < u16 > ; # [doc = "Field `TDR` writer - Передаваемые данные"]
pub type TdrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 9 , u16 > ; impl R { # [doc = "Bits 0:8 - Передаваемые данные"]
# [inline (always)]
pub fn tdr (& self) -> TdrR { TdrR :: new ((self . bits & 0x01ff) as u16) } } impl W { # [doc = "Bits 0:8 - Передаваемые данные"]
# [inline (always)]
pub fn tdr (& mut self) -> TdrW < TxdataSpec > { TdrW :: new (self , 0) } } # [doc = "Регистр передаваемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`txdata::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdata::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxdataSpec ; impl crate :: RegisterSpec for TxdataSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`txdata::R`](R) reader structure"]
impl crate :: Readable for TxdataSpec { } # [doc = "`write(|w| ..)` method takes [`txdata::W`](W) writer structure"]
impl crate :: Writable for TxdataSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TXDATA to value 0"]
impl crate :: Resettable for TxdataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MODEM (rw) register accessor: Регистр управления модемом\n\nYou can [`read`](crate::Reg::read) this register and get [`modem::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`modem::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@modem`]
module"]
# [doc (alias = "MODEM")]
pub type Modem = crate :: Reg < modem :: ModemSpec > ; # [doc = "Регистр управления модемом"]
pub mod modem { # [doc = "Register `MODEM` reader"]
pub type R = crate :: R < ModemSpec > ; # [doc = "Register `MODEM` writer"]
pub type W = crate :: W < ModemSpec > ; # [doc = "Флаг взводится при изме-нении входного сигнала DSR. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dsrif { # [doc = "0: Изменений сигнала не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Сигнал изменен с момента сброса флага"]
_1 = 1 , } impl From < Dsrif > for bool { # [inline (always)]
fn from (variant : Dsrif) -> Self { variant as u8 != 0 } } # [doc = "Field `DSRIF` reader - Флаг взводится при изме-нении входного сигнала DSR. Флаг сбрасывается записью 1"]
pub type DsrifR = crate :: BitReader < Dsrif > ; impl DsrifR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dsrif { match self . bits { false => Dsrif :: _0 , true => Dsrif :: _1 , } } # [doc = "Изменений сигнала не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Dsrif :: _0 } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Dsrif :: _1 } } # [doc = "Field `DSRIF` writer - Флаг взводится при изме-нении входного сигнала DSR. Флаг сбрасывается записью 1"]
pub type DsrifW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Dsrif > ; impl < 'a , REG > DsrifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Изменений сигнала не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dsrif :: _0) } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dsrif :: _1) } } # [doc = "Флаг взводится при изме-нении входного сигнала RI с 0 на 1. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Riif { # [doc = "0: Изменений сигнала с 0 на 1 не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Сигнал изменен с момента сброса флага"]
_1 = 1 , } impl From < Riif > for bool { # [inline (always)]
fn from (variant : Riif) -> Self { variant as u8 != 0 } } # [doc = "Field `RIIF` reader - Флаг взводится при изме-нении входного сигнала RI с 0 на 1. Флаг сбрасывается записью 1"]
pub type RiifR = crate :: BitReader < Riif > ; impl RiifR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Riif { match self . bits { false => Riif :: _0 , true => Riif :: _1 , } } # [doc = "Изменений сигнала с 0 на 1 не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Riif :: _0 } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Riif :: _1 } } # [doc = "Field `RIIF` writer - Флаг взводится при изме-нении входного сигнала RI с 0 на 1. Флаг сбрасывается записью 1"]
pub type RiifW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Riif > ; impl < 'a , REG > RiifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Изменений сигнала с 0 на 1 не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Riif :: _0) } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Riif :: _1) } } # [doc = "Флаг взводится при изменении входного сигнала DCD. Флаг сбрасывается записью 1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dcdif { # [doc = "0: Изменений сигнала не обнаружено с момента сброса флага"]
_0 = 0 , # [doc = "1: Сигнал изменен с момента сброса флага"]
_1 = 1 , } impl From < Dcdif > for bool { # [inline (always)]
fn from (variant : Dcdif) -> Self { variant as u8 != 0 } } # [doc = "Field `DCDIF` reader - Флаг взводится при изменении входного сигнала DCD. Флаг сбрасывается записью 1"]
pub type DcdifR = crate :: BitReader < Dcdif > ; impl DcdifR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dcdif { match self . bits { false => Dcdif :: _0 , true => Dcdif :: _1 , } } # [doc = "Изменений сигнала не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Dcdif :: _0 } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Dcdif :: _1 } } # [doc = "Field `DCDIF` writer - Флаг взводится при изменении входного сигнала DCD. Флаг сбрасывается записью 1"]
pub type DcdifW < 'a , REG > = crate :: BitWriter1C < 'a , REG , Dcdif > ; impl < 'a , REG > DcdifW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Изменений сигнала не обнаружено с момента сброса флага"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Dcdif :: _0) } # [doc = "Сигнал изменен с момента сброса флага"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dcdif :: _1) } } # [doc = "Регистр содержит текущее значение сигнала DSR\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dsr { # [doc = "0: Источник данных не готов"]
Unready = 0 , # [doc = "1: Источник данных готов"]
Ready = 1 , } impl From < Dsr > for bool { # [inline (always)]
fn from (variant : Dsr) -> Self { variant as u8 != 0 } } # [doc = "Field `DSR` reader - Регистр содержит текущее значение сигнала DSR"]
pub type DsrR = crate :: BitReader < Dsr > ; impl DsrR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dsr { match self . bits { false => Dsr :: Unready , true => Dsr :: Ready , } } # [doc = "Источник данных не готов"]
# [inline (always)]
pub fn is_unready (& self) -> bool { * self == Dsr :: Unready } # [doc = "Источник данных готов"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Dsr :: Ready } } # [doc = "Регистр содержит текущее значение сигнала RI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Ri { # [doc = "0: Отсутствие звонка"]
_0 = 0 , # [doc = "1: Звонок (вызов) на телефон-ной линии"]
_1 = 1 , } impl From < Ri > for bool { # [inline (always)]
fn from (variant : Ri) -> Self { variant as u8 != 0 } } # [doc = "Field `RI` reader - Регистр содержит текущее значение сигнала RI"]
pub type RiR = crate :: BitReader < Ri > ; impl RiR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ri { match self . bits { false => Ri :: _0 , true => Ri :: _1 , } } # [doc = "Отсутствие звонка"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Ri :: _0 } # [doc = "Звонок (вызов) на телефон-ной линии"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Ri :: _1 } } # [doc = "Регистр содержит текущее значение сигнала DCD\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dcd { # [doc = "0: Отсутствие несущей"]
_0 = 0 , # [doc = "1: Обнаружение несущей"]
_1 = 1 , } impl From < Dcd > for bool { # [inline (always)]
fn from (variant : Dcd) -> Self { variant as u8 != 0 } } # [doc = "Field `DCD` reader - Регистр содержит текущее значение сигнала DCD"]
pub type DcdR = crate :: BitReader < Dcd > ; impl DcdR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dcd { match self . bits { false => Dcd :: _0 , true => Dcd :: _1 , } } # [doc = "Отсутствие несущей"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Dcd :: _0 } # [doc = "Обнаружение несущей"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Dcd :: _1 } } # [doc = "Регистр управления сигналом DTR\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dtr { # [doc = "0: Отсутствие сигнала готов-ности"]
Unready = 0 , # [doc = "1: Готовность к приему дан-ных"]
Ready = 1 , } impl From < Dtr > for bool { # [inline (always)]
fn from (variant : Dtr) -> Self { variant as u8 != 0 } } # [doc = "Field `DTR` reader - Регистр управления сигналом DTR"]
pub type DtrR = crate :: BitReader < Dtr > ; impl DtrR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dtr { match self . bits { false => Dtr :: Unready , true => Dtr :: Ready , } } # [doc = "Отсутствие сигнала готов-ности"]
# [inline (always)]
pub fn is_unready (& self) -> bool { * self == Dtr :: Unready } # [doc = "Готовность к приему дан-ных"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == Dtr :: Ready } } # [doc = "Field `DTR` writer - Регистр управления сигналом DTR"]
pub type DtrW < 'a , REG > = crate :: BitWriter < 'a , REG , Dtr > ; impl < 'a , REG > DtrW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Отсутствие сигнала готов-ности"]
# [inline (always)]
pub fn unready (self) -> & 'a mut crate :: W < REG > { self . variant (Dtr :: Unready) } # [doc = "Готовность к приему дан-ных"]
# [inline (always)]
pub fn ready (self) -> & 'a mut crate :: W < REG > { self . variant (Dtr :: Ready) } } impl R { # [doc = "Bit 1 - Флаг взводится при изме-нении входного сигнала DSR. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn dsrif (& self) -> DsrifR { DsrifR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Флаг взводится при изме-нении входного сигнала RI с 0 на 1. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn riif (& self) -> RiifR { RiifR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Флаг взводится при изменении входного сигнала DCD. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn dcdif (& self) -> DcdifR { DcdifR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 5 - Регистр содержит текущее значение сигнала DSR"]
# [inline (always)]
pub fn dsr (& self) -> DsrR { DsrR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Регистр содержит текущее значение сигнала RI"]
# [inline (always)]
pub fn ri (& self) -> RiR { RiR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Регистр содержит текущее значение сигнала DCD"]
# [inline (always)]
pub fn dcd (& self) -> DcdR { DcdR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 12 - Регистр управления сигналом DTR"]
# [inline (always)]
pub fn dtr (& self) -> DtrR { DtrR :: new (((self . bits >> 12) & 1) != 0) } } impl W { # [doc = "Bit 1 - Флаг взводится при изме-нении входного сигнала DSR. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn dsrif (& mut self) -> DsrifW < ModemSpec > { DsrifW :: new (self , 1) } # [doc = "Bit 2 - Флаг взводится при изме-нении входного сигнала RI с 0 на 1. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn riif (& mut self) -> RiifW < ModemSpec > { RiifW :: new (self , 2) } # [doc = "Bit 3 - Флаг взводится при изменении входного сигнала DCD. Флаг сбрасывается записью 1"]
# [inline (always)]
pub fn dcdif (& mut self) -> DcdifW < ModemSpec > { DcdifW :: new (self , 3) } # [doc = "Bit 12 - Регистр управления сигналом DTR"]
# [inline (always)]
pub fn dtr (& mut self) -> DtrW < ModemSpec > { DtrW :: new (self , 12) } } # [doc = "Регистр управления модемом\n\nYou can [`read`](crate::Reg::read) this register and get [`modem::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`modem::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ModemSpec ; impl crate :: RegisterSpec for ModemSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`modem::R`](R) reader structure"]
impl crate :: Readable for ModemSpec { } # [doc = "`write(|w| ..)` method takes [`modem::W`](W) writer structure"]
impl crate :: Writable for ModemSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0x0e ; } # [doc = "`reset()` method sets MODEM to value 0"]
impl crate :: Resettable for ModemSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Регистры модуля таймера_0"]
pub struct Timer16_0 { _marker : PhantomData < * const () > } unsafe impl Send for Timer16_0 { } impl Timer16_0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer16_0 :: RegisterBlock = 0x0008_1c00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer16_0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Timer16_0 { type Target = timer16_0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Timer16_0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer16_0") . finish () } } # [doc = "Регистры модуля таймера_0"]
pub mod timer16_0 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { isr : Isr , icr : Icr , ier : Ier , cfgr : Cfgr , cr : Cr , cmp : Cmp , arr : Arr , cnt : Cnt , } impl RegisterBlock { # [doc = "0x00 - Регистр флагов прерываний"]
# [inline (always)]
pub const fn isr (& self) -> & Isr { & self . isr } # [doc = "0x04 - Регистр сброса флагов прерываний"]
# [inline (always)]
pub const fn icr (& self) -> & Icr { & self . icr } # [doc = "0x08 - Регистр разрешения прерываний"]
# [inline (always)]
pub const fn ier (& self) -> & Ier { & self . ier } # [doc = "0x0c - Регистр конфигурации"]
# [inline (always)]
pub const fn cfgr (& self) -> & Cfgr { & self . cfgr } # [doc = "0x10 - Регистр управления"]
# [inline (always)]
pub const fn cr (& self) -> & Cr { & self . cr } # [doc = "0x14 - Регистр сравнения"]
# [inline (always)]
pub const fn cmp (& self) -> & Cmp { & self . cmp } # [doc = "0x18 - Регистр автоматической перезагрузки"]
# [inline (always)]
pub const fn arr (& self) -> & Arr { & self . arr } # [doc = "0x1c - Регистр счётчика"]
# [inline (always)]
pub const fn cnt (& self) -> & Cnt { & self . cnt } } # [doc = "ISR (r) register accessor: Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`]
module"]
# [doc (alias = "ISR")]
pub type Isr = crate :: Reg < isr :: IsrSpec > ; # [doc = "Регистр флагов прерываний"]
pub mod isr { # [doc = "Register `ISR` reader"]
pub type R = crate :: R < IsrSpec > ; # [doc = "Field `CMPM` reader - Совпадение сравнения. Бит CMPM устанавливается аппаратными средствами, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра CMP"]
pub type CmpmR = crate :: BitReader ; # [doc = "Field `ARRM` reader - Cоответствие автозагрузки. ARRM устанавливается аппаратурой, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра ARR."]
pub type ArrmR = crate :: BitReader ; # [doc = "Field `EXTTRIG` reader - Cобытие фронта внешнего триггера. EXTTRIG устанавливается аппаратно, чтобы сообщить приложению, что на выбранном входе внешнего триггера возник достоверный фронт импульса. Если триггер игнорируется, так как таймер уже запущен, то этот флаг не устанавливается"]
pub type ExttrigR = crate :: BitReader ; # [doc = "Field `CMPOK` reader - Обновление регистра сравнения OK. CMPOK устанавливается аппаратными средствами, чтобы сообщить приложению, что операция записи в регистр CMP шины APB успешно завершена."]
pub type CmpokR = crate :: BitReader ; # [doc = "Field `ARROK` reader - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
pub type ArrokR = crate :: BitReader ; # [doc = "Field `UP` reader - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
pub type UpR = crate :: BitReader ; # [doc = "Field `DOWN` reader - Изменение направления счетчика вверх на вниз. В режиме энкодера бит DOWN устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вверх\" на \"вниз\"."]
pub type DownR = crate :: BitReader ; impl R { # [doc = "Bit 0 - Совпадение сравнения. Бит CMPM устанавливается аппаратными средствами, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра CMP"]
# [inline (always)]
pub fn cmpm (& self) -> CmpmR { CmpmR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Cоответствие автозагрузки. ARRM устанавливается аппаратурой, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра ARR."]
# [inline (always)]
pub fn arrm (& self) -> ArrmR { ArrmR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Cобытие фронта внешнего триггера. EXTTRIG устанавливается аппаратно, чтобы сообщить приложению, что на выбранном входе внешнего триггера возник достоверный фронт импульса. Если триггер игнорируется, так как таймер уже запущен, то этот флаг не устанавливается"]
# [inline (always)]
pub fn exttrig (& self) -> ExttrigR { ExttrigR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Обновление регистра сравнения OK. CMPOK устанавливается аппаратными средствами, чтобы сообщить приложению, что операция записи в регистр CMP шины APB успешно завершена."]
# [inline (always)]
pub fn cmpok (& self) -> CmpokR { CmpokR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
# [inline (always)]
pub fn arrok (& self) -> ArrokR { ArrokR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
# [inline (always)]
pub fn up (& self) -> UpR { UpR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Изменение направления счетчика вверх на вниз. В режиме энкодера бит DOWN устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вверх\" на \"вниз\"."]
# [inline (always)]
pub fn down (& self) -> DownR { DownR :: new (((self . bits >> 6) & 1) != 0) } } # [doc = "Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`isr::R`](R) reader structure"]
impl crate :: Readable for IsrSpec { } # [doc = "`reset()` method sets ISR to value 0"]
impl crate :: Resettable for IsrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ICR (w) register accessor: Регистр сброса флагов прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`]
module"]
# [doc (alias = "ICR")]
pub type Icr = crate :: Reg < icr :: IcrSpec > ; # [doc = "Регистр сброса флагов прерываний"]
pub mod icr { # [doc = "Register `ICR` writer"]
pub type W = crate :: W < IcrSpec > ; # [doc = "Field `CMPMCF` writer - Запись «1» в этот бит снимает флаг CMPM в регистре LPT_ISR"]
pub type CmpmcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `ARRMCF` writer - Запись «1» в этот бит снимает флаг ARRM в регистре LPT_ISR"]
pub type ArrmcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `EXTTRIGCF` writer - Запись «1» в этот бит снимает флаг EXTTRIG в регистре LPT_ISR"]
pub type ExttrigcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `ARRROCF` writer - Запись «1» в этот бит снимает флаг ARROK в регистре LPT_ISR"]
pub type ArrrocfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `UPCF` writer - Запись «1» в этот бит снимает флаг UP в регистре LPT_ISR"]
pub type UpcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `DOWNCF` writer - Запись «1» в этот бит снимает флаг DOWN в регистре LPT_ISR"]
pub type DowncfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; impl W { # [doc = "Bit 0 - Запись «1» в этот бит снимает флаг CMPM в регистре LPT_ISR"]
# [inline (always)]
pub fn cmpmcf (& mut self) -> CmpmcfW < IcrSpec > { CmpmcfW :: new (self , 0) } # [doc = "Bit 1 - Запись «1» в этот бит снимает флаг ARRM в регистре LPT_ISR"]
# [inline (always)]
pub fn arrmcf (& mut self) -> ArrmcfW < IcrSpec > { ArrmcfW :: new (self , 1) } # [doc = "Bit 2 - Запись «1» в этот бит снимает флаг EXTTRIG в регистре LPT_ISR"]
# [inline (always)]
pub fn exttrigcf (& mut self) -> ExttrigcfW < IcrSpec > { ExttrigcfW :: new (self , 2) } # [doc = "Bit 4 - Запись «1» в этот бит снимает флаг ARROK в регистре LPT_ISR"]
# [inline (always)]
pub fn arrrocf (& mut self) -> ArrrocfW < IcrSpec > { ArrrocfW :: new (self , 4) } # [doc = "Bit 5 - Запись «1» в этот бит снимает флаг UP в регистре LPT_ISR"]
# [inline (always)]
pub fn upcf (& mut self) -> UpcfW < IcrSpec > { UpcfW :: new (self , 5) } # [doc = "Bit 6 - Запись «1» в этот бит снимает флаг DOWN в регистре LPT_ISR"]
# [inline (always)]
pub fn downcf (& mut self) -> DowncfW < IcrSpec > { DowncfW :: new (self , 6) } } # [doc = "Регистр сброса флагов прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"]
impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0x77 ; } # [doc = "`reset()` method sets ICR to value 0"]
impl crate :: Resettable for IcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "IER (rw) register accessor: Регистр разрешения прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`]
module"]
# [doc (alias = "IER")]
pub type Ier = crate :: Reg < ier :: IerSpec > ; # [doc = "Регистр разрешения прерываний"]
pub mod ier { # [doc = "Register `IER` reader"]
pub type R = crate :: R < IerSpec > ; # [doc = "Register `IER` writer"]
pub type W = crate :: W < IerSpec > ; # [doc = "запрет/разрешение прерывания CMPM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cmpmie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Cmpmie > for bool { # [inline (always)]
fn from (variant : Cmpmie) -> Self { variant as u8 != 0 } } # [doc = "Field `CMPMIE` reader - запрет/разрешение прерывания CMPM"]
pub type CmpmieR = crate :: BitReader < Cmpmie > ; impl CmpmieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cmpmie { match self . bits { false => Cmpmie :: Disable , true => Cmpmie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Cmpmie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cmpmie :: Enable } } # [doc = "Field `CMPMIE` writer - запрет/разрешение прерывания CMPM"]
pub type CmpmieW < 'a , REG > = crate :: BitWriter < 'a , REG , Cmpmie > ; impl < 'a , REG > CmpmieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpmie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpmie :: Enable) } } # [doc = "запрет/разрешение прерывания EXTTRIG\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Exttrigie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Exttrigie > for bool { # [inline (always)]
fn from (variant : Exttrigie) -> Self { variant as u8 != 0 } } # [doc = "Field `EXTTRIGIE` reader - запрет/разрешение прерывания EXTTRIG"]
pub type ExttrigieR = crate :: BitReader < Exttrigie > ; impl ExttrigieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Exttrigie { match self . bits { false => Exttrigie :: Disable , true => Exttrigie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Exttrigie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Exttrigie :: Enable } } # [doc = "Field `EXTTRIGIE` writer - запрет/разрешение прерывания EXTTRIG"]
pub type ExttrigieW < 'a , REG > = crate :: BitWriter < 'a , REG , Exttrigie > ; impl < 'a , REG > ExttrigieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Exttrigie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Exttrigie :: Enable) } } # [doc = "запрет/разрешение прерывания CMPOK\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cmpokie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Cmpokie > for bool { # [inline (always)]
fn from (variant : Cmpokie) -> Self { variant as u8 != 0 } } # [doc = "Field `CMPOKIE` reader - запрет/разрешение прерывания CMPOK"]
pub type CmpokieR = crate :: BitReader < Cmpokie > ; impl CmpokieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cmpokie { match self . bits { false => Cmpokie :: Disable , true => Cmpokie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Cmpokie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cmpokie :: Enable } } # [doc = "Field `CMPOKIE` writer - запрет/разрешение прерывания CMPOK"]
pub type CmpokieW < 'a , REG > = crate :: BitWriter < 'a , REG , Cmpokie > ; impl < 'a , REG > CmpokieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpokie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpokie :: Enable) } } # [doc = "запрет/разрешение прерывания ARRROK\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Arrokie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Arrokie > for bool { # [inline (always)]
fn from (variant : Arrokie) -> Self { variant as u8 != 0 } } # [doc = "Field `ARROKIE` reader - запрет/разрешение прерывания ARRROK"]
pub type ArrokieR = crate :: BitReader < Arrokie > ; impl ArrokieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Arrokie { match self . bits { false => Arrokie :: Disable , true => Arrokie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Arrokie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Arrokie :: Enable } } # [doc = "Field `ARROKIE` writer - запрет/разрешение прерывания ARRROK"]
pub type ArrokieW < 'a , REG > = crate :: BitWriter < 'a , REG , Arrokie > ; impl < 'a , REG > ArrokieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrokie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrokie :: Enable) } } # [doc = "запрет/разрешение прерывания UP\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Upie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Upie > for bool { # [inline (always)]
fn from (variant : Upie) -> Self { variant as u8 != 0 } } # [doc = "Field `UPIE` reader - запрет/разрешение прерывания UP"]
pub type UpieR = crate :: BitReader < Upie > ; impl UpieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Upie { match self . bits { false => Upie :: Disable , true => Upie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Upie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Upie :: Enable } } # [doc = "Field `UPIE` writer - запрет/разрешение прерывания UP"]
pub type UpieW < 'a , REG > = crate :: BitWriter < 'a , REG , Upie > ; impl < 'a , REG > UpieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Upie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Upie :: Enable) } } # [doc = "запрет/разрешение прерывания ARRM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Arrmie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Arrmie > for bool { # [inline (always)]
fn from (variant : Arrmie) -> Self { variant as u8 != 0 } } # [doc = "Field `ARRMIE` reader - запрет/разрешение прерывания ARRM"]
pub type ArrmieR = crate :: BitReader < Arrmie > ; impl ArrmieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Arrmie { match self . bits { false => Arrmie :: Disable , true => Arrmie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Arrmie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Arrmie :: Enable } } # [doc = "Field `ARRMIE` writer - запрет/разрешение прерывания ARRM"]
pub type ArrmieW < 'a , REG > = crate :: BitWriter < 'a , REG , Arrmie > ; impl < 'a , REG > ArrmieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrmie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrmie :: Enable) } } # [doc = "запрет/разрешение прерывания DOWN\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Downie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Downie > for bool { # [inline (always)]
fn from (variant : Downie) -> Self { variant as u8 != 0 } } # [doc = "Field `DOWNIE` reader - запрет/разрешение прерывания DOWN"]
pub type DownieR = crate :: BitReader < Downie > ; impl DownieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Downie { match self . bits { false => Downie :: Disable , true => Downie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Downie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Downie :: Enable } } # [doc = "Field `DOWNIE` writer - запрет/разрешение прерывания DOWN"]
pub type DownieW < 'a , REG > = crate :: BitWriter < 'a , REG , Downie > ; impl < 'a , REG > DownieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Downie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Downie :: Enable) } } impl R { # [doc = "Bit 0 - запрет/разрешение прерывания CMPM"]
# [inline (always)]
pub fn cmpmie (& self) -> CmpmieR { CmpmieR :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - запрет/разрешение прерывания EXTTRIG"]
# [inline (always)]
pub fn exttrigie (& self) -> ExttrigieR { ExttrigieR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - запрет/разрешение прерывания CMPOK"]
# [inline (always)]
pub fn cmpokie (& self) -> CmpokieR { CmpokieR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - запрет/разрешение прерывания ARRROK"]
# [inline (always)]
pub fn arrokie (& self) -> ArrokieR { ArrokieR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - запрет/разрешение прерывания UP"]
# [inline (always)]
pub fn upie (& self) -> UpieR { UpieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 5 - запрет/разрешение прерывания ARRM"]
# [inline (always)]
pub fn arrmie (& self) -> ArrmieR { ArrmieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - запрет/разрешение прерывания DOWN"]
# [inline (always)]
pub fn downie (& self) -> DownieR { DownieR :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - запрет/разрешение прерывания CMPM"]
# [inline (always)]
pub fn cmpmie (& mut self) -> CmpmieW < IerSpec > { CmpmieW :: new (self , 0) } # [doc = "Bit 2 - запрет/разрешение прерывания EXTTRIG"]
# [inline (always)]
pub fn exttrigie (& mut self) -> ExttrigieW < IerSpec > { ExttrigieW :: new (self , 2) } # [doc = "Bit 3 - запрет/разрешение прерывания CMPOK"]
# [inline (always)]
pub fn cmpokie (& mut self) -> CmpokieW < IerSpec > { CmpokieW :: new (self , 3) } # [doc = "Bit 4 - запрет/разрешение прерывания ARRROK"]
# [inline (always)]
pub fn arrokie (& mut self) -> ArrokieW < IerSpec > { ArrokieW :: new (self , 4) } # [doc = "Bit 5 - запрет/разрешение прерывания UP"]
# [inline (always)]
pub fn upie (& mut self) -> UpieW < IerSpec > { UpieW :: new (self , 5) } # [doc = "Bit 5 - запрет/разрешение прерывания ARRM"]
# [inline (always)]
pub fn arrmie (& mut self) -> ArrmieW < IerSpec > { ArrmieW :: new (self , 5) } # [doc = "Bit 6 - запрет/разрешение прерывания DOWN"]
# [inline (always)]
pub fn downie (& mut self) -> DownieW < IerSpec > { DownieW :: new (self , 6) } } # [doc = "Регистр разрешения прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IerSpec ; impl crate :: RegisterSpec for IerSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ier::R`](R) reader structure"]
impl crate :: Readable for IerSpec { } # [doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"]
impl crate :: Writable for IerSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets IER to value 0"]
impl crate :: Resettable for IerSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CFGR (rw) register accessor: Регистр конфигурации\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`]
module"]
# [doc (alias = "CFGR")]
pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ; # [doc = "Регистр конфигурации"]
pub mod cfgr { # [doc = "Register `CFGR` reader"]
pub type R = crate :: R < CfgrSpec > ; # [doc = "Register `CFGR` writer"]
pub type W = crate :: W < CfgrSpec > ; # [doc = "Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cksel { # [doc = "0: TIMER16 тактируется внутренним источником тактового сигнала (APB тактовый генератор или любой из встроенных генераторов)"]
Internal = 0 , # [doc = "1: TIMER16 тактируется внешним источником тактового сигнала через внешний lnput1 TIMER16"]
External = 1 , } impl From < Cksel > for bool { # [inline (always)]
fn from (variant : Cksel) -> Self { variant as u8 != 0 } } # [doc = "Field `CKSEL` reader - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
pub type CkselR = crate :: BitReader < Cksel > ; impl CkselR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cksel { match self . bits { false => Cksel :: Internal , true => Cksel :: External , } } # [doc = "TIMER16 тактируется внутренним источником тактового сигнала (APB тактовый генератор или любой из встроенных генераторов)"]
# [inline (always)]
pub fn is_internal (& self) -> bool { * self == Cksel :: Internal } # [doc = "TIMER16 тактируется внешним источником тактового сигнала через внешний lnput1 TIMER16"]
# [inline (always)]
pub fn is_external (& self) -> bool { * self == Cksel :: External } } # [doc = "Field `CKSEL` writer - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
pub type CkselW < 'a , REG > = crate :: BitWriter < 'a , REG , Cksel > ; impl < 'a , REG > CkselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "TIMER16 тактируется внутренним источником тактового сигнала (APB тактовый генератор или любой из встроенных генераторов)"]
# [inline (always)]
pub fn internal (self) -> & 'a mut crate :: W < REG > { self . variant (Cksel :: Internal) } # [doc = "TIMER16 тактируется внешним источником тактового сигнала через внешний lnput1 TIMER16"]
# [inline (always)]
pub fn external (self) -> & 'a mut crate :: W < REG > { self . variant (Cksel :: External) } } # [doc = "Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Ckpol { # [doc = "0: Нарастающий фронт является активным фронтом, используемым для подсчета"]
Rising = 0 , # [doc = "1: Спадающий фронт является активным фронтом, используемым для подсчета"]
Folling = 1 , # [doc = "2: Оба фронта являются активными фронтами. Когда оба фронта внешнего тактового сигнала считаются активными, TIMER16 должен также тактироваться внутренним источником тактового сигнала с частотой, по крайней мере в четыре раза превышающей частоту внешнего тактового сигнала."]
BothEdge = 2 , } impl From < Ckpol > for u8 { # [inline (always)]
fn from (variant : Ckpol) -> Self { variant as _ } } impl crate :: FieldSpec for Ckpol { type Ux = u8 ; } impl crate :: IsEnum for Ckpol { } # [doc = "Field `CKPOL` reader - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
pub type CkpolR = crate :: FieldReader < Ckpol > ; impl CkpolR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Ckpol > { match self . bits { 0 => Some (Ckpol :: Rising) , 1 => Some (Ckpol :: Folling) , 2 => Some (Ckpol :: BothEdge) , _ => None , } } # [doc = "Нарастающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == Ckpol :: Rising } # [doc = "Спадающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn is_folling (& self) -> bool { * self == Ckpol :: Folling } # [doc = "Оба фронта являются активными фронтами. Когда оба фронта внешнего тактового сигнала считаются активными, TIMER16 должен также тактироваться внутренним источником тактового сигнала с частотой, по крайней мере в четыре раза превышающей частоту внешнего тактового сигнала."]
# [inline (always)]
pub fn is_both_edge (& self) -> bool { * self == Ckpol :: BothEdge } } # [doc = "Field `CKPOL` writer - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
pub type CkpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Ckpol > ; impl < 'a , REG > CkpolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нарастающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn rising (self) -> & 'a mut crate :: W < REG > { self . variant (Ckpol :: Rising) } # [doc = "Спадающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn folling (self) -> & 'a mut crate :: W < REG > { self . variant (Ckpol :: Folling) } # [doc = "Оба фронта являются активными фронтами. Когда оба фронта внешнего тактового сигнала считаются активными, TIMER16 должен также тактироваться внутренним источником тактового сигнала с частотой, по крайней мере в четыре раза превышающей частоту внешнего тактового сигнала."]
# [inline (always)]
pub fn both_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Ckpol :: BothEdge) } } # [doc = "Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Ckflt { # [doc = "0: Любое изменение активного уровня триггера читается действительным триггером"]
Disable = 0 , # [doc = "1: Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
_2clock = 1 , # [doc = "2: Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_4clock = 2 , # [doc = "3: Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_8clock = 3 , } impl From < Ckflt > for u8 { # [inline (always)]
fn from (variant : Ckflt) -> Self { variant as _ } } impl crate :: FieldSpec for Ckflt { type Ux = u8 ; } impl crate :: IsEnum for Ckflt { } # [doc = "Field `CKFLT` reader - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
pub type CkfltR = crate :: FieldReader < Ckflt > ; impl CkfltR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ckflt { match self . bits { 0 => Ckflt :: Disable , 1 => Ckflt :: _2clock , 2 => Ckflt :: _4clock , 3 => Ckflt :: _8clock , _ => unreachable ! () , } } # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Ckflt :: Disable } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn is_2clock (& self) -> bool { * self == Ckflt :: _2clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_4clock (& self) -> bool { * self == Ckflt :: _4clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_8clock (& self) -> bool { * self == Ckflt :: _8clock } } # [doc = "Field `CKFLT` writer - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
pub type CkfltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Ckflt , crate :: Safe > ; impl < 'a , REG > CkfltW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: Disable) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn _2clock (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: _2clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _4clock (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: _4clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _8clock (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: _8clock) } } # [doc = "Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Trgflt { # [doc = "0: Любое изменение активного уровня триггера читается действительным триггером"]
Disable = 0 , # [doc = "1: Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
_2clock = 1 , # [doc = "2: Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_4clock = 2 , # [doc = "3: Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_8clock = 3 , } impl From < Trgflt > for u8 { # [inline (always)]
fn from (variant : Trgflt) -> Self { variant as _ } } impl crate :: FieldSpec for Trgflt { type Ux = u8 ; } impl crate :: IsEnum for Trgflt { } # [doc = "Field `TRGFLT` reader - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
pub type TrgfltR = crate :: FieldReader < Trgflt > ; impl TrgfltR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Trgflt { match self . bits { 0 => Trgflt :: Disable , 1 => Trgflt :: _2clock , 2 => Trgflt :: _4clock , 3 => Trgflt :: _8clock , _ => unreachable ! () , } } # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Trgflt :: Disable } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn is_2clock (& self) -> bool { * self == Trgflt :: _2clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_4clock (& self) -> bool { * self == Trgflt :: _4clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_8clock (& self) -> bool { * self == Trgflt :: _8clock } } # [doc = "Field `TRGFLT` writer - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
pub type TrgfltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Trgflt , crate :: Safe > ; impl < 'a , REG > TrgfltW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: Disable) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn _2clock (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: _2clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _4clock (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: _4clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _8clock (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: _8clock) } } # [doc = "Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Presc { # [doc = "0: Делитель 1"]
_1 = 0 , # [doc = "1: Делитель 2"]
_2 = 1 , # [doc = "2: Делитель 4"]
_4 = 2 , # [doc = "3: Делитель 8"]
_8 = 3 , # [doc = "4: Делитель 16"]
_16 = 4 , # [doc = "5: Делитель 32"]
_32 = 5 , # [doc = "6: Делитель 64"]
_64 = 6 , # [doc = "7: Делитель 128"]
_128 = 7 , } impl From < Presc > for u8 { # [inline (always)]
fn from (variant : Presc) -> Self { variant as _ } } impl crate :: FieldSpec for Presc { type Ux = u8 ; } impl crate :: IsEnum for Presc { } # [doc = "Field `PRESC` reader - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
pub type PrescR = crate :: FieldReader < Presc > ; impl PrescR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Presc { match self . bits { 0 => Presc :: _1 , 1 => Presc :: _2 , 2 => Presc :: _4 , 3 => Presc :: _8 , 4 => Presc :: _16 , 5 => Presc :: _32 , 6 => Presc :: _64 , 7 => Presc :: _128 , _ => unreachable ! () , } } # [doc = "Делитель 1"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Presc :: _1 } # [doc = "Делитель 2"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == Presc :: _2 } # [doc = "Делитель 4"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == Presc :: _4 } # [doc = "Делитель 8"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == Presc :: _8 } # [doc = "Делитель 16"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == Presc :: _16 } # [doc = "Делитель 32"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == Presc :: _32 } # [doc = "Делитель 64"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == Presc :: _64 } # [doc = "Делитель 128"]
# [inline (always)]
pub fn is_128 (& self) -> bool { * self == Presc :: _128 } } # [doc = "Field `PRESC` writer - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
pub type PrescW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Presc , crate :: Safe > ; impl < 'a , REG > PrescW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Делитель 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _1) } # [doc = "Делитель 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _2) } # [doc = "Делитель 4"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _4) } # [doc = "Делитель 8"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _8) } # [doc = "Делитель 16"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _16) } # [doc = "Делитель 32"]
# [inline (always)]
pub fn _32 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _32) } # [doc = "Делитель 64"]
# [inline (always)]
pub fn _64 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _64) } # [doc = "Делитель 128"]
# [inline (always)]
pub fn _128 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _128) } } # [doc = "Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Trigsel { # [doc = "0: Источник триггера GPIO0_7"]
Gpio0_7 = 0 , # [doc = "1: Источник триггера GPIO0_4"]
Gpio0_4 = 1 , # [doc = "2: Источник триггера GPIO0_15"]
Gpio0_15 = 2 , # [doc = "3: Источник триггера GPIO0_14"]
Gpio0_14 = 3 , # [doc = "4: Источник триггера - окончание преобразования термосенсора"]
Tsens = 4 , # [doc = "5: окончание преобразования АЦП"]
Adc = 5 , # [doc = "6: Источник триггера - прерывание RTC"]
RtcIrq = 6 , # [doc = "7: Будильник"]
Alarm = 7 , } impl From < Trigsel > for u8 { # [inline (always)]
fn from (variant : Trigsel) -> Self { variant as _ } } impl crate :: FieldSpec for Trigsel { type Ux = u8 ; } impl crate :: IsEnum for Trigsel { } # [doc = "Field `TRIGSEL` reader - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
pub type TrigselR = crate :: FieldReader < Trigsel > ; impl TrigselR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Trigsel { match self . bits { 0 => Trigsel :: Gpio0_7 , 1 => Trigsel :: Gpio0_4 , 2 => Trigsel :: Gpio0_15 , 3 => Trigsel :: Gpio0_14 , 4 => Trigsel :: Tsens , 5 => Trigsel :: Adc , 6 => Trigsel :: RtcIrq , 7 => Trigsel :: Alarm , _ => unreachable ! () , } } # [doc = "Источник триггера GPIO0_7"]
# [inline (always)]
pub fn is_gpio0_7 (& self) -> bool { * self == Trigsel :: Gpio0_7 } # [doc = "Источник триггера GPIO0_4"]
# [inline (always)]
pub fn is_gpio0_4 (& self) -> bool { * self == Trigsel :: Gpio0_4 } # [doc = "Источник триггера GPIO0_15"]
# [inline (always)]
pub fn is_gpio0_15 (& self) -> bool { * self == Trigsel :: Gpio0_15 } # [doc = "Источник триггера GPIO0_14"]
# [inline (always)]
pub fn is_gpio0_14 (& self) -> bool { * self == Trigsel :: Gpio0_14 } # [doc = "Источник триггера - окончание преобразования термосенсора"]
# [inline (always)]
pub fn is_tsens (& self) -> bool { * self == Trigsel :: Tsens } # [doc = "окончание преобразования АЦП"]
# [inline (always)]
pub fn is_adc (& self) -> bool { * self == Trigsel :: Adc } # [doc = "Источник триггера - прерывание RTC"]
# [inline (always)]
pub fn is_rtc_irq (& self) -> bool { * self == Trigsel :: RtcIrq } # [doc = "Будильник"]
# [inline (always)]
pub fn is_alarm (& self) -> bool { * self == Trigsel :: Alarm } } # [doc = "Field `TRIGSEL` writer - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
pub type TrigselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Trigsel , crate :: Safe > ; impl < 'a , REG > TrigselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Источник триггера GPIO0_7"]
# [inline (always)]
pub fn gpio0_7 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio0_7) } # [doc = "Источник триггера GPIO0_4"]
# [inline (always)]
pub fn gpio0_4 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio0_4) } # [doc = "Источник триггера GPIO0_15"]
# [inline (always)]
pub fn gpio0_15 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio0_15) } # [doc = "Источник триггера GPIO0_14"]
# [inline (always)]
pub fn gpio0_14 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio0_14) } # [doc = "Источник триггера - окончание преобразования термосенсора"]
# [inline (always)]
pub fn tsens (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Tsens) } # [doc = "окончание преобразования АЦП"]
# [inline (always)]
pub fn adc (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Adc) } # [doc = "Источник триггера - прерывание RTC"]
# [inline (always)]
pub fn rtc_irq (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: RtcIrq) } # [doc = "Будильник"]
# [inline (always)]
pub fn alarm (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Alarm) } } # [doc = "Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Trigen { # [doc = "0: Программный триггер (начало отсчета инициируется программно)"]
Software = 0 , # [doc = "1: Нарастающий фронт является активным фронтом"]
Rising = 1 , # [doc = "2: Падающий фронт является активным фронтом"]
Folling = 2 , # [doc = "3: Оба фронта являются активными фронтами энергопотреблением"]
BothEdge = 3 , } impl From < Trigen > for u8 { # [inline (always)]
fn from (variant : Trigen) -> Self { variant as _ } } impl crate :: FieldSpec for Trigen { type Ux = u8 ; } impl crate :: IsEnum for Trigen { } # [doc = "Field `TRIGEN` reader - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
pub type TrigenR = crate :: FieldReader < Trigen > ; impl TrigenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Trigen { match self . bits { 0 => Trigen :: Software , 1 => Trigen :: Rising , 2 => Trigen :: Folling , 3 => Trigen :: BothEdge , _ => unreachable ! () , } } # [doc = "Программный триггер (начало отсчета инициируется программно)"]
# [inline (always)]
pub fn is_software (& self) -> bool { * self == Trigen :: Software } # [doc = "Нарастающий фронт является активным фронтом"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == Trigen :: Rising } # [doc = "Падающий фронт является активным фронтом"]
# [inline (always)]
pub fn is_folling (& self) -> bool { * self == Trigen :: Folling } # [doc = "Оба фронта являются активными фронтами энергопотреблением"]
# [inline (always)]
pub fn is_both_edge (& self) -> bool { * self == Trigen :: BothEdge } } # [doc = "Field `TRIGEN` writer - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
pub type TrigenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Trigen , crate :: Safe > ; impl < 'a , REG > TrigenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Программный триггер (начало отсчета инициируется программно)"]
# [inline (always)]
pub fn software (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: Software) } # [doc = "Нарастающий фронт является активным фронтом"]
# [inline (always)]
pub fn rising (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: Rising) } # [doc = "Падающий фронт является активным фронтом"]
# [inline (always)]
pub fn folling (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: Folling) } # [doc = "Оба фронта являются активными фронтами энергопотреблением"]
# [inline (always)]
pub fn both_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: BothEdge) } } # [doc = "Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timeout { # [doc = "0: Триггерное событие, поступающее, когда таймер уже запущен, будет проигнорировано"]
TriggerEventIgnor = 0 , # [doc = "1: Триггерное событие, поступающее, когда таймер уже запущен, сбросит и перезапустит счетчик"]
TriggerEventRestart = 1 , } impl From < Timeout > for bool { # [inline (always)]
fn from (variant : Timeout) -> Self { variant as u8 != 0 } } # [doc = "Field `TIMEOUT` reader - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
pub type TimeoutR = crate :: BitReader < Timeout > ; impl TimeoutR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timeout { match self . bits { false => Timeout :: TriggerEventIgnor , true => Timeout :: TriggerEventRestart , } } # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, будет проигнорировано"]
# [inline (always)]
pub fn is_trigger_event_ignor (& self) -> bool { * self == Timeout :: TriggerEventIgnor } # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, сбросит и перезапустит счетчик"]
# [inline (always)]
pub fn is_trigger_event_restart (& self) -> bool { * self == Timeout :: TriggerEventRestart } } # [doc = "Field `TIMEOUT` writer - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
pub type TimeoutW < 'a , REG > = crate :: BitWriter < 'a , REG , Timeout > ; impl < 'a , REG > TimeoutW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, будет проигнорировано"]
# [inline (always)]
pub fn trigger_event_ignor (self) -> & 'a mut crate :: W < REG > { self . variant (Timeout :: TriggerEventIgnor) } # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, сбросит и перезапустит счетчик"]
# [inline (always)]
pub fn trigger_event_restart (self) -> & 'a mut crate :: W < REG > { self . variant (Timeout :: TriggerEventRestart) } } # [doc = "Форма волны. Бит WAVE управляет формой выходного сигнала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wave { # [doc = "0: Деактивировать режим Set-once, форма волны ШИМ (PWM) / один импульс (One shot)"]
PwmOrOneShot = 0 , # [doc = "1: Активировать режим Set-once"]
SetOnce = 1 , } impl From < Wave > for bool { # [inline (always)]
fn from (variant : Wave) -> Self { variant as u8 != 0 } } # [doc = "Field `WAVE` reader - Форма волны. Бит WAVE управляет формой выходного сигнала"]
pub type WaveR = crate :: BitReader < Wave > ; impl WaveR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wave { match self . bits { false => Wave :: PwmOrOneShot , true => Wave :: SetOnce , } } # [doc = "Деактивировать режим Set-once, форма волны ШИМ (PWM) / один импульс (One shot)"]
# [inline (always)]
pub fn is_pwm_or_one_shot (& self) -> bool { * self == Wave :: PwmOrOneShot } # [doc = "Активировать режим Set-once"]
# [inline (always)]
pub fn is_set_once (& self) -> bool { * self == Wave :: SetOnce } } # [doc = "Field `WAVE` writer - Форма волны. Бит WAVE управляет формой выходного сигнала"]
pub type WaveW < 'a , REG > = crate :: BitWriter < 'a , REG , Wave > ; impl < 'a , REG > WaveW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Деактивировать режим Set-once, форма волны ШИМ (PWM) / один импульс (One shot)"]
# [inline (always)]
pub fn pwm_or_one_shot (self) -> & 'a mut crate :: W < REG > { self . variant (Wave :: PwmOrOneShot) } # [doc = "Активировать режим Set-once"]
# [inline (always)]
pub fn set_once (self) -> & 'a mut crate :: W < REG > { self . variant (Wave :: SetOnce) } } # [doc = "Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wavwpol { # [doc = "0: Выход TIMER16 отражает результаты сравнения между регистрами ARR и CMP"]
Noninverted = 0 , # [doc = "1: Выход TIMER16 отражает инверсные результаты сравнения между регистрами ARR и CMP"]
Inverted = 1 , } impl From < Wavwpol > for bool { # [inline (always)]
fn from (variant : Wavwpol) -> Self { variant as u8 != 0 } } # [doc = "Field `WAVWPOL` reader - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
pub type WavwpolR = crate :: BitReader < Wavwpol > ; impl WavwpolR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wavwpol { match self . bits { false => Wavwpol :: Noninverted , true => Wavwpol :: Inverted , } } # [doc = "Выход TIMER16 отражает результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn is_noninverted (& self) -> bool { * self == Wavwpol :: Noninverted } # [doc = "Выход TIMER16 отражает инверсные результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == Wavwpol :: Inverted } } # [doc = "Field `WAVWPOL` writer - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
pub type WavwpolW < 'a , REG > = crate :: BitWriter < 'a , REG , Wavwpol > ; impl < 'a , REG > WavwpolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Выход TIMER16 отражает результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn noninverted (self) -> & 'a mut crate :: W < REG > { self . variant (Wavwpol :: Noninverted) } # [doc = "Выход TIMER16 отражает инверсные результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (Wavwpol :: Inverted) } } # [doc = "Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Preload { # [doc = "0: Регистры обновляются после каждого доступа к записи на шине APB"]
AfterWrite = 0 , # [doc = "1: Регистры обновляются в конце текущего периода TIMER16"]
EndPeriod = 1 , } impl From < Preload > for bool { # [inline (always)]
fn from (variant : Preload) -> Self { variant as u8 != 0 } } # [doc = "Field `PRELOAD` reader - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
pub type PreloadR = crate :: BitReader < Preload > ; impl PreloadR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Preload { match self . bits { false => Preload :: AfterWrite , true => Preload :: EndPeriod , } } # [doc = "Регистры обновляются после каждого доступа к записи на шине APB"]
# [inline (always)]
pub fn is_after_write (& self) -> bool { * self == Preload :: AfterWrite } # [doc = "Регистры обновляются в конце текущего периода TIMER16"]
# [inline (always)]
pub fn is_end_period (& self) -> bool { * self == Preload :: EndPeriod } } # [doc = "Field `PRELOAD` writer - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
pub type PreloadW < 'a , REG > = crate :: BitWriter < 'a , REG , Preload > ; impl < 'a , REG > PreloadW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Регистры обновляются после каждого доступа к записи на шине APB"]
# [inline (always)]
pub fn after_write (self) -> & 'a mut crate :: W < REG > { self . variant (Preload :: AfterWrite) } # [doc = "Регистры обновляются в конце текущего периода TIMER16"]
# [inline (always)]
pub fn end_period (self) -> & 'a mut crate :: W < REG > { self . variant (Preload :: EndPeriod) } } # [doc = "Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CountMode { # [doc = "0: Счетчик инкрементируется после каждого внутреннего тактового импульса"]
Internal = 0 , # [doc = "1: Счетчик увеличивается после каждого действительного тактового импульса на внешнем lnput1 TIMER16"]
External = 1 , } impl From < CountMode > for bool { # [inline (always)]
fn from (variant : CountMode) -> Self { variant as u8 != 0 } } # [doc = "Field `COUNT_MODE` reader - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
pub type CountModeR = crate :: BitReader < CountMode > ; impl CountModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> CountMode { match self . bits { false => CountMode :: Internal , true => CountMode :: External , } } # [doc = "Счетчик инкрементируется после каждого внутреннего тактового импульса"]
# [inline (always)]
pub fn is_internal (& self) -> bool { * self == CountMode :: Internal } # [doc = "Счетчик увеличивается после каждого действительного тактового импульса на внешнем lnput1 TIMER16"]
# [inline (always)]
pub fn is_external (& self) -> bool { * self == CountMode :: External } } # [doc = "Field `COUNT_MODE` writer - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
pub type CountModeW < 'a , REG > = crate :: BitWriter < 'a , REG , CountMode > ; impl < 'a , REG > CountModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Счетчик инкрементируется после каждого внутреннего тактового импульса"]
# [inline (always)]
pub fn internal (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Internal) } # [doc = "Счетчик увеличивается после каждого действительного тактового импульса на внешнем lnput1 TIMER16"]
# [inline (always)]
pub fn external (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: External) } } # [doc = "Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Enc { # [doc = "0: Режим энкодера отключен"]
Disable = 0 , # [doc = "1: Режим энэнкодера включен"]
Enable = 1 , } impl From < Enc > for bool { # [inline (always)]
fn from (variant : Enc) -> Self { variant as u8 != 0 } } # [doc = "Field `ENC` reader - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
pub type EncR = crate :: BitReader < Enc > ; impl EncR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Enc { match self . bits { false => Enc :: Disable , true => Enc :: Enable , } } # [doc = "Режим энкодера отключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Enc :: Disable } # [doc = "Режим энэнкодера включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Enc :: Enable } } # [doc = "Field `ENC` writer - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
pub type EncW < 'a , REG > = crate :: BitWriter < 'a , REG , Enc > ; impl < 'a , REG > EncW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Режим энкодера отключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Enc :: Disable) } # [doc = "Режим энэнкодера включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Enc :: Enable) } } impl R { # [doc = "Bit 0 - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
# [inline (always)]
pub fn cksel (& self) -> CkselR { CkselR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
# [inline (always)]
pub fn ckpol (& self) -> CkpolR { CkpolR :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bits 3:4 - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
# [inline (always)]
pub fn ckflt (& self) -> CkfltR { CkfltR :: new (((self . bits >> 3) & 3) as u8) } # [doc = "Bits 6:7 - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
# [inline (always)]
pub fn trgflt (& self) -> TrgfltR { TrgfltR :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 9:11 - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
# [inline (always)]
pub fn presc (& self) -> PrescR { PrescR :: new (((self . bits >> 9) & 7) as u8) } # [doc = "Bits 13:15 - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
# [inline (always)]
pub fn trigsel (& self) -> TrigselR { TrigselR :: new (((self . bits >> 13) & 7) as u8) } # [doc = "Bits 17:18 - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
# [inline (always)]
pub fn trigen (& self) -> TrigenR { TrigenR :: new (((self . bits >> 17) & 3) as u8) } # [doc = "Bit 19 - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
# [inline (always)]
pub fn timeout (& self) -> TimeoutR { TimeoutR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Форма волны. Бит WAVE управляет формой выходного сигнала"]
# [inline (always)]
pub fn wave (& self) -> WaveR { WaveR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
# [inline (always)]
pub fn wavwpol (& self) -> WavwpolR { WavwpolR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
# [inline (always)]
pub fn preload (& self) -> PreloadR { PreloadR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
# [inline (always)]
pub fn count_mode (& self) -> CountModeR { CountModeR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 24 - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
# [inline (always)]
pub fn enc (& self) -> EncR { EncR :: new (((self . bits >> 24) & 1) != 0) } } impl W { # [doc = "Bit 0 - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
# [inline (always)]
pub fn cksel (& mut self) -> CkselW < CfgrSpec > { CkselW :: new (self , 0) } # [doc = "Bits 1:2 - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
# [inline (always)]
pub fn ckpol (& mut self) -> CkpolW < CfgrSpec > { CkpolW :: new (self , 1) } # [doc = "Bits 3:4 - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
# [inline (always)]
pub fn ckflt (& mut self) -> CkfltW < CfgrSpec > { CkfltW :: new (self , 3) } # [doc = "Bits 6:7 - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
# [inline (always)]
pub fn trgflt (& mut self) -> TrgfltW < CfgrSpec > { TrgfltW :: new (self , 6) } # [doc = "Bits 9:11 - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
# [inline (always)]
pub fn presc (& mut self) -> PrescW < CfgrSpec > { PrescW :: new (self , 9) } # [doc = "Bits 13:15 - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
# [inline (always)]
pub fn trigsel (& mut self) -> TrigselW < CfgrSpec > { TrigselW :: new (self , 13) } # [doc = "Bits 17:18 - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
# [inline (always)]
pub fn trigen (& mut self) -> TrigenW < CfgrSpec > { TrigenW :: new (self , 17) } # [doc = "Bit 19 - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
# [inline (always)]
pub fn timeout (& mut self) -> TimeoutW < CfgrSpec > { TimeoutW :: new (self , 19) } # [doc = "Bit 20 - Форма волны. Бит WAVE управляет формой выходного сигнала"]
# [inline (always)]
pub fn wave (& mut self) -> WaveW < CfgrSpec > { WaveW :: new (self , 20) } # [doc = "Bit 21 - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
# [inline (always)]
pub fn wavwpol (& mut self) -> WavwpolW < CfgrSpec > { WavwpolW :: new (self , 21) } # [doc = "Bit 22 - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
# [inline (always)]
pub fn preload (& mut self) -> PreloadW < CfgrSpec > { PreloadW :: new (self , 22) } # [doc = "Bit 23 - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
# [inline (always)]
pub fn count_mode (& mut self) -> CountModeW < CfgrSpec > { CountModeW :: new (self , 23) } # [doc = "Bit 24 - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
# [inline (always)]
pub fn enc (& mut self) -> EncW < CfgrSpec > { EncW :: new (self , 24) } } # [doc = "Регистр конфигурации\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cfgr::R`](R) reader structure"]
impl crate :: Readable for CfgrSpec { } # [doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"]
impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CFGR to value 0"]
impl crate :: Resettable for CfgrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CR (rw) register accessor: Регистр управления\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`]
module"]
# [doc (alias = "CR")]
pub type Cr = crate :: Reg < cr :: CrSpec > ; # [doc = "Регистр управления"]
pub mod cr { # [doc = "Register `CR` reader"]
pub type R = crate :: R < CrSpec > ; # [doc = "Register `CR` writer"]
pub type W = crate :: W < CrSpec > ; # [doc = "Field `ENABLE` reader - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
pub type EnableR = crate :: BitReader ; # [doc = "Field `ENABLE` writer - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
pub type EnableW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `SNGSTRT` reader - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
pub type SngstrtR = crate :: BitReader ; # [doc = "Field `SNGSTRT` writer - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
pub type SngstrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `CNTSTRT` reader - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
pub type CntstrtR = crate :: BitReader ; # [doc = "Field `CNTSTRT` writer - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
pub type CntstrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
# [inline (always)]
pub fn enable (& self) -> EnableR { EnableR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
# [inline (always)]
pub fn sngstrt (& self) -> SngstrtR { SngstrtR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
# [inline (always)]
pub fn cntstrt (& self) -> CntstrtR { CntstrtR :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
# [inline (always)]
pub fn enable (& mut self) -> EnableW < CrSpec > { EnableW :: new (self , 0) } # [doc = "Bit 1 - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
# [inline (always)]
pub fn sngstrt (& mut self) -> SngstrtW < CrSpec > { SngstrtW :: new (self , 1) } # [doc = "Bit 2 - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
# [inline (always)]
pub fn cntstrt (& mut self) -> CntstrtW < CrSpec > { CntstrtW :: new (self , 2) } } # [doc = "Регистр управления\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr::R`](R) reader structure"]
impl crate :: Readable for CrSpec { } # [doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"]
impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CR to value 0"]
impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CMP (rw) register accessor: Регистр сравнения\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmp`]
module"]
# [doc (alias = "CMP")]
pub type Cmp = crate :: Reg < cmp :: CmpSpec > ; # [doc = "Регистр сравнения"]
pub mod cmp { # [doc = "Register `CMP` reader"]
pub type R = crate :: R < CmpSpec > ; # [doc = "Register `CMP` writer"]
pub type W = crate :: W < CmpSpec > ; # [doc = "Field `CMP` reader - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type CmpR = crate :: FieldReader < u16 > ; # [doc = "Field `CMP` writer - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type CmpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn cmp (& self) -> CmpR { CmpR :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15 - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn cmp (& mut self) -> CmpW < CmpSpec > { CmpW :: new (self , 0) } } # [doc = "Регистр сравнения\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CmpSpec ; impl crate :: RegisterSpec for CmpSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cmp::R`](R) reader structure"]
impl crate :: Readable for CmpSpec { } # [doc = "`write(|w| ..)` method takes [`cmp::W`](W) writer structure"]
impl crate :: Writable for CmpSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CMP to value 0"]
impl crate :: Resettable for CmpSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ARR (rw) register accessor: Регистр автоматической перезагрузки\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`]
module"]
# [doc (alias = "ARR")]
pub type Arr = crate :: Reg < arr :: ArrSpec > ; # [doc = "Регистр автоматической перезагрузки"]
pub mod arr { # [doc = "Register `ARR` reader"]
pub type R = crate :: R < ArrSpec > ; # [doc = "Register `ARR` writer"]
pub type W = crate :: W < ArrSpec > ; # [doc = "Field `ARR` reader - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type ArrR = crate :: FieldReader < u16 > ; # [doc = "Field `ARR` writer - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15 - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn arr (& mut self) -> ArrW < ArrSpec > { ArrW :: new (self , 0) } } # [doc = "Регистр автоматической перезагрузки\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`arr::R`](R) reader structure"]
impl crate :: Readable for ArrSpec { } # [doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"]
impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ARR to value 0"]
impl crate :: Resettable for ArrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CNT (rw) register accessor: Регистр счётчика\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`]
module"]
# [doc (alias = "CNT")]
pub type Cnt = crate :: Reg < cnt :: CntSpec > ; # [doc = "Регистр счётчика"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub type R = crate :: R < CntSpec > ; # [doc = "Register `CNT` writer"]
pub type W = crate :: W < CntSpec > ; # [doc = "Field `CNT` reader - Значение счетчика. Когда TIMER16 работает с асинхронными тактовыми сигналами, чтение регистра CNT мо-жет вернуть недостоверные значения. Поэтому в этом случае необходимо выполнить два последовательных до-ступа на чтение и убедиться, что два возвращенных значения идентичны."]
pub type CntR = crate :: FieldReader < u16 > ; impl R { # [doc = "Bits 0:15 - Значение счетчика. Когда TIMER16 работает с асинхронными тактовыми сигналами, чтение регистра CNT мо-жет вернуть недостоверные значения. Поэтому в этом случае необходимо выполнить два последовательных до-ступа на чтение и убедиться, что два возвращенных значения идентичны."]
# [inline (always)]
pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W { } # [doc = "Регистр счётчика\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cnt::R`](R) reader structure"]
impl crate :: Readable for CntSpec { } # [doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"]
impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CntSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Регистры модуля таймера_1"]
pub struct Timer16_1 { _marker : PhantomData < * const () > } unsafe impl Send for Timer16_1 { } impl Timer16_1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer16_1 :: RegisterBlock = 0x0008_2000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer16_1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Timer16_1 { type Target = timer16_1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Timer16_1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer16_1") . finish () } } # [doc = "Регистры модуля таймера_1"]
pub mod timer16_1 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { isr : Isr , icr : Icr , ier : Ier , cfgr : Cfgr , cr : Cr , cmp : Cmp , arr : Arr , cnt : Cnt , } impl RegisterBlock { # [doc = "0x00 - Регистр флагов прерываний"]
# [inline (always)]
pub const fn isr (& self) -> & Isr { & self . isr } # [doc = "0x04 - Регистр сброса флагов прерываний"]
# [inline (always)]
pub const fn icr (& self) -> & Icr { & self . icr } # [doc = "0x08 - Регистр разрешения прерываний"]
# [inline (always)]
pub const fn ier (& self) -> & Ier { & self . ier } # [doc = "0x0c - Регистр конфигурации"]
# [inline (always)]
pub const fn cfgr (& self) -> & Cfgr { & self . cfgr } # [doc = "0x10 - Регистр управления"]
# [inline (always)]
pub const fn cr (& self) -> & Cr { & self . cr } # [doc = "0x14 - Регистр сравнения"]
# [inline (always)]
pub const fn cmp (& self) -> & Cmp { & self . cmp } # [doc = "0x18 - Регистр автоматической перезагрузки"]
# [inline (always)]
pub const fn arr (& self) -> & Arr { & self . arr } # [doc = "0x1c - Регистр счётчика"]
# [inline (always)]
pub const fn cnt (& self) -> & Cnt { & self . cnt } } # [doc = "ISR (r) register accessor: Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`]
module"]
# [doc (alias = "ISR")]
pub type Isr = crate :: Reg < isr :: IsrSpec > ; # [doc = "Регистр флагов прерываний"]
pub mod isr { # [doc = "Register `ISR` reader"]
pub type R = crate :: R < IsrSpec > ; # [doc = "Field `CMPM` reader - Совпадение сравнения. Бит CMPM устанавливается аппаратными средствами, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра CMP"]
pub type CmpmR = crate :: BitReader ; # [doc = "Field `ARRM` reader - Cоответствие автозагрузки. ARRM устанавливается аппаратурой, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра ARR."]
pub type ArrmR = crate :: BitReader ; # [doc = "Field `EXTTRIG` reader - Cобытие фронта внешнего триггера. EXTTRIG устанавливается аппаратно, чтобы сообщить приложению, что на выбранном входе внешнего триггера возник достоверный фронт импульса. Если триггер игнорируется, так как таймер уже запущен, то этот флаг не устанавливается"]
pub type ExttrigR = crate :: BitReader ; # [doc = "Field `CMPOK` reader - Обновление регистра сравнения OK. CMPOK устанавливается аппаратными средствами, чтобы сообщить приложению, что операция записи в регистр CMP шины APB успешно завершена."]
pub type CmpokR = crate :: BitReader ; # [doc = "Field `ARROK` reader - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
pub type ArrokR = crate :: BitReader ; # [doc = "Field `UP` reader - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
pub type UpR = crate :: BitReader ; # [doc = "Field `DOWN` reader - Изменение направления счетчика вверх на вниз. В режиме энкодера бит DOWN устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вверх\" на \"вниз\"."]
pub type DownR = crate :: BitReader ; impl R { # [doc = "Bit 0 - Совпадение сравнения. Бит CMPM устанавливается аппаратными средствами, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра CMP"]
# [inline (always)]
pub fn cmpm (& self) -> CmpmR { CmpmR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Cоответствие автозагрузки. ARRM устанавливается аппаратурой, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра ARR."]
# [inline (always)]
pub fn arrm (& self) -> ArrmR { ArrmR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Cобытие фронта внешнего триггера. EXTTRIG устанавливается аппаратно, чтобы сообщить приложению, что на выбранном входе внешнего триггера возник достоверный фронт импульса. Если триггер игнорируется, так как таймер уже запущен, то этот флаг не устанавливается"]
# [inline (always)]
pub fn exttrig (& self) -> ExttrigR { ExttrigR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Обновление регистра сравнения OK. CMPOK устанавливается аппаратными средствами, чтобы сообщить приложению, что операция записи в регистр CMP шины APB успешно завершена."]
# [inline (always)]
pub fn cmpok (& self) -> CmpokR { CmpokR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
# [inline (always)]
pub fn arrok (& self) -> ArrokR { ArrokR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
# [inline (always)]
pub fn up (& self) -> UpR { UpR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Изменение направления счетчика вверх на вниз. В режиме энкодера бит DOWN устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вверх\" на \"вниз\"."]
# [inline (always)]
pub fn down (& self) -> DownR { DownR :: new (((self . bits >> 6) & 1) != 0) } } # [doc = "Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`isr::R`](R) reader structure"]
impl crate :: Readable for IsrSpec { } # [doc = "`reset()` method sets ISR to value 0"]
impl crate :: Resettable for IsrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ICR (w) register accessor: Регистр сброса флагов прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`]
module"]
# [doc (alias = "ICR")]
pub type Icr = crate :: Reg < icr :: IcrSpec > ; # [doc = "Регистр сброса флагов прерываний"]
pub mod icr { # [doc = "Register `ICR` writer"]
pub type W = crate :: W < IcrSpec > ; # [doc = "Field `CMPMCF` writer - Запись «1» в этот бит снимает флаг CMPM в регистре LPT_ISR"]
pub type CmpmcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `ARRMCF` writer - Запись «1» в этот бит снимает флаг ARRM в регистре LPT_ISR"]
pub type ArrmcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `EXTTRIGCF` writer - Запись «1» в этот бит снимает флаг EXTTRIG в регистре LPT_ISR"]
pub type ExttrigcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `ARRROCF` writer - Запись «1» в этот бит снимает флаг ARROK в регистре LPT_ISR"]
pub type ArrrocfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `UPCF` writer - Запись «1» в этот бит снимает флаг UP в регистре LPT_ISR"]
pub type UpcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `DOWNCF` writer - Запись «1» в этот бит снимает флаг DOWN в регистре LPT_ISR"]
pub type DowncfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; impl W { # [doc = "Bit 0 - Запись «1» в этот бит снимает флаг CMPM в регистре LPT_ISR"]
# [inline (always)]
pub fn cmpmcf (& mut self) -> CmpmcfW < IcrSpec > { CmpmcfW :: new (self , 0) } # [doc = "Bit 1 - Запись «1» в этот бит снимает флаг ARRM в регистре LPT_ISR"]
# [inline (always)]
pub fn arrmcf (& mut self) -> ArrmcfW < IcrSpec > { ArrmcfW :: new (self , 1) } # [doc = "Bit 2 - Запись «1» в этот бит снимает флаг EXTTRIG в регистре LPT_ISR"]
# [inline (always)]
pub fn exttrigcf (& mut self) -> ExttrigcfW < IcrSpec > { ExttrigcfW :: new (self , 2) } # [doc = "Bit 4 - Запись «1» в этот бит снимает флаг ARROK в регистре LPT_ISR"]
# [inline (always)]
pub fn arrrocf (& mut self) -> ArrrocfW < IcrSpec > { ArrrocfW :: new (self , 4) } # [doc = "Bit 5 - Запись «1» в этот бит снимает флаг UP в регистре LPT_ISR"]
# [inline (always)]
pub fn upcf (& mut self) -> UpcfW < IcrSpec > { UpcfW :: new (self , 5) } # [doc = "Bit 6 - Запись «1» в этот бит снимает флаг DOWN в регистре LPT_ISR"]
# [inline (always)]
pub fn downcf (& mut self) -> DowncfW < IcrSpec > { DowncfW :: new (self , 6) } } # [doc = "Регистр сброса флагов прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"]
impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0x77 ; } # [doc = "`reset()` method sets ICR to value 0"]
impl crate :: Resettable for IcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "IER (rw) register accessor: Регистр разрешения прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`]
module"]
# [doc (alias = "IER")]
pub type Ier = crate :: Reg < ier :: IerSpec > ; # [doc = "Регистр разрешения прерываний"]
pub mod ier { # [doc = "Register `IER` reader"]
pub type R = crate :: R < IerSpec > ; # [doc = "Register `IER` writer"]
pub type W = crate :: W < IerSpec > ; # [doc = "запрет/разрешение прерывания CMPM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cmpmie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Cmpmie > for bool { # [inline (always)]
fn from (variant : Cmpmie) -> Self { variant as u8 != 0 } } # [doc = "Field `CMPMIE` reader - запрет/разрешение прерывания CMPM"]
pub type CmpmieR = crate :: BitReader < Cmpmie > ; impl CmpmieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cmpmie { match self . bits { false => Cmpmie :: Disable , true => Cmpmie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Cmpmie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cmpmie :: Enable } } # [doc = "Field `CMPMIE` writer - запрет/разрешение прерывания CMPM"]
pub type CmpmieW < 'a , REG > = crate :: BitWriter < 'a , REG , Cmpmie > ; impl < 'a , REG > CmpmieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpmie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpmie :: Enable) } } # [doc = "запрет/разрешение прерывания EXTTRIG\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Exttrigie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Exttrigie > for bool { # [inline (always)]
fn from (variant : Exttrigie) -> Self { variant as u8 != 0 } } # [doc = "Field `EXTTRIGIE` reader - запрет/разрешение прерывания EXTTRIG"]
pub type ExttrigieR = crate :: BitReader < Exttrigie > ; impl ExttrigieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Exttrigie { match self . bits { false => Exttrigie :: Disable , true => Exttrigie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Exttrigie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Exttrigie :: Enable } } # [doc = "Field `EXTTRIGIE` writer - запрет/разрешение прерывания EXTTRIG"]
pub type ExttrigieW < 'a , REG > = crate :: BitWriter < 'a , REG , Exttrigie > ; impl < 'a , REG > ExttrigieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Exttrigie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Exttrigie :: Enable) } } # [doc = "запрет/разрешение прерывания CMPOK\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cmpokie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Cmpokie > for bool { # [inline (always)]
fn from (variant : Cmpokie) -> Self { variant as u8 != 0 } } # [doc = "Field `CMPOKIE` reader - запрет/разрешение прерывания CMPOK"]
pub type CmpokieR = crate :: BitReader < Cmpokie > ; impl CmpokieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cmpokie { match self . bits { false => Cmpokie :: Disable , true => Cmpokie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Cmpokie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cmpokie :: Enable } } # [doc = "Field `CMPOKIE` writer - запрет/разрешение прерывания CMPOK"]
pub type CmpokieW < 'a , REG > = crate :: BitWriter < 'a , REG , Cmpokie > ; impl < 'a , REG > CmpokieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpokie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpokie :: Enable) } } # [doc = "запрет/разрешение прерывания ARRROK\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Arrokie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Arrokie > for bool { # [inline (always)]
fn from (variant : Arrokie) -> Self { variant as u8 != 0 } } # [doc = "Field `ARROKIE` reader - запрет/разрешение прерывания ARRROK"]
pub type ArrokieR = crate :: BitReader < Arrokie > ; impl ArrokieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Arrokie { match self . bits { false => Arrokie :: Disable , true => Arrokie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Arrokie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Arrokie :: Enable } } # [doc = "Field `ARROKIE` writer - запрет/разрешение прерывания ARRROK"]
pub type ArrokieW < 'a , REG > = crate :: BitWriter < 'a , REG , Arrokie > ; impl < 'a , REG > ArrokieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrokie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrokie :: Enable) } } # [doc = "запрет/разрешение прерывания UP\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Upie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Upie > for bool { # [inline (always)]
fn from (variant : Upie) -> Self { variant as u8 != 0 } } # [doc = "Field `UPIE` reader - запрет/разрешение прерывания UP"]
pub type UpieR = crate :: BitReader < Upie > ; impl UpieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Upie { match self . bits { false => Upie :: Disable , true => Upie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Upie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Upie :: Enable } } # [doc = "Field `UPIE` writer - запрет/разрешение прерывания UP"]
pub type UpieW < 'a , REG > = crate :: BitWriter < 'a , REG , Upie > ; impl < 'a , REG > UpieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Upie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Upie :: Enable) } } # [doc = "запрет/разрешение прерывания ARRM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Arrmie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Arrmie > for bool { # [inline (always)]
fn from (variant : Arrmie) -> Self { variant as u8 != 0 } } # [doc = "Field `ARRMIE` reader - запрет/разрешение прерывания ARRM"]
pub type ArrmieR = crate :: BitReader < Arrmie > ; impl ArrmieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Arrmie { match self . bits { false => Arrmie :: Disable , true => Arrmie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Arrmie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Arrmie :: Enable } } # [doc = "Field `ARRMIE` writer - запрет/разрешение прерывания ARRM"]
pub type ArrmieW < 'a , REG > = crate :: BitWriter < 'a , REG , Arrmie > ; impl < 'a , REG > ArrmieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrmie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrmie :: Enable) } } # [doc = "запрет/разрешение прерывания DOWN\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Downie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Downie > for bool { # [inline (always)]
fn from (variant : Downie) -> Self { variant as u8 != 0 } } # [doc = "Field `DOWNIE` reader - запрет/разрешение прерывания DOWN"]
pub type DownieR = crate :: BitReader < Downie > ; impl DownieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Downie { match self . bits { false => Downie :: Disable , true => Downie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Downie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Downie :: Enable } } # [doc = "Field `DOWNIE` writer - запрет/разрешение прерывания DOWN"]
pub type DownieW < 'a , REG > = crate :: BitWriter < 'a , REG , Downie > ; impl < 'a , REG > DownieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Downie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Downie :: Enable) } } impl R { # [doc = "Bit 0 - запрет/разрешение прерывания CMPM"]
# [inline (always)]
pub fn cmpmie (& self) -> CmpmieR { CmpmieR :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - запрет/разрешение прерывания EXTTRIG"]
# [inline (always)]
pub fn exttrigie (& self) -> ExttrigieR { ExttrigieR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - запрет/разрешение прерывания CMPOK"]
# [inline (always)]
pub fn cmpokie (& self) -> CmpokieR { CmpokieR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - запрет/разрешение прерывания ARRROK"]
# [inline (always)]
pub fn arrokie (& self) -> ArrokieR { ArrokieR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - запрет/разрешение прерывания UP"]
# [inline (always)]
pub fn upie (& self) -> UpieR { UpieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 5 - запрет/разрешение прерывания ARRM"]
# [inline (always)]
pub fn arrmie (& self) -> ArrmieR { ArrmieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - запрет/разрешение прерывания DOWN"]
# [inline (always)]
pub fn downie (& self) -> DownieR { DownieR :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - запрет/разрешение прерывания CMPM"]
# [inline (always)]
pub fn cmpmie (& mut self) -> CmpmieW < IerSpec > { CmpmieW :: new (self , 0) } # [doc = "Bit 2 - запрет/разрешение прерывания EXTTRIG"]
# [inline (always)]
pub fn exttrigie (& mut self) -> ExttrigieW < IerSpec > { ExttrigieW :: new (self , 2) } # [doc = "Bit 3 - запрет/разрешение прерывания CMPOK"]
# [inline (always)]
pub fn cmpokie (& mut self) -> CmpokieW < IerSpec > { CmpokieW :: new (self , 3) } # [doc = "Bit 4 - запрет/разрешение прерывания ARRROK"]
# [inline (always)]
pub fn arrokie (& mut self) -> ArrokieW < IerSpec > { ArrokieW :: new (self , 4) } # [doc = "Bit 5 - запрет/разрешение прерывания UP"]
# [inline (always)]
pub fn upie (& mut self) -> UpieW < IerSpec > { UpieW :: new (self , 5) } # [doc = "Bit 5 - запрет/разрешение прерывания ARRM"]
# [inline (always)]
pub fn arrmie (& mut self) -> ArrmieW < IerSpec > { ArrmieW :: new (self , 5) } # [doc = "Bit 6 - запрет/разрешение прерывания DOWN"]
# [inline (always)]
pub fn downie (& mut self) -> DownieW < IerSpec > { DownieW :: new (self , 6) } } # [doc = "Регистр разрешения прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IerSpec ; impl crate :: RegisterSpec for IerSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ier::R`](R) reader structure"]
impl crate :: Readable for IerSpec { } # [doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"]
impl crate :: Writable for IerSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets IER to value 0"]
impl crate :: Resettable for IerSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CFGR (rw) register accessor: Регистр конфигурации\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`]
module"]
# [doc (alias = "CFGR")]
pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ; # [doc = "Регистр конфигурации"]
pub mod cfgr { # [doc = "Register `CFGR` reader"]
pub type R = crate :: R < CfgrSpec > ; # [doc = "Register `CFGR` writer"]
pub type W = crate :: W < CfgrSpec > ; # [doc = "Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cksel { # [doc = "0: TIMER16 тактируется внутренним источником тактового сигнала (APB тактовый генератор или любой из встроенных генераторов)"]
Internal = 0 , # [doc = "1: TIMER16 тактируется внешним источником тактового сигнала через внешний lnput1 TIMER16"]
External = 1 , } impl From < Cksel > for bool { # [inline (always)]
fn from (variant : Cksel) -> Self { variant as u8 != 0 } } # [doc = "Field `CKSEL` reader - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
pub type CkselR = crate :: BitReader < Cksel > ; impl CkselR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cksel { match self . bits { false => Cksel :: Internal , true => Cksel :: External , } } # [doc = "TIMER16 тактируется внутренним источником тактового сигнала (APB тактовый генератор или любой из встроенных генераторов)"]
# [inline (always)]
pub fn is_internal (& self) -> bool { * self == Cksel :: Internal } # [doc = "TIMER16 тактируется внешним источником тактового сигнала через внешний lnput1 TIMER16"]
# [inline (always)]
pub fn is_external (& self) -> bool { * self == Cksel :: External } } # [doc = "Field `CKSEL` writer - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
pub type CkselW < 'a , REG > = crate :: BitWriter < 'a , REG , Cksel > ; impl < 'a , REG > CkselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "TIMER16 тактируется внутренним источником тактового сигнала (APB тактовый генератор или любой из встроенных генераторов)"]
# [inline (always)]
pub fn internal (self) -> & 'a mut crate :: W < REG > { self . variant (Cksel :: Internal) } # [doc = "TIMER16 тактируется внешним источником тактового сигнала через внешний lnput1 TIMER16"]
# [inline (always)]
pub fn external (self) -> & 'a mut crate :: W < REG > { self . variant (Cksel :: External) } } # [doc = "Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Ckpol { # [doc = "0: Нарастающий фронт является активным фронтом, используемым для подсчета"]
Rising = 0 , # [doc = "1: Спадающий фронт является активным фронтом, используемым для подсчета"]
Folling = 1 , # [doc = "2: Оба фронта являются активными фронтами. Когда оба фронта внешнего тактового сигнала считаются активными, TIMER16 должен также тактироваться внутренним источником тактового сигнала с частотой, по крайней мере в четыре раза превышающей частоту внешнего тактового сигнала."]
BothEdge = 2 , } impl From < Ckpol > for u8 { # [inline (always)]
fn from (variant : Ckpol) -> Self { variant as _ } } impl crate :: FieldSpec for Ckpol { type Ux = u8 ; } impl crate :: IsEnum for Ckpol { } # [doc = "Field `CKPOL` reader - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
pub type CkpolR = crate :: FieldReader < Ckpol > ; impl CkpolR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Ckpol > { match self . bits { 0 => Some (Ckpol :: Rising) , 1 => Some (Ckpol :: Folling) , 2 => Some (Ckpol :: BothEdge) , _ => None , } } # [doc = "Нарастающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == Ckpol :: Rising } # [doc = "Спадающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn is_folling (& self) -> bool { * self == Ckpol :: Folling } # [doc = "Оба фронта являются активными фронтами. Когда оба фронта внешнего тактового сигнала считаются активными, TIMER16 должен также тактироваться внутренним источником тактового сигнала с частотой, по крайней мере в четыре раза превышающей частоту внешнего тактового сигнала."]
# [inline (always)]
pub fn is_both_edge (& self) -> bool { * self == Ckpol :: BothEdge } } # [doc = "Field `CKPOL` writer - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
pub type CkpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Ckpol > ; impl < 'a , REG > CkpolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нарастающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn rising (self) -> & 'a mut crate :: W < REG > { self . variant (Ckpol :: Rising) } # [doc = "Спадающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn folling (self) -> & 'a mut crate :: W < REG > { self . variant (Ckpol :: Folling) } # [doc = "Оба фронта являются активными фронтами. Когда оба фронта внешнего тактового сигнала считаются активными, TIMER16 должен также тактироваться внутренним источником тактового сигнала с частотой, по крайней мере в четыре раза превышающей частоту внешнего тактового сигнала."]
# [inline (always)]
pub fn both_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Ckpol :: BothEdge) } } # [doc = "Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Ckflt { # [doc = "0: Любое изменение активного уровня триггера читается действительным триггером"]
Disable = 0 , # [doc = "1: Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
_2clock = 1 , # [doc = "2: Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_4clock = 2 , # [doc = "3: Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_8clock = 3 , } impl From < Ckflt > for u8 { # [inline (always)]
fn from (variant : Ckflt) -> Self { variant as _ } } impl crate :: FieldSpec for Ckflt { type Ux = u8 ; } impl crate :: IsEnum for Ckflt { } # [doc = "Field `CKFLT` reader - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
pub type CkfltR = crate :: FieldReader < Ckflt > ; impl CkfltR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ckflt { match self . bits { 0 => Ckflt :: Disable , 1 => Ckflt :: _2clock , 2 => Ckflt :: _4clock , 3 => Ckflt :: _8clock , _ => unreachable ! () , } } # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Ckflt :: Disable } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn is_2clock (& self) -> bool { * self == Ckflt :: _2clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_4clock (& self) -> bool { * self == Ckflt :: _4clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_8clock (& self) -> bool { * self == Ckflt :: _8clock } } # [doc = "Field `CKFLT` writer - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
pub type CkfltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Ckflt , crate :: Safe > ; impl < 'a , REG > CkfltW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: Disable) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn _2clock (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: _2clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _4clock (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: _4clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _8clock (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: _8clock) } } # [doc = "Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Trgflt { # [doc = "0: Любое изменение активного уровня триггера читается действительным триггером"]
Disable = 0 , # [doc = "1: Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
_2clock = 1 , # [doc = "2: Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_4clock = 2 , # [doc = "3: Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_8clock = 3 , } impl From < Trgflt > for u8 { # [inline (always)]
fn from (variant : Trgflt) -> Self { variant as _ } } impl crate :: FieldSpec for Trgflt { type Ux = u8 ; } impl crate :: IsEnum for Trgflt { } # [doc = "Field `TRGFLT` reader - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
pub type TrgfltR = crate :: FieldReader < Trgflt > ; impl TrgfltR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Trgflt { match self . bits { 0 => Trgflt :: Disable , 1 => Trgflt :: _2clock , 2 => Trgflt :: _4clock , 3 => Trgflt :: _8clock , _ => unreachable ! () , } } # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Trgflt :: Disable } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn is_2clock (& self) -> bool { * self == Trgflt :: _2clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_4clock (& self) -> bool { * self == Trgflt :: _4clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_8clock (& self) -> bool { * self == Trgflt :: _8clock } } # [doc = "Field `TRGFLT` writer - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
pub type TrgfltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Trgflt , crate :: Safe > ; impl < 'a , REG > TrgfltW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: Disable) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn _2clock (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: _2clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _4clock (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: _4clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _8clock (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: _8clock) } } # [doc = "Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Presc { # [doc = "0: Делитель 1"]
_1 = 0 , # [doc = "1: Делитель 2"]
_2 = 1 , # [doc = "2: Делитель 4"]
_4 = 2 , # [doc = "3: Делитель 8"]
_8 = 3 , # [doc = "4: Делитель 16"]
_16 = 4 , # [doc = "5: Делитель 32"]
_32 = 5 , # [doc = "6: Делитель 64"]
_64 = 6 , # [doc = "7: Делитель 128"]
_128 = 7 , } impl From < Presc > for u8 { # [inline (always)]
fn from (variant : Presc) -> Self { variant as _ } } impl crate :: FieldSpec for Presc { type Ux = u8 ; } impl crate :: IsEnum for Presc { } # [doc = "Field `PRESC` reader - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
pub type PrescR = crate :: FieldReader < Presc > ; impl PrescR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Presc { match self . bits { 0 => Presc :: _1 , 1 => Presc :: _2 , 2 => Presc :: _4 , 3 => Presc :: _8 , 4 => Presc :: _16 , 5 => Presc :: _32 , 6 => Presc :: _64 , 7 => Presc :: _128 , _ => unreachable ! () , } } # [doc = "Делитель 1"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Presc :: _1 } # [doc = "Делитель 2"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == Presc :: _2 } # [doc = "Делитель 4"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == Presc :: _4 } # [doc = "Делитель 8"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == Presc :: _8 } # [doc = "Делитель 16"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == Presc :: _16 } # [doc = "Делитель 32"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == Presc :: _32 } # [doc = "Делитель 64"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == Presc :: _64 } # [doc = "Делитель 128"]
# [inline (always)]
pub fn is_128 (& self) -> bool { * self == Presc :: _128 } } # [doc = "Field `PRESC` writer - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
pub type PrescW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Presc , crate :: Safe > ; impl < 'a , REG > PrescW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Делитель 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _1) } # [doc = "Делитель 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _2) } # [doc = "Делитель 4"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _4) } # [doc = "Делитель 8"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _8) } # [doc = "Делитель 16"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _16) } # [doc = "Делитель 32"]
# [inline (always)]
pub fn _32 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _32) } # [doc = "Делитель 64"]
# [inline (always)]
pub fn _64 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _64) } # [doc = "Делитель 128"]
# [inline (always)]
pub fn _128 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _128) } } # [doc = "Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Trigsel { # [doc = "0: Источник триггера GPIO1_9"]
Gpio1_9 = 0 , # [doc = "1: Источник триггера GPIO1_8"]
Gpio1_8 = 1 , # [doc = "2: Источник триггера GPIO1_7"]
Gpio1_7 = 2 , # [doc = "3: Источник триггера GPIO1_6"]
Gpio1_6 = 3 , # [doc = "4: Источник триггера - окончание преобразования термосенсора"]
Tsens = 4 , # [doc = "5: окончание преобразования АЦП"]
Adc = 5 , # [doc = "6: Источник триггера - прерывание RTC"]
RtcIrq = 6 , # [doc = "7: Будильник"]
Alarm = 7 , } impl From < Trigsel > for u8 { # [inline (always)]
fn from (variant : Trigsel) -> Self { variant as _ } } impl crate :: FieldSpec for Trigsel { type Ux = u8 ; } impl crate :: IsEnum for Trigsel { } # [doc = "Field `TRIGSEL` reader - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
pub type TrigselR = crate :: FieldReader < Trigsel > ; impl TrigselR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Trigsel { match self . bits { 0 => Trigsel :: Gpio1_9 , 1 => Trigsel :: Gpio1_8 , 2 => Trigsel :: Gpio1_7 , 3 => Trigsel :: Gpio1_6 , 4 => Trigsel :: Tsens , 5 => Trigsel :: Adc , 6 => Trigsel :: RtcIrq , 7 => Trigsel :: Alarm , _ => unreachable ! () , } } # [doc = "Источник триггера GPIO1_9"]
# [inline (always)]
pub fn is_gpio1_9 (& self) -> bool { * self == Trigsel :: Gpio1_9 } # [doc = "Источник триггера GPIO1_8"]
# [inline (always)]
pub fn is_gpio1_8 (& self) -> bool { * self == Trigsel :: Gpio1_8 } # [doc = "Источник триггера GPIO1_7"]
# [inline (always)]
pub fn is_gpio1_7 (& self) -> bool { * self == Trigsel :: Gpio1_7 } # [doc = "Источник триггера GPIO1_6"]
# [inline (always)]
pub fn is_gpio1_6 (& self) -> bool { * self == Trigsel :: Gpio1_6 } # [doc = "Источник триггера - окончание преобразования термосенсора"]
# [inline (always)]
pub fn is_tsens (& self) -> bool { * self == Trigsel :: Tsens } # [doc = "окончание преобразования АЦП"]
# [inline (always)]
pub fn is_adc (& self) -> bool { * self == Trigsel :: Adc } # [doc = "Источник триггера - прерывание RTC"]
# [inline (always)]
pub fn is_rtc_irq (& self) -> bool { * self == Trigsel :: RtcIrq } # [doc = "Будильник"]
# [inline (always)]
pub fn is_alarm (& self) -> bool { * self == Trigsel :: Alarm } } # [doc = "Field `TRIGSEL` writer - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
pub type TrigselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Trigsel , crate :: Safe > ; impl < 'a , REG > TrigselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Источник триггера GPIO1_9"]
# [inline (always)]
pub fn gpio1_9 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio1_9) } # [doc = "Источник триггера GPIO1_8"]
# [inline (always)]
pub fn gpio1_8 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio1_8) } # [doc = "Источник триггера GPIO1_7"]
# [inline (always)]
pub fn gpio1_7 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio1_7) } # [doc = "Источник триггера GPIO1_6"]
# [inline (always)]
pub fn gpio1_6 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio1_6) } # [doc = "Источник триггера - окончание преобразования термосенсора"]
# [inline (always)]
pub fn tsens (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Tsens) } # [doc = "окончание преобразования АЦП"]
# [inline (always)]
pub fn adc (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Adc) } # [doc = "Источник триггера - прерывание RTC"]
# [inline (always)]
pub fn rtc_irq (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: RtcIrq) } # [doc = "Будильник"]
# [inline (always)]
pub fn alarm (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Alarm) } } # [doc = "Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Trigen { # [doc = "0: Программный триггер (начало отсчета инициируется программно)"]
Software = 0 , # [doc = "1: Нарастающий фронт является активным фронтом"]
Rising = 1 , # [doc = "2: Падающий фронт является активным фронтом"]
Folling = 2 , # [doc = "3: Оба фронта являются активными фронтами энергопотреблением"]
BothEdge = 3 , } impl From < Trigen > for u8 { # [inline (always)]
fn from (variant : Trigen) -> Self { variant as _ } } impl crate :: FieldSpec for Trigen { type Ux = u8 ; } impl crate :: IsEnum for Trigen { } # [doc = "Field `TRIGEN` reader - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
pub type TrigenR = crate :: FieldReader < Trigen > ; impl TrigenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Trigen { match self . bits { 0 => Trigen :: Software , 1 => Trigen :: Rising , 2 => Trigen :: Folling , 3 => Trigen :: BothEdge , _ => unreachable ! () , } } # [doc = "Программный триггер (начало отсчета инициируется программно)"]
# [inline (always)]
pub fn is_software (& self) -> bool { * self == Trigen :: Software } # [doc = "Нарастающий фронт является активным фронтом"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == Trigen :: Rising } # [doc = "Падающий фронт является активным фронтом"]
# [inline (always)]
pub fn is_folling (& self) -> bool { * self == Trigen :: Folling } # [doc = "Оба фронта являются активными фронтами энергопотреблением"]
# [inline (always)]
pub fn is_both_edge (& self) -> bool { * self == Trigen :: BothEdge } } # [doc = "Field `TRIGEN` writer - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
pub type TrigenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Trigen , crate :: Safe > ; impl < 'a , REG > TrigenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Программный триггер (начало отсчета инициируется программно)"]
# [inline (always)]
pub fn software (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: Software) } # [doc = "Нарастающий фронт является активным фронтом"]
# [inline (always)]
pub fn rising (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: Rising) } # [doc = "Падающий фронт является активным фронтом"]
# [inline (always)]
pub fn folling (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: Folling) } # [doc = "Оба фронта являются активными фронтами энергопотреблением"]
# [inline (always)]
pub fn both_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: BothEdge) } } # [doc = "Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timeout { # [doc = "0: Триггерное событие, поступающее, когда таймер уже запущен, будет проигнорировано"]
TriggerEventIgnor = 0 , # [doc = "1: Триггерное событие, поступающее, когда таймер уже запущен, сбросит и перезапустит счетчик"]
TriggerEventRestart = 1 , } impl From < Timeout > for bool { # [inline (always)]
fn from (variant : Timeout) -> Self { variant as u8 != 0 } } # [doc = "Field `TIMEOUT` reader - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
pub type TimeoutR = crate :: BitReader < Timeout > ; impl TimeoutR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timeout { match self . bits { false => Timeout :: TriggerEventIgnor , true => Timeout :: TriggerEventRestart , } } # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, будет проигнорировано"]
# [inline (always)]
pub fn is_trigger_event_ignor (& self) -> bool { * self == Timeout :: TriggerEventIgnor } # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, сбросит и перезапустит счетчик"]
# [inline (always)]
pub fn is_trigger_event_restart (& self) -> bool { * self == Timeout :: TriggerEventRestart } } # [doc = "Field `TIMEOUT` writer - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
pub type TimeoutW < 'a , REG > = crate :: BitWriter < 'a , REG , Timeout > ; impl < 'a , REG > TimeoutW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, будет проигнорировано"]
# [inline (always)]
pub fn trigger_event_ignor (self) -> & 'a mut crate :: W < REG > { self . variant (Timeout :: TriggerEventIgnor) } # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, сбросит и перезапустит счетчик"]
# [inline (always)]
pub fn trigger_event_restart (self) -> & 'a mut crate :: W < REG > { self . variant (Timeout :: TriggerEventRestart) } } # [doc = "Форма волны. Бит WAVE управляет формой выходного сигнала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wave { # [doc = "0: Деактивировать режим Set-once, форма волны ШИМ (PWM) / один импульс (One shot)"]
PwmOrOneShot = 0 , # [doc = "1: Активировать режим Set-once"]
SetOnce = 1 , } impl From < Wave > for bool { # [inline (always)]
fn from (variant : Wave) -> Self { variant as u8 != 0 } } # [doc = "Field `WAVE` reader - Форма волны. Бит WAVE управляет формой выходного сигнала"]
pub type WaveR = crate :: BitReader < Wave > ; impl WaveR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wave { match self . bits { false => Wave :: PwmOrOneShot , true => Wave :: SetOnce , } } # [doc = "Деактивировать режим Set-once, форма волны ШИМ (PWM) / один импульс (One shot)"]
# [inline (always)]
pub fn is_pwm_or_one_shot (& self) -> bool { * self == Wave :: PwmOrOneShot } # [doc = "Активировать режим Set-once"]
# [inline (always)]
pub fn is_set_once (& self) -> bool { * self == Wave :: SetOnce } } # [doc = "Field `WAVE` writer - Форма волны. Бит WAVE управляет формой выходного сигнала"]
pub type WaveW < 'a , REG > = crate :: BitWriter < 'a , REG , Wave > ; impl < 'a , REG > WaveW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Деактивировать режим Set-once, форма волны ШИМ (PWM) / один импульс (One shot)"]
# [inline (always)]
pub fn pwm_or_one_shot (self) -> & 'a mut crate :: W < REG > { self . variant (Wave :: PwmOrOneShot) } # [doc = "Активировать режим Set-once"]
# [inline (always)]
pub fn set_once (self) -> & 'a mut crate :: W < REG > { self . variant (Wave :: SetOnce) } } # [doc = "Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wavwpol { # [doc = "0: Выход TIMER16 отражает результаты сравнения между регистрами ARR и CMP"]
Noninverted = 0 , # [doc = "1: Выход TIMER16 отражает инверсные результаты сравнения между регистрами ARR и CMP"]
Inverted = 1 , } impl From < Wavwpol > for bool { # [inline (always)]
fn from (variant : Wavwpol) -> Self { variant as u8 != 0 } } # [doc = "Field `WAVWPOL` reader - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
pub type WavwpolR = crate :: BitReader < Wavwpol > ; impl WavwpolR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wavwpol { match self . bits { false => Wavwpol :: Noninverted , true => Wavwpol :: Inverted , } } # [doc = "Выход TIMER16 отражает результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn is_noninverted (& self) -> bool { * self == Wavwpol :: Noninverted } # [doc = "Выход TIMER16 отражает инверсные результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == Wavwpol :: Inverted } } # [doc = "Field `WAVWPOL` writer - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
pub type WavwpolW < 'a , REG > = crate :: BitWriter < 'a , REG , Wavwpol > ; impl < 'a , REG > WavwpolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Выход TIMER16 отражает результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn noninverted (self) -> & 'a mut crate :: W < REG > { self . variant (Wavwpol :: Noninverted) } # [doc = "Выход TIMER16 отражает инверсные результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (Wavwpol :: Inverted) } } # [doc = "Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Preload { # [doc = "0: Регистры обновляются после каждого доступа к записи на шине APB"]
AfterWrite = 0 , # [doc = "1: Регистры обновляются в конце текущего периода TIMER16"]
EndPeriod = 1 , } impl From < Preload > for bool { # [inline (always)]
fn from (variant : Preload) -> Self { variant as u8 != 0 } } # [doc = "Field `PRELOAD` reader - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
pub type PreloadR = crate :: BitReader < Preload > ; impl PreloadR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Preload { match self . bits { false => Preload :: AfterWrite , true => Preload :: EndPeriod , } } # [doc = "Регистры обновляются после каждого доступа к записи на шине APB"]
# [inline (always)]
pub fn is_after_write (& self) -> bool { * self == Preload :: AfterWrite } # [doc = "Регистры обновляются в конце текущего периода TIMER16"]
# [inline (always)]
pub fn is_end_period (& self) -> bool { * self == Preload :: EndPeriod } } # [doc = "Field `PRELOAD` writer - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
pub type PreloadW < 'a , REG > = crate :: BitWriter < 'a , REG , Preload > ; impl < 'a , REG > PreloadW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Регистры обновляются после каждого доступа к записи на шине APB"]
# [inline (always)]
pub fn after_write (self) -> & 'a mut crate :: W < REG > { self . variant (Preload :: AfterWrite) } # [doc = "Регистры обновляются в конце текущего периода TIMER16"]
# [inline (always)]
pub fn end_period (self) -> & 'a mut crate :: W < REG > { self . variant (Preload :: EndPeriod) } } # [doc = "Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CountMode { # [doc = "0: Счетчик инкрементируется после каждого внутреннего тактового импульса"]
Internal = 0 , # [doc = "1: Счетчик увеличивается после каждого действительного тактового импульса на внешнем lnput1 TIMER16"]
External = 1 , } impl From < CountMode > for bool { # [inline (always)]
fn from (variant : CountMode) -> Self { variant as u8 != 0 } } # [doc = "Field `COUNT_MODE` reader - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
pub type CountModeR = crate :: BitReader < CountMode > ; impl CountModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> CountMode { match self . bits { false => CountMode :: Internal , true => CountMode :: External , } } # [doc = "Счетчик инкрементируется после каждого внутреннего тактового импульса"]
# [inline (always)]
pub fn is_internal (& self) -> bool { * self == CountMode :: Internal } # [doc = "Счетчик увеличивается после каждого действительного тактового импульса на внешнем lnput1 TIMER16"]
# [inline (always)]
pub fn is_external (& self) -> bool { * self == CountMode :: External } } # [doc = "Field `COUNT_MODE` writer - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
pub type CountModeW < 'a , REG > = crate :: BitWriter < 'a , REG , CountMode > ; impl < 'a , REG > CountModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Счетчик инкрементируется после каждого внутреннего тактового импульса"]
# [inline (always)]
pub fn internal (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Internal) } # [doc = "Счетчик увеличивается после каждого действительного тактового импульса на внешнем lnput1 TIMER16"]
# [inline (always)]
pub fn external (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: External) } } # [doc = "Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Enc { # [doc = "0: Режим энкодера отключен"]
Disable = 0 , # [doc = "1: Режим энэнкодера включен"]
Enable = 1 , } impl From < Enc > for bool { # [inline (always)]
fn from (variant : Enc) -> Self { variant as u8 != 0 } } # [doc = "Field `ENC` reader - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
pub type EncR = crate :: BitReader < Enc > ; impl EncR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Enc { match self . bits { false => Enc :: Disable , true => Enc :: Enable , } } # [doc = "Режим энкодера отключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Enc :: Disable } # [doc = "Режим энэнкодера включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Enc :: Enable } } # [doc = "Field `ENC` writer - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
pub type EncW < 'a , REG > = crate :: BitWriter < 'a , REG , Enc > ; impl < 'a , REG > EncW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Режим энкодера отключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Enc :: Disable) } # [doc = "Режим энэнкодера включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Enc :: Enable) } } impl R { # [doc = "Bit 0 - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
# [inline (always)]
pub fn cksel (& self) -> CkselR { CkselR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
# [inline (always)]
pub fn ckpol (& self) -> CkpolR { CkpolR :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bits 3:4 - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
# [inline (always)]
pub fn ckflt (& self) -> CkfltR { CkfltR :: new (((self . bits >> 3) & 3) as u8) } # [doc = "Bits 6:7 - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
# [inline (always)]
pub fn trgflt (& self) -> TrgfltR { TrgfltR :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 9:11 - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
# [inline (always)]
pub fn presc (& self) -> PrescR { PrescR :: new (((self . bits >> 9) & 7) as u8) } # [doc = "Bits 13:15 - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
# [inline (always)]
pub fn trigsel (& self) -> TrigselR { TrigselR :: new (((self . bits >> 13) & 7) as u8) } # [doc = "Bits 17:18 - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
# [inline (always)]
pub fn trigen (& self) -> TrigenR { TrigenR :: new (((self . bits >> 17) & 3) as u8) } # [doc = "Bit 19 - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
# [inline (always)]
pub fn timeout (& self) -> TimeoutR { TimeoutR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Форма волны. Бит WAVE управляет формой выходного сигнала"]
# [inline (always)]
pub fn wave (& self) -> WaveR { WaveR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
# [inline (always)]
pub fn wavwpol (& self) -> WavwpolR { WavwpolR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
# [inline (always)]
pub fn preload (& self) -> PreloadR { PreloadR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
# [inline (always)]
pub fn count_mode (& self) -> CountModeR { CountModeR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 24 - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
# [inline (always)]
pub fn enc (& self) -> EncR { EncR :: new (((self . bits >> 24) & 1) != 0) } } impl W { # [doc = "Bit 0 - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
# [inline (always)]
pub fn cksel (& mut self) -> CkselW < CfgrSpec > { CkselW :: new (self , 0) } # [doc = "Bits 1:2 - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
# [inline (always)]
pub fn ckpol (& mut self) -> CkpolW < CfgrSpec > { CkpolW :: new (self , 1) } # [doc = "Bits 3:4 - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
# [inline (always)]
pub fn ckflt (& mut self) -> CkfltW < CfgrSpec > { CkfltW :: new (self , 3) } # [doc = "Bits 6:7 - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
# [inline (always)]
pub fn trgflt (& mut self) -> TrgfltW < CfgrSpec > { TrgfltW :: new (self , 6) } # [doc = "Bits 9:11 - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
# [inline (always)]
pub fn presc (& mut self) -> PrescW < CfgrSpec > { PrescW :: new (self , 9) } # [doc = "Bits 13:15 - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
# [inline (always)]
pub fn trigsel (& mut self) -> TrigselW < CfgrSpec > { TrigselW :: new (self , 13) } # [doc = "Bits 17:18 - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
# [inline (always)]
pub fn trigen (& mut self) -> TrigenW < CfgrSpec > { TrigenW :: new (self , 17) } # [doc = "Bit 19 - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
# [inline (always)]
pub fn timeout (& mut self) -> TimeoutW < CfgrSpec > { TimeoutW :: new (self , 19) } # [doc = "Bit 20 - Форма волны. Бит WAVE управляет формой выходного сигнала"]
# [inline (always)]
pub fn wave (& mut self) -> WaveW < CfgrSpec > { WaveW :: new (self , 20) } # [doc = "Bit 21 - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
# [inline (always)]
pub fn wavwpol (& mut self) -> WavwpolW < CfgrSpec > { WavwpolW :: new (self , 21) } # [doc = "Bit 22 - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
# [inline (always)]
pub fn preload (& mut self) -> PreloadW < CfgrSpec > { PreloadW :: new (self , 22) } # [doc = "Bit 23 - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
# [inline (always)]
pub fn count_mode (& mut self) -> CountModeW < CfgrSpec > { CountModeW :: new (self , 23) } # [doc = "Bit 24 - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
# [inline (always)]
pub fn enc (& mut self) -> EncW < CfgrSpec > { EncW :: new (self , 24) } } # [doc = "Регистр конфигурации\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cfgr::R`](R) reader structure"]
impl crate :: Readable for CfgrSpec { } # [doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"]
impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CFGR to value 0"]
impl crate :: Resettable for CfgrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CR (rw) register accessor: Регистр управления\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`]
module"]
# [doc (alias = "CR")]
pub type Cr = crate :: Reg < cr :: CrSpec > ; # [doc = "Регистр управления"]
pub mod cr { # [doc = "Register `CR` reader"]
pub type R = crate :: R < CrSpec > ; # [doc = "Register `CR` writer"]
pub type W = crate :: W < CrSpec > ; # [doc = "Field `ENABLE` reader - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
pub type EnableR = crate :: BitReader ; # [doc = "Field `ENABLE` writer - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
pub type EnableW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `SNGSTRT` reader - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
pub type SngstrtR = crate :: BitReader ; # [doc = "Field `SNGSTRT` writer - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
pub type SngstrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `CNTSTRT` reader - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
pub type CntstrtR = crate :: BitReader ; # [doc = "Field `CNTSTRT` writer - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
pub type CntstrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
# [inline (always)]
pub fn enable (& self) -> EnableR { EnableR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
# [inline (always)]
pub fn sngstrt (& self) -> SngstrtR { SngstrtR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
# [inline (always)]
pub fn cntstrt (& self) -> CntstrtR { CntstrtR :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
# [inline (always)]
pub fn enable (& mut self) -> EnableW < CrSpec > { EnableW :: new (self , 0) } # [doc = "Bit 1 - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
# [inline (always)]
pub fn sngstrt (& mut self) -> SngstrtW < CrSpec > { SngstrtW :: new (self , 1) } # [doc = "Bit 2 - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
# [inline (always)]
pub fn cntstrt (& mut self) -> CntstrtW < CrSpec > { CntstrtW :: new (self , 2) } } # [doc = "Регистр управления\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr::R`](R) reader structure"]
impl crate :: Readable for CrSpec { } # [doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"]
impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CR to value 0"]
impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CMP (rw) register accessor: Регистр сравнения\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmp`]
module"]
# [doc (alias = "CMP")]
pub type Cmp = crate :: Reg < cmp :: CmpSpec > ; # [doc = "Регистр сравнения"]
pub mod cmp { # [doc = "Register `CMP` reader"]
pub type R = crate :: R < CmpSpec > ; # [doc = "Register `CMP` writer"]
pub type W = crate :: W < CmpSpec > ; # [doc = "Field `CMP` reader - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type CmpR = crate :: FieldReader < u16 > ; # [doc = "Field `CMP` writer - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type CmpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn cmp (& self) -> CmpR { CmpR :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15 - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn cmp (& mut self) -> CmpW < CmpSpec > { CmpW :: new (self , 0) } } # [doc = "Регистр сравнения\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CmpSpec ; impl crate :: RegisterSpec for CmpSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cmp::R`](R) reader structure"]
impl crate :: Readable for CmpSpec { } # [doc = "`write(|w| ..)` method takes [`cmp::W`](W) writer structure"]
impl crate :: Writable for CmpSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CMP to value 0"]
impl crate :: Resettable for CmpSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ARR (rw) register accessor: Регистр автоматической перезагрузки\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`]
module"]
# [doc (alias = "ARR")]
pub type Arr = crate :: Reg < arr :: ArrSpec > ; # [doc = "Регистр автоматической перезагрузки"]
pub mod arr { # [doc = "Register `ARR` reader"]
pub type R = crate :: R < ArrSpec > ; # [doc = "Register `ARR` writer"]
pub type W = crate :: W < ArrSpec > ; # [doc = "Field `ARR` reader - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type ArrR = crate :: FieldReader < u16 > ; # [doc = "Field `ARR` writer - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15 - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn arr (& mut self) -> ArrW < ArrSpec > { ArrW :: new (self , 0) } } # [doc = "Регистр автоматической перезагрузки\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`arr::R`](R) reader structure"]
impl crate :: Readable for ArrSpec { } # [doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"]
impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ARR to value 0"]
impl crate :: Resettable for ArrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CNT (rw) register accessor: Регистр счётчика\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`]
module"]
# [doc (alias = "CNT")]
pub type Cnt = crate :: Reg < cnt :: CntSpec > ; # [doc = "Регистр счётчика"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub type R = crate :: R < CntSpec > ; # [doc = "Register `CNT` writer"]
pub type W = crate :: W < CntSpec > ; # [doc = "Field `CNT` reader - Значение счетчика. Когда TIMER16 работает с асинхронными тактовыми сигналами, чтение регистра CNT мо-жет вернуть недостоверные значения. Поэтому в этом случае необходимо выполнить два последовательных до-ступа на чтение и убедиться, что два возвращенных значения идентичны."]
pub type CntR = crate :: FieldReader < u16 > ; impl R { # [doc = "Bits 0:15 - Значение счетчика. Когда TIMER16 работает с асинхронными тактовыми сигналами, чтение регистра CNT мо-жет вернуть недостоверные значения. Поэтому в этом случае необходимо выполнить два последовательных до-ступа на чтение и убедиться, что два возвращенных значения идентичны."]
# [inline (always)]
pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W { } # [doc = "Регистр счётчика\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cnt::R`](R) reader structure"]
impl crate :: Readable for CntSpec { } # [doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"]
impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CntSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Регистры модуля таймера_2"]
pub struct Timer16_2 { _marker : PhantomData < * const () > } unsafe impl Send for Timer16_2 { } impl Timer16_2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer16_2 :: RegisterBlock = 0x0008_2400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer16_2 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Timer16_2 { type Target = timer16_2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Timer16_2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer16_2") . finish () } } # [doc = "Регистры модуля таймера_2"]
pub mod timer16_2 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { isr : Isr , icr : Icr , ier : Ier , cfgr : Cfgr , cr : Cr , cmp : Cmp , arr : Arr , cnt : Cnt , } impl RegisterBlock { # [doc = "0x00 - Регистр флагов прерываний"]
# [inline (always)]
pub const fn isr (& self) -> & Isr { & self . isr } # [doc = "0x04 - Регистр сброса флагов прерываний"]
# [inline (always)]
pub const fn icr (& self) -> & Icr { & self . icr } # [doc = "0x08 - Регистр разрешения прерываний"]
# [inline (always)]
pub const fn ier (& self) -> & Ier { & self . ier } # [doc = "0x0c - Регистр конфигурации"]
# [inline (always)]
pub const fn cfgr (& self) -> & Cfgr { & self . cfgr } # [doc = "0x10 - Регистр управления"]
# [inline (always)]
pub const fn cr (& self) -> & Cr { & self . cr } # [doc = "0x14 - Регистр сравнения"]
# [inline (always)]
pub const fn cmp (& self) -> & Cmp { & self . cmp } # [doc = "0x18 - Регистр автоматической перезагрузки"]
# [inline (always)]
pub const fn arr (& self) -> & Arr { & self . arr } # [doc = "0x1c - Регистр счётчика"]
# [inline (always)]
pub const fn cnt (& self) -> & Cnt { & self . cnt } } # [doc = "ISR (r) register accessor: Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`]
module"]
# [doc (alias = "ISR")]
pub type Isr = crate :: Reg < isr :: IsrSpec > ; # [doc = "Регистр флагов прерываний"]
pub mod isr { # [doc = "Register `ISR` reader"]
pub type R = crate :: R < IsrSpec > ; # [doc = "Field `CMPM` reader - Совпадение сравнения. Бит CMPM устанавливается аппаратными средствами, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра CMP"]
pub type CmpmR = crate :: BitReader ; # [doc = "Field `ARRM` reader - Cоответствие автозагрузки. ARRM устанавливается аппаратурой, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра ARR."]
pub type ArrmR = crate :: BitReader ; # [doc = "Field `EXTTRIG` reader - Cобытие фронта внешнего триггера. EXTTRIG устанавливается аппаратно, чтобы сообщить приложению, что на выбранном входе внешнего триггера возник достоверный фронт импульса. Если триггер игнорируется, так как таймер уже запущен, то этот флаг не устанавливается"]
pub type ExttrigR = crate :: BitReader ; # [doc = "Field `CMPOK` reader - Обновление регистра сравнения OK. CMPOK устанавливается аппаратными средствами, чтобы сообщить приложению, что операция записи в регистр CMP шины APB успешно завершена."]
pub type CmpokR = crate :: BitReader ; # [doc = "Field `ARROK` reader - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
pub type ArrokR = crate :: BitReader ; # [doc = "Field `UP` reader - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
pub type UpR = crate :: BitReader ; # [doc = "Field `DOWN` reader - Изменение направления счетчика вверх на вниз. В режиме энкодера бит DOWN устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вверх\" на \"вниз\"."]
pub type DownR = crate :: BitReader ; impl R { # [doc = "Bit 0 - Совпадение сравнения. Бит CMPM устанавливается аппаратными средствами, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра CMP"]
# [inline (always)]
pub fn cmpm (& self) -> CmpmR { CmpmR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Cоответствие автозагрузки. ARRM устанавливается аппаратурой, чтобы сообщить приложению, что значение регистра CNT достигло значения регистра ARR."]
# [inline (always)]
pub fn arrm (& self) -> ArrmR { ArrmR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Cобытие фронта внешнего триггера. EXTTRIG устанавливается аппаратно, чтобы сообщить приложению, что на выбранном входе внешнего триггера возник достоверный фронт импульса. Если триггер игнорируется, так как таймер уже запущен, то этот флаг не устанавливается"]
# [inline (always)]
pub fn exttrig (& self) -> ExttrigR { ExttrigR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Обновление регистра сравнения OK. CMPOK устанавливается аппаратными средствами, чтобы сообщить приложению, что операция записи в регистр CMP шины APB успешно завершена."]
# [inline (always)]
pub fn cmpok (& self) -> CmpokR { CmpokR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
# [inline (always)]
pub fn arrok (& self) -> ArrokR { ArrokR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Изменение направления счетчика с вниз на вверх. В режиме энкодера бит UP устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вниз\" на \"вверх\"."]
# [inline (always)]
pub fn up (& self) -> UpR { UpR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Изменение направления счетчика вверх на вниз. В режиме энкодера бит DOWN устанавливается аппаратно, чтобы сообщить приложению, что направление счетчика изменилось с \"вверх\" на \"вниз\"."]
# [inline (always)]
pub fn down (& self) -> DownR { DownR :: new (((self . bits >> 6) & 1) != 0) } } # [doc = "Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`isr::R`](R) reader structure"]
impl crate :: Readable for IsrSpec { } # [doc = "`reset()` method sets ISR to value 0"]
impl crate :: Resettable for IsrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ICR (w) register accessor: Регистр сброса флагов прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`]
module"]
# [doc (alias = "ICR")]
pub type Icr = crate :: Reg < icr :: IcrSpec > ; # [doc = "Регистр сброса флагов прерываний"]
pub mod icr { # [doc = "Register `ICR` writer"]
pub type W = crate :: W < IcrSpec > ; # [doc = "Field `CMPMCF` writer - Запись «1» в этот бит снимает флаг CMPM в регистре LPT_ISR"]
pub type CmpmcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `ARRMCF` writer - Запись «1» в этот бит снимает флаг ARRM в регистре LPT_ISR"]
pub type ArrmcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `EXTTRIGCF` writer - Запись «1» в этот бит снимает флаг EXTTRIG в регистре LPT_ISR"]
pub type ExttrigcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `ARRROCF` writer - Запись «1» в этот бит снимает флаг ARROK в регистре LPT_ISR"]
pub type ArrrocfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `UPCF` writer - Запись «1» в этот бит снимает флаг UP в регистре LPT_ISR"]
pub type UpcfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `DOWNCF` writer - Запись «1» в этот бит снимает флаг DOWN в регистре LPT_ISR"]
pub type DowncfW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; impl W { # [doc = "Bit 0 - Запись «1» в этот бит снимает флаг CMPM в регистре LPT_ISR"]
# [inline (always)]
pub fn cmpmcf (& mut self) -> CmpmcfW < IcrSpec > { CmpmcfW :: new (self , 0) } # [doc = "Bit 1 - Запись «1» в этот бит снимает флаг ARRM в регистре LPT_ISR"]
# [inline (always)]
pub fn arrmcf (& mut self) -> ArrmcfW < IcrSpec > { ArrmcfW :: new (self , 1) } # [doc = "Bit 2 - Запись «1» в этот бит снимает флаг EXTTRIG в регистре LPT_ISR"]
# [inline (always)]
pub fn exttrigcf (& mut self) -> ExttrigcfW < IcrSpec > { ExttrigcfW :: new (self , 2) } # [doc = "Bit 4 - Запись «1» в этот бит снимает флаг ARROK в регистре LPT_ISR"]
# [inline (always)]
pub fn arrrocf (& mut self) -> ArrrocfW < IcrSpec > { ArrrocfW :: new (self , 4) } # [doc = "Bit 5 - Запись «1» в этот бит снимает флаг UP в регистре LPT_ISR"]
# [inline (always)]
pub fn upcf (& mut self) -> UpcfW < IcrSpec > { UpcfW :: new (self , 5) } # [doc = "Bit 6 - Запись «1» в этот бит снимает флаг DOWN в регистре LPT_ISR"]
# [inline (always)]
pub fn downcf (& mut self) -> DowncfW < IcrSpec > { DowncfW :: new (self , 6) } } # [doc = "Регистр сброса флагов прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"]
impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0x77 ; } # [doc = "`reset()` method sets ICR to value 0"]
impl crate :: Resettable for IcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "IER (rw) register accessor: Регистр разрешения прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ier`]
module"]
# [doc (alias = "IER")]
pub type Ier = crate :: Reg < ier :: IerSpec > ; # [doc = "Регистр разрешения прерываний"]
pub mod ier { # [doc = "Register `IER` reader"]
pub type R = crate :: R < IerSpec > ; # [doc = "Register `IER` writer"]
pub type W = crate :: W < IerSpec > ; # [doc = "запрет/разрешение прерывания CMPM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cmpmie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Cmpmie > for bool { # [inline (always)]
fn from (variant : Cmpmie) -> Self { variant as u8 != 0 } } # [doc = "Field `CMPMIE` reader - запрет/разрешение прерывания CMPM"]
pub type CmpmieR = crate :: BitReader < Cmpmie > ; impl CmpmieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cmpmie { match self . bits { false => Cmpmie :: Disable , true => Cmpmie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Cmpmie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cmpmie :: Enable } } # [doc = "Field `CMPMIE` writer - запрет/разрешение прерывания CMPM"]
pub type CmpmieW < 'a , REG > = crate :: BitWriter < 'a , REG , Cmpmie > ; impl < 'a , REG > CmpmieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpmie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpmie :: Enable) } } # [doc = "запрет/разрешение прерывания EXTTRIG\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Exttrigie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Exttrigie > for bool { # [inline (always)]
fn from (variant : Exttrigie) -> Self { variant as u8 != 0 } } # [doc = "Field `EXTTRIGIE` reader - запрет/разрешение прерывания EXTTRIG"]
pub type ExttrigieR = crate :: BitReader < Exttrigie > ; impl ExttrigieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Exttrigie { match self . bits { false => Exttrigie :: Disable , true => Exttrigie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Exttrigie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Exttrigie :: Enable } } # [doc = "Field `EXTTRIGIE` writer - запрет/разрешение прерывания EXTTRIG"]
pub type ExttrigieW < 'a , REG > = crate :: BitWriter < 'a , REG , Exttrigie > ; impl < 'a , REG > ExttrigieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Exttrigie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Exttrigie :: Enable) } } # [doc = "запрет/разрешение прерывания CMPOK\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cmpokie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Cmpokie > for bool { # [inline (always)]
fn from (variant : Cmpokie) -> Self { variant as u8 != 0 } } # [doc = "Field `CMPOKIE` reader - запрет/разрешение прерывания CMPOK"]
pub type CmpokieR = crate :: BitReader < Cmpokie > ; impl CmpokieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cmpokie { match self . bits { false => Cmpokie :: Disable , true => Cmpokie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Cmpokie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Cmpokie :: Enable } } # [doc = "Field `CMPOKIE` writer - запрет/разрешение прерывания CMPOK"]
pub type CmpokieW < 'a , REG > = crate :: BitWriter < 'a , REG , Cmpokie > ; impl < 'a , REG > CmpokieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpokie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Cmpokie :: Enable) } } # [doc = "запрет/разрешение прерывания ARRROK\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Arrokie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Arrokie > for bool { # [inline (always)]
fn from (variant : Arrokie) -> Self { variant as u8 != 0 } } # [doc = "Field `ARROKIE` reader - запрет/разрешение прерывания ARRROK"]
pub type ArrokieR = crate :: BitReader < Arrokie > ; impl ArrokieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Arrokie { match self . bits { false => Arrokie :: Disable , true => Arrokie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Arrokie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Arrokie :: Enable } } # [doc = "Field `ARROKIE` writer - запрет/разрешение прерывания ARRROK"]
pub type ArrokieW < 'a , REG > = crate :: BitWriter < 'a , REG , Arrokie > ; impl < 'a , REG > ArrokieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrokie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrokie :: Enable) } } # [doc = "запрет/разрешение прерывания UP\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Upie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Upie > for bool { # [inline (always)]
fn from (variant : Upie) -> Self { variant as u8 != 0 } } # [doc = "Field `UPIE` reader - запрет/разрешение прерывания UP"]
pub type UpieR = crate :: BitReader < Upie > ; impl UpieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Upie { match self . bits { false => Upie :: Disable , true => Upie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Upie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Upie :: Enable } } # [doc = "Field `UPIE` writer - запрет/разрешение прерывания UP"]
pub type UpieW < 'a , REG > = crate :: BitWriter < 'a , REG , Upie > ; impl < 'a , REG > UpieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Upie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Upie :: Enable) } } # [doc = "запрет/разрешение прерывания ARRM\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Arrmie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Arrmie > for bool { # [inline (always)]
fn from (variant : Arrmie) -> Self { variant as u8 != 0 } } # [doc = "Field `ARRMIE` reader - запрет/разрешение прерывания ARRM"]
pub type ArrmieR = crate :: BitReader < Arrmie > ; impl ArrmieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Arrmie { match self . bits { false => Arrmie :: Disable , true => Arrmie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Arrmie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Arrmie :: Enable } } # [doc = "Field `ARRMIE` writer - запрет/разрешение прерывания ARRM"]
pub type ArrmieW < 'a , REG > = crate :: BitWriter < 'a , REG , Arrmie > ; impl < 'a , REG > ArrmieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrmie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Arrmie :: Enable) } } # [doc = "запрет/разрешение прерывания DOWN\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Downie { # [doc = "0: Прерывание запрешено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Downie > for bool { # [inline (always)]
fn from (variant : Downie) -> Self { variant as u8 != 0 } } # [doc = "Field `DOWNIE` reader - запрет/разрешение прерывания DOWN"]
pub type DownieR = crate :: BitReader < Downie > ; impl DownieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Downie { match self . bits { false => Downie :: Disable , true => Downie :: Enable , } } # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Downie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Downie :: Enable } } # [doc = "Field `DOWNIE` writer - запрет/разрешение прерывания DOWN"]
pub type DownieW < 'a , REG > = crate :: BitWriter < 'a , REG , Downie > ; impl < 'a , REG > DownieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрешено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Downie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Downie :: Enable) } } impl R { # [doc = "Bit 0 - запрет/разрешение прерывания CMPM"]
# [inline (always)]
pub fn cmpmie (& self) -> CmpmieR { CmpmieR :: new ((self . bits & 1) != 0) } # [doc = "Bit 2 - запрет/разрешение прерывания EXTTRIG"]
# [inline (always)]
pub fn exttrigie (& self) -> ExttrigieR { ExttrigieR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - запрет/разрешение прерывания CMPOK"]
# [inline (always)]
pub fn cmpokie (& self) -> CmpokieR { CmpokieR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - запрет/разрешение прерывания ARRROK"]
# [inline (always)]
pub fn arrokie (& self) -> ArrokieR { ArrokieR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - запрет/разрешение прерывания UP"]
# [inline (always)]
pub fn upie (& self) -> UpieR { UpieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 5 - запрет/разрешение прерывания ARRM"]
# [inline (always)]
pub fn arrmie (& self) -> ArrmieR { ArrmieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - запрет/разрешение прерывания DOWN"]
# [inline (always)]
pub fn downie (& self) -> DownieR { DownieR :: new (((self . bits >> 6) & 1) != 0) } } impl W { # [doc = "Bit 0 - запрет/разрешение прерывания CMPM"]
# [inline (always)]
pub fn cmpmie (& mut self) -> CmpmieW < IerSpec > { CmpmieW :: new (self , 0) } # [doc = "Bit 2 - запрет/разрешение прерывания EXTTRIG"]
# [inline (always)]
pub fn exttrigie (& mut self) -> ExttrigieW < IerSpec > { ExttrigieW :: new (self , 2) } # [doc = "Bit 3 - запрет/разрешение прерывания CMPOK"]
# [inline (always)]
pub fn cmpokie (& mut self) -> CmpokieW < IerSpec > { CmpokieW :: new (self , 3) } # [doc = "Bit 4 - запрет/разрешение прерывания ARRROK"]
# [inline (always)]
pub fn arrokie (& mut self) -> ArrokieW < IerSpec > { ArrokieW :: new (self , 4) } # [doc = "Bit 5 - запрет/разрешение прерывания UP"]
# [inline (always)]
pub fn upie (& mut self) -> UpieW < IerSpec > { UpieW :: new (self , 5) } # [doc = "Bit 5 - запрет/разрешение прерывания ARRM"]
# [inline (always)]
pub fn arrmie (& mut self) -> ArrmieW < IerSpec > { ArrmieW :: new (self , 5) } # [doc = "Bit 6 - запрет/разрешение прерывания DOWN"]
# [inline (always)]
pub fn downie (& mut self) -> DownieW < IerSpec > { DownieW :: new (self , 6) } } # [doc = "Регистр разрешения прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`ier::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ier::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IerSpec ; impl crate :: RegisterSpec for IerSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ier::R`](R) reader structure"]
impl crate :: Readable for IerSpec { } # [doc = "`write(|w| ..)` method takes [`ier::W`](W) writer structure"]
impl crate :: Writable for IerSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets IER to value 0"]
impl crate :: Resettable for IerSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CFGR (rw) register accessor: Регистр конфигурации\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cfgr`]
module"]
# [doc (alias = "CFGR")]
pub type Cfgr = crate :: Reg < cfgr :: CfgrSpec > ; # [doc = "Регистр конфигурации"]
pub mod cfgr { # [doc = "Register `CFGR` reader"]
pub type R = crate :: R < CfgrSpec > ; # [doc = "Register `CFGR` writer"]
pub type W = crate :: W < CfgrSpec > ; # [doc = "Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Cksel { # [doc = "0: TIMER16 тактируется внутренним источником тактового сигнала (APB тактовый генератор или любой из встроенных генераторов)"]
Internal = 0 , # [doc = "1: TIMER16 тактируется внешним источником тактового сигнала через внешний lnput1 TIMER16"]
External = 1 , } impl From < Cksel > for bool { # [inline (always)]
fn from (variant : Cksel) -> Self { variant as u8 != 0 } } # [doc = "Field `CKSEL` reader - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
pub type CkselR = crate :: BitReader < Cksel > ; impl CkselR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Cksel { match self . bits { false => Cksel :: Internal , true => Cksel :: External , } } # [doc = "TIMER16 тактируется внутренним источником тактового сигнала (APB тактовый генератор или любой из встроенных генераторов)"]
# [inline (always)]
pub fn is_internal (& self) -> bool { * self == Cksel :: Internal } # [doc = "TIMER16 тактируется внешним источником тактового сигнала через внешний lnput1 TIMER16"]
# [inline (always)]
pub fn is_external (& self) -> bool { * self == Cksel :: External } } # [doc = "Field `CKSEL` writer - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
pub type CkselW < 'a , REG > = crate :: BitWriter < 'a , REG , Cksel > ; impl < 'a , REG > CkselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "TIMER16 тактируется внутренним источником тактового сигнала (APB тактовый генератор или любой из встроенных генераторов)"]
# [inline (always)]
pub fn internal (self) -> & 'a mut crate :: W < REG > { self . variant (Cksel :: Internal) } # [doc = "TIMER16 тактируется внешним источником тактового сигнала через внешний lnput1 TIMER16"]
# [inline (always)]
pub fn external (self) -> & 'a mut crate :: W < REG > { self . variant (Cksel :: External) } } # [doc = "Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Ckpol { # [doc = "0: Нарастающий фронт является активным фронтом, используемым для подсчета"]
Rising = 0 , # [doc = "1: Спадающий фронт является активным фронтом, используемым для подсчета"]
Folling = 1 , # [doc = "2: Оба фронта являются активными фронтами. Когда оба фронта внешнего тактового сигнала считаются активными, TIMER16 должен также тактироваться внутренним источником тактового сигнала с частотой, по крайней мере в четыре раза превышающей частоту внешнего тактового сигнала."]
BothEdge = 2 , } impl From < Ckpol > for u8 { # [inline (always)]
fn from (variant : Ckpol) -> Self { variant as _ } } impl crate :: FieldSpec for Ckpol { type Ux = u8 ; } impl crate :: IsEnum for Ckpol { } # [doc = "Field `CKPOL` reader - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
pub type CkpolR = crate :: FieldReader < Ckpol > ; impl CkpolR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Ckpol > { match self . bits { 0 => Some (Ckpol :: Rising) , 1 => Some (Ckpol :: Folling) , 2 => Some (Ckpol :: BothEdge) , _ => None , } } # [doc = "Нарастающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == Ckpol :: Rising } # [doc = "Спадающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn is_folling (& self) -> bool { * self == Ckpol :: Folling } # [doc = "Оба фронта являются активными фронтами. Когда оба фронта внешнего тактового сигнала считаются активными, TIMER16 должен также тактироваться внутренним источником тактового сигнала с частотой, по крайней мере в четыре раза превышающей частоту внешнего тактового сигнала."]
# [inline (always)]
pub fn is_both_edge (& self) -> bool { * self == Ckpol :: BothEdge } } # [doc = "Field `CKPOL` writer - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
pub type CkpolW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Ckpol > ; impl < 'a , REG > CkpolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нарастающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn rising (self) -> & 'a mut crate :: W < REG > { self . variant (Ckpol :: Rising) } # [doc = "Спадающий фронт является активным фронтом, используемым для подсчета"]
# [inline (always)]
pub fn folling (self) -> & 'a mut crate :: W < REG > { self . variant (Ckpol :: Folling) } # [doc = "Оба фронта являются активными фронтами. Когда оба фронта внешнего тактового сигнала считаются активными, TIMER16 должен также тактироваться внутренним источником тактового сигнала с частотой, по крайней мере в четыре раза превышающей частоту внешнего тактового сигнала."]
# [inline (always)]
pub fn both_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Ckpol :: BothEdge) } } # [doc = "Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Ckflt { # [doc = "0: Любое изменение активного уровня триггера читается действительным триггером"]
Disable = 0 , # [doc = "1: Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
_2clock = 1 , # [doc = "2: Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_4clock = 2 , # [doc = "3: Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_8clock = 3 , } impl From < Ckflt > for u8 { # [inline (always)]
fn from (variant : Ckflt) -> Self { variant as _ } } impl crate :: FieldSpec for Ckflt { type Ux = u8 ; } impl crate :: IsEnum for Ckflt { } # [doc = "Field `CKFLT` reader - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
pub type CkfltR = crate :: FieldReader < Ckflt > ; impl CkfltR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Ckflt { match self . bits { 0 => Ckflt :: Disable , 1 => Ckflt :: _2clock , 2 => Ckflt :: _4clock , 3 => Ckflt :: _8clock , _ => unreachable ! () , } } # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Ckflt :: Disable } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn is_2clock (& self) -> bool { * self == Ckflt :: _2clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_4clock (& self) -> bool { * self == Ckflt :: _4clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_8clock (& self) -> bool { * self == Ckflt :: _8clock } } # [doc = "Field `CKFLT` writer - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
pub type CkfltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Ckflt , crate :: Safe > ; impl < 'a , REG > CkfltW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: Disable) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn _2clock (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: _2clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _4clock (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: _4clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _8clock (self) -> & 'a mut crate :: W < REG > { self . variant (Ckflt :: _8clock) } } # [doc = "Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Trgflt { # [doc = "0: Любое изменение активного уровня триггера читается действительным триггером"]
Disable = 0 , # [doc = "1: Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
_2clock = 1 , # [doc = "2: Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_4clock = 2 , # [doc = "3: Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
_8clock = 3 , } impl From < Trgflt > for u8 { # [inline (always)]
fn from (variant : Trgflt) -> Self { variant as _ } } impl crate :: FieldSpec for Trgflt { type Ux = u8 ; } impl crate :: IsEnum for Trgflt { } # [doc = "Field `TRGFLT` reader - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
pub type TrgfltR = crate :: FieldReader < Trgflt > ; impl TrgfltR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Trgflt { match self . bits { 0 => Trgflt :: Disable , 1 => Trgflt :: _2clock , 2 => Trgflt :: _4clock , 3 => Trgflt :: _8clock , _ => unreachable ! () , } } # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Trgflt :: Disable } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn is_2clock (& self) -> bool { * self == Trgflt :: _2clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_4clock (& self) -> bool { * self == Trgflt :: _4clock } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn is_8clock (& self) -> bool { * self == Trgflt :: _8clock } } # [doc = "Field `TRGFLT` writer - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
pub type TrgfltW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Trgflt , crate :: Safe > ; impl < 'a , REG > TrgfltW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Любое изменение активного уровня триггера читается действительным триггером"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: Disable) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 2 тактовых периодов, прежде чем он будет считаться действительным триггером."]
# [inline (always)]
pub fn _2clock (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: _2clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение как минимум 4 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _4clock (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: _4clock) } # [doc = "Изменение активного уровня триггера должно быть стабильным в течение не менее 8 тактовых периодов, прежде чем он будет считаться действительным триггером"]
# [inline (always)]
pub fn _8clock (self) -> & 'a mut crate :: W < REG > { self . variant (Trgflt :: _8clock) } } # [doc = "Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Presc { # [doc = "0: Делитель 1"]
_1 = 0 , # [doc = "1: Делитель 2"]
_2 = 1 , # [doc = "2: Делитель 4"]
_4 = 2 , # [doc = "3: Делитель 8"]
_8 = 3 , # [doc = "4: Делитель 16"]
_16 = 4 , # [doc = "5: Делитель 32"]
_32 = 5 , # [doc = "6: Делитель 64"]
_64 = 6 , # [doc = "7: Делитель 128"]
_128 = 7 , } impl From < Presc > for u8 { # [inline (always)]
fn from (variant : Presc) -> Self { variant as _ } } impl crate :: FieldSpec for Presc { type Ux = u8 ; } impl crate :: IsEnum for Presc { } # [doc = "Field `PRESC` reader - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
pub type PrescR = crate :: FieldReader < Presc > ; impl PrescR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Presc { match self . bits { 0 => Presc :: _1 , 1 => Presc :: _2 , 2 => Presc :: _4 , 3 => Presc :: _8 , 4 => Presc :: _16 , 5 => Presc :: _32 , 6 => Presc :: _64 , 7 => Presc :: _128 , _ => unreachable ! () , } } # [doc = "Делитель 1"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Presc :: _1 } # [doc = "Делитель 2"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == Presc :: _2 } # [doc = "Делитель 4"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == Presc :: _4 } # [doc = "Делитель 8"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == Presc :: _8 } # [doc = "Делитель 16"]
# [inline (always)]
pub fn is_16 (& self) -> bool { * self == Presc :: _16 } # [doc = "Делитель 32"]
# [inline (always)]
pub fn is_32 (& self) -> bool { * self == Presc :: _32 } # [doc = "Делитель 64"]
# [inline (always)]
pub fn is_64 (& self) -> bool { * self == Presc :: _64 } # [doc = "Делитель 128"]
# [inline (always)]
pub fn is_128 (& self) -> bool { * self == Presc :: _128 } } # [doc = "Field `PRESC` writer - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
pub type PrescW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Presc , crate :: Safe > ; impl < 'a , REG > PrescW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Делитель 1"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _1) } # [doc = "Делитель 2"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _2) } # [doc = "Делитель 4"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _4) } # [doc = "Делитель 8"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _8) } # [doc = "Делитель 16"]
# [inline (always)]
pub fn _16 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _16) } # [doc = "Делитель 32"]
# [inline (always)]
pub fn _32 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _32) } # [doc = "Делитель 64"]
# [inline (always)]
pub fn _64 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _64) } # [doc = "Делитель 128"]
# [inline (always)]
pub fn _128 (self) -> & 'a mut crate :: W < REG > { self . variant (Presc :: _128) } } # [doc = "Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Trigsel { # [doc = "0: Источник триггера GPIO2_3"]
Gpio2_3 = 0 , # [doc = "1: Источник триггера GPIO2_2"]
Gpio2_2 = 1 , # [doc = "2: Источник триггера GPIO2_1"]
Gpio2_1 = 2 , # [doc = "3: Источник триггера GPIO2_0"]
Gpio2_0 = 3 , # [doc = "4: Источник триггера - окончание преобразования термосенсора"]
Tsens = 4 , # [doc = "5: окончание преобразования АЦП"]
Adc = 5 , # [doc = "6: Источник триггера - прерывание RTC"]
RtcIrq = 6 , # [doc = "7: Будильник"]
Alarm = 7 , } impl From < Trigsel > for u8 { # [inline (always)]
fn from (variant : Trigsel) -> Self { variant as _ } } impl crate :: FieldSpec for Trigsel { type Ux = u8 ; } impl crate :: IsEnum for Trigsel { } # [doc = "Field `TRIGSEL` reader - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
pub type TrigselR = crate :: FieldReader < Trigsel > ; impl TrigselR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Trigsel { match self . bits { 0 => Trigsel :: Gpio2_3 , 1 => Trigsel :: Gpio2_2 , 2 => Trigsel :: Gpio2_1 , 3 => Trigsel :: Gpio2_0 , 4 => Trigsel :: Tsens , 5 => Trigsel :: Adc , 6 => Trigsel :: RtcIrq , 7 => Trigsel :: Alarm , _ => unreachable ! () , } } # [doc = "Источник триггера GPIO2_3"]
# [inline (always)]
pub fn is_gpio2_3 (& self) -> bool { * self == Trigsel :: Gpio2_3 } # [doc = "Источник триггера GPIO2_2"]
# [inline (always)]
pub fn is_gpio2_2 (& self) -> bool { * self == Trigsel :: Gpio2_2 } # [doc = "Источник триггера GPIO2_1"]
# [inline (always)]
pub fn is_gpio2_1 (& self) -> bool { * self == Trigsel :: Gpio2_1 } # [doc = "Источник триггера GPIO2_0"]
# [inline (always)]
pub fn is_gpio2_0 (& self) -> bool { * self == Trigsel :: Gpio2_0 } # [doc = "Источник триггера - окончание преобразования термосенсора"]
# [inline (always)]
pub fn is_tsens (& self) -> bool { * self == Trigsel :: Tsens } # [doc = "окончание преобразования АЦП"]
# [inline (always)]
pub fn is_adc (& self) -> bool { * self == Trigsel :: Adc } # [doc = "Источник триггера - прерывание RTC"]
# [inline (always)]
pub fn is_rtc_irq (& self) -> bool { * self == Trigsel :: RtcIrq } # [doc = "Будильник"]
# [inline (always)]
pub fn is_alarm (& self) -> bool { * self == Trigsel :: Alarm } } # [doc = "Field `TRIGSEL` writer - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
pub type TrigselW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Trigsel , crate :: Safe > ; impl < 'a , REG > TrigselW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Источник триггера GPIO2_3"]
# [inline (always)]
pub fn gpio2_3 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio2_3) } # [doc = "Источник триггера GPIO2_2"]
# [inline (always)]
pub fn gpio2_2 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio2_2) } # [doc = "Источник триггера GPIO2_1"]
# [inline (always)]
pub fn gpio2_1 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio2_1) } # [doc = "Источник триггера GPIO2_0"]
# [inline (always)]
pub fn gpio2_0 (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Gpio2_0) } # [doc = "Источник триггера - окончание преобразования термосенсора"]
# [inline (always)]
pub fn tsens (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Tsens) } # [doc = "окончание преобразования АЦП"]
# [inline (always)]
pub fn adc (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Adc) } # [doc = "Источник триггера - прерывание RTC"]
# [inline (always)]
pub fn rtc_irq (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: RtcIrq) } # [doc = "Будильник"]
# [inline (always)]
pub fn alarm (self) -> & 'a mut crate :: W < REG > { self . variant (Trigsel :: Alarm) } } # [doc = "Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Trigen { # [doc = "0: Программный триггер (начало отсчета инициируется программно)"]
Software = 0 , # [doc = "1: Нарастающий фронт является активным фронтом"]
Rising = 1 , # [doc = "2: Падающий фронт является активным фронтом"]
Folling = 2 , # [doc = "3: Оба фронта являются активными фронтами энергопотреблением"]
BothEdge = 3 , } impl From < Trigen > for u8 { # [inline (always)]
fn from (variant : Trigen) -> Self { variant as _ } } impl crate :: FieldSpec for Trigen { type Ux = u8 ; } impl crate :: IsEnum for Trigen { } # [doc = "Field `TRIGEN` reader - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
pub type TrigenR = crate :: FieldReader < Trigen > ; impl TrigenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Trigen { match self . bits { 0 => Trigen :: Software , 1 => Trigen :: Rising , 2 => Trigen :: Folling , 3 => Trigen :: BothEdge , _ => unreachable ! () , } } # [doc = "Программный триггер (начало отсчета инициируется программно)"]
# [inline (always)]
pub fn is_software (& self) -> bool { * self == Trigen :: Software } # [doc = "Нарастающий фронт является активным фронтом"]
# [inline (always)]
pub fn is_rising (& self) -> bool { * self == Trigen :: Rising } # [doc = "Падающий фронт является активным фронтом"]
# [inline (always)]
pub fn is_folling (& self) -> bool { * self == Trigen :: Folling } # [doc = "Оба фронта являются активными фронтами энергопотреблением"]
# [inline (always)]
pub fn is_both_edge (& self) -> bool { * self == Trigen :: BothEdge } } # [doc = "Field `TRIGEN` writer - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
pub type TrigenW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Trigen , crate :: Safe > ; impl < 'a , REG > TrigenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Программный триггер (начало отсчета инициируется программно)"]
# [inline (always)]
pub fn software (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: Software) } # [doc = "Нарастающий фронт является активным фронтом"]
# [inline (always)]
pub fn rising (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: Rising) } # [doc = "Падающий фронт является активным фронтом"]
# [inline (always)]
pub fn folling (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: Folling) } # [doc = "Оба фронта являются активными фронтами энергопотреблением"]
# [inline (always)]
pub fn both_edge (self) -> & 'a mut crate :: W < REG > { self . variant (Trigen :: BothEdge) } } # [doc = "Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Timeout { # [doc = "0: Триггерное событие, поступающее, когда таймер уже запущен, будет проигнорировано"]
TriggerEventIgnor = 0 , # [doc = "1: Триггерное событие, поступающее, когда таймер уже запущен, сбросит и перезапустит счетчик"]
TriggerEventRestart = 1 , } impl From < Timeout > for bool { # [inline (always)]
fn from (variant : Timeout) -> Self { variant as u8 != 0 } } # [doc = "Field `TIMEOUT` reader - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
pub type TimeoutR = crate :: BitReader < Timeout > ; impl TimeoutR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Timeout { match self . bits { false => Timeout :: TriggerEventIgnor , true => Timeout :: TriggerEventRestart , } } # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, будет проигнорировано"]
# [inline (always)]
pub fn is_trigger_event_ignor (& self) -> bool { * self == Timeout :: TriggerEventIgnor } # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, сбросит и перезапустит счетчик"]
# [inline (always)]
pub fn is_trigger_event_restart (& self) -> bool { * self == Timeout :: TriggerEventRestart } } # [doc = "Field `TIMEOUT` writer - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
pub type TimeoutW < 'a , REG > = crate :: BitWriter < 'a , REG , Timeout > ; impl < 'a , REG > TimeoutW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, будет проигнорировано"]
# [inline (always)]
pub fn trigger_event_ignor (self) -> & 'a mut crate :: W < REG > { self . variant (Timeout :: TriggerEventIgnor) } # [doc = "Триггерное событие, поступающее, когда таймер уже запущен, сбросит и перезапустит счетчик"]
# [inline (always)]
pub fn trigger_event_restart (self) -> & 'a mut crate :: W < REG > { self . variant (Timeout :: TriggerEventRestart) } } # [doc = "Форма волны. Бит WAVE управляет формой выходного сигнала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wave { # [doc = "0: Деактивировать режим Set-once, форма волны ШИМ (PWM) / один импульс (One shot)"]
PwmOrOneShot = 0 , # [doc = "1: Активировать режим Set-once"]
SetOnce = 1 , } impl From < Wave > for bool { # [inline (always)]
fn from (variant : Wave) -> Self { variant as u8 != 0 } } # [doc = "Field `WAVE` reader - Форма волны. Бит WAVE управляет формой выходного сигнала"]
pub type WaveR = crate :: BitReader < Wave > ; impl WaveR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wave { match self . bits { false => Wave :: PwmOrOneShot , true => Wave :: SetOnce , } } # [doc = "Деактивировать режим Set-once, форма волны ШИМ (PWM) / один импульс (One shot)"]
# [inline (always)]
pub fn is_pwm_or_one_shot (& self) -> bool { * self == Wave :: PwmOrOneShot } # [doc = "Активировать режим Set-once"]
# [inline (always)]
pub fn is_set_once (& self) -> bool { * self == Wave :: SetOnce } } # [doc = "Field `WAVE` writer - Форма волны. Бит WAVE управляет формой выходного сигнала"]
pub type WaveW < 'a , REG > = crate :: BitWriter < 'a , REG , Wave > ; impl < 'a , REG > WaveW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Деактивировать режим Set-once, форма волны ШИМ (PWM) / один импульс (One shot)"]
# [inline (always)]
pub fn pwm_or_one_shot (self) -> & 'a mut crate :: W < REG > { self . variant (Wave :: PwmOrOneShot) } # [doc = "Активировать режим Set-once"]
# [inline (always)]
pub fn set_once (self) -> & 'a mut crate :: W < REG > { self . variant (Wave :: SetOnce) } } # [doc = "Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Wavwpol { # [doc = "0: Выход TIMER16 отражает результаты сравнения между регистрами ARR и CMP"]
Noninverted = 0 , # [doc = "1: Выход TIMER16 отражает инверсные результаты сравнения между регистрами ARR и CMP"]
Inverted = 1 , } impl From < Wavwpol > for bool { # [inline (always)]
fn from (variant : Wavwpol) -> Self { variant as u8 != 0 } } # [doc = "Field `WAVWPOL` reader - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
pub type WavwpolR = crate :: BitReader < Wavwpol > ; impl WavwpolR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Wavwpol { match self . bits { false => Wavwpol :: Noninverted , true => Wavwpol :: Inverted , } } # [doc = "Выход TIMER16 отражает результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn is_noninverted (& self) -> bool { * self == Wavwpol :: Noninverted } # [doc = "Выход TIMER16 отражает инверсные результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == Wavwpol :: Inverted } } # [doc = "Field `WAVWPOL` writer - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
pub type WavwpolW < 'a , REG > = crate :: BitWriter < 'a , REG , Wavwpol > ; impl < 'a , REG > WavwpolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Выход TIMER16 отражает результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn noninverted (self) -> & 'a mut crate :: W < REG > { self . variant (Wavwpol :: Noninverted) } # [doc = "Выход TIMER16 отражает инверсные результаты сравнения между регистрами ARR и CMP"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (Wavwpol :: Inverted) } } # [doc = "Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Preload { # [doc = "0: Регистры обновляются после каждого доступа к записи на шине APB"]
AfterWrite = 0 , # [doc = "1: Регистры обновляются в конце текущего периода TIMER16"]
EndPeriod = 1 , } impl From < Preload > for bool { # [inline (always)]
fn from (variant : Preload) -> Self { variant as u8 != 0 } } # [doc = "Field `PRELOAD` reader - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
pub type PreloadR = crate :: BitReader < Preload > ; impl PreloadR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Preload { match self . bits { false => Preload :: AfterWrite , true => Preload :: EndPeriod , } } # [doc = "Регистры обновляются после каждого доступа к записи на шине APB"]
# [inline (always)]
pub fn is_after_write (& self) -> bool { * self == Preload :: AfterWrite } # [doc = "Регистры обновляются в конце текущего периода TIMER16"]
# [inline (always)]
pub fn is_end_period (& self) -> bool { * self == Preload :: EndPeriod } } # [doc = "Field `PRELOAD` writer - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
pub type PreloadW < 'a , REG > = crate :: BitWriter < 'a , REG , Preload > ; impl < 'a , REG > PreloadW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Регистры обновляются после каждого доступа к записи на шине APB"]
# [inline (always)]
pub fn after_write (self) -> & 'a mut crate :: W < REG > { self . variant (Preload :: AfterWrite) } # [doc = "Регистры обновляются в конце текущего периода TIMER16"]
# [inline (always)]
pub fn end_period (self) -> & 'a mut crate :: W < REG > { self . variant (Preload :: EndPeriod) } } # [doc = "Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum CountMode { # [doc = "0: Счетчик инкрементируется после каждого внутреннего тактового импульса"]
Internal = 0 , # [doc = "1: Счетчик увеличивается после каждого действительного тактового импульса на внешнем lnput1 TIMER16"]
External = 1 , } impl From < CountMode > for bool { # [inline (always)]
fn from (variant : CountMode) -> Self { variant as u8 != 0 } } # [doc = "Field `COUNT_MODE` reader - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
pub type CountModeR = crate :: BitReader < CountMode > ; impl CountModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> CountMode { match self . bits { false => CountMode :: Internal , true => CountMode :: External , } } # [doc = "Счетчик инкрементируется после каждого внутреннего тактового импульса"]
# [inline (always)]
pub fn is_internal (& self) -> bool { * self == CountMode :: Internal } # [doc = "Счетчик увеличивается после каждого действительного тактового импульса на внешнем lnput1 TIMER16"]
# [inline (always)]
pub fn is_external (& self) -> bool { * self == CountMode :: External } } # [doc = "Field `COUNT_MODE` writer - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
pub type CountModeW < 'a , REG > = crate :: BitWriter < 'a , REG , CountMode > ; impl < 'a , REG > CountModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Счетчик инкрементируется после каждого внутреннего тактового импульса"]
# [inline (always)]
pub fn internal (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Internal) } # [doc = "Счетчик увеличивается после каждого действительного тактового импульса на внешнем lnput1 TIMER16"]
# [inline (always)]
pub fn external (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: External) } } # [doc = "Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Enc { # [doc = "0: Режим энкодера отключен"]
Disable = 0 , # [doc = "1: Режим энэнкодера включен"]
Enable = 1 , } impl From < Enc > for bool { # [inline (always)]
fn from (variant : Enc) -> Self { variant as u8 != 0 } } # [doc = "Field `ENC` reader - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
pub type EncR = crate :: BitReader < Enc > ; impl EncR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Enc { match self . bits { false => Enc :: Disable , true => Enc :: Enable , } } # [doc = "Режим энкодера отключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Enc :: Disable } # [doc = "Режим энэнкодера включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Enc :: Enable } } # [doc = "Field `ENC` writer - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
pub type EncW < 'a , REG > = crate :: BitWriter < 'a , REG , Enc > ; impl < 'a , REG > EncW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Режим энкодера отключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Enc :: Disable) } # [doc = "Режим энэнкодера включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Enc :: Enable) } } impl R { # [doc = "Bit 0 - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
# [inline (always)]
pub fn cksel (& self) -> CkselR { CkselR :: new ((self . bits & 1) != 0) } # [doc = "Bits 1:2 - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
# [inline (always)]
pub fn ckpol (& self) -> CkpolR { CkpolR :: new (((self . bits >> 1) & 3) as u8) } # [doc = "Bits 3:4 - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
# [inline (always)]
pub fn ckflt (& self) -> CkfltR { CkfltR :: new (((self . bits >> 3) & 3) as u8) } # [doc = "Bits 6:7 - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
# [inline (always)]
pub fn trgflt (& self) -> TrgfltR { TrgfltR :: new (((self . bits >> 6) & 3) as u8) } # [doc = "Bits 9:11 - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
# [inline (always)]
pub fn presc (& self) -> PrescR { PrescR :: new (((self . bits >> 9) & 7) as u8) } # [doc = "Bits 13:15 - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
# [inline (always)]
pub fn trigsel (& self) -> TrigselR { TrigselR :: new (((self . bits >> 13) & 7) as u8) } # [doc = "Bits 17:18 - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
# [inline (always)]
pub fn trigen (& self) -> TrigenR { TrigenR :: new (((self . bits >> 17) & 3) as u8) } # [doc = "Bit 19 - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
# [inline (always)]
pub fn timeout (& self) -> TimeoutR { TimeoutR :: new (((self . bits >> 19) & 1) != 0) } # [doc = "Bit 20 - Форма волны. Бит WAVE управляет формой выходного сигнала"]
# [inline (always)]
pub fn wave (& self) -> WaveR { WaveR :: new (((self . bits >> 20) & 1) != 0) } # [doc = "Bit 21 - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
# [inline (always)]
pub fn wavwpol (& self) -> WavwpolR { WavwpolR :: new (((self . bits >> 21) & 1) != 0) } # [doc = "Bit 22 - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
# [inline (always)]
pub fn preload (& self) -> PreloadR { PreloadR :: new (((self . bits >> 22) & 1) != 0) } # [doc = "Bit 23 - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
# [inline (always)]
pub fn count_mode (& self) -> CountModeR { CountModeR :: new (((self . bits >> 23) & 1) != 0) } # [doc = "Bit 24 - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
# [inline (always)]
pub fn enc (& self) -> EncR { EncR :: new (((self . bits >> 24) & 1) != 0) } } impl W { # [doc = "Bit 0 - Селектор тактовых импульсов. Бит CKSEL выбирает, какой источник тактовых импульсов будет использо-вать TIMER16"]
# [inline (always)]
pub fn cksel (& mut self) -> CkselW < CfgrSpec > { CkselW :: new (self , 0) } # [doc = "Bits 1:2 - Полярность синхронизации. Когда TIMER16 тактируется внешним ис-точником тактового сигнала, биты CKPOL используются для настройки активного фронта или фронтов, ис-пользуемых счетчиком"]
# [inline (always)]
pub fn ckpol (& mut self) -> CkpolW < CfgrSpec > { CkpolW :: new (self , 1) } # [doc = "Bits 3:4 - Конфигурируемый цифровой фильтр для внешнего тактового генератора. Значение CKFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня внешнего тактового сигнала, прежде чем это будет считаться действительным переходом уровня. Для ис-пользования этой функции необходимо наличие внутреннего источника тактового сигнала."]
# [inline (always)]
pub fn ckflt (& mut self) -> CkfltW < CfgrSpec > { CkfltW :: new (self , 3) } # [doc = "Bits 6:7 - Конфигурируемый цифровой фильтр для триггера. Значение TRGFLT устанавливает количество последовательных одинаковых выборок, которые должны быть обнаружены при изменении уровня на внутреннем триггере, прежде чем это будет считаться действительным переходом уровня. Для использования этой функции необходимо наличие источника внутреннего тактового сигнала."]
# [inline (always)]
pub fn trgflt (& mut self) -> TrgfltW < CfgrSpec > { TrgfltW :: new (self , 6) } # [doc = "Bits 9:11 - Делитель частоты. Биты PRESC задают коэффициент деления делителя. /n"]
# [inline (always)]
pub fn presc (& mut self) -> PrescW < CfgrSpec > { PrescW :: new (self , 9) } # [doc = "Bits 13:15 - Селектор триггера. Биты TRIGSEL выбирают источник триггера, который будет служить событием запуска для TIMER16, из 8 доступных источников."]
# [inline (always)]
pub fn trigsel (& mut self) -> TrigselW < CfgrSpec > { TrigselW :: new (self , 13) } # [doc = "Bits 17:18 - Разрешение и полярность триггера.Бит TRIGEN управляет тем, запускается ли счетчик TIMER16 внешним триггером или нет. Если выбрана опция внешнего запуска, возможны три конфигурации активного фронта триггера"]
# [inline (always)]
pub fn trigen (& mut self) -> TrigenW < CfgrSpec > { TrigenW :: new (self , 17) } # [doc = "Bit 19 - Разрешение тайм-аута. Бит TIMOUT управляет функцией тайм-аута"]
# [inline (always)]
pub fn timeout (& mut self) -> TimeoutW < CfgrSpec > { TimeoutW :: new (self , 19) } # [doc = "Bit 20 - Форма волны. Бит WAVE управляет формой выходного сигнала"]
# [inline (always)]
pub fn wave (& mut self) -> WaveW < CfgrSpec > { WaveW :: new (self , 20) } # [doc = "Bit 21 - Полярность формы волны. Бит WAVEPOL управляет полярностью выходного сигнала"]
# [inline (always)]
pub fn wavwpol (& mut self) -> WavwpolW < CfgrSpec > { WavwpolW :: new (self , 21) } # [doc = "Bit 22 - Режим обновления регистров. Бит PRELOAD управляет модальностью обновления регистров ARR и CMP"]
# [inline (always)]
pub fn preload (& mut self) -> PreloadW < CfgrSpec > { PreloadW :: new (self , 22) } # [doc = "Bit 23 - Бит COUNTMODE выбирает, какой источник тактового сигнала используется TIMER16 для синхронизации счетчика"]
# [inline (always)]
pub fn count_mode (& mut self) -> CountModeW < CfgrSpec > { CountModeW :: new (self , 23) } # [doc = "Bit 24 - Разрешение режима энкодера. Бит ENC управляет режимом работы энкодера"]
# [inline (always)]
pub fn enc (& mut self) -> EncW < CfgrSpec > { EncW :: new (self , 24) } } # [doc = "Регистр конфигурации\n\nYou can [`read`](crate::Reg::read) this register and get [`cfgr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cfgr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CfgrSpec ; impl crate :: RegisterSpec for CfgrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cfgr::R`](R) reader structure"]
impl crate :: Readable for CfgrSpec { } # [doc = "`write(|w| ..)` method takes [`cfgr::W`](W) writer structure"]
impl crate :: Writable for CfgrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CFGR to value 0"]
impl crate :: Resettable for CfgrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CR (rw) register accessor: Регистр управления\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr`]
module"]
# [doc (alias = "CR")]
pub type Cr = crate :: Reg < cr :: CrSpec > ; # [doc = "Регистр управления"]
pub mod cr { # [doc = "Register `CR` reader"]
pub type R = crate :: R < CrSpec > ; # [doc = "Register `CR` writer"]
pub type W = crate :: W < CrSpec > ; # [doc = "Field `ENABLE` reader - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
pub type EnableR = crate :: BitReader ; # [doc = "Field `ENABLE` writer - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
pub type EnableW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `SNGSTRT` reader - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
pub type SngstrtR = crate :: BitReader ; # [doc = "Field `SNGSTRT` writer - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
pub type SngstrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `CNTSTRT` reader - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
pub type CntstrtR = crate :: BitReader ; # [doc = "Field `CNTSTRT` writer - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
pub type CntstrtW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
# [inline (always)]
pub fn enable (& self) -> EnableR { EnableR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
# [inline (always)]
pub fn sngstrt (& self) -> SngstrtR { SngstrtR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
# [inline (always)]
pub fn cntstrt (& self) -> CntstrtR { CntstrtR :: new (((self . bits >> 2) & 1) != 0) } } impl W { # [doc = "Bit 0 - Разрешение TIMER16. Бит ENABLE устанавливается и очищается программно"]
# [inline (always)]
pub fn enable (& mut self) -> EnableW < CrSpec > { EnableW :: new (self , 0) } # [doc = "Bit 1 - Запуск TIMER16 в одиночном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в режиме одиночного импульса. Если про-граммный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), уста-новка этого бита запускает TIMER16 в режиме одиночного импульса, как только обнаруживается внешний триг-гер. Если этот бит установлен, когда TIMER16 находится в режиме непре-рывного счета, то TIMER16 остано-вится при следующем совпадении ре-гистров ARR и CNT. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппа-ратными средствами."]
# [inline (always)]
pub fn sngstrt (& mut self) -> SngstrtW < CrSpec > { SngstrtW :: new (self , 1) } # [doc = "Bit 2 - Запуск таймера в непрерывном режиме Этот бит устанавливается программно и очищается аппаратно. В случае программного запуска (TRIGEN\\[1:0\\]
= '00'), установка этого бита запускает TIMER16 в непрерывном режиме. Если программный запуск отключен (TRIGEN\\[1:0\\]
отличен от '00'), установка этого бита запускает таймер в непрерывном режиме, как только будет обнаружен внешний триггер. Если этот бит установлен, когда идет счет в режиме одиночного импульса, то таймер не остановится при очередном совпадении регистров ARR и CNT, и счетчик TIMER16 продолжит счет в непрерывном режиме. Этот бит может быть установлен только при включенном TIMER16. Он будет автоматически сброшен аппаратными средствами."]
# [inline (always)]
pub fn cntstrt (& mut self) -> CntstrtW < CrSpec > { CntstrtW :: new (self , 2) } } # [doc = "Регистр управления\n\nYou can [`read`](crate::Reg::read) this register and get [`cr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CrSpec ; impl crate :: RegisterSpec for CrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr::R`](R) reader structure"]
impl crate :: Readable for CrSpec { } # [doc = "`write(|w| ..)` method takes [`cr::W`](W) writer structure"]
impl crate :: Writable for CrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CR to value 0"]
impl crate :: Resettable for CrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CMP (rw) register accessor: Регистр сравнения\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cmp`]
module"]
# [doc (alias = "CMP")]
pub type Cmp = crate :: Reg < cmp :: CmpSpec > ; # [doc = "Регистр сравнения"]
pub mod cmp { # [doc = "Register `CMP` reader"]
pub type R = crate :: R < CmpSpec > ; # [doc = "Register `CMP` writer"]
pub type W = crate :: W < CmpSpec > ; # [doc = "Field `CMP` reader - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type CmpR = crate :: FieldReader < u16 > ; # [doc = "Field `CMP` writer - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type CmpW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn cmp (& self) -> CmpR { CmpR :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15 - Сравниваемое значение. CMP - это значение сравнения, используемое TIMER16. Примечание: Регистр CMP может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn cmp (& mut self) -> CmpW < CmpSpec > { CmpW :: new (self , 0) } } # [doc = "Регистр сравнения\n\nYou can [`read`](crate::Reg::read) this register and get [`cmp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cmp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CmpSpec ; impl crate :: RegisterSpec for CmpSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cmp::R`](R) reader structure"]
impl crate :: Readable for CmpSpec { } # [doc = "`write(|w| ..)` method takes [`cmp::W`](W) writer structure"]
impl crate :: Writable for CmpSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CMP to value 0"]
impl crate :: Resettable for CmpSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ARR (rw) register accessor: Регистр автоматической перезагрузки\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@arr`]
module"]
# [doc (alias = "ARR")]
pub type Arr = crate :: Reg < arr :: ArrSpec > ; # [doc = "Регистр автоматической перезагрузки"]
pub mod arr { # [doc = "Register `ARR` reader"]
pub type R = crate :: R < ArrSpec > ; # [doc = "Register `ARR` writer"]
pub type W = crate :: W < ArrSpec > ; # [doc = "Field `ARR` reader - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type ArrR = crate :: FieldReader < u16 > ; # [doc = "Field `ARR` writer - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
pub type ArrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn arr (& self) -> ArrR { ArrR :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15 - Значение автоматической перезагрузки ARR - значение автозагрузки для TIMER16. Это значение должно быть строго больше, чем значение CMP\\[15:0\\]. Примечание: Регистр ARR может быть изменен только тогда, когда TIMER16 включен (бит ENABLE установлен в '1')."]
# [inline (always)]
pub fn arr (& mut self) -> ArrW < ArrSpec > { ArrW :: new (self , 0) } } # [doc = "Регистр автоматической перезагрузки\n\nYou can [`read`](crate::Reg::read) this register and get [`arr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`arr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ArrSpec ; impl crate :: RegisterSpec for ArrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`arr::R`](R) reader structure"]
impl crate :: Readable for ArrSpec { } # [doc = "`write(|w| ..)` method takes [`arr::W`](W) writer structure"]
impl crate :: Writable for ArrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ARR to value 0"]
impl crate :: Resettable for ArrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CNT (rw) register accessor: Регистр счётчика\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cnt`]
module"]
# [doc (alias = "CNT")]
pub type Cnt = crate :: Reg < cnt :: CntSpec > ; # [doc = "Регистр счётчика"]
pub mod cnt { # [doc = "Register `CNT` reader"]
pub type R = crate :: R < CntSpec > ; # [doc = "Register `CNT` writer"]
pub type W = crate :: W < CntSpec > ; # [doc = "Field `CNT` reader - Значение счетчика. Когда TIMER16 работает с асинхронными тактовыми сигналами, чтение регистра CNT мо-жет вернуть недостоверные значения. Поэтому в этом случае необходимо выполнить два последовательных до-ступа на чтение и убедиться, что два возвращенных значения идентичны."]
pub type CntR = crate :: FieldReader < u16 > ; impl R { # [doc = "Bits 0:15 - Значение счетчика. Когда TIMER16 работает с асинхронными тактовыми сигналами, чтение регистра CNT мо-жет вернуть недостоверные значения. Поэтому в этом случае необходимо выполнить два последовательных до-ступа на чтение и убедиться, что два возвращенных значения идентичны."]
# [inline (always)]
pub fn cnt (& self) -> CntR { CntR :: new ((self . bits & 0xffff) as u16) } } impl W { } # [doc = "Регистр счётчика\n\nYou can [`read`](crate::Reg::read) this register and get [`cnt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cnt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct CntSpec ; impl crate :: RegisterSpec for CntSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`cnt::R`](R) reader structure"]
impl crate :: Readable for CntSpec { } # [doc = "`write(|w| ..)` method takes [`cnt::W`](W) writer structure"]
impl crate :: Writable for CntSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CNT to value 0"]
impl crate :: Resettable for CntSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "регистры модуля таймера_1"]
pub struct Timer32_1 { _marker : PhantomData < * const () > } unsafe impl Send for Timer32_1 { } impl Timer32_1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer32_1 :: RegisterBlock = 0x0008_2800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer32_1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Timer32_1 { type Target = timer32_1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Timer32_1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer32_1") . finish () } } # [doc = "регистры модуля таймера_1"]
pub mod timer32_1 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { value : Value , top : Top , prescale : Prescale , control : Control , enable : Enable , int_mask : IntMask , int_clear : IntClear , int_flag : IntFlag , _reserved8 : [u8 ; 0x60]
, ch1_cntr : Ch1Cntr , ch1_ocr : Ch1Ocr , ch1_icr : Ch1Icr , _reserved11 : [u8 ; 0x04]
, ch2_cntr : Ch2Cntr , ch2_ocr : Ch2Ocr , ch2_icr : Ch2Icr , _reserved14 : [u8 ; 0x04]
, ch3_cntr : Ch3Cntr , ch3_ocr : Ch3Ocr , ch3_icr : Ch3Icr , _reserved17 : [u8 ; 0x04]
, ch4_cntr : Ch4Cntr , ch4_ocr : Ch4Ocr , ch4_icr : Ch4Icr , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn value (& self) -> & Value { & self . value } # [doc = "0x04 - максимальное значение счетной последовательности"]
# [inline (always)]
pub const fn top (& self) -> & Top { & self . top } # [doc = "0x08 - значение делителя"]
# [inline (always)]
pub const fn prescale (& self) -> & Prescale { & self . prescale } # [doc = "0x0c - Конфигурационный регистр основного таймера"]
# [inline (always)]
pub const fn control (& self) -> & Control { & self . control } # [doc = "0x10 - Регистр включения таймера"]
# [inline (always)]
pub const fn enable (& self) -> & Enable { & self . enable } # [doc = "0x14 - Регистр маски прерываний"]
# [inline (always)]
pub const fn int_mask (& self) -> & IntMask { & self . int_mask } # [doc = "0x18 - Регистр сброса флагов прерываний"]
# [inline (always)]
pub const fn int_clear (& self) -> & IntClear { & self . int_clear } # [doc = "0x1c - Регистр флагов прерываний"]
# [inline (always)]
pub const fn int_flag (& self) -> & IntFlag { & self . int_flag } # [doc = "0x80 - Конфигурационный регистр 1 канала"]
# [inline (always)]
pub const fn ch1_cntr (& self) -> & Ch1Cntr { & self . ch1_cntr } # [doc = "0x84 - Значение сравнения 1 канала"]
# [inline (always)]
pub const fn ch1_ocr (& self) -> & Ch1Ocr { & self . ch1_ocr } # [doc = "0x88 - Значение захвата 1 канала"]
# [inline (always)]
pub const fn ch1_icr (& self) -> & Ch1Icr { & self . ch1_icr } # [doc = "0x90 - Конфигурационный регистр 2 канала"]
# [inline (always)]
pub const fn ch2_cntr (& self) -> & Ch2Cntr { & self . ch2_cntr } # [doc = "0x94 - Значение сравнения 2 канала"]
# [inline (always)]
pub const fn ch2_ocr (& self) -> & Ch2Ocr { & self . ch2_ocr } # [doc = "0x98 - Значение захвата 2 канала"]
# [inline (always)]
pub const fn ch2_icr (& self) -> & Ch2Icr { & self . ch2_icr } # [doc = "0xa0 - Конфигурационный регистр 3 канала"]
# [inline (always)]
pub const fn ch3_cntr (& self) -> & Ch3Cntr { & self . ch3_cntr } # [doc = "0xa4 - Значение сравнения 3 канала"]
# [inline (always)]
pub const fn ch3_ocr (& self) -> & Ch3Ocr { & self . ch3_ocr } # [doc = "0xa8 - Значение захвата 3 канала"]
# [inline (always)]
pub const fn ch3_icr (& self) -> & Ch3Icr { & self . ch3_icr } # [doc = "0xb0 - Конфигурационный регистр 4 канала"]
# [inline (always)]
pub const fn ch4_cntr (& self) -> & Ch4Cntr { & self . ch4_cntr } # [doc = "0xb4 - Значение сравнения 4 канала"]
# [inline (always)]
pub const fn ch4_ocr (& self) -> & Ch4Ocr { & self . ch4_ocr } # [doc = "0xb8 - Значение захвата 4 канала"]
# [inline (always)]
pub const fn ch4_icr (& self) -> & Ch4Icr { & self . ch4_icr } } # [doc = "VALUE (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`value::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`value::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@value`]
module"]
# [doc (alias = "VALUE")]
pub type Value = crate :: Reg < value :: ValueSpec > ; # [doc = ""]
pub mod value { # [doc = "Register `VALUE` reader"]
pub type R = crate :: R < ValueSpec > ; # [doc = "Register `VALUE` writer"]
pub type W = crate :: W < ValueSpec > ; # [doc = "Field `TIM_VAL` reader - текущее значение счетчика"]
pub type TimValR = crate :: FieldReader < u32 > ; impl R { # [doc = "Bits 0:31 - текущее значение счетчика"]
# [inline (always)]
pub fn tim_val (& self) -> TimValR { TimValR :: new (self . bits) } } impl W { } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`value::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`value::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ValueSpec ; impl crate :: RegisterSpec for ValueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`value::R`](R) reader structure"]
impl crate :: Readable for ValueSpec { } # [doc = "`write(|w| ..)` method takes [`value::W`](W) writer structure"]
impl crate :: Writable for ValueSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets VALUE to value 0"]
impl crate :: Resettable for ValueSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TOP (rw) register accessor: максимальное значение счетной последовательности\n\nYou can [`read`](crate::Reg::read) this register and get [`top::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`top::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@top`]
module"]
# [doc (alias = "TOP")]
pub type Top = crate :: Reg < top :: TopSpec > ; # [doc = "максимальное значение счетной последовательности"]
pub mod top { # [doc = "Register `TOP` reader"]
pub type R = crate :: R < TopSpec > ; # [doc = "Register `TOP` writer"]
pub type W = crate :: W < TopSpec > ; # [doc = "Field `TIM_TOP` reader - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
pub type TimTopR = crate :: FieldReader < u32 > ; # [doc = "Field `TIM_TOP` writer - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
pub type TimTopW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
# [inline (always)]
pub fn tim_top (& self) -> TimTopR { TimTopR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
# [inline (always)]
pub fn tim_top (& mut self) -> TimTopW < TopSpec > { TimTopW :: new (self , 0) } } # [doc = "максимальное значение счетной последовательности\n\nYou can [`read`](crate::Reg::read) this register and get [`top::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`top::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TopSpec ; impl crate :: RegisterSpec for TopSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`top::R`](R) reader structure"]
impl crate :: Readable for TopSpec { } # [doc = "`write(|w| ..)` method takes [`top::W`](W) writer structure"]
impl crate :: Writable for TopSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TOP to value 0xffff_ffff"]
impl crate :: Resettable for TopSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } } # [doc = "PRESCALE (rw) register accessor: значение делителя\n\nYou can [`read`](crate::Reg::read) this register and get [`prescale::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prescale::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@prescale`]
module"]
# [doc (alias = "PRESCALE")]
pub type Prescale = crate :: Reg < prescale :: PrescaleSpec > ; # [doc = "значение делителя"]
pub mod prescale { # [doc = "Register `PRESCALE` reader"]
pub type R = crate :: R < PrescaleSpec > ; # [doc = "Register `PRESCALE` writer"]
pub type W = crate :: W < PrescaleSpec > ; # [doc = "Field `TIM_PRESCALE` reader - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
pub type TimPrescaleR = crate :: FieldReader < u32 > ; # [doc = "Field `TIM_PRESCALE` writer - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
pub type TimPrescaleW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
# [inline (always)]
pub fn tim_prescale (& self) -> TimPrescaleR { TimPrescaleR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
# [inline (always)]
pub fn tim_prescale (& mut self) -> TimPrescaleW < PrescaleSpec > { TimPrescaleW :: new (self , 0) } } # [doc = "значение делителя\n\nYou can [`read`](crate::Reg::read) this register and get [`prescale::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prescale::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct PrescaleSpec ; impl crate :: RegisterSpec for PrescaleSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`prescale::R`](R) reader structure"]
impl crate :: Readable for PrescaleSpec { } # [doc = "`write(|w| ..)` method takes [`prescale::W`](W) writer structure"]
impl crate :: Writable for PrescaleSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PRESCALE to value 0"]
impl crate :: Resettable for PrescaleSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONTROL (rw) register accessor: Конфигурационный регистр основного таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control`]
module"]
# [doc (alias = "CONTROL")]
pub type Control = crate :: Reg < control :: ControlSpec > ; # [doc = "Конфигурационный регистр основного таймера"]
pub mod control { # [doc = "Register `CONTROL` reader"]
pub type R = crate :: R < ControlSpec > ; # [doc = "Register `CONTROL` writer"]
pub type W = crate :: W < ControlSpec > ; # [doc = "Режим счёта таймера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CountMode { # [doc = "0: Прямой режим"]
Direct = 0 , # [doc = "1: Обратный режим"]
Reverse = 1 , # [doc = "2: Двунаправленный режим"]
Bidirectional = 2 , } impl From < CountMode > for u8 { # [inline (always)]
fn from (variant : CountMode) -> Self { variant as _ } } impl crate :: FieldSpec for CountMode { type Ux = u8 ; } impl crate :: IsEnum for CountMode { } # [doc = "Field `COUNT_MODE` reader - Режим счёта таймера"]
pub type CountModeR = crate :: FieldReader < CountMode > ; impl CountModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < CountMode > { match self . bits { 0 => Some (CountMode :: Direct) , 1 => Some (CountMode :: Reverse) , 2 => Some (CountMode :: Bidirectional) , _ => None , } } # [doc = "Прямой режим"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == CountMode :: Direct } # [doc = "Обратный режим"]
# [inline (always)]
pub fn is_reverse (& self) -> bool { * self == CountMode :: Reverse } # [doc = "Двунаправленный режим"]
# [inline (always)]
pub fn is_bidirectional (& self) -> bool { * self == CountMode :: Bidirectional } } # [doc = "Field `COUNT_MODE` writer - Режим счёта таймера"]
pub type CountModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , CountMode > ; impl < 'a , REG > CountModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Прямой режим"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Direct) } # [doc = "Обратный режим"]
# [inline (always)]
pub fn reverse (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Reverse) } # [doc = "Двунаправленный режим"]
# [inline (always)]
pub fn bidirectional (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Bidirectional) } } # [doc = "Выбор источника тактового сигнала для счета\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Sourse { # [doc = "0: Вход модуля TIM1"]
Tim1 = 0 , # [doc = "2: Вход модуля TIM2"]
Tim2 = 2 , # [doc = "3: Выход предделителя"]
Tim3 = 3 , } impl From < Sourse > for u8 { # [inline (always)]
fn from (variant : Sourse) -> Self { variant as _ } } impl crate :: FieldSpec for Sourse { type Ux = u8 ; } impl crate :: IsEnum for Sourse { } # [doc = "Field `SOURSE` reader - Выбор источника тактового сигнала для счета"]
pub type SourseR = crate :: FieldReader < Sourse > ; impl SourseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Sourse > { match self . bits { 0 => Some (Sourse :: Tim1) , 2 => Some (Sourse :: Tim2) , 3 => Some (Sourse :: Tim3) , _ => None , } } # [doc = "Вход модуля TIM1"]
# [inline (always)]
pub fn is_tim1 (& self) -> bool { * self == Sourse :: Tim1 } # [doc = "Вход модуля TIM2"]
# [inline (always)]
pub fn is_tim2 (& self) -> bool { * self == Sourse :: Tim2 } # [doc = "Выход предделителя"]
# [inline (always)]
pub fn is_tim3 (& self) -> bool { * self == Sourse :: Tim3 } } # [doc = "Field `SOURSE` writer - Выбор источника тактового сигнала для счета"]
pub type SourseW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Sourse > ; impl < 'a , REG > SourseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Вход модуля TIM1"]
# [inline (always)]
pub fn tim1 (self) -> & 'a mut crate :: W < REG > { self . variant (Sourse :: Tim1) } # [doc = "Вход модуля TIM2"]
# [inline (always)]
pub fn tim2 (self) -> & 'a mut crate :: W < REG > { self . variant (Sourse :: Tim2) } # [doc = "Выход предделителя"]
# [inline (always)]
pub fn tim3 (self) -> & 'a mut crate :: W < REG > { self . variant (Sourse :: Tim3) } } impl R { # [doc = "Bits 0:1 - Режим счёта таймера"]
# [inline (always)]
pub fn count_mode (& self) -> CountModeR { CountModeR :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Выбор источника тактового сигнала для счета"]
# [inline (always)]
pub fn sourse (& self) -> SourseR { SourseR :: new (((self . bits >> 2) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Режим счёта таймера"]
# [inline (always)]
pub fn count_mode (& mut self) -> CountModeW < ControlSpec > { CountModeW :: new (self , 0) } # [doc = "Bits 2:3 - Выбор источника тактового сигнала для счета"]
# [inline (always)]
pub fn sourse (& mut self) -> SourseW < ControlSpec > { SourseW :: new (self , 2) } } # [doc = "Конфигурационный регистр основного таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ControlSpec ; impl crate :: RegisterSpec for ControlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`control::R`](R) reader structure"]
impl crate :: Readable for ControlSpec { } # [doc = "`write(|w| ..)` method takes [`control::W`](W) writer structure"]
impl crate :: Writable for ControlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL to value 0"]
impl crate :: Resettable for ControlSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ENABLE (rw) register accessor: Регистр включения таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable`]
module"]
# [doc (alias = "ENABLE")]
pub type Enable = crate :: Reg < enable :: EnableSpec > ; # [doc = "Регистр включения таймера"]
pub mod enable { # [doc = "Register `ENABLE` reader"]
pub type R = crate :: R < EnableSpec > ; # [doc = "Register `ENABLE` writer"]
pub type W = crate :: W < EnableSpec > ; # [doc = "Запуск/остановка работы счетчика\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TimEn { # [doc = "0: Счетчик выключен"]
Disable = 0 , # [doc = "1: Счетчик работает"]
Enable = 1 , } impl From < TimEn > for bool { # [inline (always)]
fn from (variant : TimEn) -> Self { variant as u8 != 0 } } # [doc = "Field `TIM_EN` reader - Запуск/остановка работы счетчика"]
pub type TimEnR = crate :: BitReader < TimEn > ; impl TimEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TimEn { match self . bits { false => TimEn :: Disable , true => TimEn :: Enable , } } # [doc = "Счетчик выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == TimEn :: Disable } # [doc = "Счетчик работает"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == TimEn :: Enable } } # [doc = "Field `TIM_EN` writer - Запуск/остановка работы счетчика"]
pub type TimEnW < 'a , REG > = crate :: BitWriter < 'a , REG , TimEn > ; impl < 'a , REG > TimEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Счетчик выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (TimEn :: Disable) } # [doc = "Счетчик работает"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (TimEn :: Enable) } } # [doc = "Field `TIM_CLR` writer - Сброс (обнуление) текущего значения счетчика при записи «1»"]
pub type TimClrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Запуск/остановка работы счетчика"]
# [inline (always)]
pub fn tim_en (& self) -> TimEnR { TimEnR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Запуск/остановка работы счетчика"]
# [inline (always)]
pub fn tim_en (& mut self) -> TimEnW < EnableSpec > { TimEnW :: new (self , 0) } # [doc = "Bit 1 - Сброс (обнуление) текущего значения счетчика при записи «1»"]
# [inline (always)]
pub fn tim_clr (& mut self) -> TimClrW < EnableSpec > { TimClrW :: new (self , 1) } } # [doc = "Регистр включения таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EnableSpec ; impl crate :: RegisterSpec for EnableSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`enable::R`](R) reader structure"]
impl crate :: Readable for EnableSpec { } # [doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
impl crate :: Writable for EnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ENABLE to value 0"]
impl crate :: Resettable for EnableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INT_MASK (rw) register accessor: Регистр маски прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mask::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mask::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_mask`]
module"]
# [doc (alias = "INT_MASK")]
pub type IntMask = crate :: Reg < int_mask :: IntMaskSpec > ; # [doc = "Регистр маски прерываний"]
pub mod int_mask { # [doc = "Register `INT_MASK` reader"]
pub type R = crate :: R < IntMaskSpec > ; # [doc = "Register `INT_MASK` writer"]
pub type W = crate :: W < IntMaskSpec > ; # [doc = "Field `OVF_Int` reader - Маска прерывания по переполнению счетчика"]
pub type OvfIntR = crate :: BitReader ; # [doc = "Field `OVF_Int` writer - Маска прерывания по переполнению счетчика"]
pub type OvfIntW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `UDF_Int` reader - Маска прерывания опустошения счетчика"]
pub type UdfIntR = crate :: BitReader ; # [doc = "Field `UDF_Int` writer - Маска прерывания опустошения счетчика"]
pub type UdfIntW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH1` reader - Маска прерывания захвата 1 канала таймера"]
pub type IcIntCh1R = crate :: BitReader ; # [doc = "Field `IC_Int_CH1` writer - Маска прерывания захвата 1 канала таймера"]
pub type IcIntCh1W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH2` reader - Маска прерывания захвата 2 канала таймера"]
pub type IcIntCh2R = crate :: BitReader ; # [doc = "Field `IC_Int_CH2` writer - Маска прерывания захвата 2 канала таймера"]
pub type IcIntCh2W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH3` reader - Маска прерывания захвата 3 канала таймера"]
pub type IcIntCh3R = crate :: BitReader ; # [doc = "Field `IC_Int_CH3` writer - Маска прерывания захвата 3 канала таймера"]
pub type IcIntCh3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH4` reader - Маска прерывания захвата 4 канала таймера"]
pub type IcIntCh4R = crate :: BitReader ; # [doc = "Field `IC_Int_CH4` writer - Маска прерывания захвата 4 канала таймера"]
pub type IcIntCh4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH1` reader - Маска прерывания совпадения 1 канала таймера"]
pub type OcIntCh1R = crate :: BitReader ; # [doc = "Field `OC_Int_CH1` writer - Маска прерывания совпадения 1 канала таймера"]
pub type OcIntCh1W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH2` reader - Маска прерывания совпадения 2 канала таймера"]
pub type OcIntCh2R = crate :: BitReader ; # [doc = "Field `OC_Int_CH2` writer - Маска прерывания совпадения 2 канала таймера"]
pub type OcIntCh2W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH3` reader - Маска прерывания совпадения 3 канала таймера"]
pub type OcIntCh3R = crate :: BitReader ; # [doc = "Field `OC_Int_CH3` writer - Маска прерывания совпадения 3 канала таймера"]
pub type OcIntCh3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH4` reader - Маска прерывания совпадения 4 канала таймера"]
pub type OcIntCh4R = crate :: BitReader ; # [doc = "Field `OC_Int_CH4` writer - Маска прерывания совпадения 4 канала таймера"]
pub type OcIntCh4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Маска прерывания по переполнению счетчика"]
# [inline (always)]
pub fn ovf_int (& self) -> OvfIntR { OvfIntR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Маска прерывания опустошения счетчика"]
# [inline (always)]
pub fn udf_int (& self) -> UdfIntR { UdfIntR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Маска прерывания захвата 1 канала таймера"]
# [inline (always)]
pub fn ic_int_ch1 (& self) -> IcIntCh1R { IcIntCh1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Маска прерывания захвата 2 канала таймера"]
# [inline (always)]
pub fn ic_int_ch2 (& self) -> IcIntCh2R { IcIntCh2R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Маска прерывания захвата 3 канала таймера"]
# [inline (always)]
pub fn ic_int_ch3 (& self) -> IcIntCh3R { IcIntCh3R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Маска прерывания захвата 4 канала таймера"]
# [inline (always)]
pub fn ic_int_ch4 (& self) -> IcIntCh4R { IcIntCh4R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Маска прерывания совпадения 1 канала таймера"]
# [inline (always)]
pub fn oc_int_ch1 (& self) -> OcIntCh1R { OcIntCh1R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Маска прерывания совпадения 2 канала таймера"]
# [inline (always)]
pub fn oc_int_ch2 (& self) -> OcIntCh2R { OcIntCh2R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Маска прерывания совпадения 3 канала таймера"]
# [inline (always)]
pub fn oc_int_ch3 (& self) -> OcIntCh3R { OcIntCh3R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Маска прерывания совпадения 4 канала таймера"]
# [inline (always)]
pub fn oc_int_ch4 (& self) -> OcIntCh4R { OcIntCh4R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Маска прерывания по переполнению счетчика"]
# [inline (always)]
pub fn ovf_int (& mut self) -> OvfIntW < IntMaskSpec > { OvfIntW :: new (self , 0) } # [doc = "Bit 1 - Маска прерывания опустошения счетчика"]
# [inline (always)]
pub fn udf_int (& mut self) -> UdfIntW < IntMaskSpec > { UdfIntW :: new (self , 1) } # [doc = "Bit 2 - Маска прерывания захвата 1 канала таймера"]
# [inline (always)]
pub fn ic_int_ch1 (& mut self) -> IcIntCh1W < IntMaskSpec > { IcIntCh1W :: new (self , 2) } # [doc = "Bit 3 - Маска прерывания захвата 2 канала таймера"]
# [inline (always)]
pub fn ic_int_ch2 (& mut self) -> IcIntCh2W < IntMaskSpec > { IcIntCh2W :: new (self , 3) } # [doc = "Bit 4 - Маска прерывания захвата 3 канала таймера"]
# [inline (always)]
pub fn ic_int_ch3 (& mut self) -> IcIntCh3W < IntMaskSpec > { IcIntCh3W :: new (self , 4) } # [doc = "Bit 5 - Маска прерывания захвата 4 канала таймера"]
# [inline (always)]
pub fn ic_int_ch4 (& mut self) -> IcIntCh4W < IntMaskSpec > { IcIntCh4W :: new (self , 5) } # [doc = "Bit 6 - Маска прерывания совпадения 1 канала таймера"]
# [inline (always)]
pub fn oc_int_ch1 (& mut self) -> OcIntCh1W < IntMaskSpec > { OcIntCh1W :: new (self , 6) } # [doc = "Bit 7 - Маска прерывания совпадения 2 канала таймера"]
# [inline (always)]
pub fn oc_int_ch2 (& mut self) -> OcIntCh2W < IntMaskSpec > { OcIntCh2W :: new (self , 7) } # [doc = "Bit 8 - Маска прерывания совпадения 3 канала таймера"]
# [inline (always)]
pub fn oc_int_ch3 (& mut self) -> OcIntCh3W < IntMaskSpec > { OcIntCh3W :: new (self , 8) } # [doc = "Bit 9 - Маска прерывания совпадения 4 канала таймера"]
# [inline (always)]
pub fn oc_int_ch4 (& mut self) -> OcIntCh4W < IntMaskSpec > { OcIntCh4W :: new (self , 9) } } # [doc = "Регистр маски прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mask::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mask::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntMaskSpec ; impl crate :: RegisterSpec for IntMaskSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`int_mask::R`](R) reader structure"]
impl crate :: Readable for IntMaskSpec { } # [doc = "`write(|w| ..)` method takes [`int_mask::W`](W) writer structure"]
impl crate :: Writable for IntMaskSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_MASK to value 0"]
impl crate :: Resettable for IntMaskSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INT_CLEAR (rw) register accessor: Регистр сброса флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_clear::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_clear::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_clear`]
module"]
# [doc (alias = "INT_CLEAR")]
pub type IntClear = crate :: Reg < int_clear :: IntClearSpec > ; # [doc = "Регистр сброса флагов прерываний"]
pub mod int_clear { # [doc = "Register `INT_CLEAR` reader"]
pub type R = crate :: R < IntClearSpec > ; # [doc = "Register `INT_CLEAR` writer"]
pub type W = crate :: W < IntClearSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр сброса флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_clear::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_clear::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntClearSpec ; impl crate :: RegisterSpec for IntClearSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`int_clear::R`](R) reader structure"]
impl crate :: Readable for IntClearSpec { } # [doc = "`write(|w| ..)` method takes [`int_clear::W`](W) writer structure"]
impl crate :: Writable for IntClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_CLEAR to value 0xffff_ffff"]
impl crate :: Resettable for IntClearSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } } # [doc = "INT_FLAG (rw) register accessor: Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`]
module"]
# [doc (alias = "INT_FLAG")]
pub type IntFlag = crate :: Reg < int_flag :: IntFlagSpec > ; # [doc = "Регистр флагов прерываний"]
pub mod int_flag { # [doc = "Register `INT_FLAG` reader"]
pub type R = crate :: R < IntFlagSpec > ; # [doc = "Register `INT_FLAG` writer"]
pub type W = crate :: W < IntFlagSpec > ; # [doc = "Field `OVF_Int` reader - Статус прерывания по переполнению счетчика"]
pub type OvfIntR = crate :: BitReader ; # [doc = "Field `UDF_Int` reader - Статус прерывания опустошения счетчика"]
pub type UdfIntR = crate :: BitReader ; # [doc = "Field `IC_Int_CH1` reader - Статус прерывания захвата 1 канала таймера"]
pub type IcIntCh1R = crate :: BitReader ; # [doc = "Field `IC_Int_CH2` reader - Статус прерывания захвата 2 канала таймера"]
pub type IcIntCh2R = crate :: BitReader ; # [doc = "Field `IC_Int_CH3` reader - Статус прерывания захвата 3 канала таймера"]
pub type IcIntCh3R = crate :: BitReader ; # [doc = "Field `IC_Int_CH4` reader - Статус прерывания захвата 4 канала таймера"]
pub type IcIntCh4R = crate :: BitReader ; # [doc = "Field `OC_Int_CH1` reader - Статус прерывания совпадения 1 канала таймера"]
pub type OcIntCh1R = crate :: BitReader ; # [doc = "Field `OC_Int_CH2` reader - Статус прерывания совпадения 2 канала таймера"]
pub type OcIntCh2R = crate :: BitReader ; # [doc = "Field `OC_Int_CH3` reader - Статус прерывания совпадения 3 канала таймера"]
pub type OcIntCh3R = crate :: BitReader ; # [doc = "Field `OC_Int_CH4` reader - Статус прерывания совпадения 4 канала таймера"]
pub type OcIntCh4R = crate :: BitReader ; impl R { # [doc = "Bit 0 - Статус прерывания по переполнению счетчика"]
# [inline (always)]
pub fn ovf_int (& self) -> OvfIntR { OvfIntR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Статус прерывания опустошения счетчика"]
# [inline (always)]
pub fn udf_int (& self) -> UdfIntR { UdfIntR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Статус прерывания захвата 1 канала таймера"]
# [inline (always)]
pub fn ic_int_ch1 (& self) -> IcIntCh1R { IcIntCh1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Статус прерывания захвата 2 канала таймера"]
# [inline (always)]
pub fn ic_int_ch2 (& self) -> IcIntCh2R { IcIntCh2R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Статус прерывания захвата 3 канала таймера"]
# [inline (always)]
pub fn ic_int_ch3 (& self) -> IcIntCh3R { IcIntCh3R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Статус прерывания захвата 4 канала таймера"]
# [inline (always)]
pub fn ic_int_ch4 (& self) -> IcIntCh4R { IcIntCh4R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Статус прерывания совпадения 1 канала таймера"]
# [inline (always)]
pub fn oc_int_ch1 (& self) -> OcIntCh1R { OcIntCh1R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Статус прерывания совпадения 2 канала таймера"]
# [inline (always)]
pub fn oc_int_ch2 (& self) -> OcIntCh2R { OcIntCh2R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Статус прерывания совпадения 3 канала таймера"]
# [inline (always)]
pub fn oc_int_ch3 (& self) -> OcIntCh3R { OcIntCh3R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Статус прерывания совпадения 4 канала таймера"]
# [inline (always)]
pub fn oc_int_ch4 (& self) -> OcIntCh4R { OcIntCh4R :: new (((self . bits >> 9) & 1) != 0) } } impl W { } # [doc = "Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntFlagSpec ; impl crate :: RegisterSpec for IntFlagSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`int_flag::R`](R) reader structure"]
impl crate :: Readable for IntFlagSpec { } # [doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"]
impl crate :: Writable for IntFlagSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_FLAG to value 0"]
impl crate :: Resettable for IntFlagSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH1_CNTR (rw) register accessor: Конфигурационный регистр 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_cntr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_cntr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch1_cntr`]
module"]
# [doc (alias = "CH1_CNTR")]
pub type Ch1Cntr = crate :: Reg < ch1_cntr :: Ch1CntrSpec > ; # [doc = "Конфигурационный регистр 1 канала"]
pub mod ch1_cntr { # [doc = "Register `CH1_CNTR` reader"]
pub type R = crate :: R < Ch1CntrSpec > ; # [doc = "Register `CH1_CNTR` writer"]
pub type W = crate :: W < Ch1CntrSpec > ; # [doc = "Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Noise { # [doc = "0: Фильтрация выключена"]
Enable = 0 , # [doc = "1: Фильтрация включена"]
Disable = 1 , } impl From < Noise > for bool { # [inline (always)]
fn from (variant : Noise) -> Self { variant as u8 != 0 } } # [doc = "Field `NOISE` reader - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseR = crate :: BitReader < Noise > ; impl NoiseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Noise { match self . bits { false => Noise :: Enable , true => Noise :: Disable , } } # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Noise :: Enable } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Noise :: Disable } } # [doc = "Field `NOISE` writer - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseW < 'a , REG > = crate :: BitWriter < 'a , REG , Noise > ; impl < 'a , REG > NoiseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Enable) } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Disable) } } # [doc = "Режим сигнала захвата\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Edge { # [doc = "0: фронт"]
Front = 0 , # [doc = "1: срез"]
Back = 1 , } impl From < Edge > for bool { # [inline (always)]
fn from (variant : Edge) -> Self { variant as u8 != 0 } } # [doc = "Field `EDGE` reader - Режим сигнала захвата"]
pub type EdgeR = crate :: BitReader < Edge > ; impl EdgeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Edge { match self . bits { false => Edge :: Front , true => Edge :: Back , } } # [doc = "фронт"]
# [inline (always)]
pub fn is_front (& self) -> bool { * self == Edge :: Front } # [doc = "срез"]
# [inline (always)]
pub fn is_back (& self) -> bool { * self == Edge :: Back } } # [doc = "Field `EDGE` writer - Режим сигнала захвата"]
pub type EdgeW < 'a , REG > = crate :: BitWriter < 'a , REG , Edge > ; impl < 'a , REG > EdgeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "фронт"]
# [inline (always)]
pub fn front (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Front) } # [doc = "срез"]
# [inline (always)]
pub fn back (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Back) } } # [doc = "Режим работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Mode { # [doc = "1: Режим сравнения (для timer0)"]
Compare = 1 , # [doc = "2: Режим захвата(для timer0)"]
Capture = 2 , # [doc = "3: ШИМ"]
Pwm = 3 , } impl From < Mode > for u8 { # [inline (always)]
fn from (variant : Mode) -> Self { variant as _ } } impl crate :: FieldSpec for Mode { type Ux = u8 ; } impl crate :: IsEnum for Mode { } # [doc = "Field `MODE` reader - Режим работы канала"]
pub type ModeR = crate :: FieldReader < Mode > ; impl ModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Mode { match self . bits { 1 => Mode :: Compare , 2 => Mode :: Capture , 3 => Mode :: Pwm , _ => unreachable ! () , } } # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn is_compare (& self) -> bool { * self == Mode :: Compare } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn is_capture (& self) -> bool { * self == Mode :: Capture } # [doc = "ШИМ"]
# [inline (always)]
pub fn is_pwm (& self) -> bool { * self == Mode :: Pwm } } # [doc = "Field `MODE` writer - Режим работы канала"]
pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mode > ; impl < 'a , REG > ModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn compare (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Compare) } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn capture (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Capture) } # [doc = "ШИМ"]
# [inline (always)]
pub fn pwm (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Pwm) } } # [doc = "Field `EN` reader - Включение/выключение канала"]
pub type EnR = crate :: BitReader ; # [doc = "Field `EN` writer - Включение/выключение канала"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Тип вывода в режиме ШИМ инвертирование\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PwmInv { # [doc = "1: Прямой (не инвертированный) выход"]
Direct = 1 , # [doc = "0: Инвертированный выход"]
Inverted = 0 , } impl From < PwmInv > for bool { # [inline (always)]
fn from (variant : PwmInv) -> Self { variant as u8 != 0 } } # [doc = "Field `PWM_INV` reader - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvR = crate :: BitReader < PwmInv > ; impl PwmInvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PwmInv { match self . bits { true => PwmInv :: Direct , false => PwmInv :: Inverted , } } # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == PwmInv :: Direct } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == PwmInv :: Inverted } } # [doc = "Field `PWM_INV` writer - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvW < 'a , REG > = crate :: BitWriter < 'a , REG , PwmInv > ; impl < 'a , REG > PwmInvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Direct) } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Inverted) } } # [doc = "Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dir { # [doc = "1: Выход"]
Output = 1 , # [doc = "0: Вход"]
Input = 0 , } impl From < Dir > for bool { # [inline (always)]
fn from (variant : Dir) -> Self { variant as u8 != 0 } } # [doc = "Field `DIR` reader - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
pub type DirR = crate :: BitReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dir { match self . bits { true => Dir :: Output , false => Dir :: Input , } } # [doc = "Выход"]
# [inline (always)]
pub fn is_output (& self) -> bool { * self == Dir :: Output } # [doc = "Вход"]
# [inline (always)]
pub fn is_input (& self) -> bool { * self == Dir :: Input } } impl R { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& self) -> NoiseR { NoiseR :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& self) -> EdgeR { EdgeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& self) -> PwmInvR { PwmInvR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
# [inline (always)]
pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& mut self) -> NoiseW < Ch1CntrSpec > { NoiseW :: new (self , 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& mut self) -> EdgeW < Ch1CntrSpec > { EdgeW :: new (self , 4) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& mut self) -> ModeW < Ch1CntrSpec > { ModeW :: new (self , 5) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& mut self) -> EnW < Ch1CntrSpec > { EnW :: new (self , 7) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& mut self) -> PwmInvW < Ch1CntrSpec > { PwmInvW :: new (self , 8) } } # [doc = "Конфигурационный регистр 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_cntr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_cntr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch1CntrSpec ; impl crate :: RegisterSpec for Ch1CntrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch1_cntr::R`](R) reader structure"]
impl crate :: Readable for Ch1CntrSpec { } # [doc = "`write(|w| ..)` method takes [`ch1_cntr::W`](W) writer structure"]
impl crate :: Writable for Ch1CntrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH1_CNTR to value 0"]
impl crate :: Resettable for Ch1CntrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH1_OCR (rw) register accessor: Значение сравнения 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_ocr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_ocr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch1_ocr`]
module"]
# [doc (alias = "CH1_OCR")]
pub type Ch1Ocr = crate :: Reg < ch1_ocr :: Ch1OcrSpec > ; # [doc = "Значение сравнения 1 канала"]
pub mod ch1_ocr { # [doc = "Register `CH1_OCR` reader"]
pub type R = crate :: R < Ch1OcrSpec > ; # [doc = "Register `CH1_OCR` writer"]
pub type W = crate :: W < Ch1OcrSpec > ; # [doc = "Field `OCR` reader - Значение таймера в режиме сравнения"]
pub type OcrR = crate :: FieldReader < u32 > ; # [doc = "Field `OCR` writer - Значение таймера в режиме сравнения"]
pub type OcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& self) -> OcrR { OcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& mut self) -> OcrW < Ch1OcrSpec > { OcrW :: new (self , 0) } } # [doc = "Значение сравнения 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_ocr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_ocr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch1OcrSpec ; impl crate :: RegisterSpec for Ch1OcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch1_ocr::R`](R) reader structure"]
impl crate :: Readable for Ch1OcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch1_ocr::W`](W) writer structure"]
impl crate :: Writable for Ch1OcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH1_OCR to value 0"]
impl crate :: Resettable for Ch1OcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH1_ICR (rw) register accessor: Значение захвата 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch1_icr`]
module"]
# [doc (alias = "CH1_ICR")]
pub type Ch1Icr = crate :: Reg < ch1_icr :: Ch1IcrSpec > ; # [doc = "Значение захвата 1 канала"]
pub mod ch1_icr { # [doc = "Register `CH1_ICR` reader"]
pub type R = crate :: R < Ch1IcrSpec > ; # [doc = "Register `CH1_ICR` writer"]
pub type W = crate :: W < Ch1IcrSpec > ; # [doc = "Field `ICR` reader - Значение таймера в режиме захвата"]
pub type IcrR = crate :: FieldReader < u32 > ; # [doc = "Field `ICR` writer - Значение таймера в режиме захвата"]
pub type IcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& self) -> IcrR { IcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& mut self) -> IcrW < Ch1IcrSpec > { IcrW :: new (self , 0) } } # [doc = "Значение захвата 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch1IcrSpec ; impl crate :: RegisterSpec for Ch1IcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch1_icr::R`](R) reader structure"]
impl crate :: Readable for Ch1IcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch1_icr::W`](W) writer structure"]
impl crate :: Writable for Ch1IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH1_ICR to value 0"]
impl crate :: Resettable for Ch1IcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH2_CNTR (rw) register accessor: Конфигурационный регистр 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_cntr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_cntr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch2_cntr`]
module"]
# [doc (alias = "CH2_CNTR")]
pub type Ch2Cntr = crate :: Reg < ch2_cntr :: Ch2CntrSpec > ; # [doc = "Конфигурационный регистр 2 канала"]
pub mod ch2_cntr { # [doc = "Register `CH2_CNTR` reader"]
pub type R = crate :: R < Ch2CntrSpec > ; # [doc = "Register `CH2_CNTR` writer"]
pub type W = crate :: W < Ch2CntrSpec > ; # [doc = "Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Noise { # [doc = "0: Фильтрация выключена"]
Enable = 0 , # [doc = "1: Фильтрация включена"]
Disable = 1 , } impl From < Noise > for bool { # [inline (always)]
fn from (variant : Noise) -> Self { variant as u8 != 0 } } # [doc = "Field `NOISE` reader - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseR = crate :: BitReader < Noise > ; impl NoiseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Noise { match self . bits { false => Noise :: Enable , true => Noise :: Disable , } } # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Noise :: Enable } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Noise :: Disable } } # [doc = "Field `NOISE` writer - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseW < 'a , REG > = crate :: BitWriter < 'a , REG , Noise > ; impl < 'a , REG > NoiseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Enable) } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Disable) } } # [doc = "Режим сигнала захвата\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Edge { # [doc = "0: фронт"]
Front = 0 , # [doc = "1: срез"]
Back = 1 , } impl From < Edge > for bool { # [inline (always)]
fn from (variant : Edge) -> Self { variant as u8 != 0 } } # [doc = "Field `EDGE` reader - Режим сигнала захвата"]
pub type EdgeR = crate :: BitReader < Edge > ; impl EdgeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Edge { match self . bits { false => Edge :: Front , true => Edge :: Back , } } # [doc = "фронт"]
# [inline (always)]
pub fn is_front (& self) -> bool { * self == Edge :: Front } # [doc = "срез"]
# [inline (always)]
pub fn is_back (& self) -> bool { * self == Edge :: Back } } # [doc = "Field `EDGE` writer - Режим сигнала захвата"]
pub type EdgeW < 'a , REG > = crate :: BitWriter < 'a , REG , Edge > ; impl < 'a , REG > EdgeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "фронт"]
# [inline (always)]
pub fn front (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Front) } # [doc = "срез"]
# [inline (always)]
pub fn back (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Back) } } # [doc = "Режим работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Mode { # [doc = "1: Режим сравнения (для timer0)"]
Compare = 1 , # [doc = "2: Режим захвата(для timer0)"]
Capture = 2 , # [doc = "3: ШИМ"]
Pwm = 3 , } impl From < Mode > for u8 { # [inline (always)]
fn from (variant : Mode) -> Self { variant as _ } } impl crate :: FieldSpec for Mode { type Ux = u8 ; } impl crate :: IsEnum for Mode { } # [doc = "Field `MODE` reader - Режим работы канала"]
pub type ModeR = crate :: FieldReader < Mode > ; impl ModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Mode { match self . bits { 1 => Mode :: Compare , 2 => Mode :: Capture , 3 => Mode :: Pwm , _ => unreachable ! () , } } # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn is_compare (& self) -> bool { * self == Mode :: Compare } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn is_capture (& self) -> bool { * self == Mode :: Capture } # [doc = "ШИМ"]
# [inline (always)]
pub fn is_pwm (& self) -> bool { * self == Mode :: Pwm } } # [doc = "Field `MODE` writer - Режим работы канала"]
pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mode > ; impl < 'a , REG > ModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn compare (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Compare) } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn capture (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Capture) } # [doc = "ШИМ"]
# [inline (always)]
pub fn pwm (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Pwm) } } # [doc = "Field `EN` reader - Включение/выключение канала"]
pub type EnR = crate :: BitReader ; # [doc = "Field `EN` writer - Включение/выключение канала"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Тип вывода в режиме ШИМ инвертирование\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PwmInv { # [doc = "1: Прямой (не инвертированный) выход"]
Direct = 1 , # [doc = "0: Инвертированный выход"]
Inverted = 0 , } impl From < PwmInv > for bool { # [inline (always)]
fn from (variant : PwmInv) -> Self { variant as u8 != 0 } } # [doc = "Field `PWM_INV` reader - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvR = crate :: BitReader < PwmInv > ; impl PwmInvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PwmInv { match self . bits { true => PwmInv :: Direct , false => PwmInv :: Inverted , } } # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == PwmInv :: Direct } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == PwmInv :: Inverted } } # [doc = "Field `PWM_INV` writer - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvW < 'a , REG > = crate :: BitWriter < 'a , REG , PwmInv > ; impl < 'a , REG > PwmInvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Direct) } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Inverted) } } # [doc = "Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dir { # [doc = "1: Выход"]
Output = 1 , # [doc = "0: Вход"]
Input = 0 , } impl From < Dir > for bool { # [inline (always)]
fn from (variant : Dir) -> Self { variant as u8 != 0 } } # [doc = "Field `DIR` reader - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
pub type DirR = crate :: BitReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dir { match self . bits { true => Dir :: Output , false => Dir :: Input , } } # [doc = "Выход"]
# [inline (always)]
pub fn is_output (& self) -> bool { * self == Dir :: Output } # [doc = "Вход"]
# [inline (always)]
pub fn is_input (& self) -> bool { * self == Dir :: Input } } impl R { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& self) -> NoiseR { NoiseR :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& self) -> EdgeR { EdgeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& self) -> PwmInvR { PwmInvR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
# [inline (always)]
pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& mut self) -> NoiseW < Ch2CntrSpec > { NoiseW :: new (self , 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& mut self) -> EdgeW < Ch2CntrSpec > { EdgeW :: new (self , 4) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& mut self) -> ModeW < Ch2CntrSpec > { ModeW :: new (self , 5) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& mut self) -> EnW < Ch2CntrSpec > { EnW :: new (self , 7) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& mut self) -> PwmInvW < Ch2CntrSpec > { PwmInvW :: new (self , 8) } } # [doc = "Конфигурационный регистр 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_cntr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_cntr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch2CntrSpec ; impl crate :: RegisterSpec for Ch2CntrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch2_cntr::R`](R) reader structure"]
impl crate :: Readable for Ch2CntrSpec { } # [doc = "`write(|w| ..)` method takes [`ch2_cntr::W`](W) writer structure"]
impl crate :: Writable for Ch2CntrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH2_CNTR to value 0"]
impl crate :: Resettable for Ch2CntrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH2_OCR (rw) register accessor: Значение сравнения 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_ocr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_ocr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch2_ocr`]
module"]
# [doc (alias = "CH2_OCR")]
pub type Ch2Ocr = crate :: Reg < ch2_ocr :: Ch2OcrSpec > ; # [doc = "Значение сравнения 2 канала"]
pub mod ch2_ocr { # [doc = "Register `CH2_OCR` reader"]
pub type R = crate :: R < Ch2OcrSpec > ; # [doc = "Register `CH2_OCR` writer"]
pub type W = crate :: W < Ch2OcrSpec > ; # [doc = "Field `OCR` reader - Значение таймера в режиме сравнения"]
pub type OcrR = crate :: FieldReader < u32 > ; # [doc = "Field `OCR` writer - Значение таймера в режиме сравнения"]
pub type OcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& self) -> OcrR { OcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& mut self) -> OcrW < Ch2OcrSpec > { OcrW :: new (self , 0) } } # [doc = "Значение сравнения 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_ocr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_ocr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch2OcrSpec ; impl crate :: RegisterSpec for Ch2OcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch2_ocr::R`](R) reader structure"]
impl crate :: Readable for Ch2OcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch2_ocr::W`](W) writer structure"]
impl crate :: Writable for Ch2OcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH2_OCR to value 0"]
impl crate :: Resettable for Ch2OcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH2_ICR (rw) register accessor: Значение захвата 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch2_icr`]
module"]
# [doc (alias = "CH2_ICR")]
pub type Ch2Icr = crate :: Reg < ch2_icr :: Ch2IcrSpec > ; # [doc = "Значение захвата 2 канала"]
pub mod ch2_icr { # [doc = "Register `CH2_ICR` reader"]
pub type R = crate :: R < Ch2IcrSpec > ; # [doc = "Register `CH2_ICR` writer"]
pub type W = crate :: W < Ch2IcrSpec > ; # [doc = "Field `ICR` reader - Значение таймера в режиме захвата"]
pub type IcrR = crate :: FieldReader < u32 > ; # [doc = "Field `ICR` writer - Значение таймера в режиме захвата"]
pub type IcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& self) -> IcrR { IcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& mut self) -> IcrW < Ch2IcrSpec > { IcrW :: new (self , 0) } } # [doc = "Значение захвата 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch2IcrSpec ; impl crate :: RegisterSpec for Ch2IcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch2_icr::R`](R) reader structure"]
impl crate :: Readable for Ch2IcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch2_icr::W`](W) writer structure"]
impl crate :: Writable for Ch2IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH2_ICR to value 0"]
impl crate :: Resettable for Ch2IcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH3_CNTR (rw) register accessor: Конфигурационный регистр 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_cntr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_cntr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch3_cntr`]
module"]
# [doc (alias = "CH3_CNTR")]
pub type Ch3Cntr = crate :: Reg < ch3_cntr :: Ch3CntrSpec > ; # [doc = "Конфигурационный регистр 3 канала"]
pub mod ch3_cntr { # [doc = "Register `CH3_CNTR` reader"]
pub type R = crate :: R < Ch3CntrSpec > ; # [doc = "Register `CH3_CNTR` writer"]
pub type W = crate :: W < Ch3CntrSpec > ; # [doc = "Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Noise { # [doc = "0: Фильтрация выключена"]
Enable = 0 , # [doc = "1: Фильтрация включена"]
Disable = 1 , } impl From < Noise > for bool { # [inline (always)]
fn from (variant : Noise) -> Self { variant as u8 != 0 } } # [doc = "Field `NOISE` reader - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseR = crate :: BitReader < Noise > ; impl NoiseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Noise { match self . bits { false => Noise :: Enable , true => Noise :: Disable , } } # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Noise :: Enable } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Noise :: Disable } } # [doc = "Field `NOISE` writer - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseW < 'a , REG > = crate :: BitWriter < 'a , REG , Noise > ; impl < 'a , REG > NoiseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Enable) } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Disable) } } # [doc = "Режим сигнала захвата\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Edge { # [doc = "0: фронт"]
Front = 0 , # [doc = "1: срез"]
Back = 1 , } impl From < Edge > for bool { # [inline (always)]
fn from (variant : Edge) -> Self { variant as u8 != 0 } } # [doc = "Field `EDGE` reader - Режим сигнала захвата"]
pub type EdgeR = crate :: BitReader < Edge > ; impl EdgeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Edge { match self . bits { false => Edge :: Front , true => Edge :: Back , } } # [doc = "фронт"]
# [inline (always)]
pub fn is_front (& self) -> bool { * self == Edge :: Front } # [doc = "срез"]
# [inline (always)]
pub fn is_back (& self) -> bool { * self == Edge :: Back } } # [doc = "Field `EDGE` writer - Режим сигнала захвата"]
pub type EdgeW < 'a , REG > = crate :: BitWriter < 'a , REG , Edge > ; impl < 'a , REG > EdgeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "фронт"]
# [inline (always)]
pub fn front (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Front) } # [doc = "срез"]
# [inline (always)]
pub fn back (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Back) } } # [doc = "Режим работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Mode { # [doc = "1: Режим сравнения (для timer0)"]
Compare = 1 , # [doc = "2: Режим захвата(для timer0)"]
Capture = 2 , # [doc = "3: ШИМ"]
Pwm = 3 , } impl From < Mode > for u8 { # [inline (always)]
fn from (variant : Mode) -> Self { variant as _ } } impl crate :: FieldSpec for Mode { type Ux = u8 ; } impl crate :: IsEnum for Mode { } # [doc = "Field `MODE` reader - Режим работы канала"]
pub type ModeR = crate :: FieldReader < Mode > ; impl ModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Mode { match self . bits { 1 => Mode :: Compare , 2 => Mode :: Capture , 3 => Mode :: Pwm , _ => unreachable ! () , } } # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn is_compare (& self) -> bool { * self == Mode :: Compare } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn is_capture (& self) -> bool { * self == Mode :: Capture } # [doc = "ШИМ"]
# [inline (always)]
pub fn is_pwm (& self) -> bool { * self == Mode :: Pwm } } # [doc = "Field `MODE` writer - Режим работы канала"]
pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mode > ; impl < 'a , REG > ModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn compare (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Compare) } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn capture (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Capture) } # [doc = "ШИМ"]
# [inline (always)]
pub fn pwm (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Pwm) } } # [doc = "Field `EN` reader - Включение/выключение канала"]
pub type EnR = crate :: BitReader ; # [doc = "Field `EN` writer - Включение/выключение канала"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Тип вывода в режиме ШИМ инвертирование\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PwmInv { # [doc = "1: Прямой (не инвертированный) выход"]
Direct = 1 , # [doc = "0: Инвертированный выход"]
Inverted = 0 , } impl From < PwmInv > for bool { # [inline (always)]
fn from (variant : PwmInv) -> Self { variant as u8 != 0 } } # [doc = "Field `PWM_INV` reader - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvR = crate :: BitReader < PwmInv > ; impl PwmInvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PwmInv { match self . bits { true => PwmInv :: Direct , false => PwmInv :: Inverted , } } # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == PwmInv :: Direct } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == PwmInv :: Inverted } } # [doc = "Field `PWM_INV` writer - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvW < 'a , REG > = crate :: BitWriter < 'a , REG , PwmInv > ; impl < 'a , REG > PwmInvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Direct) } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Inverted) } } # [doc = "Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dir { # [doc = "1: Выход"]
Output = 1 , # [doc = "0: Вход"]
Input = 0 , } impl From < Dir > for bool { # [inline (always)]
fn from (variant : Dir) -> Self { variant as u8 != 0 } } # [doc = "Field `DIR` reader - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
pub type DirR = crate :: BitReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dir { match self . bits { true => Dir :: Output , false => Dir :: Input , } } # [doc = "Выход"]
# [inline (always)]
pub fn is_output (& self) -> bool { * self == Dir :: Output } # [doc = "Вход"]
# [inline (always)]
pub fn is_input (& self) -> bool { * self == Dir :: Input } } impl R { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& self) -> NoiseR { NoiseR :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& self) -> EdgeR { EdgeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& self) -> PwmInvR { PwmInvR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
# [inline (always)]
pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& mut self) -> NoiseW < Ch3CntrSpec > { NoiseW :: new (self , 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& mut self) -> EdgeW < Ch3CntrSpec > { EdgeW :: new (self , 4) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& mut self) -> ModeW < Ch3CntrSpec > { ModeW :: new (self , 5) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& mut self) -> EnW < Ch3CntrSpec > { EnW :: new (self , 7) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& mut self) -> PwmInvW < Ch3CntrSpec > { PwmInvW :: new (self , 8) } } # [doc = "Конфигурационный регистр 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_cntr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_cntr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch3CntrSpec ; impl crate :: RegisterSpec for Ch3CntrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch3_cntr::R`](R) reader structure"]
impl crate :: Readable for Ch3CntrSpec { } # [doc = "`write(|w| ..)` method takes [`ch3_cntr::W`](W) writer structure"]
impl crate :: Writable for Ch3CntrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH3_CNTR to value 0"]
impl crate :: Resettable for Ch3CntrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH3_OCR (rw) register accessor: Значение сравнения 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_ocr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_ocr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch3_ocr`]
module"]
# [doc (alias = "CH3_OCR")]
pub type Ch3Ocr = crate :: Reg < ch3_ocr :: Ch3OcrSpec > ; # [doc = "Значение сравнения 3 канала"]
pub mod ch3_ocr { # [doc = "Register `CH3_OCR` reader"]
pub type R = crate :: R < Ch3OcrSpec > ; # [doc = "Register `CH3_OCR` writer"]
pub type W = crate :: W < Ch3OcrSpec > ; # [doc = "Field `OCR` reader - Значение таймера в режиме сравнения"]
pub type OcrR = crate :: FieldReader < u32 > ; # [doc = "Field `OCR` writer - Значение таймера в режиме сравнения"]
pub type OcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& self) -> OcrR { OcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& mut self) -> OcrW < Ch3OcrSpec > { OcrW :: new (self , 0) } } # [doc = "Значение сравнения 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_ocr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_ocr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch3OcrSpec ; impl crate :: RegisterSpec for Ch3OcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch3_ocr::R`](R) reader structure"]
impl crate :: Readable for Ch3OcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch3_ocr::W`](W) writer structure"]
impl crate :: Writable for Ch3OcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH3_OCR to value 0"]
impl crate :: Resettable for Ch3OcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH3_ICR (rw) register accessor: Значение захвата 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch3_icr`]
module"]
# [doc (alias = "CH3_ICR")]
pub type Ch3Icr = crate :: Reg < ch3_icr :: Ch3IcrSpec > ; # [doc = "Значение захвата 3 канала"]
pub mod ch3_icr { # [doc = "Register `CH3_ICR` reader"]
pub type R = crate :: R < Ch3IcrSpec > ; # [doc = "Register `CH3_ICR` writer"]
pub type W = crate :: W < Ch3IcrSpec > ; # [doc = "Field `ICR` reader - Значение таймера в режиме захвата"]
pub type IcrR = crate :: FieldReader < u32 > ; # [doc = "Field `ICR` writer - Значение таймера в режиме захвата"]
pub type IcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& self) -> IcrR { IcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& mut self) -> IcrW < Ch3IcrSpec > { IcrW :: new (self , 0) } } # [doc = "Значение захвата 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch3IcrSpec ; impl crate :: RegisterSpec for Ch3IcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch3_icr::R`](R) reader structure"]
impl crate :: Readable for Ch3IcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch3_icr::W`](W) writer structure"]
impl crate :: Writable for Ch3IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH3_ICR to value 0"]
impl crate :: Resettable for Ch3IcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH4_CNTR (rw) register accessor: Конфигурационный регистр 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_cntr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_cntr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch4_cntr`]
module"]
# [doc (alias = "CH4_CNTR")]
pub type Ch4Cntr = crate :: Reg < ch4_cntr :: Ch4CntrSpec > ; # [doc = "Конфигурационный регистр 4 канала"]
pub mod ch4_cntr { # [doc = "Register `CH4_CNTR` reader"]
pub type R = crate :: R < Ch4CntrSpec > ; # [doc = "Register `CH4_CNTR` writer"]
pub type W = crate :: W < Ch4CntrSpec > ; # [doc = "Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Noise { # [doc = "0: Фильтрация выключена"]
Enable = 0 , # [doc = "1: Фильтрация включена"]
Disable = 1 , } impl From < Noise > for bool { # [inline (always)]
fn from (variant : Noise) -> Self { variant as u8 != 0 } } # [doc = "Field `NOISE` reader - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseR = crate :: BitReader < Noise > ; impl NoiseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Noise { match self . bits { false => Noise :: Enable , true => Noise :: Disable , } } # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Noise :: Enable } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Noise :: Disable } } # [doc = "Field `NOISE` writer - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseW < 'a , REG > = crate :: BitWriter < 'a , REG , Noise > ; impl < 'a , REG > NoiseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Enable) } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Disable) } } # [doc = "Режим сигнала захвата\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Edge { # [doc = "0: фронт"]
Front = 0 , # [doc = "1: срез"]
Back = 1 , } impl From < Edge > for bool { # [inline (always)]
fn from (variant : Edge) -> Self { variant as u8 != 0 } } # [doc = "Field `EDGE` reader - Режим сигнала захвата"]
pub type EdgeR = crate :: BitReader < Edge > ; impl EdgeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Edge { match self . bits { false => Edge :: Front , true => Edge :: Back , } } # [doc = "фронт"]
# [inline (always)]
pub fn is_front (& self) -> bool { * self == Edge :: Front } # [doc = "срез"]
# [inline (always)]
pub fn is_back (& self) -> bool { * self == Edge :: Back } } # [doc = "Field `EDGE` writer - Режим сигнала захвата"]
pub type EdgeW < 'a , REG > = crate :: BitWriter < 'a , REG , Edge > ; impl < 'a , REG > EdgeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "фронт"]
# [inline (always)]
pub fn front (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Front) } # [doc = "срез"]
# [inline (always)]
pub fn back (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Back) } } # [doc = "Режим работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Mode { # [doc = "1: Режим сравнения (для timer0)"]
Compare = 1 , # [doc = "2: Режим захвата(для timer0)"]
Capture = 2 , # [doc = "3: ШИМ"]
Pwm = 3 , } impl From < Mode > for u8 { # [inline (always)]
fn from (variant : Mode) -> Self { variant as _ } } impl crate :: FieldSpec for Mode { type Ux = u8 ; } impl crate :: IsEnum for Mode { } # [doc = "Field `MODE` reader - Режим работы канала"]
pub type ModeR = crate :: FieldReader < Mode > ; impl ModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Mode { match self . bits { 1 => Mode :: Compare , 2 => Mode :: Capture , 3 => Mode :: Pwm , _ => unreachable ! () , } } # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn is_compare (& self) -> bool { * self == Mode :: Compare } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn is_capture (& self) -> bool { * self == Mode :: Capture } # [doc = "ШИМ"]
# [inline (always)]
pub fn is_pwm (& self) -> bool { * self == Mode :: Pwm } } # [doc = "Field `MODE` writer - Режим работы канала"]
pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mode > ; impl < 'a , REG > ModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn compare (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Compare) } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn capture (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Capture) } # [doc = "ШИМ"]
# [inline (always)]
pub fn pwm (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Pwm) } } # [doc = "Field `EN` reader - Включение/выключение канала"]
pub type EnR = crate :: BitReader ; # [doc = "Field `EN` writer - Включение/выключение канала"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Тип вывода в режиме ШИМ инвертирование\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PwmInv { # [doc = "1: Прямой (не инвертированный) выход"]
Direct = 1 , # [doc = "0: Инвертированный выход"]
Inverted = 0 , } impl From < PwmInv > for bool { # [inline (always)]
fn from (variant : PwmInv) -> Self { variant as u8 != 0 } } # [doc = "Field `PWM_INV` reader - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvR = crate :: BitReader < PwmInv > ; impl PwmInvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PwmInv { match self . bits { true => PwmInv :: Direct , false => PwmInv :: Inverted , } } # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == PwmInv :: Direct } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == PwmInv :: Inverted } } # [doc = "Field `PWM_INV` writer - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvW < 'a , REG > = crate :: BitWriter < 'a , REG , PwmInv > ; impl < 'a , REG > PwmInvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Direct) } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Inverted) } } # [doc = "Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dir { # [doc = "1: Выход"]
Output = 1 , # [doc = "0: Вход"]
Input = 0 , } impl From < Dir > for bool { # [inline (always)]
fn from (variant : Dir) -> Self { variant as u8 != 0 } } # [doc = "Field `DIR` reader - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
pub type DirR = crate :: BitReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dir { match self . bits { true => Dir :: Output , false => Dir :: Input , } } # [doc = "Выход"]
# [inline (always)]
pub fn is_output (& self) -> bool { * self == Dir :: Output } # [doc = "Вход"]
# [inline (always)]
pub fn is_input (& self) -> bool { * self == Dir :: Input } } impl R { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& self) -> NoiseR { NoiseR :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& self) -> EdgeR { EdgeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& self) -> PwmInvR { PwmInvR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
# [inline (always)]
pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& mut self) -> NoiseW < Ch4CntrSpec > { NoiseW :: new (self , 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& mut self) -> EdgeW < Ch4CntrSpec > { EdgeW :: new (self , 4) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& mut self) -> ModeW < Ch4CntrSpec > { ModeW :: new (self , 5) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& mut self) -> EnW < Ch4CntrSpec > { EnW :: new (self , 7) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& mut self) -> PwmInvW < Ch4CntrSpec > { PwmInvW :: new (self , 8) } } # [doc = "Конфигурационный регистр 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_cntr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_cntr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch4CntrSpec ; impl crate :: RegisterSpec for Ch4CntrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch4_cntr::R`](R) reader structure"]
impl crate :: Readable for Ch4CntrSpec { } # [doc = "`write(|w| ..)` method takes [`ch4_cntr::W`](W) writer structure"]
impl crate :: Writable for Ch4CntrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH4_CNTR to value 0"]
impl crate :: Resettable for Ch4CntrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH4_OCR (rw) register accessor: Значение сравнения 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_ocr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_ocr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch4_ocr`]
module"]
# [doc (alias = "CH4_OCR")]
pub type Ch4Ocr = crate :: Reg < ch4_ocr :: Ch4OcrSpec > ; # [doc = "Значение сравнения 4 канала"]
pub mod ch4_ocr { # [doc = "Register `CH4_OCR` reader"]
pub type R = crate :: R < Ch4OcrSpec > ; # [doc = "Register `CH4_OCR` writer"]
pub type W = crate :: W < Ch4OcrSpec > ; # [doc = "Field `OCR` reader - Значение таймера в режиме сравнения"]
pub type OcrR = crate :: FieldReader < u32 > ; # [doc = "Field `OCR` writer - Значение таймера в режиме сравнения"]
pub type OcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& self) -> OcrR { OcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& mut self) -> OcrW < Ch4OcrSpec > { OcrW :: new (self , 0) } } # [doc = "Значение сравнения 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_ocr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_ocr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch4OcrSpec ; impl crate :: RegisterSpec for Ch4OcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch4_ocr::R`](R) reader structure"]
impl crate :: Readable for Ch4OcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch4_ocr::W`](W) writer structure"]
impl crate :: Writable for Ch4OcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH4_OCR to value 0"]
impl crate :: Resettable for Ch4OcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH4_ICR (rw) register accessor: Значение захвата 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch4_icr`]
module"]
# [doc (alias = "CH4_ICR")]
pub type Ch4Icr = crate :: Reg < ch4_icr :: Ch4IcrSpec > ; # [doc = "Значение захвата 4 канала"]
pub mod ch4_icr { # [doc = "Register `CH4_ICR` reader"]
pub type R = crate :: R < Ch4IcrSpec > ; # [doc = "Register `CH4_ICR` writer"]
pub type W = crate :: W < Ch4IcrSpec > ; # [doc = "Field `ICR` reader - Значение таймера в режиме захвата"]
pub type IcrR = crate :: FieldReader < u32 > ; # [doc = "Field `ICR` writer - Значение таймера в режиме захвата"]
pub type IcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& self) -> IcrR { IcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& mut self) -> IcrW < Ch4IcrSpec > { IcrW :: new (self , 0) } } # [doc = "Значение захвата 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch4IcrSpec ; impl crate :: RegisterSpec for Ch4IcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch4_icr::R`](R) reader structure"]
impl crate :: Readable for Ch4IcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch4_icr::W`](W) writer structure"]
impl crate :: Writable for Ch4IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH4_ICR to value 0"]
impl crate :: Resettable for Ch4IcrSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "регистры модуля таймера_2"]
pub struct Timer32_2 { _marker : PhantomData < * const () > } unsafe impl Send for Timer32_2 { } impl Timer32_2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const timer32_2 :: RegisterBlock = 0x0008_2c00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const timer32_2 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Timer32_2 { type Target = timer32_2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Timer32_2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Timer32_2") . finish () } } # [doc = "регистры модуля таймера_2"]
pub mod timer32_2 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { value : Value , top : Top , prescale : Prescale , control : Control , enable : Enable , int_mask : IntMask , int_clear : IntClear , int_flag : IntFlag , _reserved8 : [u8 ; 0x60]
, ch1_cntr : Ch1Cntr , ch1_ocr : Ch1Ocr , ch1_icr : Ch1Icr , _reserved11 : [u8 ; 0x04]
, _reserved_11_ch2_cntr : [u8 ; 0x04]
, ch2_ocr : Ch2Ocr , ch2_icr : Ch2Icr , _reserved14 : [u8 ; 0x08]
, ch3_ocr : Ch3Ocr , ch3_icr : Ch3Icr , _reserved16 : [u8 ; 0x04]
, ch4_cntr : Ch4Cntr , ch4_ocr : Ch4Ocr , ch4_icr : Ch4Icr , } impl RegisterBlock { # [doc = "0x00 - "]
# [inline (always)]
pub const fn value (& self) -> & Value { & self . value } # [doc = "0x04 - максимальное значение счетной последовательности"]
# [inline (always)]
pub const fn top (& self) -> & Top { & self . top } # [doc = "0x08 - значение делителя"]
# [inline (always)]
pub const fn prescale (& self) -> & Prescale { & self . prescale } # [doc = "0x0c - Конфигурационный регистр основного таймера"]
# [inline (always)]
pub const fn control (& self) -> & Control { & self . control } # [doc = "0x10 - Регистр включения таймера"]
# [inline (always)]
pub const fn enable (& self) -> & Enable { & self . enable } # [doc = "0x14 - Регистр маски прерываний"]
# [inline (always)]
pub const fn int_mask (& self) -> & IntMask { & self . int_mask } # [doc = "0x18 - Регистр сброса флагов прерываний"]
# [inline (always)]
pub const fn int_clear (& self) -> & IntClear { & self . int_clear } # [doc = "0x1c - Регистр флагов прерываний"]
# [inline (always)]
pub const fn int_flag (& self) -> & IntFlag { & self . int_flag } # [doc = "0x80 - Конфигурационный регистр 1 канала"]
# [inline (always)]
pub const fn ch1_cntr (& self) -> & Ch1Cntr { & self . ch1_cntr } # [doc = "0x84 - Значение сравнения 1 канала"]
# [inline (always)]
pub const fn ch1_ocr (& self) -> & Ch1Ocr { & self . ch1_ocr } # [doc = "0x88 - Значение захвата 1 канала"]
# [inline (always)]
pub const fn ch1_icr (& self) -> & Ch1Icr { & self . ch1_icr } # [doc = "0x90 - Конфигурационный регистр 3 канала"]
# [inline (always)]
pub const fn ch3_cntr (& self) -> & Ch3Cntr { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (144) . cast () } } # [doc = "0x90 - Конфигурационный регистр 2 канала"]
# [inline (always)]
pub const fn ch2_cntr (& self) -> & Ch2Cntr { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . add (144) . cast () } } # [doc = "0x94 - Значение сравнения 2 канала"]
# [inline (always)]
pub const fn ch2_ocr (& self) -> & Ch2Ocr { & self . ch2_ocr } # [doc = "0x98 - Значение захвата 2 канала"]
# [inline (always)]
pub const fn ch2_icr (& self) -> & Ch2Icr { & self . ch2_icr } # [doc = "0xa4 - Значение сравнения 3 канала"]
# [inline (always)]
pub const fn ch3_ocr (& self) -> & Ch3Ocr { & self . ch3_ocr } # [doc = "0xa8 - Значение захвата 3 канала"]
# [inline (always)]
pub const fn ch3_icr (& self) -> & Ch3Icr { & self . ch3_icr } # [doc = "0xb0 - Конфигурационный регистр 4 канала"]
# [inline (always)]
pub const fn ch4_cntr (& self) -> & Ch4Cntr { & self . ch4_cntr } # [doc = "0xb4 - Значение сравнения 4 канала"]
# [inline (always)]
pub const fn ch4_ocr (& self) -> & Ch4Ocr { & self . ch4_ocr } # [doc = "0xb8 - Значение захвата 4 канала"]
# [inline (always)]
pub const fn ch4_icr (& self) -> & Ch4Icr { & self . ch4_icr } } # [doc = "VALUE (rw) register accessor: \n\nYou can [`read`](crate::Reg::read) this register and get [`value::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`value::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@value`]
module"]
# [doc (alias = "VALUE")]
pub type Value = crate :: Reg < value :: ValueSpec > ; # [doc = ""]
pub mod value { # [doc = "Register `VALUE` reader"]
pub type R = crate :: R < ValueSpec > ; # [doc = "Register `VALUE` writer"]
pub type W = crate :: W < ValueSpec > ; # [doc = "Field `TIM_VAL` reader - текущее значение счетчика"]
pub type TimValR = crate :: FieldReader < u32 > ; impl R { # [doc = "Bits 0:31 - текущее значение счетчика"]
# [inline (always)]
pub fn tim_val (& self) -> TimValR { TimValR :: new (self . bits) } } impl W { } # [doc = "\n\nYou can [`read`](crate::Reg::read) this register and get [`value::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`value::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ValueSpec ; impl crate :: RegisterSpec for ValueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`value::R`](R) reader structure"]
impl crate :: Readable for ValueSpec { } # [doc = "`write(|w| ..)` method takes [`value::W`](W) writer structure"]
impl crate :: Writable for ValueSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets VALUE to value 0"]
impl crate :: Resettable for ValueSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TOP (rw) register accessor: максимальное значение счетной последовательности\n\nYou can [`read`](crate::Reg::read) this register and get [`top::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`top::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@top`]
module"]
# [doc (alias = "TOP")]
pub type Top = crate :: Reg < top :: TopSpec > ; # [doc = "максимальное значение счетной последовательности"]
pub mod top { # [doc = "Register `TOP` reader"]
pub type R = crate :: R < TopSpec > ; # [doc = "Register `TOP` writer"]
pub type W = crate :: W < TopSpec > ; # [doc = "Field `TIM_TOP` reader - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
pub type TimTopR = crate :: FieldReader < u32 > ; # [doc = "Field `TIM_TOP` writer - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
pub type TimTopW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
# [inline (always)]
pub fn tim_top (& self) -> TimTopR { TimTopR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - максимальное значение счетчика (ограничивает счетную последоваельность сверху)"]
# [inline (always)]
pub fn tim_top (& mut self) -> TimTopW < TopSpec > { TimTopW :: new (self , 0) } } # [doc = "максимальное значение счетной последовательности\n\nYou can [`read`](crate::Reg::read) this register and get [`top::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`top::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TopSpec ; impl crate :: RegisterSpec for TopSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`top::R`](R) reader structure"]
impl crate :: Readable for TopSpec { } # [doc = "`write(|w| ..)` method takes [`top::W`](W) writer structure"]
impl crate :: Writable for TopSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TOP to value 0xffff_ffff"]
impl crate :: Resettable for TopSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } } # [doc = "PRESCALE (rw) register accessor: значение делителя\n\nYou can [`read`](crate::Reg::read) this register and get [`prescale::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prescale::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@prescale`]
module"]
# [doc (alias = "PRESCALE")]
pub type Prescale = crate :: Reg < prescale :: PrescaleSpec > ; # [doc = "значение делителя"]
pub mod prescale { # [doc = "Register `PRESCALE` reader"]
pub type R = crate :: R < PrescaleSpec > ; # [doc = "Register `PRESCALE` writer"]
pub type W = crate :: W < PrescaleSpec > ; # [doc = "Field `TIM_PRESCALE` reader - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
pub type TimPrescaleR = crate :: FieldReader < u32 > ; # [doc = "Field `TIM_PRESCALE` writer - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
pub type TimPrescaleW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
# [inline (always)]
pub fn tim_prescale (& self) -> TimPrescaleR { TimPrescaleR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение предварительного делителя. Предделитель вырабатывает тактовый сигнал для счета, частота которого в целое раз меньше входной"]
# [inline (always)]
pub fn tim_prescale (& mut self) -> TimPrescaleW < PrescaleSpec > { TimPrescaleW :: new (self , 0) } } # [doc = "значение делителя\n\nYou can [`read`](crate::Reg::read) this register and get [`prescale::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`prescale::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct PrescaleSpec ; impl crate :: RegisterSpec for PrescaleSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`prescale::R`](R) reader structure"]
impl crate :: Readable for PrescaleSpec { } # [doc = "`write(|w| ..)` method takes [`prescale::W`](W) writer structure"]
impl crate :: Writable for PrescaleSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets PRESCALE to value 0"]
impl crate :: Resettable for PrescaleSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONTROL (rw) register accessor: Конфигурационный регистр основного таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control`]
module"]
# [doc (alias = "CONTROL")]
pub type Control = crate :: Reg < control :: ControlSpec > ; # [doc = "Конфигурационный регистр основного таймера"]
pub mod control { # [doc = "Register `CONTROL` reader"]
pub type R = crate :: R < ControlSpec > ; # [doc = "Register `CONTROL` writer"]
pub type W = crate :: W < ControlSpec > ; # [doc = "Режим счёта таймера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum CountMode { # [doc = "0: Прямой режим"]
Direct = 0 , # [doc = "1: Обратный режим"]
Reverse = 1 , # [doc = "2: Двунаправленный режим"]
Bidirectional = 2 , } impl From < CountMode > for u8 { # [inline (always)]
fn from (variant : CountMode) -> Self { variant as _ } } impl crate :: FieldSpec for CountMode { type Ux = u8 ; } impl crate :: IsEnum for CountMode { } # [doc = "Field `COUNT_MODE` reader - Режим счёта таймера"]
pub type CountModeR = crate :: FieldReader < CountMode > ; impl CountModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < CountMode > { match self . bits { 0 => Some (CountMode :: Direct) , 1 => Some (CountMode :: Reverse) , 2 => Some (CountMode :: Bidirectional) , _ => None , } } # [doc = "Прямой режим"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == CountMode :: Direct } # [doc = "Обратный режим"]
# [inline (always)]
pub fn is_reverse (& self) -> bool { * self == CountMode :: Reverse } # [doc = "Двунаправленный режим"]
# [inline (always)]
pub fn is_bidirectional (& self) -> bool { * self == CountMode :: Bidirectional } } # [doc = "Field `COUNT_MODE` writer - Режим счёта таймера"]
pub type CountModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , CountMode > ; impl < 'a , REG > CountModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Прямой режим"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Direct) } # [doc = "Обратный режим"]
# [inline (always)]
pub fn reverse (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Reverse) } # [doc = "Двунаправленный режим"]
# [inline (always)]
pub fn bidirectional (self) -> & 'a mut crate :: W < REG > { self . variant (CountMode :: Bidirectional) } } # [doc = "Выбор источника тактового сигнала для счета\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Sourse { # [doc = "0: Вход модуля TIM1"]
Tim1 = 0 , # [doc = "2: Вход модуля TIM2"]
Tim2 = 2 , # [doc = "3: Выход предделителя"]
Tim3 = 3 , } impl From < Sourse > for u8 { # [inline (always)]
fn from (variant : Sourse) -> Self { variant as _ } } impl crate :: FieldSpec for Sourse { type Ux = u8 ; } impl crate :: IsEnum for Sourse { } # [doc = "Field `SOURSE` reader - Выбор источника тактового сигнала для счета"]
pub type SourseR = crate :: FieldReader < Sourse > ; impl SourseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Sourse > { match self . bits { 0 => Some (Sourse :: Tim1) , 2 => Some (Sourse :: Tim2) , 3 => Some (Sourse :: Tim3) , _ => None , } } # [doc = "Вход модуля TIM1"]
# [inline (always)]
pub fn is_tim1 (& self) -> bool { * self == Sourse :: Tim1 } # [doc = "Вход модуля TIM2"]
# [inline (always)]
pub fn is_tim2 (& self) -> bool { * self == Sourse :: Tim2 } # [doc = "Выход предделителя"]
# [inline (always)]
pub fn is_tim3 (& self) -> bool { * self == Sourse :: Tim3 } } # [doc = "Field `SOURSE` writer - Выбор источника тактового сигнала для счета"]
pub type SourseW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Sourse > ; impl < 'a , REG > SourseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Вход модуля TIM1"]
# [inline (always)]
pub fn tim1 (self) -> & 'a mut crate :: W < REG > { self . variant (Sourse :: Tim1) } # [doc = "Вход модуля TIM2"]
# [inline (always)]
pub fn tim2 (self) -> & 'a mut crate :: W < REG > { self . variant (Sourse :: Tim2) } # [doc = "Выход предделителя"]
# [inline (always)]
pub fn tim3 (self) -> & 'a mut crate :: W < REG > { self . variant (Sourse :: Tim3) } } impl R { # [doc = "Bits 0:1 - Режим счёта таймера"]
# [inline (always)]
pub fn count_mode (& self) -> CountModeR { CountModeR :: new ((self . bits & 3) as u8) } # [doc = "Bits 2:3 - Выбор источника тактового сигнала для счета"]
# [inline (always)]
pub fn sourse (& self) -> SourseR { SourseR :: new (((self . bits >> 2) & 3) as u8) } } impl W { # [doc = "Bits 0:1 - Режим счёта таймера"]
# [inline (always)]
pub fn count_mode (& mut self) -> CountModeW < ControlSpec > { CountModeW :: new (self , 0) } # [doc = "Bits 2:3 - Выбор источника тактового сигнала для счета"]
# [inline (always)]
pub fn sourse (& mut self) -> SourseW < ControlSpec > { SourseW :: new (self , 2) } } # [doc = "Конфигурационный регистр основного таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ControlSpec ; impl crate :: RegisterSpec for ControlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`control::R`](R) reader structure"]
impl crate :: Readable for ControlSpec { } # [doc = "`write(|w| ..)` method takes [`control::W`](W) writer structure"]
impl crate :: Writable for ControlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL to value 0"]
impl crate :: Resettable for ControlSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ENABLE (rw) register accessor: Регистр включения таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable`]
module"]
# [doc (alias = "ENABLE")]
pub type Enable = crate :: Reg < enable :: EnableSpec > ; # [doc = "Регистр включения таймера"]
pub mod enable { # [doc = "Register `ENABLE` reader"]
pub type R = crate :: R < EnableSpec > ; # [doc = "Register `ENABLE` writer"]
pub type W = crate :: W < EnableSpec > ; # [doc = "Запуск/остановка работы счетчика\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TimEn { # [doc = "0: Счетчик выключен"]
Disable = 0 , # [doc = "1: Счетчик работает"]
Enable = 1 , } impl From < TimEn > for bool { # [inline (always)]
fn from (variant : TimEn) -> Self { variant as u8 != 0 } } # [doc = "Field `TIM_EN` reader - Запуск/остановка работы счетчика"]
pub type TimEnR = crate :: BitReader < TimEn > ; impl TimEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TimEn { match self . bits { false => TimEn :: Disable , true => TimEn :: Enable , } } # [doc = "Счетчик выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == TimEn :: Disable } # [doc = "Счетчик работает"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == TimEn :: Enable } } # [doc = "Field `TIM_EN` writer - Запуск/остановка работы счетчика"]
pub type TimEnW < 'a , REG > = crate :: BitWriter < 'a , REG , TimEn > ; impl < 'a , REG > TimEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Счетчик выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (TimEn :: Disable) } # [doc = "Счетчик работает"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (TimEn :: Enable) } } # [doc = "Field `TIM_CLR` writer - Сброс (обнуление) текущего значения счетчика при записи «1»"]
pub type TimClrW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Запуск/остановка работы счетчика"]
# [inline (always)]
pub fn tim_en (& self) -> TimEnR { TimEnR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Запуск/остановка работы счетчика"]
# [inline (always)]
pub fn tim_en (& mut self) -> TimEnW < EnableSpec > { TimEnW :: new (self , 0) } # [doc = "Bit 1 - Сброс (обнуление) текущего значения счетчика при записи «1»"]
# [inline (always)]
pub fn tim_clr (& mut self) -> TimClrW < EnableSpec > { TimClrW :: new (self , 1) } } # [doc = "Регистр включения таймера\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EnableSpec ; impl crate :: RegisterSpec for EnableSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`enable::R`](R) reader structure"]
impl crate :: Readable for EnableSpec { } # [doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
impl crate :: Writable for EnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ENABLE to value 0"]
impl crate :: Resettable for EnableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INT_MASK (rw) register accessor: Регистр маски прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mask::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mask::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_mask`]
module"]
# [doc (alias = "INT_MASK")]
pub type IntMask = crate :: Reg < int_mask :: IntMaskSpec > ; # [doc = "Регистр маски прерываний"]
pub mod int_mask { # [doc = "Register `INT_MASK` reader"]
pub type R = crate :: R < IntMaskSpec > ; # [doc = "Register `INT_MASK` writer"]
pub type W = crate :: W < IntMaskSpec > ; # [doc = "Field `OVF_Int` reader - Маска прерывания по переполнению счетчика"]
pub type OvfIntR = crate :: BitReader ; # [doc = "Field `OVF_Int` writer - Маска прерывания по переполнению счетчика"]
pub type OvfIntW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `UDF_Int` reader - Маска прерывания опустошения счетчика"]
pub type UdfIntR = crate :: BitReader ; # [doc = "Field `UDF_Int` writer - Маска прерывания опустошения счетчика"]
pub type UdfIntW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH1` reader - Маска прерывания захвата 1 канала таймера"]
pub type IcIntCh1R = crate :: BitReader ; # [doc = "Field `IC_Int_CH1` writer - Маска прерывания захвата 1 канала таймера"]
pub type IcIntCh1W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH2` reader - Маска прерывания захвата 2 канала таймера"]
pub type IcIntCh2R = crate :: BitReader ; # [doc = "Field `IC_Int_CH2` writer - Маска прерывания захвата 2 канала таймера"]
pub type IcIntCh2W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH3` reader - Маска прерывания захвата 3 канала таймера"]
pub type IcIntCh3R = crate :: BitReader ; # [doc = "Field `IC_Int_CH3` writer - Маска прерывания захвата 3 канала таймера"]
pub type IcIntCh3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `IC_Int_CH4` reader - Маска прерывания захвата 4 канала таймера"]
pub type IcIntCh4R = crate :: BitReader ; # [doc = "Field `IC_Int_CH4` writer - Маска прерывания захвата 4 канала таймера"]
pub type IcIntCh4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH1` reader - Маска прерывания совпадения 1 канала таймера"]
pub type OcIntCh1R = crate :: BitReader ; # [doc = "Field `OC_Int_CH1` writer - Маска прерывания совпадения 1 канала таймера"]
pub type OcIntCh1W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH2` reader - Маска прерывания совпадения 2 канала таймера"]
pub type OcIntCh2R = crate :: BitReader ; # [doc = "Field `OC_Int_CH2` writer - Маска прерывания совпадения 2 канала таймера"]
pub type OcIntCh2W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH3` reader - Маска прерывания совпадения 3 канала таймера"]
pub type OcIntCh3R = crate :: BitReader ; # [doc = "Field `OC_Int_CH3` writer - Маска прерывания совпадения 3 канала таймера"]
pub type OcIntCh3W < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OC_Int_CH4` reader - Маска прерывания совпадения 4 канала таймера"]
pub type OcIntCh4R = crate :: BitReader ; # [doc = "Field `OC_Int_CH4` writer - Маска прерывания совпадения 4 канала таймера"]
pub type OcIntCh4W < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Маска прерывания по переполнению счетчика"]
# [inline (always)]
pub fn ovf_int (& self) -> OvfIntR { OvfIntR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Маска прерывания опустошения счетчика"]
# [inline (always)]
pub fn udf_int (& self) -> UdfIntR { UdfIntR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Маска прерывания захвата 1 канала таймера"]
# [inline (always)]
pub fn ic_int_ch1 (& self) -> IcIntCh1R { IcIntCh1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Маска прерывания захвата 2 канала таймера"]
# [inline (always)]
pub fn ic_int_ch2 (& self) -> IcIntCh2R { IcIntCh2R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Маска прерывания захвата 3 канала таймера"]
# [inline (always)]
pub fn ic_int_ch3 (& self) -> IcIntCh3R { IcIntCh3R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Маска прерывания захвата 4 канала таймера"]
# [inline (always)]
pub fn ic_int_ch4 (& self) -> IcIntCh4R { IcIntCh4R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Маска прерывания совпадения 1 канала таймера"]
# [inline (always)]
pub fn oc_int_ch1 (& self) -> OcIntCh1R { OcIntCh1R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Маска прерывания совпадения 2 канала таймера"]
# [inline (always)]
pub fn oc_int_ch2 (& self) -> OcIntCh2R { OcIntCh2R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Маска прерывания совпадения 3 канала таймера"]
# [inline (always)]
pub fn oc_int_ch3 (& self) -> OcIntCh3R { OcIntCh3R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Маска прерывания совпадения 4 канала таймера"]
# [inline (always)]
pub fn oc_int_ch4 (& self) -> OcIntCh4R { OcIntCh4R :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Маска прерывания по переполнению счетчика"]
# [inline (always)]
pub fn ovf_int (& mut self) -> OvfIntW < IntMaskSpec > { OvfIntW :: new (self , 0) } # [doc = "Bit 1 - Маска прерывания опустошения счетчика"]
# [inline (always)]
pub fn udf_int (& mut self) -> UdfIntW < IntMaskSpec > { UdfIntW :: new (self , 1) } # [doc = "Bit 2 - Маска прерывания захвата 1 канала таймера"]
# [inline (always)]
pub fn ic_int_ch1 (& mut self) -> IcIntCh1W < IntMaskSpec > { IcIntCh1W :: new (self , 2) } # [doc = "Bit 3 - Маска прерывания захвата 2 канала таймера"]
# [inline (always)]
pub fn ic_int_ch2 (& mut self) -> IcIntCh2W < IntMaskSpec > { IcIntCh2W :: new (self , 3) } # [doc = "Bit 4 - Маска прерывания захвата 3 канала таймера"]
# [inline (always)]
pub fn ic_int_ch3 (& mut self) -> IcIntCh3W < IntMaskSpec > { IcIntCh3W :: new (self , 4) } # [doc = "Bit 5 - Маска прерывания захвата 4 канала таймера"]
# [inline (always)]
pub fn ic_int_ch4 (& mut self) -> IcIntCh4W < IntMaskSpec > { IcIntCh4W :: new (self , 5) } # [doc = "Bit 6 - Маска прерывания совпадения 1 канала таймера"]
# [inline (always)]
pub fn oc_int_ch1 (& mut self) -> OcIntCh1W < IntMaskSpec > { OcIntCh1W :: new (self , 6) } # [doc = "Bit 7 - Маска прерывания совпадения 2 канала таймера"]
# [inline (always)]
pub fn oc_int_ch2 (& mut self) -> OcIntCh2W < IntMaskSpec > { OcIntCh2W :: new (self , 7) } # [doc = "Bit 8 - Маска прерывания совпадения 3 канала таймера"]
# [inline (always)]
pub fn oc_int_ch3 (& mut self) -> OcIntCh3W < IntMaskSpec > { OcIntCh3W :: new (self , 8) } # [doc = "Bit 9 - Маска прерывания совпадения 4 канала таймера"]
# [inline (always)]
pub fn oc_int_ch4 (& mut self) -> OcIntCh4W < IntMaskSpec > { OcIntCh4W :: new (self , 9) } } # [doc = "Регистр маски прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mask::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_mask::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntMaskSpec ; impl crate :: RegisterSpec for IntMaskSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`int_mask::R`](R) reader structure"]
impl crate :: Readable for IntMaskSpec { } # [doc = "`write(|w| ..)` method takes [`int_mask::W`](W) writer structure"]
impl crate :: Writable for IntMaskSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_MASK to value 0"]
impl crate :: Resettable for IntMaskSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INT_CLEAR (rw) register accessor: Регистр сброса флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_clear::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_clear::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_clear`]
module"]
# [doc (alias = "INT_CLEAR")]
pub type IntClear = crate :: Reg < int_clear :: IntClearSpec > ; # [doc = "Регистр сброса флагов прерываний"]
pub mod int_clear { # [doc = "Register `INT_CLEAR` reader"]
pub type R = crate :: R < IntClearSpec > ; # [doc = "Register `INT_CLEAR` writer"]
pub type W = crate :: W < IntClearSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр сброса флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_clear::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_clear::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntClearSpec ; impl crate :: RegisterSpec for IntClearSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`int_clear::R`](R) reader structure"]
impl crate :: Readable for IntClearSpec { } # [doc = "`write(|w| ..)` method takes [`int_clear::W`](W) writer structure"]
impl crate :: Writable for IntClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_CLEAR to value 0xffff_ffff"]
impl crate :: Resettable for IntClearSpec { const RESET_VALUE : u32 = 0xffff_ffff ; } } # [doc = "INT_FLAG (rw) register accessor: Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_flag`]
module"]
# [doc (alias = "INT_FLAG")]
pub type IntFlag = crate :: Reg < int_flag :: IntFlagSpec > ; # [doc = "Регистр флагов прерываний"]
pub mod int_flag { # [doc = "Register `INT_FLAG` reader"]
pub type R = crate :: R < IntFlagSpec > ; # [doc = "Register `INT_FLAG` writer"]
pub type W = crate :: W < IntFlagSpec > ; # [doc = "Field `OVF_Int` reader - Статус прерывания по переполнению счетчика"]
pub type OvfIntR = crate :: BitReader ; # [doc = "Field `UDF_Int` reader - Статус прерывания опустошения счетчика"]
pub type UdfIntR = crate :: BitReader ; # [doc = "Field `IC_Int_CH1` reader - Статус прерывания захвата 1 канала таймера"]
pub type IcIntCh1R = crate :: BitReader ; # [doc = "Field `IC_Int_CH2` reader - Статус прерывания захвата 2 канала таймера"]
pub type IcIntCh2R = crate :: BitReader ; # [doc = "Field `IC_Int_CH3` reader - Статус прерывания захвата 3 канала таймера"]
pub type IcIntCh3R = crate :: BitReader ; # [doc = "Field `IC_Int_CH4` reader - Статус прерывания захвата 4 канала таймера"]
pub type IcIntCh4R = crate :: BitReader ; # [doc = "Field `OC_Int_CH1` reader - Статус прерывания совпадения 1 канала таймера"]
pub type OcIntCh1R = crate :: BitReader ; # [doc = "Field `OC_Int_CH2` reader - Статус прерывания совпадения 2 канала таймера"]
pub type OcIntCh2R = crate :: BitReader ; # [doc = "Field `OC_Int_CH3` reader - Статус прерывания совпадения 3 канала таймера"]
pub type OcIntCh3R = crate :: BitReader ; # [doc = "Field `OC_Int_CH4` reader - Статус прерывания совпадения 4 канала таймера"]
pub type OcIntCh4R = crate :: BitReader ; impl R { # [doc = "Bit 0 - Статус прерывания по переполнению счетчика"]
# [inline (always)]
pub fn ovf_int (& self) -> OvfIntR { OvfIntR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Статус прерывания опустошения счетчика"]
# [inline (always)]
pub fn udf_int (& self) -> UdfIntR { UdfIntR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Статус прерывания захвата 1 канала таймера"]
# [inline (always)]
pub fn ic_int_ch1 (& self) -> IcIntCh1R { IcIntCh1R :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Статус прерывания захвата 2 канала таймера"]
# [inline (always)]
pub fn ic_int_ch2 (& self) -> IcIntCh2R { IcIntCh2R :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Статус прерывания захвата 3 канала таймера"]
# [inline (always)]
pub fn ic_int_ch3 (& self) -> IcIntCh3R { IcIntCh3R :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Статус прерывания захвата 4 канала таймера"]
# [inline (always)]
pub fn ic_int_ch4 (& self) -> IcIntCh4R { IcIntCh4R :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Статус прерывания совпадения 1 канала таймера"]
# [inline (always)]
pub fn oc_int_ch1 (& self) -> OcIntCh1R { OcIntCh1R :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Статус прерывания совпадения 2 канала таймера"]
# [inline (always)]
pub fn oc_int_ch2 (& self) -> OcIntCh2R { OcIntCh2R :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Статус прерывания совпадения 3 канала таймера"]
# [inline (always)]
pub fn oc_int_ch3 (& self) -> OcIntCh3R { OcIntCh3R :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Статус прерывания совпадения 4 канала таймера"]
# [inline (always)]
pub fn oc_int_ch4 (& self) -> OcIntCh4R { OcIntCh4R :: new (((self . bits >> 9) & 1) != 0) } } impl W { } # [doc = "Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_flag::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_flag::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntFlagSpec ; impl crate :: RegisterSpec for IntFlagSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`int_flag::R`](R) reader structure"]
impl crate :: Readable for IntFlagSpec { } # [doc = "`write(|w| ..)` method takes [`int_flag::W`](W) writer structure"]
impl crate :: Writable for IntFlagSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_FLAG to value 0"]
impl crate :: Resettable for IntFlagSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH1_CNTR (rw) register accessor: Конфигурационный регистр 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_cntr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_cntr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch1_cntr`]
module"]
# [doc (alias = "CH1_CNTR")]
pub type Ch1Cntr = crate :: Reg < ch1_cntr :: Ch1CntrSpec > ; # [doc = "Конфигурационный регистр 1 канала"]
pub mod ch1_cntr { # [doc = "Register `CH1_CNTR` reader"]
pub type R = crate :: R < Ch1CntrSpec > ; # [doc = "Register `CH1_CNTR` writer"]
pub type W = crate :: W < Ch1CntrSpec > ; # [doc = "Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Noise { # [doc = "0: Фильтрация выключена"]
Enable = 0 , # [doc = "1: Фильтрация включена"]
Disable = 1 , } impl From < Noise > for bool { # [inline (always)]
fn from (variant : Noise) -> Self { variant as u8 != 0 } } # [doc = "Field `NOISE` reader - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseR = crate :: BitReader < Noise > ; impl NoiseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Noise { match self . bits { false => Noise :: Enable , true => Noise :: Disable , } } # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Noise :: Enable } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Noise :: Disable } } # [doc = "Field `NOISE` writer - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseW < 'a , REG > = crate :: BitWriter < 'a , REG , Noise > ; impl < 'a , REG > NoiseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Enable) } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Disable) } } # [doc = "Режим сигнала захвата\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Edge { # [doc = "0: фронт"]
Front = 0 , # [doc = "1: срез"]
Back = 1 , } impl From < Edge > for bool { # [inline (always)]
fn from (variant : Edge) -> Self { variant as u8 != 0 } } # [doc = "Field `EDGE` reader - Режим сигнала захвата"]
pub type EdgeR = crate :: BitReader < Edge > ; impl EdgeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Edge { match self . bits { false => Edge :: Front , true => Edge :: Back , } } # [doc = "фронт"]
# [inline (always)]
pub fn is_front (& self) -> bool { * self == Edge :: Front } # [doc = "срез"]
# [inline (always)]
pub fn is_back (& self) -> bool { * self == Edge :: Back } } # [doc = "Field `EDGE` writer - Режим сигнала захвата"]
pub type EdgeW < 'a , REG > = crate :: BitWriter < 'a , REG , Edge > ; impl < 'a , REG > EdgeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "фронт"]
# [inline (always)]
pub fn front (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Front) } # [doc = "срез"]
# [inline (always)]
pub fn back (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Back) } } # [doc = "Режим работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Mode { # [doc = "1: Режим сравнения (для timer0)"]
Compare = 1 , # [doc = "2: Режим захвата(для timer0)"]
Capture = 2 , # [doc = "3: ШИМ"]
Pwm = 3 , } impl From < Mode > for u8 { # [inline (always)]
fn from (variant : Mode) -> Self { variant as _ } } impl crate :: FieldSpec for Mode { type Ux = u8 ; } impl crate :: IsEnum for Mode { } # [doc = "Field `MODE` reader - Режим работы канала"]
pub type ModeR = crate :: FieldReader < Mode > ; impl ModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Mode { match self . bits { 1 => Mode :: Compare , 2 => Mode :: Capture , 3 => Mode :: Pwm , _ => unreachable ! () , } } # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn is_compare (& self) -> bool { * self == Mode :: Compare } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn is_capture (& self) -> bool { * self == Mode :: Capture } # [doc = "ШИМ"]
# [inline (always)]
pub fn is_pwm (& self) -> bool { * self == Mode :: Pwm } } # [doc = "Field `MODE` writer - Режим работы канала"]
pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mode > ; impl < 'a , REG > ModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn compare (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Compare) } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn capture (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Capture) } # [doc = "ШИМ"]
# [inline (always)]
pub fn pwm (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Pwm) } } # [doc = "Field `EN` reader - Включение/выключение канала"]
pub type EnR = crate :: BitReader ; # [doc = "Field `EN` writer - Включение/выключение канала"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Тип вывода в режиме ШИМ инвертирование\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PwmInv { # [doc = "1: Прямой (не инвертированный) выход"]
Direct = 1 , # [doc = "0: Инвертированный выход"]
Inverted = 0 , } impl From < PwmInv > for bool { # [inline (always)]
fn from (variant : PwmInv) -> Self { variant as u8 != 0 } } # [doc = "Field `PWM_INV` reader - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvR = crate :: BitReader < PwmInv > ; impl PwmInvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PwmInv { match self . bits { true => PwmInv :: Direct , false => PwmInv :: Inverted , } } # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == PwmInv :: Direct } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == PwmInv :: Inverted } } # [doc = "Field `PWM_INV` writer - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvW < 'a , REG > = crate :: BitWriter < 'a , REG , PwmInv > ; impl < 'a , REG > PwmInvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Direct) } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Inverted) } } # [doc = "Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dir { # [doc = "1: Выход"]
Output = 1 , # [doc = "0: Вход"]
Input = 0 , } impl From < Dir > for bool { # [inline (always)]
fn from (variant : Dir) -> Self { variant as u8 != 0 } } # [doc = "Field `DIR` reader - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
pub type DirR = crate :: BitReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dir { match self . bits { true => Dir :: Output , false => Dir :: Input , } } # [doc = "Выход"]
# [inline (always)]
pub fn is_output (& self) -> bool { * self == Dir :: Output } # [doc = "Вход"]
# [inline (always)]
pub fn is_input (& self) -> bool { * self == Dir :: Input } } impl R { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& self) -> NoiseR { NoiseR :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& self) -> EdgeR { EdgeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& self) -> PwmInvR { PwmInvR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
# [inline (always)]
pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& mut self) -> NoiseW < Ch1CntrSpec > { NoiseW :: new (self , 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& mut self) -> EdgeW < Ch1CntrSpec > { EdgeW :: new (self , 4) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& mut self) -> ModeW < Ch1CntrSpec > { ModeW :: new (self , 5) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& mut self) -> EnW < Ch1CntrSpec > { EnW :: new (self , 7) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& mut self) -> PwmInvW < Ch1CntrSpec > { PwmInvW :: new (self , 8) } } # [doc = "Конфигурационный регистр 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_cntr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_cntr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch1CntrSpec ; impl crate :: RegisterSpec for Ch1CntrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch1_cntr::R`](R) reader structure"]
impl crate :: Readable for Ch1CntrSpec { } # [doc = "`write(|w| ..)` method takes [`ch1_cntr::W`](W) writer structure"]
impl crate :: Writable for Ch1CntrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH1_CNTR to value 0"]
impl crate :: Resettable for Ch1CntrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH1_OCR (rw) register accessor: Значение сравнения 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_ocr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_ocr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch1_ocr`]
module"]
# [doc (alias = "CH1_OCR")]
pub type Ch1Ocr = crate :: Reg < ch1_ocr :: Ch1OcrSpec > ; # [doc = "Значение сравнения 1 канала"]
pub mod ch1_ocr { # [doc = "Register `CH1_OCR` reader"]
pub type R = crate :: R < Ch1OcrSpec > ; # [doc = "Register `CH1_OCR` writer"]
pub type W = crate :: W < Ch1OcrSpec > ; # [doc = "Field `OCR` reader - Значение таймера в режиме сравнения"]
pub type OcrR = crate :: FieldReader < u32 > ; # [doc = "Field `OCR` writer - Значение таймера в режиме сравнения"]
pub type OcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& self) -> OcrR { OcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& mut self) -> OcrW < Ch1OcrSpec > { OcrW :: new (self , 0) } } # [doc = "Значение сравнения 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_ocr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_ocr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch1OcrSpec ; impl crate :: RegisterSpec for Ch1OcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch1_ocr::R`](R) reader structure"]
impl crate :: Readable for Ch1OcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch1_ocr::W`](W) writer structure"]
impl crate :: Writable for Ch1OcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH1_OCR to value 0"]
impl crate :: Resettable for Ch1OcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH1_ICR (rw) register accessor: Значение захвата 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch1_icr`]
module"]
# [doc (alias = "CH1_ICR")]
pub type Ch1Icr = crate :: Reg < ch1_icr :: Ch1IcrSpec > ; # [doc = "Значение захвата 1 канала"]
pub mod ch1_icr { # [doc = "Register `CH1_ICR` reader"]
pub type R = crate :: R < Ch1IcrSpec > ; # [doc = "Register `CH1_ICR` writer"]
pub type W = crate :: W < Ch1IcrSpec > ; # [doc = "Field `ICR` reader - Значение таймера в режиме захвата"]
pub type IcrR = crate :: FieldReader < u32 > ; # [doc = "Field `ICR` writer - Значение таймера в режиме захвата"]
pub type IcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& self) -> IcrR { IcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& mut self) -> IcrW < Ch1IcrSpec > { IcrW :: new (self , 0) } } # [doc = "Значение захвата 1 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch1_icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch1_icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch1IcrSpec ; impl crate :: RegisterSpec for Ch1IcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch1_icr::R`](R) reader structure"]
impl crate :: Readable for Ch1IcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch1_icr::W`](W) writer structure"]
impl crate :: Writable for Ch1IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH1_ICR to value 0"]
impl crate :: Resettable for Ch1IcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH2_CNTR (rw) register accessor: Конфигурационный регистр 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_cntr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_cntr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch2_cntr`]
module"]
# [doc (alias = "CH2_CNTR")]
pub type Ch2Cntr = crate :: Reg < ch2_cntr :: Ch2CntrSpec > ; # [doc = "Конфигурационный регистр 2 канала"]
pub mod ch2_cntr { # [doc = "Register `CH2_CNTR` reader"]
pub type R = crate :: R < Ch2CntrSpec > ; # [doc = "Register `CH2_CNTR` writer"]
pub type W = crate :: W < Ch2CntrSpec > ; # [doc = "Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Noise { # [doc = "0: Фильтрация выключена"]
Enable = 0 , # [doc = "1: Фильтрация включена"]
Disable = 1 , } impl From < Noise > for bool { # [inline (always)]
fn from (variant : Noise) -> Self { variant as u8 != 0 } } # [doc = "Field `NOISE` reader - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseR = crate :: BitReader < Noise > ; impl NoiseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Noise { match self . bits { false => Noise :: Enable , true => Noise :: Disable , } } # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Noise :: Enable } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Noise :: Disable } } # [doc = "Field `NOISE` writer - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseW < 'a , REG > = crate :: BitWriter < 'a , REG , Noise > ; impl < 'a , REG > NoiseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Enable) } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Disable) } } # [doc = "Режим сигнала захвата\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Edge { # [doc = "0: фронт"]
Front = 0 , # [doc = "1: срез"]
Back = 1 , } impl From < Edge > for bool { # [inline (always)]
fn from (variant : Edge) -> Self { variant as u8 != 0 } } # [doc = "Field `EDGE` reader - Режим сигнала захвата"]
pub type EdgeR = crate :: BitReader < Edge > ; impl EdgeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Edge { match self . bits { false => Edge :: Front , true => Edge :: Back , } } # [doc = "фронт"]
# [inline (always)]
pub fn is_front (& self) -> bool { * self == Edge :: Front } # [doc = "срез"]
# [inline (always)]
pub fn is_back (& self) -> bool { * self == Edge :: Back } } # [doc = "Field `EDGE` writer - Режим сигнала захвата"]
pub type EdgeW < 'a , REG > = crate :: BitWriter < 'a , REG , Edge > ; impl < 'a , REG > EdgeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "фронт"]
# [inline (always)]
pub fn front (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Front) } # [doc = "срез"]
# [inline (always)]
pub fn back (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Back) } } # [doc = "Режим работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Mode { # [doc = "1: Режим сравнения (для timer0)"]
Compare = 1 , # [doc = "2: Режим захвата(для timer0)"]
Capture = 2 , # [doc = "3: ШИМ"]
Pwm = 3 , } impl From < Mode > for u8 { # [inline (always)]
fn from (variant : Mode) -> Self { variant as _ } } impl crate :: FieldSpec for Mode { type Ux = u8 ; } impl crate :: IsEnum for Mode { } # [doc = "Field `MODE` reader - Режим работы канала"]
pub type ModeR = crate :: FieldReader < Mode > ; impl ModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Mode { match self . bits { 1 => Mode :: Compare , 2 => Mode :: Capture , 3 => Mode :: Pwm , _ => unreachable ! () , } } # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn is_compare (& self) -> bool { * self == Mode :: Compare } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn is_capture (& self) -> bool { * self == Mode :: Capture } # [doc = "ШИМ"]
# [inline (always)]
pub fn is_pwm (& self) -> bool { * self == Mode :: Pwm } } # [doc = "Field `MODE` writer - Режим работы канала"]
pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mode > ; impl < 'a , REG > ModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn compare (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Compare) } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn capture (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Capture) } # [doc = "ШИМ"]
# [inline (always)]
pub fn pwm (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Pwm) } } # [doc = "Field `EN` reader - Включение/выключение канала"]
pub type EnR = crate :: BitReader ; # [doc = "Field `EN` writer - Включение/выключение канала"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Тип вывода в режиме ШИМ инвертирование\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PwmInv { # [doc = "1: Прямой (не инвертированный) выход"]
Direct = 1 , # [doc = "0: Инвертированный выход"]
Inverted = 0 , } impl From < PwmInv > for bool { # [inline (always)]
fn from (variant : PwmInv) -> Self { variant as u8 != 0 } } # [doc = "Field `PWM_INV` reader - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvR = crate :: BitReader < PwmInv > ; impl PwmInvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PwmInv { match self . bits { true => PwmInv :: Direct , false => PwmInv :: Inverted , } } # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == PwmInv :: Direct } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == PwmInv :: Inverted } } # [doc = "Field `PWM_INV` writer - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvW < 'a , REG > = crate :: BitWriter < 'a , REG , PwmInv > ; impl < 'a , REG > PwmInvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Direct) } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Inverted) } } # [doc = "Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dir { # [doc = "1: Выход"]
Output = 1 , # [doc = "0: Вход"]
Input = 0 , } impl From < Dir > for bool { # [inline (always)]
fn from (variant : Dir) -> Self { variant as u8 != 0 } } # [doc = "Field `DIR` reader - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
pub type DirR = crate :: BitReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dir { match self . bits { true => Dir :: Output , false => Dir :: Input , } } # [doc = "Выход"]
# [inline (always)]
pub fn is_output (& self) -> bool { * self == Dir :: Output } # [doc = "Вход"]
# [inline (always)]
pub fn is_input (& self) -> bool { * self == Dir :: Input } } impl R { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& self) -> NoiseR { NoiseR :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& self) -> EdgeR { EdgeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& self) -> PwmInvR { PwmInvR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
# [inline (always)]
pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& mut self) -> NoiseW < Ch2CntrSpec > { NoiseW :: new (self , 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& mut self) -> EdgeW < Ch2CntrSpec > { EdgeW :: new (self , 4) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& mut self) -> ModeW < Ch2CntrSpec > { ModeW :: new (self , 5) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& mut self) -> EnW < Ch2CntrSpec > { EnW :: new (self , 7) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& mut self) -> PwmInvW < Ch2CntrSpec > { PwmInvW :: new (self , 8) } } # [doc = "Конфигурационный регистр 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_cntr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_cntr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch2CntrSpec ; impl crate :: RegisterSpec for Ch2CntrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch2_cntr::R`](R) reader structure"]
impl crate :: Readable for Ch2CntrSpec { } # [doc = "`write(|w| ..)` method takes [`ch2_cntr::W`](W) writer structure"]
impl crate :: Writable for Ch2CntrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH2_CNTR to value 0"]
impl crate :: Resettable for Ch2CntrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH2_OCR (rw) register accessor: Значение сравнения 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_ocr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_ocr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch2_ocr`]
module"]
# [doc (alias = "CH2_OCR")]
pub type Ch2Ocr = crate :: Reg < ch2_ocr :: Ch2OcrSpec > ; # [doc = "Значение сравнения 2 канала"]
pub mod ch2_ocr { # [doc = "Register `CH2_OCR` reader"]
pub type R = crate :: R < Ch2OcrSpec > ; # [doc = "Register `CH2_OCR` writer"]
pub type W = crate :: W < Ch2OcrSpec > ; # [doc = "Field `OCR` reader - Значение таймера в режиме сравнения"]
pub type OcrR = crate :: FieldReader < u32 > ; # [doc = "Field `OCR` writer - Значение таймера в режиме сравнения"]
pub type OcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& self) -> OcrR { OcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& mut self) -> OcrW < Ch2OcrSpec > { OcrW :: new (self , 0) } } # [doc = "Значение сравнения 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_ocr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_ocr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch2OcrSpec ; impl crate :: RegisterSpec for Ch2OcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch2_ocr::R`](R) reader structure"]
impl crate :: Readable for Ch2OcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch2_ocr::W`](W) writer structure"]
impl crate :: Writable for Ch2OcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH2_OCR to value 0"]
impl crate :: Resettable for Ch2OcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH2_ICR (rw) register accessor: Значение захвата 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch2_icr`]
module"]
# [doc (alias = "CH2_ICR")]
pub type Ch2Icr = crate :: Reg < ch2_icr :: Ch2IcrSpec > ; # [doc = "Значение захвата 2 канала"]
pub mod ch2_icr { # [doc = "Register `CH2_ICR` reader"]
pub type R = crate :: R < Ch2IcrSpec > ; # [doc = "Register `CH2_ICR` writer"]
pub type W = crate :: W < Ch2IcrSpec > ; # [doc = "Field `ICR` reader - Значение таймера в режиме захвата"]
pub type IcrR = crate :: FieldReader < u32 > ; # [doc = "Field `ICR` writer - Значение таймера в режиме захвата"]
pub type IcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& self) -> IcrR { IcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& mut self) -> IcrW < Ch2IcrSpec > { IcrW :: new (self , 0) } } # [doc = "Значение захвата 2 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch2_icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch2_icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch2IcrSpec ; impl crate :: RegisterSpec for Ch2IcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch2_icr::R`](R) reader structure"]
impl crate :: Readable for Ch2IcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch2_icr::W`](W) writer structure"]
impl crate :: Writable for Ch2IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH2_ICR to value 0"]
impl crate :: Resettable for Ch2IcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH3_CNTR (rw) register accessor: Конфигурационный регистр 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_cntr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_cntr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch3_cntr`]
module"]
# [doc (alias = "CH3_CNTR")]
pub type Ch3Cntr = crate :: Reg < ch3_cntr :: Ch3CntrSpec > ; # [doc = "Конфигурационный регистр 3 канала"]
pub mod ch3_cntr { # [doc = "Register `CH3_CNTR` reader"]
pub type R = crate :: R < Ch3CntrSpec > ; # [doc = "Register `CH3_CNTR` writer"]
pub type W = crate :: W < Ch3CntrSpec > ; # [doc = "Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Noise { # [doc = "0: Фильтрация выключена"]
Enable = 0 , # [doc = "1: Фильтрация включена"]
Disable = 1 , } impl From < Noise > for bool { # [inline (always)]
fn from (variant : Noise) -> Self { variant as u8 != 0 } } # [doc = "Field `NOISE` reader - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseR = crate :: BitReader < Noise > ; impl NoiseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Noise { match self . bits { false => Noise :: Enable , true => Noise :: Disable , } } # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Noise :: Enable } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Noise :: Disable } } # [doc = "Field `NOISE` writer - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseW < 'a , REG > = crate :: BitWriter < 'a , REG , Noise > ; impl < 'a , REG > NoiseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Enable) } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Disable) } } # [doc = "Режим сигнала захвата\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Edge { # [doc = "0: фронт"]
Front = 0 , # [doc = "1: срез"]
Back = 1 , } impl From < Edge > for bool { # [inline (always)]
fn from (variant : Edge) -> Self { variant as u8 != 0 } } # [doc = "Field `EDGE` reader - Режим сигнала захвата"]
pub type EdgeR = crate :: BitReader < Edge > ; impl EdgeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Edge { match self . bits { false => Edge :: Front , true => Edge :: Back , } } # [doc = "фронт"]
# [inline (always)]
pub fn is_front (& self) -> bool { * self == Edge :: Front } # [doc = "срез"]
# [inline (always)]
pub fn is_back (& self) -> bool { * self == Edge :: Back } } # [doc = "Field `EDGE` writer - Режим сигнала захвата"]
pub type EdgeW < 'a , REG > = crate :: BitWriter < 'a , REG , Edge > ; impl < 'a , REG > EdgeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "фронт"]
# [inline (always)]
pub fn front (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Front) } # [doc = "срез"]
# [inline (always)]
pub fn back (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Back) } } # [doc = "Режим работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Mode { # [doc = "1: Режим сравнения (для timer0)"]
Compare = 1 , # [doc = "2: Режим захвата(для timer0)"]
Capture = 2 , # [doc = "3: ШИМ"]
Pwm = 3 , } impl From < Mode > for u8 { # [inline (always)]
fn from (variant : Mode) -> Self { variant as _ } } impl crate :: FieldSpec for Mode { type Ux = u8 ; } impl crate :: IsEnum for Mode { } # [doc = "Field `MODE` reader - Режим работы канала"]
pub type ModeR = crate :: FieldReader < Mode > ; impl ModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Mode { match self . bits { 1 => Mode :: Compare , 2 => Mode :: Capture , 3 => Mode :: Pwm , _ => unreachable ! () , } } # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn is_compare (& self) -> bool { * self == Mode :: Compare } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn is_capture (& self) -> bool { * self == Mode :: Capture } # [doc = "ШИМ"]
# [inline (always)]
pub fn is_pwm (& self) -> bool { * self == Mode :: Pwm } } # [doc = "Field `MODE` writer - Режим работы канала"]
pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mode > ; impl < 'a , REG > ModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn compare (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Compare) } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn capture (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Capture) } # [doc = "ШИМ"]
# [inline (always)]
pub fn pwm (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Pwm) } } # [doc = "Field `EN` reader - Включение/выключение канала"]
pub type EnR = crate :: BitReader ; # [doc = "Field `EN` writer - Включение/выключение канала"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Тип вывода в режиме ШИМ инвертирование\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PwmInv { # [doc = "1: Прямой (не инвертированный) выход"]
Direct = 1 , # [doc = "0: Инвертированный выход"]
Inverted = 0 , } impl From < PwmInv > for bool { # [inline (always)]
fn from (variant : PwmInv) -> Self { variant as u8 != 0 } } # [doc = "Field `PWM_INV` reader - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvR = crate :: BitReader < PwmInv > ; impl PwmInvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PwmInv { match self . bits { true => PwmInv :: Direct , false => PwmInv :: Inverted , } } # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == PwmInv :: Direct } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == PwmInv :: Inverted } } # [doc = "Field `PWM_INV` writer - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvW < 'a , REG > = crate :: BitWriter < 'a , REG , PwmInv > ; impl < 'a , REG > PwmInvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Direct) } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Inverted) } } # [doc = "Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dir { # [doc = "1: Выход"]
Output = 1 , # [doc = "0: Вход"]
Input = 0 , } impl From < Dir > for bool { # [inline (always)]
fn from (variant : Dir) -> Self { variant as u8 != 0 } } # [doc = "Field `DIR` reader - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
pub type DirR = crate :: BitReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dir { match self . bits { true => Dir :: Output , false => Dir :: Input , } } # [doc = "Выход"]
# [inline (always)]
pub fn is_output (& self) -> bool { * self == Dir :: Output } # [doc = "Вход"]
# [inline (always)]
pub fn is_input (& self) -> bool { * self == Dir :: Input } } impl R { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& self) -> NoiseR { NoiseR :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& self) -> EdgeR { EdgeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& self) -> PwmInvR { PwmInvR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
# [inline (always)]
pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& mut self) -> NoiseW < Ch3CntrSpec > { NoiseW :: new (self , 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& mut self) -> EdgeW < Ch3CntrSpec > { EdgeW :: new (self , 4) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& mut self) -> ModeW < Ch3CntrSpec > { ModeW :: new (self , 5) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& mut self) -> EnW < Ch3CntrSpec > { EnW :: new (self , 7) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& mut self) -> PwmInvW < Ch3CntrSpec > { PwmInvW :: new (self , 8) } } # [doc = "Конфигурационный регистр 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_cntr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_cntr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch3CntrSpec ; impl crate :: RegisterSpec for Ch3CntrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch3_cntr::R`](R) reader structure"]
impl crate :: Readable for Ch3CntrSpec { } # [doc = "`write(|w| ..)` method takes [`ch3_cntr::W`](W) writer structure"]
impl crate :: Writable for Ch3CntrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH3_CNTR to value 0"]
impl crate :: Resettable for Ch3CntrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH3_OCR (rw) register accessor: Значение сравнения 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_ocr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_ocr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch3_ocr`]
module"]
# [doc (alias = "CH3_OCR")]
pub type Ch3Ocr = crate :: Reg < ch3_ocr :: Ch3OcrSpec > ; # [doc = "Значение сравнения 3 канала"]
pub mod ch3_ocr { # [doc = "Register `CH3_OCR` reader"]
pub type R = crate :: R < Ch3OcrSpec > ; # [doc = "Register `CH3_OCR` writer"]
pub type W = crate :: W < Ch3OcrSpec > ; # [doc = "Field `OCR` reader - Значение таймера в режиме сравнения"]
pub type OcrR = crate :: FieldReader < u32 > ; # [doc = "Field `OCR` writer - Значение таймера в режиме сравнения"]
pub type OcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& self) -> OcrR { OcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& mut self) -> OcrW < Ch3OcrSpec > { OcrW :: new (self , 0) } } # [doc = "Значение сравнения 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_ocr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_ocr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch3OcrSpec ; impl crate :: RegisterSpec for Ch3OcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch3_ocr::R`](R) reader structure"]
impl crate :: Readable for Ch3OcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch3_ocr::W`](W) writer structure"]
impl crate :: Writable for Ch3OcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH3_OCR to value 0"]
impl crate :: Resettable for Ch3OcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH3_ICR (rw) register accessor: Значение захвата 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch3_icr`]
module"]
# [doc (alias = "CH3_ICR")]
pub type Ch3Icr = crate :: Reg < ch3_icr :: Ch3IcrSpec > ; # [doc = "Значение захвата 3 канала"]
pub mod ch3_icr { # [doc = "Register `CH3_ICR` reader"]
pub type R = crate :: R < Ch3IcrSpec > ; # [doc = "Register `CH3_ICR` writer"]
pub type W = crate :: W < Ch3IcrSpec > ; # [doc = "Field `ICR` reader - Значение таймера в режиме захвата"]
pub type IcrR = crate :: FieldReader < u32 > ; # [doc = "Field `ICR` writer - Значение таймера в режиме захвата"]
pub type IcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& self) -> IcrR { IcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& mut self) -> IcrW < Ch3IcrSpec > { IcrW :: new (self , 0) } } # [doc = "Значение захвата 3 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch3_icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch3_icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch3IcrSpec ; impl crate :: RegisterSpec for Ch3IcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch3_icr::R`](R) reader structure"]
impl crate :: Readable for Ch3IcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch3_icr::W`](W) writer structure"]
impl crate :: Writable for Ch3IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH3_ICR to value 0"]
impl crate :: Resettable for Ch3IcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH4_CNTR (rw) register accessor: Конфигурационный регистр 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_cntr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_cntr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch4_cntr`]
module"]
# [doc (alias = "CH4_CNTR")]
pub type Ch4Cntr = crate :: Reg < ch4_cntr :: Ch4CntrSpec > ; # [doc = "Конфигурационный регистр 4 канала"]
pub mod ch4_cntr { # [doc = "Register `CH4_CNTR` reader"]
pub type R = crate :: R < Ch4CntrSpec > ; # [doc = "Register `CH4_CNTR` writer"]
pub type W = crate :: W < Ch4CntrSpec > ; # [doc = "Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Noise { # [doc = "0: Фильтрация выключена"]
Enable = 0 , # [doc = "1: Фильтрация включена"]
Disable = 1 , } impl From < Noise > for bool { # [inline (always)]
fn from (variant : Noise) -> Self { variant as u8 != 0 } } # [doc = "Field `NOISE` reader - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseR = crate :: BitReader < Noise > ; impl NoiseR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Noise { match self . bits { false => Noise :: Enable , true => Noise :: Disable , } } # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Noise :: Enable } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Noise :: Disable } } # [doc = "Field `NOISE` writer - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
pub type NoiseW < 'a , REG > = crate :: BitWriter < 'a , REG , Noise > ; impl < 'a , REG > NoiseW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Фильтрация выключена"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Enable) } # [doc = "Фильтрация включена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Noise :: Disable) } } # [doc = "Режим сигнала захвата\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Edge { # [doc = "0: фронт"]
Front = 0 , # [doc = "1: срез"]
Back = 1 , } impl From < Edge > for bool { # [inline (always)]
fn from (variant : Edge) -> Self { variant as u8 != 0 } } # [doc = "Field `EDGE` reader - Режим сигнала захвата"]
pub type EdgeR = crate :: BitReader < Edge > ; impl EdgeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Edge { match self . bits { false => Edge :: Front , true => Edge :: Back , } } # [doc = "фронт"]
# [inline (always)]
pub fn is_front (& self) -> bool { * self == Edge :: Front } # [doc = "срез"]
# [inline (always)]
pub fn is_back (& self) -> bool { * self == Edge :: Back } } # [doc = "Field `EDGE` writer - Режим сигнала захвата"]
pub type EdgeW < 'a , REG > = crate :: BitWriter < 'a , REG , Edge > ; impl < 'a , REG > EdgeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "фронт"]
# [inline (always)]
pub fn front (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Front) } # [doc = "срез"]
# [inline (always)]
pub fn back (self) -> & 'a mut crate :: W < REG > { self . variant (Edge :: Back) } } # [doc = "Режим работы канала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Mode { # [doc = "1: Режим сравнения (для timer0)"]
Compare = 1 , # [doc = "2: Режим захвата(для timer0)"]
Capture = 2 , # [doc = "3: ШИМ"]
Pwm = 3 , } impl From < Mode > for u8 { # [inline (always)]
fn from (variant : Mode) -> Self { variant as _ } } impl crate :: FieldSpec for Mode { type Ux = u8 ; } impl crate :: IsEnum for Mode { } # [doc = "Field `MODE` reader - Режим работы канала"]
pub type ModeR = crate :: FieldReader < Mode > ; impl ModeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Mode { match self . bits { 1 => Mode :: Compare , 2 => Mode :: Capture , 3 => Mode :: Pwm , _ => unreachable ! () , } } # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn is_compare (& self) -> bool { * self == Mode :: Compare } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn is_capture (& self) -> bool { * self == Mode :: Capture } # [doc = "ШИМ"]
# [inline (always)]
pub fn is_pwm (& self) -> bool { * self == Mode :: Pwm } } # [doc = "Field `MODE` writer - Режим работы канала"]
pub type ModeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 2 , Mode > ; impl < 'a , REG > ModeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Режим сравнения (для timer0)"]
# [inline (always)]
pub fn compare (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Compare) } # [doc = "Режим захвата(для timer0)"]
# [inline (always)]
pub fn capture (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Capture) } # [doc = "ШИМ"]
# [inline (always)]
pub fn pwm (self) -> & 'a mut crate :: W < REG > { self . variant (Mode :: Pwm) } } # [doc = "Field `EN` reader - Включение/выключение канала"]
pub type EnR = crate :: BitReader ; # [doc = "Field `EN` writer - Включение/выключение канала"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Тип вывода в режиме ШИМ инвертирование\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PwmInv { # [doc = "1: Прямой (не инвертированный) выход"]
Direct = 1 , # [doc = "0: Инвертированный выход"]
Inverted = 0 , } impl From < PwmInv > for bool { # [inline (always)]
fn from (variant : PwmInv) -> Self { variant as u8 != 0 } } # [doc = "Field `PWM_INV` reader - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvR = crate :: BitReader < PwmInv > ; impl PwmInvR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PwmInv { match self . bits { true => PwmInv :: Direct , false => PwmInv :: Inverted , } } # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn is_direct (& self) -> bool { * self == PwmInv :: Direct } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn is_inverted (& self) -> bool { * self == PwmInv :: Inverted } } # [doc = "Field `PWM_INV` writer - Тип вывода в режиме ШИМ инвертирование"]
pub type PwmInvW < 'a , REG > = crate :: BitWriter < 'a , REG , PwmInv > ; impl < 'a , REG > PwmInvW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прямой (не инвертированный) выход"]
# [inline (always)]
pub fn direct (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Direct) } # [doc = "Инвертированный выход"]
# [inline (always)]
pub fn inverted (self) -> & 'a mut crate :: W < REG > { self . variant (PwmInv :: Inverted) } } # [doc = "Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dir { # [doc = "1: Выход"]
Output = 1 , # [doc = "0: Вход"]
Input = 0 , } impl From < Dir > for bool { # [inline (always)]
fn from (variant : Dir) -> Self { variant as u8 != 0 } } # [doc = "Field `DIR` reader - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
pub type DirR = crate :: BitReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dir { match self . bits { true => Dir :: Output , false => Dir :: Input , } } # [doc = "Выход"]
# [inline (always)]
pub fn is_output (& self) -> bool { * self == Dir :: Output } # [doc = "Вход"]
# [inline (always)]
pub fn is_input (& self) -> bool { * self == Dir :: Input } } impl R { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& self) -> NoiseR { NoiseR :: new ((self . bits & 1) != 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& self) -> EdgeR { EdgeR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& self) -> ModeR { ModeR :: new (((self . bits >> 5) & 3) as u8) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& self) -> PwmInvR { PwmInvR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Направление передачи данных. Устанавливается автоматически в зависимости от режима работы (1 - выход, 0 - вход)"]
# [inline (always)]
pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 9) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление фильтрацией входных помех на входе ic_port: 0 – фильтрация выклю-чена; 1 – фильтрация выклю-чена"]
# [inline (always)]
pub fn noise (& mut self) -> NoiseW < Ch4CntrSpec > { NoiseW :: new (self , 0) } # [doc = "Bit 4 - Режим сигнала захвата"]
# [inline (always)]
pub fn edge (& mut self) -> EdgeW < Ch4CntrSpec > { EdgeW :: new (self , 4) } # [doc = "Bits 5:6 - Режим работы канала"]
# [inline (always)]
pub fn mode (& mut self) -> ModeW < Ch4CntrSpec > { ModeW :: new (self , 5) } # [doc = "Bit 7 - Включение/выключение канала"]
# [inline (always)]
pub fn en (& mut self) -> EnW < Ch4CntrSpec > { EnW :: new (self , 7) } # [doc = "Bit 8 - Тип вывода в режиме ШИМ инвертирование"]
# [inline (always)]
pub fn pwm_inv (& mut self) -> PwmInvW < Ch4CntrSpec > { PwmInvW :: new (self , 8) } } # [doc = "Конфигурационный регистр 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_cntr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_cntr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch4CntrSpec ; impl crate :: RegisterSpec for Ch4CntrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch4_cntr::R`](R) reader structure"]
impl crate :: Readable for Ch4CntrSpec { } # [doc = "`write(|w| ..)` method takes [`ch4_cntr::W`](W) writer structure"]
impl crate :: Writable for Ch4CntrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH4_CNTR to value 0"]
impl crate :: Resettable for Ch4CntrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH4_OCR (rw) register accessor: Значение сравнения 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_ocr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_ocr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch4_ocr`]
module"]
# [doc (alias = "CH4_OCR")]
pub type Ch4Ocr = crate :: Reg < ch4_ocr :: Ch4OcrSpec > ; # [doc = "Значение сравнения 4 канала"]
pub mod ch4_ocr { # [doc = "Register `CH4_OCR` reader"]
pub type R = crate :: R < Ch4OcrSpec > ; # [doc = "Register `CH4_OCR` writer"]
pub type W = crate :: W < Ch4OcrSpec > ; # [doc = "Field `OCR` reader - Значение таймера в режиме сравнения"]
pub type OcrR = crate :: FieldReader < u32 > ; # [doc = "Field `OCR` writer - Значение таймера в режиме сравнения"]
pub type OcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& self) -> OcrR { OcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме сравнения"]
# [inline (always)]
pub fn ocr (& mut self) -> OcrW < Ch4OcrSpec > { OcrW :: new (self , 0) } } # [doc = "Значение сравнения 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_ocr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_ocr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch4OcrSpec ; impl crate :: RegisterSpec for Ch4OcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch4_ocr::R`](R) reader structure"]
impl crate :: Readable for Ch4OcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch4_ocr::W`](W) writer structure"]
impl crate :: Writable for Ch4OcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH4_OCR to value 0"]
impl crate :: Resettable for Ch4OcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CH4_ICR (rw) register accessor: Значение захвата 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_icr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_icr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ch4_icr`]
module"]
# [doc (alias = "CH4_ICR")]
pub type Ch4Icr = crate :: Reg < ch4_icr :: Ch4IcrSpec > ; # [doc = "Значение захвата 4 канала"]
pub mod ch4_icr { # [doc = "Register `CH4_ICR` reader"]
pub type R = crate :: R < Ch4IcrSpec > ; # [doc = "Register `CH4_ICR` writer"]
pub type W = crate :: W < Ch4IcrSpec > ; # [doc = "Field `ICR` reader - Значение таймера в режиме захвата"]
pub type IcrR = crate :: FieldReader < u32 > ; # [doc = "Field `ICR` writer - Значение таймера в режиме захвата"]
pub type IcrW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& self) -> IcrR { IcrR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Значение таймера в режиме захвата"]
# [inline (always)]
pub fn icr (& mut self) -> IcrW < Ch4IcrSpec > { IcrW :: new (self , 0) } } # [doc = "Значение захвата 4 канала\n\nYou can [`read`](crate::Reg::read) this register and get [`ch4_icr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ch4_icr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Ch4IcrSpec ; impl crate :: RegisterSpec for Ch4IcrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ch4_icr::R`](R) reader structure"]
impl crate :: Readable for Ch4IcrSpec { } # [doc = "`write(|w| ..)` method takes [`ch4_icr::W`](W) writer structure"]
impl crate :: Writable for Ch4IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CH4_ICR to value 0"]
impl crate :: Resettable for Ch4IcrSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Модуль обеспечивает взаимодействие с различными периферийными устройствами"]
pub struct Spi0 { _marker : PhantomData < * const () > } unsafe impl Send for Spi0 { } impl Spi0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const spi_0 :: RegisterBlock = 0x0008_3000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spi_0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Spi0 { type Target = spi_0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Spi0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi0") . finish () } } # [doc = "Модуль обеспечивает взаимодействие с различными периферийными устройствами"]
pub mod spi_0 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { config : Config , status : Status , int_enable : IntEnable , int_disable : IntDisable , int_mask : IntMask , enable : Enable , delay : Delay , txdata : Txdata , rxdata : Rxdata , sic : Sic , tx_thr : TxThr , id : Id , } impl RegisterBlock { # [doc = "0x00 - Регистр конфигурации SPI"]
# [inline (always)]
pub const fn config (& self) -> & Config { & self . config } # [doc = "0x04 - Регистр статуса. Примечание: биты регистра \\[6:0\\]
устанавливаются в «1», если произошло событие вызывающее прерывание."]
# [inline (always)]
pub const fn status (& self) -> & Status { & self . status } # [doc = "0x08 - Регистр разрешения прерываний"]
# [inline (always)]
pub const fn int_enable (& self) -> & IntEnable { & self . int_enable } # [doc = "0x0c - Регистр запрета прерываний"]
# [inline (always)]
pub const fn int_disable (& self) -> & IntDisable { & self . int_disable } # [doc = "0x10 - Регистр текущих масок прерываний"]
# [inline (always)]
pub const fn int_mask (& self) -> & IntMask { & self . int_mask } # [doc = "0x14 - Регистр включения/выключения SPI"]
# [inline (always)]
pub const fn enable (& self) -> & Enable { & self . enable } # [doc = "0x18 - Регистр задержек"]
# [inline (always)]
pub const fn delay (& self) -> & Delay { & self . delay } # [doc = "0x1c - Регистр передаваемых данных"]
# [inline (always)]
pub const fn txdata (& self) -> & Txdata { & self . txdata } # [doc = "0x20 - Регистр принимаемых данных"]
# [inline (always)]
pub const fn rxdata (& self) -> & Rxdata { & self . rxdata } # [doc = "0x24 - Регистр счетчика останова ведомого устройства"]
# [inline (always)]
pub const fn sic (& self) -> & Sic { & self . sic } # [doc = "0x28 - Регистр пороговых значений TX_FIFO"]
# [inline (always)]
pub const fn tx_thr (& self) -> & TxThr { & self . tx_thr } # [doc = "0x2c - Идентификационный номер модуля"]
# [inline (always)]
pub const fn id (& self) -> & Id { & self . id } } # [doc = "CONFIG (rw) register accessor: Регистр конфигурации SPI\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@config`]
module"]
# [doc (alias = "CONFIG")]
pub type Config = crate :: Reg < config :: ConfigSpec > ; # [doc = "Регистр конфигурации SPI"]
pub mod config { # [doc = "Register `CONFIG` reader"]
pub type R = crate :: R < ConfigSpec > ; # [doc = "Register `CONFIG` writer"]
pub type W = crate :: W < ConfigSpec > ; # [doc = "(MSTREN) Выбор режима\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ModeSel { # [doc = "0: SPI в режиме ведомого устройства"]
Slave = 0 , # [doc = "1: SPI в режиме ведущего устройства"]
Master = 1 , } impl From < ModeSel > for bool { # [inline (always)]
fn from (variant : ModeSel) -> Self { variant as u8 != 0 } } # [doc = "Field `MODE_SEL` reader - (MSTREN) Выбор режима"]
pub type ModeSelR = crate :: BitReader < ModeSel > ; impl ModeSelR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ModeSel { match self . bits { false => ModeSel :: Slave , true => ModeSel :: Master , } } # [doc = "SPI в режиме ведомого устройства"]
# [inline (always)]
pub fn is_slave (& self) -> bool { * self == ModeSel :: Slave } # [doc = "SPI в режиме ведущего устройства"]
# [inline (always)]
pub fn is_master (& self) -> bool { * self == ModeSel :: Master } } # [doc = "Field `MODE_SEL` writer - (MSTREN) Выбор режима"]
pub type ModeSelW < 'a , REG > = crate :: BitWriter < 'a , REG , ModeSel > ; impl < 'a , REG > ModeSelW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "SPI в режиме ведомого устройства"]
# [inline (always)]
pub fn slave (self) -> & 'a mut crate :: W < REG > { self . variant (ModeSel :: Slave) } # [doc = "SPI в режиме ведущего устройства"]
# [inline (always)]
pub fn master (self) -> & 'a mut crate :: W < REG > { self . variant (ModeSel :: Master) } } # [doc = "(CPOL)Выбор полярности тактового сигнала вне слова\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ClkPol { # [doc = "0: Тактовый сигнал вне слова удерживается на низком уровне"]
_0 = 0 , # [doc = "1: Тактовый сигнал вне слова удерживается на высоком уровне"]
_1 = 1 , } impl From < ClkPol > for bool { # [inline (always)]
fn from (variant : ClkPol) -> Self { variant as u8 != 0 } } # [doc = "Field `CLK_POL` reader - (CPOL)Выбор полярности тактового сигнала вне слова"]
pub type ClkPolR = crate :: BitReader < ClkPol > ; impl ClkPolR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ClkPol { match self . bits { false => ClkPol :: _0 , true => ClkPol :: _1 , } } # [doc = "Тактовый сигнал вне слова удерживается на низком уровне"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == ClkPol :: _0 } # [doc = "Тактовый сигнал вне слова удерживается на высоком уровне"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == ClkPol :: _1 } } # [doc = "Field `CLK_POL` writer - (CPOL)Выбор полярности тактового сигнала вне слова"]
pub type ClkPolW < 'a , REG > = crate :: BitWriter < 'a , REG , ClkPol > ; impl < 'a , REG > ClkPolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактовый сигнал вне слова удерживается на низком уровне"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (ClkPol :: _0) } # [doc = "Тактовый сигнал вне слова удерживается на высоком уровне"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (ClkPol :: _1) } } # [doc = "(CPHA)Выбор фазы тактового сигнала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ClkPh { # [doc = "0: Тактовая частота SPI неактивна вне слова"]
_0 = 0 , # [doc = "1: Тактовая частота SPI активна вне слова"]
_1 = 1 , } impl From < ClkPh > for bool { # [inline (always)]
fn from (variant : ClkPh) -> Self { variant as u8 != 0 } } # [doc = "Field `CLK_PH` reader - (CPHA)Выбор фазы тактового сигнала"]
pub type ClkPhR = crate :: BitReader < ClkPh > ; impl ClkPhR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ClkPh { match self . bits { false => ClkPh :: _0 , true => ClkPh :: _1 , } } # [doc = "Тактовая частота SPI неактивна вне слова"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == ClkPh :: _0 } # [doc = "Тактовая частота SPI активна вне слова"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == ClkPh :: _1 } } # [doc = "Field `CLK_PH` writer - (CPHA)Выбор фазы тактового сигнала"]
pub type ClkPhW < 'a , REG > = crate :: BitWriter < 'a , REG , ClkPh > ; impl < 'a , REG > ClkPhW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактовая частота SPI неактивна вне слова"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (ClkPh :: _0) } # [doc = "Тактовая частота SPI активна вне слова"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (ClkPh :: _1) } } # [doc = "Управляет скоростью передачи данных, задает коэффициент деления частоты spi_ref_clk\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BaudRateDiv { # [doc = "0: Не поддерживается"]
NotSupported = 0 , # [doc = "1: Деление на 4"]
Div4 = 1 , # [doc = "2: Деление на 8"]
Div8 = 2 , # [doc = "3: Деление на 16"]
Div16 = 3 , # [doc = "4: Деление на 32"]
Div32 = 4 , # [doc = "5: деление на 64"]
Div64 = 5 , # [doc = "6: деление на 128"]
Div128 = 6 , # [doc = "7: деление на 256"]
Div256 = 7 , } impl From < BaudRateDiv > for u8 { # [inline (always)]
fn from (variant : BaudRateDiv) -> Self { variant as _ } } impl crate :: FieldSpec for BaudRateDiv { type Ux = u8 ; } impl crate :: IsEnum for BaudRateDiv { } # [doc = "Field `BAUD_RATE_DIV` reader - Управляет скоростью передачи данных, задает коэффициент деления частоты spi_ref_clk"]
pub type BaudRateDivR = crate :: FieldReader < BaudRateDiv > ; impl BaudRateDivR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> BaudRateDiv { match self . bits { 0 => BaudRateDiv :: NotSupported , 1 => BaudRateDiv :: Div4 , 2 => BaudRateDiv :: Div8 , 3 => BaudRateDiv :: Div16 , 4 => BaudRateDiv :: Div32 , 5 => BaudRateDiv :: Div64 , 6 => BaudRateDiv :: Div128 , 7 => BaudRateDiv :: Div256 , _ => unreachable ! () , } } # [doc = "Не поддерживается"]
# [inline (always)]
pub fn is_not_supported (& self) -> bool { * self == BaudRateDiv :: NotSupported } # [doc = "Деление на 4"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == BaudRateDiv :: Div4 } # [doc = "Деление на 8"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == BaudRateDiv :: Div8 } # [doc = "Деление на 16"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == BaudRateDiv :: Div16 } # [doc = "Деление на 32"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == BaudRateDiv :: Div32 } # [doc = "деление на 64"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == BaudRateDiv :: Div64 } # [doc = "деление на 128"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == BaudRateDiv :: Div128 } # [doc = "деление на 256"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == BaudRateDiv :: Div256 } } # [doc = "Field `BAUD_RATE_DIV` writer - Управляет скоростью передачи данных, задает коэффициент деления частоты spi_ref_clk"]
pub type BaudRateDivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , BaudRateDiv , crate :: Safe > ; impl < 'a , REG > BaudRateDivW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Не поддерживается"]
# [inline (always)]
pub fn not_supported (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: NotSupported) } # [doc = "Деление на 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div4) } # [doc = "Деление на 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div8) } # [doc = "Деление на 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div16) } # [doc = "Деление на 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div32) } # [doc = "деление на 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div64) } # [doc = "деление на 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div128) } # [doc = "деление на 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div256) } } # [doc = "Выбор опорной тактовой частоты\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RefClk { # [doc = "0: Не поддерживается"]
NotSupported = 0 , # [doc = "1: Используется опорная частота SPI"]
ApbPClk = 1 , } impl From < RefClk > for bool { # [inline (always)]
fn from (variant : RefClk) -> Self { variant as u8 != 0 } } # [doc = "Field `REF_CLK` reader - Выбор опорной тактовой частоты"]
pub type RefClkR = crate :: BitReader < RefClk > ; impl RefClkR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RefClk { match self . bits { false => RefClk :: NotSupported , true => RefClk :: ApbPClk , } } # [doc = "Не поддерживается"]
# [inline (always)]
pub fn is_not_supported (& self) -> bool { * self == RefClk :: NotSupported } # [doc = "Используется опорная частота SPI"]
# [inline (always)]
pub fn is_apb_p_clk (& self) -> bool { * self == RefClk :: ApbPClk } } # [doc = "Field `REF_CLK` writer - Выбор опорной тактовой частоты"]
pub type RefClkW < 'a , REG > = crate :: BitWriter < 'a , REG , RefClk > ; impl < 'a , REG > RefClkW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Не поддерживается"]
# [inline (always)]
pub fn not_supported (self) -> & 'a mut crate :: W < REG > { self . variant (RefClk :: NotSupported) } # [doc = "Используется опорная частота SPI"]
# [inline (always)]
pub fn apb_p_clk (self) -> & 'a mut crate :: W < REG > { self . variant (RefClk :: ApbPClk) } } # [doc = "Выбор ведомых устройств\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Cs { # [doc = "15: Ведомые устройства не выбраны"]
NotSelected = 15 , # [doc = "1: Выбрано устройство 1"]
Cs1 = 1 , # [doc = "3: Выбрано устройство 2"]
Cs2 = 3 , # [doc = "7: Выбрано устройство 3"]
Cs3 = 7 , # [doc = "0: Выбрано устройство 4"]
Cs4 = 0 , } impl From < Cs > for u8 { # [inline (always)]
fn from (variant : Cs) -> Self { variant as _ } } impl crate :: FieldSpec for Cs { type Ux = u8 ; } impl crate :: IsEnum for Cs { } # [doc = "Field `CS` reader - Выбор ведомых устройств"]
pub type CsR = crate :: FieldReader < Cs > ; impl CsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Cs > { match self . bits { 15 => Some (Cs :: NotSelected) , 1 => Some (Cs :: Cs1) , 3 => Some (Cs :: Cs2) , 7 => Some (Cs :: Cs3) , 0 => Some (Cs :: Cs4) , _ => None , } } # [doc = "Ведомые устройства не выбраны"]
# [inline (always)]
pub fn is_not_selected (& self) -> bool { * self == Cs :: NotSelected } # [doc = "Выбрано устройство 1"]
# [inline (always)]
pub fn is_cs1 (& self) -> bool { * self == Cs :: Cs1 } # [doc = "Выбрано устройство 2"]
# [inline (always)]
pub fn is_cs2 (& self) -> bool { * self == Cs :: Cs2 } # [doc = "Выбрано устройство 3"]
# [inline (always)]
pub fn is_cs3 (& self) -> bool { * self == Cs :: Cs3 } # [doc = "Выбрано устройство 4"]
# [inline (always)]
pub fn is_cs4 (& self) -> bool { * self == Cs :: Cs4 } } # [doc = "Field `CS` writer - Выбор ведомых устройств"]
pub type CsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Cs > ; impl < 'a , REG > CsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Ведомые устройства не выбраны"]
# [inline (always)]
pub fn not_selected (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: NotSelected) } # [doc = "Выбрано устройство 1"]
# [inline (always)]
pub fn cs1 (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: Cs1) } # [doc = "Выбрано устройство 2"]
# [inline (always)]
pub fn cs2 (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: Cs2) } # [doc = "Выбрано устройство 3"]
# [inline (always)]
pub fn cs3 (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: Cs3) } # [doc = "Выбрано устройство 4"]
# [inline (always)]
pub fn cs4 (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: Cs4) } } # [doc = "Выбор режима управления сигналом выбора ведомого\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ManualCs { # [doc = "0: Автоматический режим"]
Automatic = 0 , # [doc = "1: Ручной режим"]
Manual = 1 , } impl From < ManualCs > for bool { # [inline (always)]
fn from (variant : ManualCs) -> Self { variant as u8 != 0 } } # [doc = "Field `Manual_CS` reader - Выбор режима управления сигналом выбора ведомого"]
pub type ManualCsR = crate :: BitReader < ManualCs > ; impl ManualCsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ManualCs { match self . bits { false => ManualCs :: Automatic , true => ManualCs :: Manual , } } # [doc = "Автоматический режим"]
# [inline (always)]
pub fn is_automatic (& self) -> bool { * self == ManualCs :: Automatic } # [doc = "Ручной режим"]
# [inline (always)]
pub fn is_manual (& self) -> bool { * self == ManualCs :: Manual } } # [doc = "Field `Manual_CS` writer - Выбор режима управления сигналом выбора ведомого"]
pub type ManualCsW < 'a , REG > = crate :: BitWriter < 'a , REG , ManualCs > ; impl < 'a , REG > ManualCsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Автоматический режим"]
# [inline (always)]
pub fn automatic (self) -> & 'a mut crate :: W < REG > { self . variant (ManualCs :: Automatic) } # [doc = "Ручной режим"]
# [inline (always)]
pub fn manual (self) -> & 'a mut crate :: W < REG > { self . variant (ManualCs :: Manual) } } impl R { # [doc = "Bit 0 - (MSTREN) Выбор режима"]
# [inline (always)]
pub fn mode_sel (& self) -> ModeSelR { ModeSelR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - (CPOL)Выбор полярности тактового сигнала вне слова"]
# [inline (always)]
pub fn clk_pol (& self) -> ClkPolR { ClkPolR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - (CPHA)Выбор фазы тактового сигнала"]
# [inline (always)]
pub fn clk_ph (& self) -> ClkPhR { ClkPhR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:5 - Управляет скоростью передачи данных, задает коэффициент деления частоты spi_ref_clk"]
# [inline (always)]
pub fn baud_rate_div (& self) -> BaudRateDivR { BaudRateDivR :: new (((self . bits >> 3) & 7) as u8) } # [doc = "Bit 8 - Выбор опорной тактовой частоты"]
# [inline (always)]
pub fn ref_clk (& self) -> RefClkR { RefClkR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bits 10:13 - Выбор ведомых устройств"]
# [inline (always)]
pub fn cs (& self) -> CsR { CsR :: new (((self . bits >> 10) & 0x0f) as u8) } # [doc = "Bit 14 - Выбор режима управления сигналом выбора ведомого"]
# [inline (always)]
pub fn manual_cs (& self) -> ManualCsR { ManualCsR :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bit 0 - (MSTREN) Выбор режима"]
# [inline (always)]
pub fn mode_sel (& mut self) -> ModeSelW < ConfigSpec > { ModeSelW :: new (self , 0) } # [doc = "Bit 1 - (CPOL)Выбор полярности тактового сигнала вне слова"]
# [inline (always)]
pub fn clk_pol (& mut self) -> ClkPolW < ConfigSpec > { ClkPolW :: new (self , 1) } # [doc = "Bit 2 - (CPHA)Выбор фазы тактового сигнала"]
# [inline (always)]
pub fn clk_ph (& mut self) -> ClkPhW < ConfigSpec > { ClkPhW :: new (self , 2) } # [doc = "Bits 3:5 - Управляет скоростью передачи данных, задает коэффициент деления частоты spi_ref_clk"]
# [inline (always)]
pub fn baud_rate_div (& mut self) -> BaudRateDivW < ConfigSpec > { BaudRateDivW :: new (self , 3) } # [doc = "Bit 8 - Выбор опорной тактовой частоты"]
# [inline (always)]
pub fn ref_clk (& mut self) -> RefClkW < ConfigSpec > { RefClkW :: new (self , 8) } # [doc = "Bits 10:13 - Выбор ведомых устройств"]
# [inline (always)]
pub fn cs (& mut self) -> CsW < ConfigSpec > { CsW :: new (self , 10) } # [doc = "Bit 14 - Выбор режима управления сигналом выбора ведомого"]
# [inline (always)]
pub fn manual_cs (& mut self) -> ManualCsW < ConfigSpec > { ManualCsW :: new (self , 14) } } # [doc = "Регистр конфигурации SPI\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ConfigSpec ; impl crate :: RegisterSpec for ConfigSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`config::R`](R) reader structure"]
impl crate :: Readable for ConfigSpec { } # [doc = "`write(|w| ..)` method takes [`config::W`](W) writer structure"]
impl crate :: Writable for ConfigSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONFIG to value 0"]
impl crate :: Resettable for ConfigSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "STATUS (rw) register accessor: Регистр статуса. Примечание: биты регистра \\[6:0\\]
устанавливаются в «1», если произошло событие вызывающее прерывание.\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`status::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@status`]
module"]
# [doc (alias = "STATUS")]
pub type Status = crate :: Reg < status :: StatusSpec > ; # [doc = "Регистр статуса. Примечание: биты регистра \\[6:0\\]
устанавливаются в «1», если произошло событие вызывающее прерывание."]
pub mod status { # [doc = "Register `STATUS` reader"]
pub type R = crate :: R < StatusSpec > ; # [doc = "Register `STATUS` writer"]
pub type W = crate :: W < StatusSpec > ; # [doc = "(IXR_RXOVR) Прерывание при переполнении RX_FIFO, значение сбрасывается при чтении\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RxOverflow { # [doc = "0: Нет переполнения"]
Ok = 0 , # [doc = "1: Переполнение RX_FIFO"]
Overflow = 1 , } impl From < RxOverflow > for bool { # [inline (always)]
fn from (variant : RxOverflow) -> Self { variant as u8 != 0 } } # [doc = "Field `RX_OVERFLOW` reader - (IXR_RXOVR) Прерывание при переполнении RX_FIFO, значение сбрасывается при чтении"]
pub type RxOverflowR = crate :: BitReader < RxOverflow > ; impl RxOverflowR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RxOverflow { match self . bits { false => RxOverflow :: Ok , true => RxOverflow :: Overflow , } } # [doc = "Нет переполнения"]
# [inline (always)]
pub fn is_ok (& self) -> bool { * self == RxOverflow :: Ok } # [doc = "Переполнение RX_FIFO"]
# [inline (always)]
pub fn is_overflow (& self) -> bool { * self == RxOverflow :: Overflow } } # [doc = "(IXR_MODF) Напряжение на выводе n_ss_in не соответствую режиму работы SPI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ModeFail { # [doc = "0: Корректная работа"]
Ok = 0 , # [doc = "1: n_ss_in имеет низкий уровень в режиме ведомого устройства"]
Fail = 1 , } impl From < ModeFail > for bool { # [inline (always)]
fn from (variant : ModeFail) -> Self { variant as u8 != 0 } } # [doc = "Field `MODE_FAIL` reader - (IXR_MODF) Напряжение на выводе n_ss_in не соответствую режиму работы SPI"]
pub type ModeFailR = crate :: BitReader < ModeFail > ; impl ModeFailR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ModeFail { match self . bits { false => ModeFail :: Ok , true => ModeFail :: Fail , } } # [doc = "Корректная работа"]
# [inline (always)]
pub fn is_ok (& self) -> bool { * self == ModeFail :: Ok } # [doc = "n_ss_in имеет низкий уровень в режиме ведомого устройства"]
# [inline (always)]
pub fn is_fail (& self) -> bool { * self == ModeFail :: Fail } } # [doc = "(IXR_TXOW) Регистр TX_FIFO не заполнен\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoNotFull { # [doc = "0: Регистр заполнен до значение THRESHOLD или больше"]
LessThanTheThreshold = 0 , # [doc = "1: Регистр заполнен меньше чем THRESHOLD"]
MoreThanTheThreshold = 1 , } impl From < TxFifoNotFull > for bool { # [inline (always)]
fn from (variant : TxFifoNotFull) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_NOT_FULL` reader - (IXR_TXOW) Регистр TX_FIFO не заполнен"]
pub type TxFifoNotFullR = crate :: BitReader < TxFifoNotFull > ; impl TxFifoNotFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoNotFull { match self . bits { false => TxFifoNotFull :: LessThanTheThreshold , true => TxFifoNotFull :: MoreThanTheThreshold , } } # [doc = "Регистр заполнен до значение THRESHOLD или больше"]
# [inline (always)]
pub fn is_less_than_the_threshold (& self) -> bool { * self == TxFifoNotFull :: LessThanTheThreshold } # [doc = "Регистр заполнен меньше чем THRESHOLD"]
# [inline (always)]
pub fn is_more_than_the_threshold (& self) -> bool { * self == TxFifoNotFull :: MoreThanTheThreshold } } # [doc = "(IXR_TXFULL) Регистр TX_FIFO заполнен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoFull { # [doc = "0: FIFO не заполнен"]
NotFull = 0 , # [doc = "1: FIFO заполнен"]
Full = 1 , } impl From < TxFifoFull > for bool { # [inline (always)]
fn from (variant : TxFifoFull) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_FULL` reader - (IXR_TXFULL) Регистр TX_FIFO заполнен"]
pub type TxFifoFullR = crate :: BitReader < TxFifoFull > ; impl TxFifoFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoFull { match self . bits { false => TxFifoFull :: NotFull , true => TxFifoFull :: Full , } } # [doc = "FIFO не заполнен"]
# [inline (always)]
pub fn is_not_full (& self) -> bool { * self == TxFifoFull :: NotFull } # [doc = "FIFO заполнен"]
# [inline (always)]
pub fn is_full (& self) -> bool { * self == TxFifoFull :: Full } } # [doc = "(IXR_RXNEMPTY) Регистр RX_FIFO не пустой\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RxFifoNotEmpty { # [doc = "0: FIFO пустой"]
Empty = 0 , # [doc = "1: В FIFO есть хотя бы один байт"]
NotEmpty = 1 , } impl From < RxFifoNotEmpty > for bool { # [inline (always)]
fn from (variant : RxFifoNotEmpty) -> Self { variant as u8 != 0 } } # [doc = "Field `RX_FIFO_NOT_EMPTY` reader - (IXR_RXNEMPTY) Регистр RX_FIFO не пустой"]
pub type RxFifoNotEmptyR = crate :: BitReader < RxFifoNotEmpty > ; impl RxFifoNotEmptyR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RxFifoNotEmpty { match self . bits { false => RxFifoNotEmpty :: Empty , true => RxFifoNotEmpty :: NotEmpty , } } # [doc = "FIFO пустой"]
# [inline (always)]
pub fn is_empty (& self) -> bool { * self == RxFifoNotEmpty :: Empty } # [doc = "В FIFO есть хотя бы один байт"]
# [inline (always)]
pub fn is_not_empty (& self) -> bool { * self == RxFifoNotEmpty :: NotEmpty } } # [doc = "(IXR_RXFULL) Регистр RX_FIFO заполнен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RxFifoFull { # [doc = "0: FIFO не заполнен"]
NotFull = 0 , # [doc = "1: FIFO заполнен"]
Full = 1 , } impl From < RxFifoFull > for bool { # [inline (always)]
fn from (variant : RxFifoFull) -> Self { variant as u8 != 0 } } # [doc = "Field `RX_FIFO_FULL` reader - (IXR_RXFULL) Регистр RX_FIFO заполнен"]
pub type RxFifoFullR = crate :: BitReader < RxFifoFull > ; impl RxFifoFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RxFifoFull { match self . bits { false => RxFifoFull :: NotFull , true => RxFifoFull :: Full , } } # [doc = "FIFO не заполнен"]
# [inline (always)]
pub fn is_not_full (& self) -> bool { * self == RxFifoFull :: NotFull } # [doc = "FIFO заполнен"]
# [inline (always)]
pub fn is_full (& self) -> bool { * self == RxFifoFull :: Full } } # [doc = "(IXR_TXUF) Регистр TX FIFO опустошен. Устанавливается в режиме ведомого в случае, если к началу обмена в TX_FIFO нет данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoUnderflow { # [doc = "0: Опустошение не детектируется"]
NotEmpty = 0 , # [doc = "1: Определение опустошения"]
Underflow = 1 , } impl From < TxFifoUnderflow > for bool { # [inline (always)]
fn from (variant : TxFifoUnderflow) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_UNDERFLOW` reader - (IXR_TXUF) Регистр TX FIFO опустошен. Устанавливается в режиме ведомого в случае, если к началу обмена в TX_FIFO нет данных"]
pub type TxFifoUnderflowR = crate :: BitReader < TxFifoUnderflow > ; impl TxFifoUnderflowR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoUnderflow { match self . bits { false => TxFifoUnderflow :: NotEmpty , true => TxFifoUnderflow :: Underflow , } } # [doc = "Опустошение не детектируется"]
# [inline (always)]
pub fn is_not_empty (& self) -> bool { * self == TxFifoUnderflow :: NotEmpty } # [doc = "Определение опустошения"]
# [inline (always)]
pub fn is_underflow (& self) -> bool { * self == TxFifoUnderflow :: Underflow } } # [doc = "Статус сеанса передачи\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SpiActive { # [doc = "0: Контроллер SPI в состоянии ожидания обмена"]
Ready = 0 , # [doc = "1: Контроллер SPI в процессе обмена"]
Busy = 1 , } impl From < SpiActive > for bool { # [inline (always)]
fn from (variant : SpiActive) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_ACTIVE` reader - Статус сеанса передачи"]
pub type SpiActiveR = crate :: BitReader < SpiActive > ; impl SpiActiveR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> SpiActive { match self . bits { false => SpiActive :: Ready , true => SpiActive :: Busy , } } # [doc = "Контроллер SPI в состоянии ожидания обмена"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == SpiActive :: Ready } # [doc = "Контроллер SPI в процессе обмена"]
# [inline (always)]
pub fn is_busy (& self) -> bool { * self == SpiActive :: Busy } } impl R { # [doc = "Bit 0 - (IXR_RXOVR) Прерывание при переполнении RX_FIFO, значение сбрасывается при чтении"]
# [inline (always)]
pub fn rx_overflow (& self) -> RxOverflowR { RxOverflowR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - (IXR_MODF) Напряжение на выводе n_ss_in не соответствую режиму работы SPI"]
# [inline (always)]
pub fn mode_fail (& self) -> ModeFailR { ModeFailR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - (IXR_TXOW) Регистр TX_FIFO не заполнен"]
# [inline (always)]
pub fn tx_fifo_not_full (& self) -> TxFifoNotFullR { TxFifoNotFullR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - (IXR_TXFULL) Регистр TX_FIFO заполнен"]
# [inline (always)]
pub fn tx_fifo_full (& self) -> TxFifoFullR { TxFifoFullR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - (IXR_RXNEMPTY) Регистр RX_FIFO не пустой"]
# [inline (always)]
pub fn rx_fifo_not_empty (& self) -> RxFifoNotEmptyR { RxFifoNotEmptyR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - (IXR_RXFULL) Регистр RX_FIFO заполнен"]
# [inline (always)]
pub fn rx_fifo_full (& self) -> RxFifoFullR { RxFifoFullR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - (IXR_TXUF) Регистр TX FIFO опустошен. Устанавливается в режиме ведомого в случае, если к началу обмена в TX_FIFO нет данных"]
# [inline (always)]
pub fn tx_fifo_underflow (& self) -> TxFifoUnderflowR { TxFifoUnderflowR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 15 - Статус сеанса передачи"]
# [inline (always)]
pub fn spi_active (& self) -> SpiActiveR { SpiActiveR :: new (((self . bits >> 15) & 1) != 0) } } impl W { } # [doc = "Регистр статуса. Примечание: биты регистра \\[6:0\\]
устанавливаются в «1», если произошло событие вызывающее прерывание.\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`status::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StatusSpec ; impl crate :: RegisterSpec for StatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`status::R`](R) reader structure"]
impl crate :: Readable for StatusSpec { } # [doc = "`write(|w| ..)` method takes [`status::W`](W) writer structure"]
impl crate :: Writable for StatusSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets STATUS to value 0x04"]
impl crate :: Resettable for StatusSpec { const RESET_VALUE : u32 = 0x04 ; } } # [doc = "INT_ENABLE (w) register accessor: Регистр разрешения прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_enable::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_enable`]
module"]
# [doc (alias = "INT_ENABLE")]
pub type IntEnable = crate :: Reg < int_enable :: IntEnableSpec > ; # [doc = "Регистр разрешения прерываний"]
pub mod int_enable { # [doc = "Register `INT_ENABLE` writer"]
pub type W = crate :: W < IntEnableSpec > ; # [doc = "Field `RX_OVERFLOW` writer - (IXR_RXOVR) Запись «1» устанавливает маску прерывания (разрешает прерывание) при переполнении при приеме"]
pub type RxOverflowW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `MODE_FAIL` writer - (IXR_MODF) Запись «1» устанавливает маску прерывания (разрешает прерывание) при нарушении режима"]
pub type ModeFailW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_NOT_FULL` writer - (IXR_TXOW) Запись «1» устанавливает маску прерывания (разрешает прерывание) когда TX_FIFO не заполнен"]
pub type TxFifoNotFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_FULL` writer - (IXR_TXFULL) Запись «1» устанавливает маску прерывания (разрешает прерывание), когда TX_FIFO заполнен"]
pub type TxFifoFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `RX_FIFO_NOT_EMPTY` writer - (IXR_RXNEMPTY) Запись «1» устанавливает маску прерывания (разрешает прерывание), когда RX_FIFO не пустой"]
pub type RxFifoNotEmptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `PX_FIFO_FULL` writer - (IXR_RXFULL) Запись «1» устанавливает маску прерывания (разрешает прерывание) при заполнении RX_FIFO"]
pub type PxFifoFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_UNDERFLOW` writer - (IXR_TXUF) Запись «1» устанавливает маску прерывания (разрешает прерывание) при опустошении TX_FIFO"]
pub type TxFifoUnderflowW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W { # [doc = "Bit 0 - (IXR_RXOVR) Запись «1» устанавливает маску прерывания (разрешает прерывание) при переполнении при приеме"]
# [inline (always)]
pub fn rx_overflow (& mut self) -> RxOverflowW < IntEnableSpec > { RxOverflowW :: new (self , 0) } # [doc = "Bit 1 - (IXR_MODF) Запись «1» устанавливает маску прерывания (разрешает прерывание) при нарушении режима"]
# [inline (always)]
pub fn mode_fail (& mut self) -> ModeFailW < IntEnableSpec > { ModeFailW :: new (self , 1) } # [doc = "Bit 2 - (IXR_TXOW) Запись «1» устанавливает маску прерывания (разрешает прерывание) когда TX_FIFO не заполнен"]
# [inline (always)]
pub fn tx_fifo_not_full (& mut self) -> TxFifoNotFullW < IntEnableSpec > { TxFifoNotFullW :: new (self , 2) } # [doc = "Bit 3 - (IXR_TXFULL) Запись «1» устанавливает маску прерывания (разрешает прерывание), когда TX_FIFO заполнен"]
# [inline (always)]
pub fn tx_fifo_full (& mut self) -> TxFifoFullW < IntEnableSpec > { TxFifoFullW :: new (self , 3) } # [doc = "Bit 4 - (IXR_RXNEMPTY) Запись «1» устанавливает маску прерывания (разрешает прерывание), когда RX_FIFO не пустой"]
# [inline (always)]
pub fn rx_fifo_not_empty (& mut self) -> RxFifoNotEmptyW < IntEnableSpec > { RxFifoNotEmptyW :: new (self , 4) } # [doc = "Bit 5 - (IXR_RXFULL) Запись «1» устанавливает маску прерывания (разрешает прерывание) при заполнении RX_FIFO"]
# [inline (always)]
pub fn px_fifo_full (& mut self) -> PxFifoFullW < IntEnableSpec > { PxFifoFullW :: new (self , 5) } # [doc = "Bit 6 - (IXR_TXUF) Запись «1» устанавливает маску прерывания (разрешает прерывание) при опустошении TX_FIFO"]
# [inline (always)]
pub fn tx_fifo_underflow (& mut self) -> TxFifoUnderflowW < IntEnableSpec > { TxFifoUnderflowW :: new (self , 6) } } # [doc = "Регистр разрешения прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_enable::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntEnableSpec ; impl crate :: RegisterSpec for IntEnableSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`int_enable::W`](W) writer structure"]
impl crate :: Writable for IntEnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_ENABLE to value 0"]
impl crate :: Resettable for IntEnableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INT_DISABLE (w) register accessor: Регистр запрета прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_disable::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_disable`]
module"]
# [doc (alias = "INT_DISABLE")]
pub type IntDisable = crate :: Reg < int_disable :: IntDisableSpec > ; # [doc = "Регистр запрета прерываний"]
pub mod int_disable { # [doc = "Register `INT_DISABLE` writer"]
pub type W = crate :: W < IntDisableSpec > ; # [doc = "Field `RX_OVERFLOW` writer - (IXR_RXOVR) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при переполнении при приеме"]
pub type RxOverflowW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `MODE_FAIL` writer - (IXR_MODF) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при нарушении режима"]
pub type ModeFailW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_NOT_FULL` writer - (IXR_TXOW) Запись «1» сбрасывает маску прерывания (запрещает прерывание) когда TX_FIFO не заполнен"]
pub type TxFifoNotFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_FULL` writer - (IXR_TXFULL) Запись «1» сбрасывает маску прерывания (запрещает прерывание), когда TX_FIFO заполнен"]
pub type TxFifoFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `RX_FIFO_NOT_EMPTY` writer - (IXR_RXNEMPTY) Запись «1» сбрасывает маску прерывания (запрещает прерывание), когда RX_FIFO не пустой"]
pub type RxFifoNotEmptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `PX_FIFO_FULL` writer - (IXR_RXFULL) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при заполнении RX_FIFO"]
pub type PxFifoFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_UNDERFLOW` writer - (IXR_TXUF) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при опустошении TX_FIFO"]
pub type TxFifoUnderflowW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W { # [doc = "Bit 0 - (IXR_RXOVR) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при переполнении при приеме"]
# [inline (always)]
pub fn rx_overflow (& mut self) -> RxOverflowW < IntDisableSpec > { RxOverflowW :: new (self , 0) } # [doc = "Bit 1 - (IXR_MODF) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при нарушении режима"]
# [inline (always)]
pub fn mode_fail (& mut self) -> ModeFailW < IntDisableSpec > { ModeFailW :: new (self , 1) } # [doc = "Bit 2 - (IXR_TXOW) Запись «1» сбрасывает маску прерывания (запрещает прерывание) когда TX_FIFO не заполнен"]
# [inline (always)]
pub fn tx_fifo_not_full (& mut self) -> TxFifoNotFullW < IntDisableSpec > { TxFifoNotFullW :: new (self , 2) } # [doc = "Bit 3 - (IXR_TXFULL) Запись «1» сбрасывает маску прерывания (запрещает прерывание), когда TX_FIFO заполнен"]
# [inline (always)]
pub fn tx_fifo_full (& mut self) -> TxFifoFullW < IntDisableSpec > { TxFifoFullW :: new (self , 3) } # [doc = "Bit 4 - (IXR_RXNEMPTY) Запись «1» сбрасывает маску прерывания (запрещает прерывание), когда RX_FIFO не пустой"]
# [inline (always)]
pub fn rx_fifo_not_empty (& mut self) -> RxFifoNotEmptyW < IntDisableSpec > { RxFifoNotEmptyW :: new (self , 4) } # [doc = "Bit 5 - (IXR_RXFULL) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при заполнении RX_FIFO"]
# [inline (always)]
pub fn px_fifo_full (& mut self) -> PxFifoFullW < IntDisableSpec > { PxFifoFullW :: new (self , 5) } # [doc = "Bit 6 - (IXR_TXUF) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при опустошении TX_FIFO"]
# [inline (always)]
pub fn tx_fifo_underflow (& mut self) -> TxFifoUnderflowW < IntDisableSpec > { TxFifoUnderflowW :: new (self , 6) } } # [doc = "Регистр запрета прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_disable::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntDisableSpec ; impl crate :: RegisterSpec for IntDisableSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`int_disable::W`](W) writer structure"]
impl crate :: Writable for IntDisableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_DISABLE to value 0"]
impl crate :: Resettable for IntDisableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INT_MASK (r) register accessor: Регистр текущих масок прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mask::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_mask`]
module"]
# [doc (alias = "INT_MASK")]
pub type IntMask = crate :: Reg < int_mask :: IntMaskSpec > ; # [doc = "Регистр текущих масок прерываний"]
pub mod int_mask { # [doc = "Register `INT_MASK` reader"]
pub type R = crate :: R < IntMaskSpec > ; # [doc = "(IXR_RXOVR) Текущее состояние маски прерывания при переполнении при приеме\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RxOverflow { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < RxOverflow > for bool { # [inline (always)]
fn from (variant : RxOverflow) -> Self { variant as u8 != 0 } } # [doc = "Field `RX_OVERFLOW` reader - (IXR_RXOVR) Текущее состояние маски прерывания при переполнении при приеме"]
pub type RxOverflowR = crate :: BitReader < RxOverflow > ; impl RxOverflowR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RxOverflow { match self . bits { false => RxOverflow :: Disable , true => RxOverflow :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == RxOverflow :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == RxOverflow :: Enable } } # [doc = "(IXR_MODF) Текущее состояние маски прерывания при нарушении режима\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ModeFail { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < ModeFail > for bool { # [inline (always)]
fn from (variant : ModeFail) -> Self { variant as u8 != 0 } } # [doc = "Field `MODE_FAIL` reader - (IXR_MODF) Текущее состояние маски прерывания при нарушении режима"]
pub type ModeFailR = crate :: BitReader < ModeFail > ; impl ModeFailR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ModeFail { match self . bits { false => ModeFail :: Disable , true => ModeFail :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == ModeFail :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == ModeFail :: Enable } } # [doc = "(IXR_TXOW) Текущее состояние маски прерывания, когда TX_FIFO не заполнен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoNotFull { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < TxFifoNotFull > for bool { # [inline (always)]
fn from (variant : TxFifoNotFull) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_NOT_FULL` reader - (IXR_TXOW) Текущее состояние маски прерывания, когда TX_FIFO не заполнен"]
pub type TxFifoNotFullR = crate :: BitReader < TxFifoNotFull > ; impl TxFifoNotFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoNotFull { match self . bits { false => TxFifoNotFull :: Disable , true => TxFifoNotFull :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == TxFifoNotFull :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == TxFifoNotFull :: Enable } } # [doc = "(IXR_TXFULL) Текущее состояние маски прерывания, когда TX_FIFO заполнен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoFull { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < TxFifoFull > for bool { # [inline (always)]
fn from (variant : TxFifoFull) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_FULL` reader - (IXR_TXFULL) Текущее состояние маски прерывания, когда TX_FIFO заполнен"]
pub type TxFifoFullR = crate :: BitReader < TxFifoFull > ; impl TxFifoFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoFull { match self . bits { false => TxFifoFull :: Disable , true => TxFifoFull :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == TxFifoFull :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == TxFifoFull :: Enable } } # [doc = "(IXR_RXNEMPTY) Текущее состояние маски прерывания, когда RX_FIFO не пустой\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RxFifoNotEmpty { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < RxFifoNotEmpty > for bool { # [inline (always)]
fn from (variant : RxFifoNotEmpty) -> Self { variant as u8 != 0 } } # [doc = "Field `RX_FIFO_NOT_EMPTY` reader - (IXR_RXNEMPTY) Текущее состояние маски прерывания, когда RX_FIFO не пустой"]
pub type RxFifoNotEmptyR = crate :: BitReader < RxFifoNotEmpty > ; impl RxFifoNotEmptyR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RxFifoNotEmpty { match self . bits { false => RxFifoNotEmpty :: Disable , true => RxFifoNotEmpty :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == RxFifoNotEmpty :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == RxFifoNotEmpty :: Enable } } # [doc = "(IXR_RXFULL) Текущее состояние маски прерывания при заполнении RX_FIFO\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PxFifoFull { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < PxFifoFull > for bool { # [inline (always)]
fn from (variant : PxFifoFull) -> Self { variant as u8 != 0 } } # [doc = "Field `PX_FIFO_FULL` reader - (IXR_RXFULL) Текущее состояние маски прерывания при заполнении RX_FIFO"]
pub type PxFifoFullR = crate :: BitReader < PxFifoFull > ; impl PxFifoFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PxFifoFull { match self . bits { false => PxFifoFull :: Disable , true => PxFifoFull :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PxFifoFull :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PxFifoFull :: Enable } } # [doc = "(IXR_TXUF) Текущее состояние маски прерывания при опустошении\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoUnderflow { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < TxFifoUnderflow > for bool { # [inline (always)]
fn from (variant : TxFifoUnderflow) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_UNDERFLOW` reader - (IXR_TXUF) Текущее состояние маски прерывания при опустошении"]
pub type TxFifoUnderflowR = crate :: BitReader < TxFifoUnderflow > ; impl TxFifoUnderflowR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoUnderflow { match self . bits { false => TxFifoUnderflow :: Disable , true => TxFifoUnderflow :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == TxFifoUnderflow :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == TxFifoUnderflow :: Enable } } impl R { # [doc = "Bit 0 - (IXR_RXOVR) Текущее состояние маски прерывания при переполнении при приеме"]
# [inline (always)]
pub fn rx_overflow (& self) -> RxOverflowR { RxOverflowR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - (IXR_MODF) Текущее состояние маски прерывания при нарушении режима"]
# [inline (always)]
pub fn mode_fail (& self) -> ModeFailR { ModeFailR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - (IXR_TXOW) Текущее состояние маски прерывания, когда TX_FIFO не заполнен"]
# [inline (always)]
pub fn tx_fifo_not_full (& self) -> TxFifoNotFullR { TxFifoNotFullR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - (IXR_TXFULL) Текущее состояние маски прерывания, когда TX_FIFO заполнен"]
# [inline (always)]
pub fn tx_fifo_full (& self) -> TxFifoFullR { TxFifoFullR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - (IXR_RXNEMPTY) Текущее состояние маски прерывания, когда RX_FIFO не пустой"]
# [inline (always)]
pub fn rx_fifo_not_empty (& self) -> RxFifoNotEmptyR { RxFifoNotEmptyR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - (IXR_RXFULL) Текущее состояние маски прерывания при заполнении RX_FIFO"]
# [inline (always)]
pub fn px_fifo_full (& self) -> PxFifoFullR { PxFifoFullR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - (IXR_TXUF) Текущее состояние маски прерывания при опустошении"]
# [inline (always)]
pub fn tx_fifo_underflow (& self) -> TxFifoUnderflowR { TxFifoUnderflowR :: new (((self . bits >> 6) & 1) != 0) } } # [doc = "Регистр текущих масок прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mask::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntMaskSpec ; impl crate :: RegisterSpec for IntMaskSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`int_mask::R`](R) reader structure"]
impl crate :: Readable for IntMaskSpec { } # [doc = "`reset()` method sets INT_MASK to value 0"]
impl crate :: Resettable for IntMaskSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ENABLE (rw) register accessor: Регистр включения/выключения SPI\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable`]
module"]
# [doc (alias = "ENABLE")]
pub type Enable = crate :: Reg < enable :: EnableSpec > ; # [doc = "Регистр включения/выключения SPI"]
pub mod enable { # [doc = "Register `ENABLE` reader"]
pub type R = crate :: R < EnableSpec > ; # [doc = "Register `ENABLE` writer"]
pub type W = crate :: W < EnableSpec > ; # [doc = "(ENABLE) Включение/выключение модуля SPI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SpiEn { # [doc = "0: Выключение модуля SPI"]
Disable = 0 , # [doc = "1: Включение модуля SPI"]
Enable = 1 , } impl From < SpiEn > for bool { # [inline (always)]
fn from (variant : SpiEn) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_EN` reader - (ENABLE) Включение/выключение модуля SPI"]
pub type SpiEnR = crate :: BitReader < SpiEn > ; impl SpiEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> SpiEn { match self . bits { false => SpiEn :: Disable , true => SpiEn :: Enable , } } # [doc = "Выключение модуля SPI"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SpiEn :: Disable } # [doc = "Включение модуля SPI"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == SpiEn :: Enable } } # [doc = "Field `SPI_EN` writer - (ENABLE) Включение/выключение модуля SPI"]
pub type SpiEnW < 'a , REG > = crate :: BitWriter < 'a , REG , SpiEn > ; impl < 'a , REG > SpiEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Выключение модуля SPI"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (SpiEn :: Disable) } # [doc = "Включение модуля SPI"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (SpiEn :: Enable) } } # [doc = "Field `CLEAR_TX_FIFO` writer - Запись 1 при SPI_EN = 0 очищает буфер TX_FIFO."]
pub type ClearTxFifoW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `CLEAR_PX_FIFO` writer - Запись 1 при SPI_EN = 0 очищает буфер RX_FIFO."]
pub type ClearPxFifoW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - (ENABLE) Включение/выключение модуля SPI"]
# [inline (always)]
pub fn spi_en (& self) -> SpiEnR { SpiEnR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - (ENABLE) Включение/выключение модуля SPI"]
# [inline (always)]
pub fn spi_en (& mut self) -> SpiEnW < EnableSpec > { SpiEnW :: new (self , 0) } # [doc = "Bit 2 - Запись 1 при SPI_EN = 0 очищает буфер TX_FIFO."]
# [inline (always)]
pub fn clear_tx_fifo (& mut self) -> ClearTxFifoW < EnableSpec > { ClearTxFifoW :: new (self , 2) } # [doc = "Bit 3 - Запись 1 при SPI_EN = 0 очищает буфер RX_FIFO."]
# [inline (always)]
pub fn clear_px_fifo (& mut self) -> ClearPxFifoW < EnableSpec > { ClearPxFifoW :: new (self , 3) } } # [doc = "Регистр включения/выключения SPI\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EnableSpec ; impl crate :: RegisterSpec for EnableSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`enable::R`](R) reader structure"]
impl crate :: Readable for EnableSpec { } # [doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
impl crate :: Writable for EnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ENABLE to value 0"]
impl crate :: Resettable for EnableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DELAY (rw) register accessor: Регистр задержек\n\nYou can [`read`](crate::Reg::read) this register and get [`delay::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`delay::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@delay`]
module"]
# [doc (alias = "DELAY")]
pub type Delay = crate :: Reg < delay :: DelaySpec > ; # [doc = "Регистр задержек"]
pub mod delay { # [doc = "Register `DELAY` reader"]
pub type R = crate :: R < DelaySpec > ; # [doc = "Register `DELAY` writer"]
pub type W = crate :: W < DelaySpec > ; # [doc = "Field `D_INT` reader - (INIT) Дополнительная задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между установкой сигнала n_ss_out в «0» и передачей первого бита"]
pub type DIntR = crate :: FieldReader ; # [doc = "Field `D_INT` writer - (INIT) Дополнительная задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между установкой сигнала n_ss_out в «0» и передачей первого бита"]
pub type DIntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `D_AFTER` reader - (AFTER) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между последним битом текущего слова и первым битом следующего слова"]
pub type DAfterR = crate :: FieldReader ; # [doc = "Field `D_AFTER` writer - (AFTER) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между последним битом текущего слова и первым битом следующего слова"]
pub type DAfterW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `D_BTWN` reader - (BTWN) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между снятием сигнала выбора одного ведомого устройства и установкой сигнала выбора другого ведомого устройства"]
pub type DBtwnR = crate :: FieldReader ; # [doc = "Field `D_BTWN` writer - (BTWN) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между снятием сигнала выбора одного ведомого устройства и установкой сигнала выбора другого ведомого устройства"]
pub type DBtwnW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7 - (INIT) Дополнительная задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между установкой сигнала n_ss_out в «0» и передачей первого бита"]
# [inline (always)]
pub fn d_int (& self) -> DIntR { DIntR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - (AFTER) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между последним битом текущего слова и первым битом следующего слова"]
# [inline (always)]
pub fn d_after (& self) -> DAfterR { DAfterR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:23 - (BTWN) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между снятием сигнала выбора одного ведомого устройства и установкой сигнала выбора другого ведомого устройства"]
# [inline (always)]
pub fn d_btwn (& self) -> DBtwnR { DBtwnR :: new (((self . bits >> 16) & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - (INIT) Дополнительная задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между установкой сигнала n_ss_out в «0» и передачей первого бита"]
# [inline (always)]
pub fn d_int (& mut self) -> DIntW < DelaySpec > { DIntW :: new (self , 0) } # [doc = "Bits 8:15 - (AFTER) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между последним битом текущего слова и первым битом следующего слова"]
# [inline (always)]
pub fn d_after (& mut self) -> DAfterW < DelaySpec > { DAfterW :: new (self , 8) } # [doc = "Bits 16:23 - (BTWN) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между снятием сигнала выбора одного ведомого устройства и установкой сигнала выбора другого ведомого устройства"]
# [inline (always)]
pub fn d_btwn (& mut self) -> DBtwnW < DelaySpec > { DBtwnW :: new (self , 16) } } # [doc = "Регистр задержек\n\nYou can [`read`](crate::Reg::read) this register and get [`delay::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`delay::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DelaySpec ; impl crate :: RegisterSpec for DelaySpec { type Ux = u32 ; } # [doc = "`read()` method returns [`delay::R`](R) reader structure"]
impl crate :: Readable for DelaySpec { } # [doc = "`write(|w| ..)` method takes [`delay::W`](W) writer structure"]
impl crate :: Writable for DelaySpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DELAY to value 0"]
impl crate :: Resettable for DelaySpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TXDATA (w) register accessor: Регистр передаваемых данных\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdata::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txdata`]
module"]
# [doc (alias = "TXDATA")]
pub type Txdata = crate :: Reg < txdata :: TxdataSpec > ; # [doc = "Регистр передаваемых данных"]
pub mod txdata { # [doc = "Register `TXDATA` writer"]
pub type W = crate :: W < TxdataSpec > ; # [doc = "Field `TX_FIFO_data` writer - Данные для TX_FIFO"]
pub type TxFifoDataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl W { # [doc = "Bits 0:7 - Данные для TX_FIFO"]
# [inline (always)]
pub fn tx_fifo_data (& mut self) -> TxFifoDataW < TxdataSpec > { TxFifoDataW :: new (self , 0) } } # [doc = "Регистр передаваемых данных\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdata::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxdataSpec ; impl crate :: RegisterSpec for TxdataSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`txdata::W`](W) writer structure"]
impl crate :: Writable for TxdataSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TXDATA to value 0"]
impl crate :: Resettable for TxdataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RXDATA (r) register accessor: Регистр принимаемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdata::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxdata`]
module"]
# [doc (alias = "RXDATA")]
pub type Rxdata = crate :: Reg < rxdata :: RxdataSpec > ; # [doc = "Регистр принимаемых данных"]
pub mod rxdata { # [doc = "Register `RXDATA` reader"]
pub type R = crate :: R < RxdataSpec > ; # [doc = "Field `RX_FIFO_data` reader - Данные из RX_FIFO."]
pub type RxFifoDataR = crate :: FieldReader ; impl R { # [doc = "Bits 0:7 - Данные из RX_FIFO."]
# [inline (always)]
pub fn rx_fifo_data (& self) -> RxFifoDataR { RxFifoDataR :: new ((self . bits & 0xff) as u8) } } # [doc = "Регистр принимаемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdata::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxdataSpec ; impl crate :: RegisterSpec for RxdataSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rxdata::R`](R) reader structure"]
impl crate :: Readable for RxdataSpec { } # [doc = "`reset()` method sets RXDATA to value 0"]
impl crate :: Resettable for RxdataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SIC (rw) register accessor: Регистр счетчика останова ведомого устройства\n\nYou can [`read`](crate::Reg::read) this register and get [`sic::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sic::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sic`]
module"]
# [doc (alias = "SIC")]
pub type Sic = crate :: Reg < sic :: SicSpec > ; # [doc = "Регистр счетчика останова ведомого устройства"]
pub mod sic { # [doc = "Register `SIC` reader"]
pub type R = crate :: R < SicSpec > ; # [doc = "Register `SIC` writer"]
pub type W = crate :: W < SicSpec > ; # [doc = "Field `Slave_Idle_coun` reader - Модуль SPI в режиме ведомого устройства начинает передачу только когда тактовый сигнал sclk_in (внешнего ведущего устройства) не изменяется в течение количества периодов опорного тактового сигнала SPI заданного в этом поле или когда модуль SPI не активен"]
pub type SlaveIdleCounR = crate :: FieldReader ; # [doc = "Field `Slave_Idle_coun` writer - Модуль SPI в режиме ведомого устройства начинает передачу только когда тактовый сигнал sclk_in (внешнего ведущего устройства) не изменяется в течение количества периодов опорного тактового сигнала SPI заданного в этом поле или когда модуль SPI не активен"]
pub type SlaveIdleCounW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7 - Модуль SPI в режиме ведомого устройства начинает передачу только когда тактовый сигнал sclk_in (внешнего ведущего устройства) не изменяется в течение количества периодов опорного тактового сигнала SPI заданного в этом поле или когда модуль SPI не активен"]
# [inline (always)]
pub fn slave_idle_coun (& self) -> SlaveIdleCounR { SlaveIdleCounR :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - Модуль SPI в режиме ведомого устройства начинает передачу только когда тактовый сигнал sclk_in (внешнего ведущего устройства) не изменяется в течение количества периодов опорного тактового сигнала SPI заданного в этом поле или когда модуль SPI не активен"]
# [inline (always)]
pub fn slave_idle_coun (& mut self) -> SlaveIdleCounW < SicSpec > { SlaveIdleCounW :: new (self , 0) } } # [doc = "Регистр счетчика останова ведомого устройства\n\nYou can [`read`](crate::Reg::read) this register and get [`sic::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sic::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SicSpec ; impl crate :: RegisterSpec for SicSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sic::R`](R) reader structure"]
impl crate :: Readable for SicSpec { } # [doc = "`write(|w| ..)` method takes [`sic::W`](W) writer structure"]
impl crate :: Writable for SicSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SIC to value 0xff"]
impl crate :: Resettable for SicSpec { const RESET_VALUE : u32 = 0xff ; } } # [doc = "TX_THR (rw) register accessor: Регистр пороговых значений TX_FIFO\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_thr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tx_thr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tx_thr`]
module"]
# [doc (alias = "TX_THR")]
pub type TxThr = crate :: Reg < tx_thr :: TxThrSpec > ; # [doc = "Регистр пороговых значений TX_FIFO"]
pub mod tx_thr { # [doc = "Register `TX_THR` reader"]
pub type R = crate :: R < TxThrSpec > ; # [doc = "Register `TX_THR` writer"]
pub type W = crate :: W < TxThrSpec > ; # [doc = "Field `Threshold_of_TX_FIFO` reader - Задает уровень, при котором TX_FIFO считается не заполненным и формируется прерывание"]
pub type ThresholdOfTxFifoR = crate :: FieldReader < u32 > ; # [doc = "Field `Threshold_of_TX_FIFO` writer - Задает уровень, при котором TX_FIFO считается не заполненным и формируется прерывание"]
pub type ThresholdOfTxFifoW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Задает уровень, при котором TX_FIFO считается не заполненным и формируется прерывание"]
# [inline (always)]
pub fn threshold_of_tx_fifo (& self) -> ThresholdOfTxFifoR { ThresholdOfTxFifoR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Задает уровень, при котором TX_FIFO считается не заполненным и формируется прерывание"]
# [inline (always)]
pub fn threshold_of_tx_fifo (& mut self) -> ThresholdOfTxFifoW < TxThrSpec > { ThresholdOfTxFifoW :: new (self , 0) } } # [doc = "Регистр пороговых значений TX_FIFO\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_thr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tx_thr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxThrSpec ; impl crate :: RegisterSpec for TxThrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`tx_thr::R`](R) reader structure"]
impl crate :: Readable for TxThrSpec { } # [doc = "`write(|w| ..)` method takes [`tx_thr::W`](W) writer structure"]
impl crate :: Writable for TxThrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TX_THR to value 0x01"]
impl crate :: Resettable for TxThrSpec { const RESET_VALUE : u32 = 0x01 ; } } # [doc = "ID (r) register accessor: Идентификационный номер модуля\n\nYou can [`read`](crate::Reg::read) this register and get [`id::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@id`]
module"]
# [doc (alias = "ID")]
pub type Id = crate :: Reg < id :: IdSpec > ; # [doc = "Идентификационный номер модуля"]
pub mod id { # [doc = "Register `ID` reader"]
pub type R = crate :: R < IdSpec > ; # [doc = "Field `Threshold_of_TX_FIFO` reader - Идентификационный номер модуля"]
pub type ThresholdOfTxFifoR = crate :: FieldReader < u32 > ; impl R { # [doc = "Bits 0:31 - Идентификационный номер модуля"]
# [inline (always)]
pub fn threshold_of_tx_fifo (& self) -> ThresholdOfTxFifoR { ThresholdOfTxFifoR :: new (self . bits) } } # [doc = "Идентификационный номер модуля\n\nYou can [`read`](crate::Reg::read) this register and get [`id::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IdSpec ; impl crate :: RegisterSpec for IdSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`id::R`](R) reader structure"]
impl crate :: Readable for IdSpec { } # [doc = "`reset()` method sets ID to value 0x0109_0100"]
impl crate :: Resettable for IdSpec { const RESET_VALUE : u32 = 0x0109_0100 ; } } } # [doc = "Модуль обеспечивает взаимодействие с различными периферийными устройствами"]
pub struct Spi1 { _marker : PhantomData < * const () > } unsafe impl Send for Spi1 { } impl Spi1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const spi_1 :: RegisterBlock = 0x0008_3400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const spi_1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Spi1 { type Target = spi_1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Spi1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Spi1") . finish () } } # [doc = "Модуль обеспечивает взаимодействие с различными периферийными устройствами"]
pub mod spi_1 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { config : Config , status : Status , int_enable : IntEnable , int_disable : IntDisable , int_mask : IntMask , enable : Enable , delay : Delay , txdata : Txdata , rxdata : Rxdata , sic : Sic , tx_thr : TxThr , id : Id , } impl RegisterBlock { # [doc = "0x00 - Регистр конфигурации SPI"]
# [inline (always)]
pub const fn config (& self) -> & Config { & self . config } # [doc = "0x04 - Регистр статуса. Примечание: биты регистра \\[6:0\\]
устанавливаются в «1», если произошло событие вызывающее прерывание."]
# [inline (always)]
pub const fn status (& self) -> & Status { & self . status } # [doc = "0x08 - Регистр разрешения прерываний"]
# [inline (always)]
pub const fn int_enable (& self) -> & IntEnable { & self . int_enable } # [doc = "0x0c - Регистр запрета прерываний"]
# [inline (always)]
pub const fn int_disable (& self) -> & IntDisable { & self . int_disable } # [doc = "0x10 - Регистр текущих масок прерываний"]
# [inline (always)]
pub const fn int_mask (& self) -> & IntMask { & self . int_mask } # [doc = "0x14 - Регистр включения/выключения SPI"]
# [inline (always)]
pub const fn enable (& self) -> & Enable { & self . enable } # [doc = "0x18 - Регистр задержек"]
# [inline (always)]
pub const fn delay (& self) -> & Delay { & self . delay } # [doc = "0x1c - Регистр передаваемых данных"]
# [inline (always)]
pub const fn txdata (& self) -> & Txdata { & self . txdata } # [doc = "0x20 - Регистр принимаемых данных"]
# [inline (always)]
pub const fn rxdata (& self) -> & Rxdata { & self . rxdata } # [doc = "0x24 - Регистр счетчика останова ведомого устройства"]
# [inline (always)]
pub const fn sic (& self) -> & Sic { & self . sic } # [doc = "0x28 - Регистр пороговых значений TX_FIFO"]
# [inline (always)]
pub const fn tx_thr (& self) -> & TxThr { & self . tx_thr } # [doc = "0x2c - Идентификационный номер модуля"]
# [inline (always)]
pub const fn id (& self) -> & Id { & self . id } } # [doc = "CONFIG (rw) register accessor: Регистр конфигурации SPI\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@config`]
module"]
# [doc (alias = "CONFIG")]
pub type Config = crate :: Reg < config :: ConfigSpec > ; # [doc = "Регистр конфигурации SPI"]
pub mod config { # [doc = "Register `CONFIG` reader"]
pub type R = crate :: R < ConfigSpec > ; # [doc = "Register `CONFIG` writer"]
pub type W = crate :: W < ConfigSpec > ; # [doc = "(MSTREN) Выбор режима\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ModeSel { # [doc = "0: SPI в режиме ведомого устройства"]
Slave = 0 , # [doc = "1: SPI в режиме ведущего устройства"]
Master = 1 , } impl From < ModeSel > for bool { # [inline (always)]
fn from (variant : ModeSel) -> Self { variant as u8 != 0 } } # [doc = "Field `MODE_SEL` reader - (MSTREN) Выбор режима"]
pub type ModeSelR = crate :: BitReader < ModeSel > ; impl ModeSelR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ModeSel { match self . bits { false => ModeSel :: Slave , true => ModeSel :: Master , } } # [doc = "SPI в режиме ведомого устройства"]
# [inline (always)]
pub fn is_slave (& self) -> bool { * self == ModeSel :: Slave } # [doc = "SPI в режиме ведущего устройства"]
# [inline (always)]
pub fn is_master (& self) -> bool { * self == ModeSel :: Master } } # [doc = "Field `MODE_SEL` writer - (MSTREN) Выбор режима"]
pub type ModeSelW < 'a , REG > = crate :: BitWriter < 'a , REG , ModeSel > ; impl < 'a , REG > ModeSelW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "SPI в режиме ведомого устройства"]
# [inline (always)]
pub fn slave (self) -> & 'a mut crate :: W < REG > { self . variant (ModeSel :: Slave) } # [doc = "SPI в режиме ведущего устройства"]
# [inline (always)]
pub fn master (self) -> & 'a mut crate :: W < REG > { self . variant (ModeSel :: Master) } } # [doc = "(CPOL)Выбор полярности тактового сигнала вне слова\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ClkPol { # [doc = "0: Тактовый сигнал вне слова удерживается на низком уровне"]
_0 = 0 , # [doc = "1: Тактовый сигнал вне слова удерживается на высоком уровне"]
_1 = 1 , } impl From < ClkPol > for bool { # [inline (always)]
fn from (variant : ClkPol) -> Self { variant as u8 != 0 } } # [doc = "Field `CLK_POL` reader - (CPOL)Выбор полярности тактового сигнала вне слова"]
pub type ClkPolR = crate :: BitReader < ClkPol > ; impl ClkPolR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ClkPol { match self . bits { false => ClkPol :: _0 , true => ClkPol :: _1 , } } # [doc = "Тактовый сигнал вне слова удерживается на низком уровне"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == ClkPol :: _0 } # [doc = "Тактовый сигнал вне слова удерживается на высоком уровне"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == ClkPol :: _1 } } # [doc = "Field `CLK_POL` writer - (CPOL)Выбор полярности тактового сигнала вне слова"]
pub type ClkPolW < 'a , REG > = crate :: BitWriter < 'a , REG , ClkPol > ; impl < 'a , REG > ClkPolW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактовый сигнал вне слова удерживается на низком уровне"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (ClkPol :: _0) } # [doc = "Тактовый сигнал вне слова удерживается на высоком уровне"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (ClkPol :: _1) } } # [doc = "(CPHA)Выбор фазы тактового сигнала\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ClkPh { # [doc = "0: Тактовая частота SPI неактивна вне слова"]
_0 = 0 , # [doc = "1: Тактовая частота SPI активна вне слова"]
_1 = 1 , } impl From < ClkPh > for bool { # [inline (always)]
fn from (variant : ClkPh) -> Self { variant as u8 != 0 } } # [doc = "Field `CLK_PH` reader - (CPHA)Выбор фазы тактового сигнала"]
pub type ClkPhR = crate :: BitReader < ClkPh > ; impl ClkPhR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ClkPh { match self . bits { false => ClkPh :: _0 , true => ClkPh :: _1 , } } # [doc = "Тактовая частота SPI неактивна вне слова"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == ClkPh :: _0 } # [doc = "Тактовая частота SPI активна вне слова"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == ClkPh :: _1 } } # [doc = "Field `CLK_PH` writer - (CPHA)Выбор фазы тактового сигнала"]
pub type ClkPhW < 'a , REG > = crate :: BitWriter < 'a , REG , ClkPh > ; impl < 'a , REG > ClkPhW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактовая частота SPI неактивна вне слова"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (ClkPh :: _0) } # [doc = "Тактовая частота SPI активна вне слова"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (ClkPh :: _1) } } # [doc = "Управляет скоростью передачи данных, задает коэффициент деления частоты spi_ref_clk\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum BaudRateDiv { # [doc = "0: Не поддерживается"]
NotSupported = 0 , # [doc = "1: Деление на 4"]
Div4 = 1 , # [doc = "2: Деление на 8"]
Div8 = 2 , # [doc = "3: Деление на 16"]
Div16 = 3 , # [doc = "4: Деление на 32"]
Div32 = 4 , # [doc = "5: деление на 64"]
Div64 = 5 , # [doc = "6: деление на 128"]
Div128 = 6 , # [doc = "7: деление на 256"]
Div256 = 7 , } impl From < BaudRateDiv > for u8 { # [inline (always)]
fn from (variant : BaudRateDiv) -> Self { variant as _ } } impl crate :: FieldSpec for BaudRateDiv { type Ux = u8 ; } impl crate :: IsEnum for BaudRateDiv { } # [doc = "Field `BAUD_RATE_DIV` reader - Управляет скоростью передачи данных, задает коэффициент деления частоты spi_ref_clk"]
pub type BaudRateDivR = crate :: FieldReader < BaudRateDiv > ; impl BaudRateDivR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> BaudRateDiv { match self . bits { 0 => BaudRateDiv :: NotSupported , 1 => BaudRateDiv :: Div4 , 2 => BaudRateDiv :: Div8 , 3 => BaudRateDiv :: Div16 , 4 => BaudRateDiv :: Div32 , 5 => BaudRateDiv :: Div64 , 6 => BaudRateDiv :: Div128 , 7 => BaudRateDiv :: Div256 , _ => unreachable ! () , } } # [doc = "Не поддерживается"]
# [inline (always)]
pub fn is_not_supported (& self) -> bool { * self == BaudRateDiv :: NotSupported } # [doc = "Деление на 4"]
# [inline (always)]
pub fn is_div4 (& self) -> bool { * self == BaudRateDiv :: Div4 } # [doc = "Деление на 8"]
# [inline (always)]
pub fn is_div8 (& self) -> bool { * self == BaudRateDiv :: Div8 } # [doc = "Деление на 16"]
# [inline (always)]
pub fn is_div16 (& self) -> bool { * self == BaudRateDiv :: Div16 } # [doc = "Деление на 32"]
# [inline (always)]
pub fn is_div32 (& self) -> bool { * self == BaudRateDiv :: Div32 } # [doc = "деление на 64"]
# [inline (always)]
pub fn is_div64 (& self) -> bool { * self == BaudRateDiv :: Div64 } # [doc = "деление на 128"]
# [inline (always)]
pub fn is_div128 (& self) -> bool { * self == BaudRateDiv :: Div128 } # [doc = "деление на 256"]
# [inline (always)]
pub fn is_div256 (& self) -> bool { * self == BaudRateDiv :: Div256 } } # [doc = "Field `BAUD_RATE_DIV` writer - Управляет скоростью передачи данных, задает коэффициент деления частоты spi_ref_clk"]
pub type BaudRateDivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , BaudRateDiv , crate :: Safe > ; impl < 'a , REG > BaudRateDivW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Не поддерживается"]
# [inline (always)]
pub fn not_supported (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: NotSupported) } # [doc = "Деление на 4"]
# [inline (always)]
pub fn div4 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div4) } # [doc = "Деление на 8"]
# [inline (always)]
pub fn div8 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div8) } # [doc = "Деление на 16"]
# [inline (always)]
pub fn div16 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div16) } # [doc = "Деление на 32"]
# [inline (always)]
pub fn div32 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div32) } # [doc = "деление на 64"]
# [inline (always)]
pub fn div64 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div64) } # [doc = "деление на 128"]
# [inline (always)]
pub fn div128 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div128) } # [doc = "деление на 256"]
# [inline (always)]
pub fn div256 (self) -> & 'a mut crate :: W < REG > { self . variant (BaudRateDiv :: Div256) } } # [doc = "Выбор опорной тактовой частоты\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RefClk { # [doc = "0: Не поддерживается"]
NotSupported = 0 , # [doc = "1: Используется опорная частота SPI"]
ApbPClk = 1 , } impl From < RefClk > for bool { # [inline (always)]
fn from (variant : RefClk) -> Self { variant as u8 != 0 } } # [doc = "Field `REF_CLK` reader - Выбор опорной тактовой частоты"]
pub type RefClkR = crate :: BitReader < RefClk > ; impl RefClkR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RefClk { match self . bits { false => RefClk :: NotSupported , true => RefClk :: ApbPClk , } } # [doc = "Не поддерживается"]
# [inline (always)]
pub fn is_not_supported (& self) -> bool { * self == RefClk :: NotSupported } # [doc = "Используется опорная частота SPI"]
# [inline (always)]
pub fn is_apb_p_clk (& self) -> bool { * self == RefClk :: ApbPClk } } # [doc = "Field `REF_CLK` writer - Выбор опорной тактовой частоты"]
pub type RefClkW < 'a , REG > = crate :: BitWriter < 'a , REG , RefClk > ; impl < 'a , REG > RefClkW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Не поддерживается"]
# [inline (always)]
pub fn not_supported (self) -> & 'a mut crate :: W < REG > { self . variant (RefClk :: NotSupported) } # [doc = "Используется опорная частота SPI"]
# [inline (always)]
pub fn apb_p_clk (self) -> & 'a mut crate :: W < REG > { self . variant (RefClk :: ApbPClk) } } # [doc = "Выбор ведомых устройств\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Cs { # [doc = "15: Ведомые устройства не выбраны"]
NotSelected = 15 , # [doc = "1: Выбрано устройство 1"]
Cs1 = 1 , # [doc = "3: Выбрано устройство 2"]
Cs2 = 3 , # [doc = "7: Выбрано устройство 3"]
Cs3 = 7 , # [doc = "0: Выбрано устройство 4"]
Cs4 = 0 , } impl From < Cs > for u8 { # [inline (always)]
fn from (variant : Cs) -> Self { variant as _ } } impl crate :: FieldSpec for Cs { type Ux = u8 ; } impl crate :: IsEnum for Cs { } # [doc = "Field `CS` reader - Выбор ведомых устройств"]
pub type CsR = crate :: FieldReader < Cs > ; impl CsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < Cs > { match self . bits { 15 => Some (Cs :: NotSelected) , 1 => Some (Cs :: Cs1) , 3 => Some (Cs :: Cs2) , 7 => Some (Cs :: Cs3) , 0 => Some (Cs :: Cs4) , _ => None , } } # [doc = "Ведомые устройства не выбраны"]
# [inline (always)]
pub fn is_not_selected (& self) -> bool { * self == Cs :: NotSelected } # [doc = "Выбрано устройство 1"]
# [inline (always)]
pub fn is_cs1 (& self) -> bool { * self == Cs :: Cs1 } # [doc = "Выбрано устройство 2"]
# [inline (always)]
pub fn is_cs2 (& self) -> bool { * self == Cs :: Cs2 } # [doc = "Выбрано устройство 3"]
# [inline (always)]
pub fn is_cs3 (& self) -> bool { * self == Cs :: Cs3 } # [doc = "Выбрано устройство 4"]
# [inline (always)]
pub fn is_cs4 (& self) -> bool { * self == Cs :: Cs4 } } # [doc = "Field `CS` writer - Выбор ведомых устройств"]
pub type CsW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Cs > ; impl < 'a , REG > CsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Ведомые устройства не выбраны"]
# [inline (always)]
pub fn not_selected (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: NotSelected) } # [doc = "Выбрано устройство 1"]
# [inline (always)]
pub fn cs1 (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: Cs1) } # [doc = "Выбрано устройство 2"]
# [inline (always)]
pub fn cs2 (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: Cs2) } # [doc = "Выбрано устройство 3"]
# [inline (always)]
pub fn cs3 (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: Cs3) } # [doc = "Выбрано устройство 4"]
# [inline (always)]
pub fn cs4 (self) -> & 'a mut crate :: W < REG > { self . variant (Cs :: Cs4) } } # [doc = "Выбор режима управления сигналом выбора ведомого\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ManualCs { # [doc = "0: Автоматический режим"]
Automatic = 0 , # [doc = "1: Ручной режим"]
Manual = 1 , } impl From < ManualCs > for bool { # [inline (always)]
fn from (variant : ManualCs) -> Self { variant as u8 != 0 } } # [doc = "Field `Manual_CS` reader - Выбор режима управления сигналом выбора ведомого"]
pub type ManualCsR = crate :: BitReader < ManualCs > ; impl ManualCsR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ManualCs { match self . bits { false => ManualCs :: Automatic , true => ManualCs :: Manual , } } # [doc = "Автоматический режим"]
# [inline (always)]
pub fn is_automatic (& self) -> bool { * self == ManualCs :: Automatic } # [doc = "Ручной режим"]
# [inline (always)]
pub fn is_manual (& self) -> bool { * self == ManualCs :: Manual } } # [doc = "Field `Manual_CS` writer - Выбор режима управления сигналом выбора ведомого"]
pub type ManualCsW < 'a , REG > = crate :: BitWriter < 'a , REG , ManualCs > ; impl < 'a , REG > ManualCsW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Автоматический режим"]
# [inline (always)]
pub fn automatic (self) -> & 'a mut crate :: W < REG > { self . variant (ManualCs :: Automatic) } # [doc = "Ручной режим"]
# [inline (always)]
pub fn manual (self) -> & 'a mut crate :: W < REG > { self . variant (ManualCs :: Manual) } } impl R { # [doc = "Bit 0 - (MSTREN) Выбор режима"]
# [inline (always)]
pub fn mode_sel (& self) -> ModeSelR { ModeSelR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - (CPOL)Выбор полярности тактового сигнала вне слова"]
# [inline (always)]
pub fn clk_pol (& self) -> ClkPolR { ClkPolR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - (CPHA)Выбор фазы тактового сигнала"]
# [inline (always)]
pub fn clk_ph (& self) -> ClkPhR { ClkPhR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:5 - Управляет скоростью передачи данных, задает коэффициент деления частоты spi_ref_clk"]
# [inline (always)]
pub fn baud_rate_div (& self) -> BaudRateDivR { BaudRateDivR :: new (((self . bits >> 3) & 7) as u8) } # [doc = "Bit 8 - Выбор опорной тактовой частоты"]
# [inline (always)]
pub fn ref_clk (& self) -> RefClkR { RefClkR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bits 10:13 - Выбор ведомых устройств"]
# [inline (always)]
pub fn cs (& self) -> CsR { CsR :: new (((self . bits >> 10) & 0x0f) as u8) } # [doc = "Bit 14 - Выбор режима управления сигналом выбора ведомого"]
# [inline (always)]
pub fn manual_cs (& self) -> ManualCsR { ManualCsR :: new (((self . bits >> 14) & 1) != 0) } } impl W { # [doc = "Bit 0 - (MSTREN) Выбор режима"]
# [inline (always)]
pub fn mode_sel (& mut self) -> ModeSelW < ConfigSpec > { ModeSelW :: new (self , 0) } # [doc = "Bit 1 - (CPOL)Выбор полярности тактового сигнала вне слова"]
# [inline (always)]
pub fn clk_pol (& mut self) -> ClkPolW < ConfigSpec > { ClkPolW :: new (self , 1) } # [doc = "Bit 2 - (CPHA)Выбор фазы тактового сигнала"]
# [inline (always)]
pub fn clk_ph (& mut self) -> ClkPhW < ConfigSpec > { ClkPhW :: new (self , 2) } # [doc = "Bits 3:5 - Управляет скоростью передачи данных, задает коэффициент деления частоты spi_ref_clk"]
# [inline (always)]
pub fn baud_rate_div (& mut self) -> BaudRateDivW < ConfigSpec > { BaudRateDivW :: new (self , 3) } # [doc = "Bit 8 - Выбор опорной тактовой частоты"]
# [inline (always)]
pub fn ref_clk (& mut self) -> RefClkW < ConfigSpec > { RefClkW :: new (self , 8) } # [doc = "Bits 10:13 - Выбор ведомых устройств"]
# [inline (always)]
pub fn cs (& mut self) -> CsW < ConfigSpec > { CsW :: new (self , 10) } # [doc = "Bit 14 - Выбор режима управления сигналом выбора ведомого"]
# [inline (always)]
pub fn manual_cs (& mut self) -> ManualCsW < ConfigSpec > { ManualCsW :: new (self , 14) } } # [doc = "Регистр конфигурации SPI\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ConfigSpec ; impl crate :: RegisterSpec for ConfigSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`config::R`](R) reader structure"]
impl crate :: Readable for ConfigSpec { } # [doc = "`write(|w| ..)` method takes [`config::W`](W) writer structure"]
impl crate :: Writable for ConfigSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONFIG to value 0"]
impl crate :: Resettable for ConfigSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "STATUS (rw) register accessor: Регистр статуса. Примечание: биты регистра \\[6:0\\]
устанавливаются в «1», если произошло событие вызывающее прерывание.\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`status::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@status`]
module"]
# [doc (alias = "STATUS")]
pub type Status = crate :: Reg < status :: StatusSpec > ; # [doc = "Регистр статуса. Примечание: биты регистра \\[6:0\\]
устанавливаются в «1», если произошло событие вызывающее прерывание."]
pub mod status { # [doc = "Register `STATUS` reader"]
pub type R = crate :: R < StatusSpec > ; # [doc = "Register `STATUS` writer"]
pub type W = crate :: W < StatusSpec > ; # [doc = "(IXR_RXOVR) Прерывание при переполнении RX_FIFO, значение сбрасывается при чтении\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RxOverflow { # [doc = "0: Нет переполнения"]
Ok = 0 , # [doc = "1: Переполнение RX_FIFO"]
Overflow = 1 , } impl From < RxOverflow > for bool { # [inline (always)]
fn from (variant : RxOverflow) -> Self { variant as u8 != 0 } } # [doc = "Field `RX_OVERFLOW` reader - (IXR_RXOVR) Прерывание при переполнении RX_FIFO, значение сбрасывается при чтении"]
pub type RxOverflowR = crate :: BitReader < RxOverflow > ; impl RxOverflowR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RxOverflow { match self . bits { false => RxOverflow :: Ok , true => RxOverflow :: Overflow , } } # [doc = "Нет переполнения"]
# [inline (always)]
pub fn is_ok (& self) -> bool { * self == RxOverflow :: Ok } # [doc = "Переполнение RX_FIFO"]
# [inline (always)]
pub fn is_overflow (& self) -> bool { * self == RxOverflow :: Overflow } } # [doc = "(IXR_MODF) Напряжение на выводе n_ss_in не соответствую режиму работы SPI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ModeFail { # [doc = "0: Корректная работа"]
Ok = 0 , # [doc = "1: n_ss_in имеет низкий уровень в режиме ведомого устройства"]
Fail = 1 , } impl From < ModeFail > for bool { # [inline (always)]
fn from (variant : ModeFail) -> Self { variant as u8 != 0 } } # [doc = "Field `MODE_FAIL` reader - (IXR_MODF) Напряжение на выводе n_ss_in не соответствую режиму работы SPI"]
pub type ModeFailR = crate :: BitReader < ModeFail > ; impl ModeFailR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ModeFail { match self . bits { false => ModeFail :: Ok , true => ModeFail :: Fail , } } # [doc = "Корректная работа"]
# [inline (always)]
pub fn is_ok (& self) -> bool { * self == ModeFail :: Ok } # [doc = "n_ss_in имеет низкий уровень в режиме ведомого устройства"]
# [inline (always)]
pub fn is_fail (& self) -> bool { * self == ModeFail :: Fail } } # [doc = "(IXR_TXOW) Регистр TX_FIFO не заполнен\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoNotFull { # [doc = "0: Регистр заполнен до значение THRESHOLD или больше"]
LessThanTheThreshold = 0 , # [doc = "1: Регистр заполнен меньше чем THRESHOLD"]
MoreThanTheThreshold = 1 , } impl From < TxFifoNotFull > for bool { # [inline (always)]
fn from (variant : TxFifoNotFull) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_NOT_FULL` reader - (IXR_TXOW) Регистр TX_FIFO не заполнен"]
pub type TxFifoNotFullR = crate :: BitReader < TxFifoNotFull > ; impl TxFifoNotFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoNotFull { match self . bits { false => TxFifoNotFull :: LessThanTheThreshold , true => TxFifoNotFull :: MoreThanTheThreshold , } } # [doc = "Регистр заполнен до значение THRESHOLD или больше"]
# [inline (always)]
pub fn is_less_than_the_threshold (& self) -> bool { * self == TxFifoNotFull :: LessThanTheThreshold } # [doc = "Регистр заполнен меньше чем THRESHOLD"]
# [inline (always)]
pub fn is_more_than_the_threshold (& self) -> bool { * self == TxFifoNotFull :: MoreThanTheThreshold } } # [doc = "(IXR_TXFULL) Регистр TX_FIFO заполнен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoFull { # [doc = "0: FIFO не заполнен"]
NotFull = 0 , # [doc = "1: FIFO заполнен"]
Full = 1 , } impl From < TxFifoFull > for bool { # [inline (always)]
fn from (variant : TxFifoFull) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_FULL` reader - (IXR_TXFULL) Регистр TX_FIFO заполнен"]
pub type TxFifoFullR = crate :: BitReader < TxFifoFull > ; impl TxFifoFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoFull { match self . bits { false => TxFifoFull :: NotFull , true => TxFifoFull :: Full , } } # [doc = "FIFO не заполнен"]
# [inline (always)]
pub fn is_not_full (& self) -> bool { * self == TxFifoFull :: NotFull } # [doc = "FIFO заполнен"]
# [inline (always)]
pub fn is_full (& self) -> bool { * self == TxFifoFull :: Full } } # [doc = "(IXR_RXNEMPTY) Регистр RX_FIFO не пустой\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RxFifoNotEmpty { # [doc = "0: FIFO пустой"]
Empty = 0 , # [doc = "1: В FIFO есть хотя бы один байт"]
NotEmpty = 1 , } impl From < RxFifoNotEmpty > for bool { # [inline (always)]
fn from (variant : RxFifoNotEmpty) -> Self { variant as u8 != 0 } } # [doc = "Field `RX_FIFO_NOT_EMPTY` reader - (IXR_RXNEMPTY) Регистр RX_FIFO не пустой"]
pub type RxFifoNotEmptyR = crate :: BitReader < RxFifoNotEmpty > ; impl RxFifoNotEmptyR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RxFifoNotEmpty { match self . bits { false => RxFifoNotEmpty :: Empty , true => RxFifoNotEmpty :: NotEmpty , } } # [doc = "FIFO пустой"]
# [inline (always)]
pub fn is_empty (& self) -> bool { * self == RxFifoNotEmpty :: Empty } # [doc = "В FIFO есть хотя бы один байт"]
# [inline (always)]
pub fn is_not_empty (& self) -> bool { * self == RxFifoNotEmpty :: NotEmpty } } # [doc = "(IXR_RXFULL) Регистр RX_FIFO заполнен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RxFifoFull { # [doc = "0: FIFO не заполнен"]
NotFull = 0 , # [doc = "1: FIFO заполнен"]
Full = 1 , } impl From < RxFifoFull > for bool { # [inline (always)]
fn from (variant : RxFifoFull) -> Self { variant as u8 != 0 } } # [doc = "Field `RX_FIFO_FULL` reader - (IXR_RXFULL) Регистр RX_FIFO заполнен"]
pub type RxFifoFullR = crate :: BitReader < RxFifoFull > ; impl RxFifoFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RxFifoFull { match self . bits { false => RxFifoFull :: NotFull , true => RxFifoFull :: Full , } } # [doc = "FIFO не заполнен"]
# [inline (always)]
pub fn is_not_full (& self) -> bool { * self == RxFifoFull :: NotFull } # [doc = "FIFO заполнен"]
# [inline (always)]
pub fn is_full (& self) -> bool { * self == RxFifoFull :: Full } } # [doc = "(IXR_TXUF) Регистр TX FIFO опустошен. Устанавливается в режиме ведомого в случае, если к началу обмена в TX_FIFO нет данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoUnderflow { # [doc = "0: Опустошение не детектируется"]
NotEmpty = 0 , # [doc = "1: Определение опустошения"]
Underflow = 1 , } impl From < TxFifoUnderflow > for bool { # [inline (always)]
fn from (variant : TxFifoUnderflow) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_UNDERFLOW` reader - (IXR_TXUF) Регистр TX FIFO опустошен. Устанавливается в режиме ведомого в случае, если к началу обмена в TX_FIFO нет данных"]
pub type TxFifoUnderflowR = crate :: BitReader < TxFifoUnderflow > ; impl TxFifoUnderflowR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoUnderflow { match self . bits { false => TxFifoUnderflow :: NotEmpty , true => TxFifoUnderflow :: Underflow , } } # [doc = "Опустошение не детектируется"]
# [inline (always)]
pub fn is_not_empty (& self) -> bool { * self == TxFifoUnderflow :: NotEmpty } # [doc = "Определение опустошения"]
# [inline (always)]
pub fn is_underflow (& self) -> bool { * self == TxFifoUnderflow :: Underflow } } # [doc = "Статус сеанса передачи\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SpiActive { # [doc = "0: Контроллер SPI в состоянии ожидания обмена"]
Ready = 0 , # [doc = "1: Контроллер SPI в процессе обмена"]
Busy = 1 , } impl From < SpiActive > for bool { # [inline (always)]
fn from (variant : SpiActive) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_ACTIVE` reader - Статус сеанса передачи"]
pub type SpiActiveR = crate :: BitReader < SpiActive > ; impl SpiActiveR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> SpiActive { match self . bits { false => SpiActive :: Ready , true => SpiActive :: Busy , } } # [doc = "Контроллер SPI в состоянии ожидания обмена"]
# [inline (always)]
pub fn is_ready (& self) -> bool { * self == SpiActive :: Ready } # [doc = "Контроллер SPI в процессе обмена"]
# [inline (always)]
pub fn is_busy (& self) -> bool { * self == SpiActive :: Busy } } impl R { # [doc = "Bit 0 - (IXR_RXOVR) Прерывание при переполнении RX_FIFO, значение сбрасывается при чтении"]
# [inline (always)]
pub fn rx_overflow (& self) -> RxOverflowR { RxOverflowR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - (IXR_MODF) Напряжение на выводе n_ss_in не соответствую режиму работы SPI"]
# [inline (always)]
pub fn mode_fail (& self) -> ModeFailR { ModeFailR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - (IXR_TXOW) Регистр TX_FIFO не заполнен"]
# [inline (always)]
pub fn tx_fifo_not_full (& self) -> TxFifoNotFullR { TxFifoNotFullR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - (IXR_TXFULL) Регистр TX_FIFO заполнен"]
# [inline (always)]
pub fn tx_fifo_full (& self) -> TxFifoFullR { TxFifoFullR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - (IXR_RXNEMPTY) Регистр RX_FIFO не пустой"]
# [inline (always)]
pub fn rx_fifo_not_empty (& self) -> RxFifoNotEmptyR { RxFifoNotEmptyR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - (IXR_RXFULL) Регистр RX_FIFO заполнен"]
# [inline (always)]
pub fn rx_fifo_full (& self) -> RxFifoFullR { RxFifoFullR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - (IXR_TXUF) Регистр TX FIFO опустошен. Устанавливается в режиме ведомого в случае, если к началу обмена в TX_FIFO нет данных"]
# [inline (always)]
pub fn tx_fifo_underflow (& self) -> TxFifoUnderflowR { TxFifoUnderflowR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 15 - Статус сеанса передачи"]
# [inline (always)]
pub fn spi_active (& self) -> SpiActiveR { SpiActiveR :: new (((self . bits >> 15) & 1) != 0) } } impl W { } # [doc = "Регистр статуса. Примечание: биты регистра \\[6:0\\]
устанавливаются в «1», если произошло событие вызывающее прерывание.\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`status::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StatusSpec ; impl crate :: RegisterSpec for StatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`status::R`](R) reader structure"]
impl crate :: Readable for StatusSpec { } # [doc = "`write(|w| ..)` method takes [`status::W`](W) writer structure"]
impl crate :: Writable for StatusSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets STATUS to value 0x04"]
impl crate :: Resettable for StatusSpec { const RESET_VALUE : u32 = 0x04 ; } } # [doc = "INT_ENABLE (w) register accessor: Регистр разрешения прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_enable::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_enable`]
module"]
# [doc (alias = "INT_ENABLE")]
pub type IntEnable = crate :: Reg < int_enable :: IntEnableSpec > ; # [doc = "Регистр разрешения прерываний"]
pub mod int_enable { # [doc = "Register `INT_ENABLE` writer"]
pub type W = crate :: W < IntEnableSpec > ; # [doc = "Field `RX_OVERFLOW` writer - (IXR_RXOVR) Запись «1» устанавливает маску прерывания (разрешает прерывание) при переполнении при приеме"]
pub type RxOverflowW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `MODE_FAIL` writer - (IXR_MODF) Запись «1» устанавливает маску прерывания (разрешает прерывание) при нарушении режима"]
pub type ModeFailW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_NOT_FULL` writer - (IXR_TXOW) Запись «1» устанавливает маску прерывания (разрешает прерывание) когда TX_FIFO не заполнен"]
pub type TxFifoNotFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_FULL` writer - (IXR_TXFULL) Запись «1» устанавливает маску прерывания (разрешает прерывание), когда TX_FIFO заполнен"]
pub type TxFifoFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `RX_FIFO_NOT_EMPTY` writer - (IXR_RXNEMPTY) Запись «1» устанавливает маску прерывания (разрешает прерывание), когда RX_FIFO не пустой"]
pub type RxFifoNotEmptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `PX_FIFO_FULL` writer - (IXR_RXFULL) Запись «1» устанавливает маску прерывания (разрешает прерывание) при заполнении RX_FIFO"]
pub type PxFifoFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_UNDERFLOW` writer - (IXR_TXUF) Запись «1» устанавливает маску прерывания (разрешает прерывание) при опустошении TX_FIFO"]
pub type TxFifoUnderflowW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W { # [doc = "Bit 0 - (IXR_RXOVR) Запись «1» устанавливает маску прерывания (разрешает прерывание) при переполнении при приеме"]
# [inline (always)]
pub fn rx_overflow (& mut self) -> RxOverflowW < IntEnableSpec > { RxOverflowW :: new (self , 0) } # [doc = "Bit 1 - (IXR_MODF) Запись «1» устанавливает маску прерывания (разрешает прерывание) при нарушении режима"]
# [inline (always)]
pub fn mode_fail (& mut self) -> ModeFailW < IntEnableSpec > { ModeFailW :: new (self , 1) } # [doc = "Bit 2 - (IXR_TXOW) Запись «1» устанавливает маску прерывания (разрешает прерывание) когда TX_FIFO не заполнен"]
# [inline (always)]
pub fn tx_fifo_not_full (& mut self) -> TxFifoNotFullW < IntEnableSpec > { TxFifoNotFullW :: new (self , 2) } # [doc = "Bit 3 - (IXR_TXFULL) Запись «1» устанавливает маску прерывания (разрешает прерывание), когда TX_FIFO заполнен"]
# [inline (always)]
pub fn tx_fifo_full (& mut self) -> TxFifoFullW < IntEnableSpec > { TxFifoFullW :: new (self , 3) } # [doc = "Bit 4 - (IXR_RXNEMPTY) Запись «1» устанавливает маску прерывания (разрешает прерывание), когда RX_FIFO не пустой"]
# [inline (always)]
pub fn rx_fifo_not_empty (& mut self) -> RxFifoNotEmptyW < IntEnableSpec > { RxFifoNotEmptyW :: new (self , 4) } # [doc = "Bit 5 - (IXR_RXFULL) Запись «1» устанавливает маску прерывания (разрешает прерывание) при заполнении RX_FIFO"]
# [inline (always)]
pub fn px_fifo_full (& mut self) -> PxFifoFullW < IntEnableSpec > { PxFifoFullW :: new (self , 5) } # [doc = "Bit 6 - (IXR_TXUF) Запись «1» устанавливает маску прерывания (разрешает прерывание) при опустошении TX_FIFO"]
# [inline (always)]
pub fn tx_fifo_underflow (& mut self) -> TxFifoUnderflowW < IntEnableSpec > { TxFifoUnderflowW :: new (self , 6) } } # [doc = "Регистр разрешения прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_enable::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntEnableSpec ; impl crate :: RegisterSpec for IntEnableSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`int_enable::W`](W) writer structure"]
impl crate :: Writable for IntEnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_ENABLE to value 0"]
impl crate :: Resettable for IntEnableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INT_DISABLE (w) register accessor: Регистр запрета прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_disable::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_disable`]
module"]
# [doc (alias = "INT_DISABLE")]
pub type IntDisable = crate :: Reg < int_disable :: IntDisableSpec > ; # [doc = "Регистр запрета прерываний"]
pub mod int_disable { # [doc = "Register `INT_DISABLE` writer"]
pub type W = crate :: W < IntDisableSpec > ; # [doc = "Field `RX_OVERFLOW` writer - (IXR_RXOVR) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при переполнении при приеме"]
pub type RxOverflowW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `MODE_FAIL` writer - (IXR_MODF) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при нарушении режима"]
pub type ModeFailW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_NOT_FULL` writer - (IXR_TXOW) Запись «1» сбрасывает маску прерывания (запрещает прерывание) когда TX_FIFO не заполнен"]
pub type TxFifoNotFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_FULL` writer - (IXR_TXFULL) Запись «1» сбрасывает маску прерывания (запрещает прерывание), когда TX_FIFO заполнен"]
pub type TxFifoFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `RX_FIFO_NOT_EMPTY` writer - (IXR_RXNEMPTY) Запись «1» сбрасывает маску прерывания (запрещает прерывание), когда RX_FIFO не пустой"]
pub type RxFifoNotEmptyW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `PX_FIFO_FULL` writer - (IXR_RXFULL) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при заполнении RX_FIFO"]
pub type PxFifoFullW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `TX_FIFO_UNDERFLOW` writer - (IXR_TXUF) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при опустошении TX_FIFO"]
pub type TxFifoUnderflowW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W { # [doc = "Bit 0 - (IXR_RXOVR) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при переполнении при приеме"]
# [inline (always)]
pub fn rx_overflow (& mut self) -> RxOverflowW < IntDisableSpec > { RxOverflowW :: new (self , 0) } # [doc = "Bit 1 - (IXR_MODF) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при нарушении режима"]
# [inline (always)]
pub fn mode_fail (& mut self) -> ModeFailW < IntDisableSpec > { ModeFailW :: new (self , 1) } # [doc = "Bit 2 - (IXR_TXOW) Запись «1» сбрасывает маску прерывания (запрещает прерывание) когда TX_FIFO не заполнен"]
# [inline (always)]
pub fn tx_fifo_not_full (& mut self) -> TxFifoNotFullW < IntDisableSpec > { TxFifoNotFullW :: new (self , 2) } # [doc = "Bit 3 - (IXR_TXFULL) Запись «1» сбрасывает маску прерывания (запрещает прерывание), когда TX_FIFO заполнен"]
# [inline (always)]
pub fn tx_fifo_full (& mut self) -> TxFifoFullW < IntDisableSpec > { TxFifoFullW :: new (self , 3) } # [doc = "Bit 4 - (IXR_RXNEMPTY) Запись «1» сбрасывает маску прерывания (запрещает прерывание), когда RX_FIFO не пустой"]
# [inline (always)]
pub fn rx_fifo_not_empty (& mut self) -> RxFifoNotEmptyW < IntDisableSpec > { RxFifoNotEmptyW :: new (self , 4) } # [doc = "Bit 5 - (IXR_RXFULL) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при заполнении RX_FIFO"]
# [inline (always)]
pub fn px_fifo_full (& mut self) -> PxFifoFullW < IntDisableSpec > { PxFifoFullW :: new (self , 5) } # [doc = "Bit 6 - (IXR_TXUF) Запись «1» сбрасывает маску прерывания (запрещает прерывание) при опустошении TX_FIFO"]
# [inline (always)]
pub fn tx_fifo_underflow (& mut self) -> TxFifoUnderflowW < IntDisableSpec > { TxFifoUnderflowW :: new (self , 6) } } # [doc = "Регистр запрета прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`int_disable::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntDisableSpec ; impl crate :: RegisterSpec for IntDisableSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`int_disable::W`](W) writer structure"]
impl crate :: Writable for IntDisableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INT_DISABLE to value 0"]
impl crate :: Resettable for IntDisableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INT_MASK (r) register accessor: Регистр текущих масок прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mask::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@int_mask`]
module"]
# [doc (alias = "INT_MASK")]
pub type IntMask = crate :: Reg < int_mask :: IntMaskSpec > ; # [doc = "Регистр текущих масок прерываний"]
pub mod int_mask { # [doc = "Register `INT_MASK` reader"]
pub type R = crate :: R < IntMaskSpec > ; # [doc = "(IXR_RXOVR) Текущее состояние маски прерывания при переполнении при приеме\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RxOverflow { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < RxOverflow > for bool { # [inline (always)]
fn from (variant : RxOverflow) -> Self { variant as u8 != 0 } } # [doc = "Field `RX_OVERFLOW` reader - (IXR_RXOVR) Текущее состояние маски прерывания при переполнении при приеме"]
pub type RxOverflowR = crate :: BitReader < RxOverflow > ; impl RxOverflowR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RxOverflow { match self . bits { false => RxOverflow :: Disable , true => RxOverflow :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == RxOverflow :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == RxOverflow :: Enable } } # [doc = "(IXR_MODF) Текущее состояние маски прерывания при нарушении режима\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ModeFail { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < ModeFail > for bool { # [inline (always)]
fn from (variant : ModeFail) -> Self { variant as u8 != 0 } } # [doc = "Field `MODE_FAIL` reader - (IXR_MODF) Текущее состояние маски прерывания при нарушении режима"]
pub type ModeFailR = crate :: BitReader < ModeFail > ; impl ModeFailR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ModeFail { match self . bits { false => ModeFail :: Disable , true => ModeFail :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == ModeFail :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == ModeFail :: Enable } } # [doc = "(IXR_TXOW) Текущее состояние маски прерывания, когда TX_FIFO не заполнен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoNotFull { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < TxFifoNotFull > for bool { # [inline (always)]
fn from (variant : TxFifoNotFull) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_NOT_FULL` reader - (IXR_TXOW) Текущее состояние маски прерывания, когда TX_FIFO не заполнен"]
pub type TxFifoNotFullR = crate :: BitReader < TxFifoNotFull > ; impl TxFifoNotFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoNotFull { match self . bits { false => TxFifoNotFull :: Disable , true => TxFifoNotFull :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == TxFifoNotFull :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == TxFifoNotFull :: Enable } } # [doc = "(IXR_TXFULL) Текущее состояние маски прерывания, когда TX_FIFO заполнен\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoFull { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < TxFifoFull > for bool { # [inline (always)]
fn from (variant : TxFifoFull) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_FULL` reader - (IXR_TXFULL) Текущее состояние маски прерывания, когда TX_FIFO заполнен"]
pub type TxFifoFullR = crate :: BitReader < TxFifoFull > ; impl TxFifoFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoFull { match self . bits { false => TxFifoFull :: Disable , true => TxFifoFull :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == TxFifoFull :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == TxFifoFull :: Enable } } # [doc = "(IXR_RXNEMPTY) Текущее состояние маски прерывания, когда RX_FIFO не пустой\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RxFifoNotEmpty { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < RxFifoNotEmpty > for bool { # [inline (always)]
fn from (variant : RxFifoNotEmpty) -> Self { variant as u8 != 0 } } # [doc = "Field `RX_FIFO_NOT_EMPTY` reader - (IXR_RXNEMPTY) Текущее состояние маски прерывания, когда RX_FIFO не пустой"]
pub type RxFifoNotEmptyR = crate :: BitReader < RxFifoNotEmpty > ; impl RxFifoNotEmptyR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RxFifoNotEmpty { match self . bits { false => RxFifoNotEmpty :: Disable , true => RxFifoNotEmpty :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == RxFifoNotEmpty :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == RxFifoNotEmpty :: Enable } } # [doc = "(IXR_RXFULL) Текущее состояние маски прерывания при заполнении RX_FIFO\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum PxFifoFull { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < PxFifoFull > for bool { # [inline (always)]
fn from (variant : PxFifoFull) -> Self { variant as u8 != 0 } } # [doc = "Field `PX_FIFO_FULL` reader - (IXR_RXFULL) Текущее состояние маски прерывания при заполнении RX_FIFO"]
pub type PxFifoFullR = crate :: BitReader < PxFifoFull > ; impl PxFifoFullR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> PxFifoFull { match self . bits { false => PxFifoFull :: Disable , true => PxFifoFull :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == PxFifoFull :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == PxFifoFull :: Enable } } # [doc = "(IXR_TXUF) Текущее состояние маски прерывания при опустошении\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum TxFifoUnderflow { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < TxFifoUnderflow > for bool { # [inline (always)]
fn from (variant : TxFifoUnderflow) -> Self { variant as u8 != 0 } } # [doc = "Field `TX_FIFO_UNDERFLOW` reader - (IXR_TXUF) Текущее состояние маски прерывания при опустошении"]
pub type TxFifoUnderflowR = crate :: BitReader < TxFifoUnderflow > ; impl TxFifoUnderflowR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> TxFifoUnderflow { match self . bits { false => TxFifoUnderflow :: Disable , true => TxFifoUnderflow :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == TxFifoUnderflow :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == TxFifoUnderflow :: Enable } } impl R { # [doc = "Bit 0 - (IXR_RXOVR) Текущее состояние маски прерывания при переполнении при приеме"]
# [inline (always)]
pub fn rx_overflow (& self) -> RxOverflowR { RxOverflowR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - (IXR_MODF) Текущее состояние маски прерывания при нарушении режима"]
# [inline (always)]
pub fn mode_fail (& self) -> ModeFailR { ModeFailR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - (IXR_TXOW) Текущее состояние маски прерывания, когда TX_FIFO не заполнен"]
# [inline (always)]
pub fn tx_fifo_not_full (& self) -> TxFifoNotFullR { TxFifoNotFullR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - (IXR_TXFULL) Текущее состояние маски прерывания, когда TX_FIFO заполнен"]
# [inline (always)]
pub fn tx_fifo_full (& self) -> TxFifoFullR { TxFifoFullR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - (IXR_RXNEMPTY) Текущее состояние маски прерывания, когда RX_FIFO не пустой"]
# [inline (always)]
pub fn rx_fifo_not_empty (& self) -> RxFifoNotEmptyR { RxFifoNotEmptyR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - (IXR_RXFULL) Текущее состояние маски прерывания при заполнении RX_FIFO"]
# [inline (always)]
pub fn px_fifo_full (& self) -> PxFifoFullR { PxFifoFullR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - (IXR_TXUF) Текущее состояние маски прерывания при опустошении"]
# [inline (always)]
pub fn tx_fifo_underflow (& self) -> TxFifoUnderflowR { TxFifoUnderflowR :: new (((self . bits >> 6) & 1) != 0) } } # [doc = "Регистр текущих масок прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`int_mask::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IntMaskSpec ; impl crate :: RegisterSpec for IntMaskSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`int_mask::R`](R) reader structure"]
impl crate :: Readable for IntMaskSpec { } # [doc = "`reset()` method sets INT_MASK to value 0"]
impl crate :: Resettable for IntMaskSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ENABLE (rw) register accessor: Регистр включения/выключения SPI\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable`]
module"]
# [doc (alias = "ENABLE")]
pub type Enable = crate :: Reg < enable :: EnableSpec > ; # [doc = "Регистр включения/выключения SPI"]
pub mod enable { # [doc = "Register `ENABLE` reader"]
pub type R = crate :: R < EnableSpec > ; # [doc = "Register `ENABLE` writer"]
pub type W = crate :: W < EnableSpec > ; # [doc = "(ENABLE) Включение/выключение модуля SPI\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum SpiEn { # [doc = "0: Выключение модуля SPI"]
Disable = 0 , # [doc = "1: Включение модуля SPI"]
Enable = 1 , } impl From < SpiEn > for bool { # [inline (always)]
fn from (variant : SpiEn) -> Self { variant as u8 != 0 } } # [doc = "Field `SPI_EN` reader - (ENABLE) Включение/выключение модуля SPI"]
pub type SpiEnR = crate :: BitReader < SpiEn > ; impl SpiEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> SpiEn { match self . bits { false => SpiEn :: Disable , true => SpiEn :: Enable , } } # [doc = "Выключение модуля SPI"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == SpiEn :: Disable } # [doc = "Включение модуля SPI"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == SpiEn :: Enable } } # [doc = "Field `SPI_EN` writer - (ENABLE) Включение/выключение модуля SPI"]
pub type SpiEnW < 'a , REG > = crate :: BitWriter < 'a , REG , SpiEn > ; impl < 'a , REG > SpiEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Выключение модуля SPI"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (SpiEn :: Disable) } # [doc = "Включение модуля SPI"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (SpiEn :: Enable) } } # [doc = "Field `CLEAR_TX_FIFO` writer - Запись 1 при SPI_EN = 0 очищает буфер TX_FIFO."]
pub type ClearTxFifoW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `CLEAR_PX_FIFO` writer - Запись 1 при SPI_EN = 0 очищает буфер RX_FIFO."]
pub type ClearPxFifoW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - (ENABLE) Включение/выключение модуля SPI"]
# [inline (always)]
pub fn spi_en (& self) -> SpiEnR { SpiEnR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - (ENABLE) Включение/выключение модуля SPI"]
# [inline (always)]
pub fn spi_en (& mut self) -> SpiEnW < EnableSpec > { SpiEnW :: new (self , 0) } # [doc = "Bit 2 - Запись 1 при SPI_EN = 0 очищает буфер TX_FIFO."]
# [inline (always)]
pub fn clear_tx_fifo (& mut self) -> ClearTxFifoW < EnableSpec > { ClearTxFifoW :: new (self , 2) } # [doc = "Bit 3 - Запись 1 при SPI_EN = 0 очищает буфер RX_FIFO."]
# [inline (always)]
pub fn clear_px_fifo (& mut self) -> ClearPxFifoW < EnableSpec > { ClearPxFifoW :: new (self , 3) } } # [doc = "Регистр включения/выключения SPI\n\nYou can [`read`](crate::Reg::read) this register and get [`enable::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EnableSpec ; impl crate :: RegisterSpec for EnableSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`enable::R`](R) reader structure"]
impl crate :: Readable for EnableSpec { } # [doc = "`write(|w| ..)` method takes [`enable::W`](W) writer structure"]
impl crate :: Writable for EnableSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ENABLE to value 0"]
impl crate :: Resettable for EnableSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DELAY (rw) register accessor: Регистр задержек\n\nYou can [`read`](crate::Reg::read) this register and get [`delay::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`delay::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@delay`]
module"]
# [doc (alias = "DELAY")]
pub type Delay = crate :: Reg < delay :: DelaySpec > ; # [doc = "Регистр задержек"]
pub mod delay { # [doc = "Register `DELAY` reader"]
pub type R = crate :: R < DelaySpec > ; # [doc = "Register `DELAY` writer"]
pub type W = crate :: W < DelaySpec > ; # [doc = "Field `D_INT` reader - (INIT) Дополнительная задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между установкой сигнала n_ss_out в «0» и передачей первого бита"]
pub type DIntR = crate :: FieldReader ; # [doc = "Field `D_INT` writer - (INIT) Дополнительная задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между установкой сигнала n_ss_out в «0» и передачей первого бита"]
pub type DIntW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `D_AFTER` reader - (AFTER) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между последним битом текущего слова и первым битом следующего слова"]
pub type DAfterR = crate :: FieldReader ; # [doc = "Field `D_AFTER` writer - (AFTER) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между последним битом текущего слова и первым битом следующего слова"]
pub type DAfterW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `D_BTWN` reader - (BTWN) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между снятием сигнала выбора одного ведомого устройства и установкой сигнала выбора другого ведомого устройства"]
pub type DBtwnR = crate :: FieldReader ; # [doc = "Field `D_BTWN` writer - (BTWN) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между снятием сигнала выбора одного ведомого устройства и установкой сигнала выбора другого ведомого устройства"]
pub type DBtwnW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7 - (INIT) Дополнительная задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между установкой сигнала n_ss_out в «0» и передачей первого бита"]
# [inline (always)]
pub fn d_int (& self) -> DIntR { DIntR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - (AFTER) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между последним битом текущего слова и первым битом следующего слова"]
# [inline (always)]
pub fn d_after (& self) -> DAfterR { DAfterR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:23 - (BTWN) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между снятием сигнала выбора одного ведомого устройства и установкой сигнала выбора другого ведомого устройства"]
# [inline (always)]
pub fn d_btwn (& self) -> DBtwnR { DBtwnR :: new (((self . bits >> 16) & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - (INIT) Дополнительная задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между установкой сигнала n_ss_out в «0» и передачей первого бита"]
# [inline (always)]
pub fn d_int (& mut self) -> DIntW < DelaySpec > { DIntW :: new (self , 0) } # [doc = "Bits 8:15 - (AFTER) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между последним битом текущего слова и первым битом следующего слова"]
# [inline (always)]
pub fn d_after (& mut self) -> DAfterW < DelaySpec > { DAfterW :: new (self , 8) } # [doc = "Bits 16:23 - (BTWN) Задержка в периодах опорного тактового сигнала или внешнего тактового сигнала ext_clk между снятием сигнала выбора одного ведомого устройства и установкой сигнала выбора другого ведомого устройства"]
# [inline (always)]
pub fn d_btwn (& mut self) -> DBtwnW < DelaySpec > { DBtwnW :: new (self , 16) } } # [doc = "Регистр задержек\n\nYou can [`read`](crate::Reg::read) this register and get [`delay::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`delay::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DelaySpec ; impl crate :: RegisterSpec for DelaySpec { type Ux = u32 ; } # [doc = "`read()` method returns [`delay::R`](R) reader structure"]
impl crate :: Readable for DelaySpec { } # [doc = "`write(|w| ..)` method takes [`delay::W`](W) writer structure"]
impl crate :: Writable for DelaySpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DELAY to value 0"]
impl crate :: Resettable for DelaySpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TXDATA (w) register accessor: Регистр передаваемых данных\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdata::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txdata`]
module"]
# [doc (alias = "TXDATA")]
pub type Txdata = crate :: Reg < txdata :: TxdataSpec > ; # [doc = "Регистр передаваемых данных"]
pub mod txdata { # [doc = "Register `TXDATA` writer"]
pub type W = crate :: W < TxdataSpec > ; # [doc = "Field `TX_FIFO_data` writer - Данные для TX_FIFO"]
pub type TxFifoDataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl W { # [doc = "Bits 0:7 - Данные для TX_FIFO"]
# [inline (always)]
pub fn tx_fifo_data (& mut self) -> TxFifoDataW < TxdataSpec > { TxFifoDataW :: new (self , 0) } } # [doc = "Регистр передаваемых данных\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdata::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxdataSpec ; impl crate :: RegisterSpec for TxdataSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`txdata::W`](W) writer structure"]
impl crate :: Writable for TxdataSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TXDATA to value 0"]
impl crate :: Resettable for TxdataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RXDATA (r) register accessor: Регистр принимаемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdata::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxdata`]
module"]
# [doc (alias = "RXDATA")]
pub type Rxdata = crate :: Reg < rxdata :: RxdataSpec > ; # [doc = "Регистр принимаемых данных"]
pub mod rxdata { # [doc = "Register `RXDATA` reader"]
pub type R = crate :: R < RxdataSpec > ; # [doc = "Field `RX_FIFO_data` reader - Данные из RX_FIFO."]
pub type RxFifoDataR = crate :: FieldReader ; impl R { # [doc = "Bits 0:7 - Данные из RX_FIFO."]
# [inline (always)]
pub fn rx_fifo_data (& self) -> RxFifoDataR { RxFifoDataR :: new ((self . bits & 0xff) as u8) } } # [doc = "Регистр принимаемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdata::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxdataSpec ; impl crate :: RegisterSpec for RxdataSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rxdata::R`](R) reader structure"]
impl crate :: Readable for RxdataSpec { } # [doc = "`reset()` method sets RXDATA to value 0"]
impl crate :: Resettable for RxdataSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "SIC (rw) register accessor: Регистр счетчика останова ведомого устройства\n\nYou can [`read`](crate::Reg::read) this register and get [`sic::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sic::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@sic`]
module"]
# [doc (alias = "SIC")]
pub type Sic = crate :: Reg < sic :: SicSpec > ; # [doc = "Регистр счетчика останова ведомого устройства"]
pub mod sic { # [doc = "Register `SIC` reader"]
pub type R = crate :: R < SicSpec > ; # [doc = "Register `SIC` writer"]
pub type W = crate :: W < SicSpec > ; # [doc = "Field `Slave_Idle_coun` reader - Модуль SPI в режиме ведомого устройства начинает передачу только когда тактовый сигнал sclk_in (внешнего ведущего устройства) не изменяется в течение количества периодов опорного тактового сигнала SPI заданного в этом поле или когда модуль SPI не активен"]
pub type SlaveIdleCounR = crate :: FieldReader ; # [doc = "Field `Slave_Idle_coun` writer - Модуль SPI в режиме ведомого устройства начинает передачу только когда тактовый сигнал sclk_in (внешнего ведущего устройства) не изменяется в течение количества периодов опорного тактового сигнала SPI заданного в этом поле или когда модуль SPI не активен"]
pub type SlaveIdleCounW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7 - Модуль SPI в режиме ведомого устройства начинает передачу только когда тактовый сигнал sclk_in (внешнего ведущего устройства) не изменяется в течение количества периодов опорного тактового сигнала SPI заданного в этом поле или когда модуль SPI не активен"]
# [inline (always)]
pub fn slave_idle_coun (& self) -> SlaveIdleCounR { SlaveIdleCounR :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - Модуль SPI в режиме ведомого устройства начинает передачу только когда тактовый сигнал sclk_in (внешнего ведущего устройства) не изменяется в течение количества периодов опорного тактового сигнала SPI заданного в этом поле или когда модуль SPI не активен"]
# [inline (always)]
pub fn slave_idle_coun (& mut self) -> SlaveIdleCounW < SicSpec > { SlaveIdleCounW :: new (self , 0) } } # [doc = "Регистр счетчика останова ведомого устройства\n\nYou can [`read`](crate::Reg::read) this register and get [`sic::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`sic::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SicSpec ; impl crate :: RegisterSpec for SicSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`sic::R`](R) reader structure"]
impl crate :: Readable for SicSpec { } # [doc = "`write(|w| ..)` method takes [`sic::W`](W) writer structure"]
impl crate :: Writable for SicSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SIC to value 0xff"]
impl crate :: Resettable for SicSpec { const RESET_VALUE : u32 = 0xff ; } } # [doc = "TX_THR (rw) register accessor: Регистр пороговых значений TX_FIFO\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_thr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tx_thr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tx_thr`]
module"]
# [doc (alias = "TX_THR")]
pub type TxThr = crate :: Reg < tx_thr :: TxThrSpec > ; # [doc = "Регистр пороговых значений TX_FIFO"]
pub mod tx_thr { # [doc = "Register `TX_THR` reader"]
pub type R = crate :: R < TxThrSpec > ; # [doc = "Register `TX_THR` writer"]
pub type W = crate :: W < TxThrSpec > ; # [doc = "Field `Threshold_of_TX_FIFO` reader - Задает уровень, при котором TX_FIFO считается не заполненным и формируется прерывание"]
pub type ThresholdOfTxFifoR = crate :: FieldReader < u32 > ; # [doc = "Field `Threshold_of_TX_FIFO` writer - Задает уровень, при котором TX_FIFO считается не заполненным и формируется прерывание"]
pub type ThresholdOfTxFifoW < 'a , REG > = crate :: FieldWriter < 'a , REG , 32 , u32 > ; impl R { # [doc = "Bits 0:31 - Задает уровень, при котором TX_FIFO считается не заполненным и формируется прерывание"]
# [inline (always)]
pub fn threshold_of_tx_fifo (& self) -> ThresholdOfTxFifoR { ThresholdOfTxFifoR :: new (self . bits) } } impl W { # [doc = "Bits 0:31 - Задает уровень, при котором TX_FIFO считается не заполненным и формируется прерывание"]
# [inline (always)]
pub fn threshold_of_tx_fifo (& mut self) -> ThresholdOfTxFifoW < TxThrSpec > { ThresholdOfTxFifoW :: new (self , 0) } } # [doc = "Регистр пороговых значений TX_FIFO\n\nYou can [`read`](crate::Reg::read) this register and get [`tx_thr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tx_thr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxThrSpec ; impl crate :: RegisterSpec for TxThrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`tx_thr::R`](R) reader structure"]
impl crate :: Readable for TxThrSpec { } # [doc = "`write(|w| ..)` method takes [`tx_thr::W`](W) writer structure"]
impl crate :: Writable for TxThrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TX_THR to value 0x01"]
impl crate :: Resettable for TxThrSpec { const RESET_VALUE : u32 = 0x01 ; } } # [doc = "ID (r) register accessor: Идентификационный номер модуля\n\nYou can [`read`](crate::Reg::read) this register and get [`id::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@id`]
module"]
# [doc (alias = "ID")]
pub type Id = crate :: Reg < id :: IdSpec > ; # [doc = "Идентификационный номер модуля"]
pub mod id { # [doc = "Register `ID` reader"]
pub type R = crate :: R < IdSpec > ; # [doc = "Field `Threshold_of_TX_FIFO` reader - Идентификационный номер модуля"]
pub type ThresholdOfTxFifoR = crate :: FieldReader < u32 > ; impl R { # [doc = "Bits 0:31 - Идентификационный номер модуля"]
# [inline (always)]
pub fn threshold_of_tx_fifo (& self) -> ThresholdOfTxFifoR { ThresholdOfTxFifoR :: new (self . bits) } } # [doc = "Идентификационный номер модуля\n\nYou can [`read`](crate::Reg::read) this register and get [`id::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IdSpec ; impl crate :: RegisterSpec for IdSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`id::R`](R) reader structure"]
impl crate :: Readable for IdSpec { } # [doc = "`reset()` method sets ID to value 0x0109_0100"]
impl crate :: Resettable for IdSpec { const RESET_VALUE : u32 = 0x0109_0100 ; } } } # [doc = "Модуль обеспечивает интерфейс для связи контроллера и последовательной шины I2C"]
pub struct I2c0 { _marker : PhantomData < * const () > } unsafe impl Send for I2c0 { } impl I2c0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const i2c_0 :: RegisterBlock = 0x0008_3800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const i2c_0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for I2c0 { type Target = i2c_0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for I2c0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c0") . finish () } } # [doc = "Модуль обеспечивает интерфейс для связи контроллера и последовательной шины I2C"]
pub mod i2c_0 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , oar1 : Oar1 , oar2 : Oar2 , timingr : Timingr , _reserved5 : [u8 ; 0x04]
, isr : Isr , icr : Icr , rxdr : Rxdr , txdr : Txdr , } impl RegisterBlock { # [doc = "0x00 - Регистр управления 1"]
# [inline (always)]
pub const fn cr1 (& self) -> & Cr1 { & self . cr1 } # [doc = "0x04 - Регистр управления 2"]
# [inline (always)]
pub const fn cr2 (& self) -> & Cr2 { & self . cr2 } # [doc = "0x08 - Регистр адреса 1"]
# [inline (always)]
pub const fn oar1 (& self) -> & Oar1 { & self . oar1 } # [doc = "0x0c - Регистр адреса 2"]
# [inline (always)]
pub const fn oar2 (& self) -> & Oar2 { & self . oar2 } # [doc = "0x10 - Регистр настройки временных ограничений. Регистр должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub const fn timingr (& self) -> & Timingr { & self . timingr } # [doc = "0x18 - Регистр флагов прерываний"]
# [inline (always)]
pub const fn isr (& self) -> & Isr { & self . isr } # [doc = "0x1c - Регистр сроса флагов прерываний"]
# [inline (always)]
pub const fn icr (& self) -> & Icr { & self . icr } # [doc = "0x20 - Регистр принятых данных"]
# [inline (always)]
pub const fn rxdr (& self) -> & Rxdr { & self . rxdr } # [doc = "0x24 - Регистр передаваемых данных"]
# [inline (always)]
pub const fn txdr (& self) -> & Txdr { & self . txdr } } # [doc = "CR1 (rw) register accessor: Регистр управления 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`]
module"]
# [doc (alias = "CR1")]
pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ; # [doc = "Регистр управления 1"]
pub mod cr1 { # [doc = "Register `CR1` reader"]
pub type R = crate :: R < Cr1Spec > ; # [doc = "Register `CR1` writer"]
pub type W = crate :: W < Cr1Spec > ; # [doc = "Управление интерфейсом. После очистки, бит должен оставаться в ‘0’ минимум три периода тактового сигнала APB\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pe { # [doc = "0: Интерфейс выключен"]
Disable = 0 , # [doc = "1: Интерфейс включен"]
Enable = 1 , } impl From < Pe > for bool { # [inline (always)]
fn from (variant : Pe) -> Self { variant as u8 != 0 } } # [doc = "Field `PE` reader - Управление интерфейсом. После очистки, бит должен оставаться в ‘0’ минимум три периода тактового сигнала APB"]
pub type PeR = crate :: BitReader < Pe > ; impl PeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pe { match self . bits { false => Pe :: Disable , true => Pe :: Enable , } } # [doc = "Интерфейс выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Pe :: Disable } # [doc = "Интерфейс включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Pe :: Enable } } # [doc = "Field `PE` writer - Управление интерфейсом. После очистки, бит должен оставаться в ‘0’ минимум три периода тактового сигнала APB"]
pub type PeW < 'a , REG > = crate :: BitWriter < 'a , REG , Pe > ; impl < 'a , REG > PeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Интерфейс выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Pe :: Disable) } # [doc = "Интерфейс включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Pe :: Enable) } } # [doc = "Разрешение прерывания при передаче\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Txie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Txie > for bool { # [inline (always)]
fn from (variant : Txie) -> Self { variant as u8 != 0 } } # [doc = "Field `TXIE` reader - Разрешение прерывания при передаче"]
pub type TxieR = crate :: BitReader < Txie > ; impl TxieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Txie { match self . bits { false => Txie :: Disable , true => Txie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Txie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Txie :: Enable } } # [doc = "Field `TXIE` writer - Разрешение прерывания при передаче"]
pub type TxieW < 'a , REG > = crate :: BitWriter < 'a , REG , Txie > ; impl < 'a , REG > TxieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Txie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Txie :: Enable) } } # [doc = "Разрешение прерывания при приеме\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rxie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Rxie > for bool { # [inline (always)]
fn from (variant : Rxie) -> Self { variant as u8 != 0 } } # [doc = "Field `RXIE` reader - Разрешение прерывания при приеме"]
pub type RxieR = crate :: BitReader < Rxie > ; impl RxieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rxie { match self . bits { false => Rxie :: Disable , true => Rxie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Rxie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Rxie :: Enable } } # [doc = "Field `RXIE` writer - Разрешение прерывания при приеме"]
pub type RxieW < 'a , REG > = crate :: BitWriter < 'a , REG , Rxie > ; impl < 'a , REG > RxieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxie :: Enable) } } # [doc = "Разрешение прерывания соот-ветствия адреса в режиме «ведомый»\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Addrie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Addrie > for bool { # [inline (always)]
fn from (variant : Addrie) -> Self { variant as u8 != 0 } } # [doc = "Field `ADDRIE` reader - Разрешение прерывания соот-ветствия адреса в режиме «ведомый»"]
pub type AddrieR = crate :: BitReader < Addrie > ; impl AddrieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Addrie { match self . bits { false => Addrie :: Disable , true => Addrie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Addrie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Addrie :: Enable } } # [doc = "Field `ADDRIE` writer - Разрешение прерывания соот-ветствия адреса в режиме «ведомый»"]
pub type AddrieW < 'a , REG > = crate :: BitWriter < 'a , REG , Addrie > ; impl < 'a , REG > AddrieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Addrie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Addrie :: Enable) } } # [doc = "Разрешение прерывания прием NACK\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nackie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Nackie > for bool { # [inline (always)]
fn from (variant : Nackie) -> Self { variant as u8 != 0 } } # [doc = "Field `NACKIE` reader - Разрешение прерывания прием NACK"]
pub type NackieR = crate :: BitReader < Nackie > ; impl NackieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nackie { match self . bits { false => Nackie :: Disable , true => Nackie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Nackie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Nackie :: Enable } } # [doc = "Field `NACKIE` writer - Разрешение прерывания прием NACK"]
pub type NackieW < 'a , REG > = crate :: BitWriter < 'a , REG , Nackie > ; impl < 'a , REG > NackieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Nackie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Nackie :: Enable) } } # [doc = "Разрешение прерывания обнаружения STOP на линии\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Stopie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Stopie > for bool { # [inline (always)]
fn from (variant : Stopie) -> Self { variant as u8 != 0 } } # [doc = "Field `STOPIE` reader - Разрешение прерывания обнаружения STOP на линии"]
pub type StopieR = crate :: BitReader < Stopie > ; impl StopieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Stopie { match self . bits { false => Stopie :: Disable , true => Stopie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Stopie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Stopie :: Enable } } # [doc = "Field `STOPIE` writer - Разрешение прерывания обнаружения STOP на линии"]
pub type StopieW < 'a , REG > = crate :: BitWriter < 'a , REG , Stopie > ; impl < 'a , REG > StopieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Stopie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Stopie :: Enable) } } # [doc = "Разрешение прерывания окончания передачи. События, вызывающие прерывание: - окончание передачи (TC); - окончание передачи при RELOAD=1 (TCR).\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Tcie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Tcie > for bool { # [inline (always)]
fn from (variant : Tcie) -> Self { variant as u8 != 0 } } # [doc = "Field `TCIE` reader - Разрешение прерывания окончания передачи. События, вызывающие прерывание: - окончание передачи (TC); - окончание передачи при RELOAD=1 (TCR)."]
pub type TcieR = crate :: BitReader < Tcie > ; impl TcieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Tcie { match self . bits { false => Tcie :: Disable , true => Tcie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Tcie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Tcie :: Enable } } # [doc = "Field `TCIE` writer - Разрешение прерывания окончания передачи. События, вызывающие прерывание: - окончание передачи (TC); - окончание передачи при RELOAD=1 (TCR)."]
pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG , Tcie > ; impl < 'a , REG > TcieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Enable) } } # [doc = "Разрешение прерывания при ошибке. События, вызывающие прерывание: - потеря арбитража (ARLO); - ошибка шины (BERR); - переполне-ние/недозагрузка (OVR).\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Errie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Errie > for bool { # [inline (always)]
fn from (variant : Errie) -> Self { variant as u8 != 0 } } # [doc = "Field `ERRIE` reader - Разрешение прерывания при ошибке. События, вызывающие прерывание: - потеря арбитража (ARLO); - ошибка шины (BERR); - переполне-ние/недозагрузка (OVR)."]
pub type ErrieR = crate :: BitReader < Errie > ; impl ErrieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Errie { match self . bits { false => Errie :: Disable , true => Errie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Errie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Errie :: Enable } } # [doc = "Field `ERRIE` writer - Разрешение прерывания при ошибке. События, вызывающие прерывание: - потеря арбитража (ARLO); - ошибка шины (BERR); - переполне-ние/недозагрузка (OVR)."]
pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG , Errie > ; impl < 'a , REG > ErrieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Errie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Errie :: Enable) } } # [doc = "Управление цифровым фильтром шумов. Изменение значения допускается только при выключенном блоке (PE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Dnf { # [doc = "0: Цифровой фильтр выключен"]
Disable = 0 , # [doc = "1: Цифровой фильтр установлен на 1 такт I2CCLK"]
_1 = 1 , # [doc = "2: Цифровой фильтр установлен на 2 такта I2CCLK"]
_2 = 2 , # [doc = "3: Цифровой фильтр установлен на 3 такта I2CCLK"]
_3 = 3 , # [doc = "4: Цифровой фильтр установлен на 4 такта I2CCLK"]
_4 = 4 , # [doc = "5: Цифровой фильтр установлен на 5 тактов I2CCLK"]
_5 = 5 , # [doc = "6: Цифровой фильтр установлен на 6 тактов I2CCLK"]
_6 = 6 , # [doc = "7: Цифровой фильтр установлен на 7 тактов I2CCLK"]
_7 = 7 , # [doc = "8: Цифровой фильтр установлен на 8 тактов I2CCLK"]
_8 = 8 , # [doc = "9: Цифровой фильтр установлен на 9 тактов I2CCLK"]
_9 = 9 , # [doc = "10: Цифровой фильтр установлен на 10 тактов I2CCLK"]
_10 = 10 , # [doc = "11: Цифровой фильтр установлен на 11 тактов I2CCLK"]
_11 = 11 , # [doc = "12: Цифровой фильтр установлен на 12 тактов I2CCLK"]
_12 = 12 , # [doc = "13: Цифровой фильтр установлен на 13 тактов I2CCLK"]
_13 = 13 , # [doc = "14: цифровой фильтр установлен на 14 тактов I2CCLK"]
_14 = 14 , # [doc = "15: Цифровой фильтр установлен на 15 тактов I2CCLK"]
_15 = 15 , } impl From < Dnf > for u8 { # [inline (always)]
fn from (variant : Dnf) -> Self { variant as _ } } impl crate :: FieldSpec for Dnf { type Ux = u8 ; } impl crate :: IsEnum for Dnf { } # [doc = "Field `DNF` reader - Управление цифровым фильтром шумов. Изменение значения допускается только при выключенном блоке (PE=0)"]
pub type DnfR = crate :: FieldReader < Dnf > ; impl DnfR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dnf { match self . bits { 0 => Dnf :: Disable , 1 => Dnf :: _1 , 2 => Dnf :: _2 , 3 => Dnf :: _3 , 4 => Dnf :: _4 , 5 => Dnf :: _5 , 6 => Dnf :: _6 , 7 => Dnf :: _7 , 8 => Dnf :: _8 , 9 => Dnf :: _9 , 10 => Dnf :: _10 , 11 => Dnf :: _11 , 12 => Dnf :: _12 , 13 => Dnf :: _13 , 14 => Dnf :: _14 , 15 => Dnf :: _15 , _ => unreachable ! () , } } # [doc = "Цифровой фильтр выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dnf :: Disable } # [doc = "Цифровой фильтр установлен на 1 такт I2CCLK"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Dnf :: _1 } # [doc = "Цифровой фильтр установлен на 2 такта I2CCLK"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == Dnf :: _2 } # [doc = "Цифровой фильтр установлен на 3 такта I2CCLK"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == Dnf :: _3 } # [doc = "Цифровой фильтр установлен на 4 такта I2CCLK"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == Dnf :: _4 } # [doc = "Цифровой фильтр установлен на 5 тактов I2CCLK"]
# [inline (always)]
pub fn is_5 (& self) -> bool { * self == Dnf :: _5 } # [doc = "Цифровой фильтр установлен на 6 тактов I2CCLK"]
# [inline (always)]
pub fn is_6 (& self) -> bool { * self == Dnf :: _6 } # [doc = "Цифровой фильтр установлен на 7 тактов I2CCLK"]
# [inline (always)]
pub fn is_7 (& self) -> bool { * self == Dnf :: _7 } # [doc = "Цифровой фильтр установлен на 8 тактов I2CCLK"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == Dnf :: _8 } # [doc = "Цифровой фильтр установлен на 9 тактов I2CCLK"]
# [inline (always)]
pub fn is_9 (& self) -> bool { * self == Dnf :: _9 } # [doc = "Цифровой фильтр установлен на 10 тактов I2CCLK"]
# [inline (always)]
pub fn is_10 (& self) -> bool { * self == Dnf :: _10 } # [doc = "Цифровой фильтр установлен на 11 тактов I2CCLK"]
# [inline (always)]
pub fn is_11 (& self) -> bool { * self == Dnf :: _11 } # [doc = "Цифровой фильтр установлен на 12 тактов I2CCLK"]
# [inline (always)]
pub fn is_12 (& self) -> bool { * self == Dnf :: _12 } # [doc = "Цифровой фильтр установлен на 13 тактов I2CCLK"]
# [inline (always)]
pub fn is_13 (& self) -> bool { * self == Dnf :: _13 } # [doc = "цифровой фильтр установлен на 14 тактов I2CCLK"]
# [inline (always)]
pub fn is_14 (& self) -> bool { * self == Dnf :: _14 } # [doc = "Цифровой фильтр установлен на 15 тактов I2CCLK"]
# [inline (always)]
pub fn is_15 (& self) -> bool { * self == Dnf :: _15 } } # [doc = "Field `DNF` writer - Управление цифровым фильтром шумов. Изменение значения допускается только при выключенном блоке (PE=0)"]
pub type DnfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Dnf , crate :: Safe > ; impl < 'a , REG > DnfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Цифровой фильтр выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: Disable) } # [doc = "Цифровой фильтр установлен на 1 такт I2CCLK"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _1) } # [doc = "Цифровой фильтр установлен на 2 такта I2CCLK"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _2) } # [doc = "Цифровой фильтр установлен на 3 такта I2CCLK"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _3) } # [doc = "Цифровой фильтр установлен на 4 такта I2CCLK"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _4) } # [doc = "Цифровой фильтр установлен на 5 тактов I2CCLK"]
# [inline (always)]
pub fn _5 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _5) } # [doc = "Цифровой фильтр установлен на 6 тактов I2CCLK"]
# [inline (always)]
pub fn _6 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _6) } # [doc = "Цифровой фильтр установлен на 7 тактов I2CCLK"]
# [inline (always)]
pub fn _7 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _7) } # [doc = "Цифровой фильтр установлен на 8 тактов I2CCLK"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _8) } # [doc = "Цифровой фильтр установлен на 9 тактов I2CCLK"]
# [inline (always)]
pub fn _9 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _9) } # [doc = "Цифровой фильтр установлен на 10 тактов I2CCLK"]
# [inline (always)]
pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _10) } # [doc = "Цифровой фильтр установлен на 11 тактов I2CCLK"]
# [inline (always)]
pub fn _11 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _11) } # [doc = "Цифровой фильтр установлен на 12 тактов I2CCLK"]
# [inline (always)]
pub fn _12 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _12) } # [doc = "Цифровой фильтр установлен на 13 тактов I2CCLK"]
# [inline (always)]
pub fn _13 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _13) } # [doc = "цифровой фильтр установлен на 14 тактов I2CCLK"]
# [inline (always)]
pub fn _14 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _14) } # [doc = "Цифровой фильтр установлен на 15 тактов I2CCLK"]
# [inline (always)]
pub fn _15 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _15) } } # [doc = "Управление аналоговым фильтром шумов\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Anfoff { # [doc = "0: Фильтр выключен"]
Disable = 0 , # [doc = "1: Фильтр включен"]
Enable = 1 , } impl From < Anfoff > for bool { # [inline (always)]
fn from (variant : Anfoff) -> Self { variant as u8 != 0 } } # [doc = "Field `ANFOFF` reader - Управление аналоговым фильтром шумов"]
pub type AnfoffR = crate :: BitReader < Anfoff > ; impl AnfoffR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Anfoff { match self . bits { false => Anfoff :: Disable , true => Anfoff :: Enable , } } # [doc = "Фильтр выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Anfoff :: Disable } # [doc = "Фильтр включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Anfoff :: Enable } } # [doc = "Field `ANFOFF` writer - Управление аналоговым фильтром шумов"]
pub type AnfoffW < 'a , REG > = crate :: BitWriter < 'a , REG , Anfoff > ; impl < 'a , REG > AnfoffW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Фильтр выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Anfoff :: Disable) } # [doc = "Фильтр включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Anfoff :: Enable) } } # [doc = "Режим поддержки DMA при передаче данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Txdmaen { # [doc = "0: Поддержка DMA выключена"]
Disable = 0 , # [doc = "1: Поддержка DMA включена"]
Enable = 1 , } impl From < Txdmaen > for bool { # [inline (always)]
fn from (variant : Txdmaen) -> Self { variant as u8 != 0 } } # [doc = "Field `TXDMAEN` reader - Режим поддержки DMA при передаче данных"]
pub type TxdmaenR = crate :: BitReader < Txdmaen > ; impl TxdmaenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Txdmaen { match self . bits { false => Txdmaen :: Disable , true => Txdmaen :: Enable , } } # [doc = "Поддержка DMA выключена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Txdmaen :: Disable } # [doc = "Поддержка DMA включена"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Txdmaen :: Enable } } # [doc = "Field `TXDMAEN` writer - Режим поддержки DMA при передаче данных"]
pub type TxdmaenW < 'a , REG > = crate :: BitWriter < 'a , REG , Txdmaen > ; impl < 'a , REG > TxdmaenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Поддержка DMA выключена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Txdmaen :: Disable) } # [doc = "Поддержка DMA включена"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Txdmaen :: Enable) } } # [doc = "Режим поддержки DMA при приеме данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rxdmaen { # [doc = "0: Поддержка DMA выключена"]
Disable = 0 , # [doc = "1: Поддержка DMA включенa"]
Enable = 1 , } impl From < Rxdmaen > for bool { # [inline (always)]
fn from (variant : Rxdmaen) -> Self { variant as u8 != 0 } } # [doc = "Field `RXDMAEN` reader - Режим поддержки DMA при приеме данных"]
pub type RxdmaenR = crate :: BitReader < Rxdmaen > ; impl RxdmaenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rxdmaen { match self . bits { false => Rxdmaen :: Disable , true => Rxdmaen :: Enable , } } # [doc = "Поддержка DMA выключена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Rxdmaen :: Disable } # [doc = "Поддержка DMA включенa"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Rxdmaen :: Enable } } # [doc = "Field `RXDMAEN` writer - Режим поддержки DMA при приеме данных"]
pub type RxdmaenW < 'a , REG > = crate :: BitWriter < 'a , REG , Rxdmaen > ; impl < 'a , REG > RxdmaenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Поддержка DMA выключена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxdmaen :: Disable) } # [doc = "Поддержка DMA включенa"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxdmaen :: Enable) } } # [doc = "Режим аппаратного контроля передачи данных в режиме «ведомый»\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Sbc { # [doc = "0: Контроль выключен"]
Disable = 0 , # [doc = "1: Контроль включен"]
Enable = 1 , } impl From < Sbc > for bool { # [inline (always)]
fn from (variant : Sbc) -> Self { variant as u8 != 0 } } # [doc = "Field `SBC` reader - Режим аппаратного контроля передачи данных в режиме «ведомый»"]
pub type SbcR = crate :: BitReader < Sbc > ; impl SbcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Sbc { match self . bits { false => Sbc :: Disable , true => Sbc :: Enable , } } # [doc = "Контроль выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Sbc :: Disable } # [doc = "Контроль включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Sbc :: Enable } } # [doc = "Field `SBC` writer - Режим аппаратного контроля передачи данных в режиме «ведомый»"]
pub type SbcW < 'a , REG > = crate :: BitWriter < 'a , REG , Sbc > ; impl < 'a , REG > SbcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Контроль выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Sbc :: Disable) } # [doc = "Контроль включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Sbc :: Enable) } } # [doc = "Отключение растягивания тактового сигнала в режиме «ведомый». Изменение значения допуска-ется только при выключенном блоке (PE=0). В режиме «ве-дущий» бит должен быть установлен в ‘0’\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nostretch { # [doc = "0: Растягивание активно"]
StretchingEnabled = 0 , # [doc = "1: Растягивание выключено"]
StretchingDisable = 1 , } impl From < Nostretch > for bool { # [inline (always)]
fn from (variant : Nostretch) -> Self { variant as u8 != 0 } } # [doc = "Field `NOSTRETCH` reader - Отключение растягивания тактового сигнала в режиме «ведомый». Изменение значения допуска-ется только при выключенном блоке (PE=0). В режиме «ве-дущий» бит должен быть установлен в ‘0’"]
pub type NostretchR = crate :: BitReader < Nostretch > ; impl NostretchR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nostretch { match self . bits { false => Nostretch :: StretchingEnabled , true => Nostretch :: StretchingDisable , } } # [doc = "Растягивание активно"]
# [inline (always)]
pub fn is_stretching_enabled (& self) -> bool { * self == Nostretch :: StretchingEnabled } # [doc = "Растягивание выключено"]
# [inline (always)]
pub fn is_stretching_disable (& self) -> bool { * self == Nostretch :: StretchingDisable } } # [doc = "Field `NOSTRETCH` writer - Отключение растягивания тактового сигнала в режиме «ведомый». Изменение значения допуска-ется только при выключенном блоке (PE=0). В режиме «ве-дущий» бит должен быть установлен в ‘0’"]
pub type NostretchW < 'a , REG > = crate :: BitWriter < 'a , REG , Nostretch > ; impl < 'a , REG > NostretchW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Растягивание активно"]
# [inline (always)]
pub fn stretching_enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Nostretch :: StretchingEnabled) } # [doc = "Растягивание выключено"]
# [inline (always)]
pub fn stretching_disable (self) -> & 'a mut crate :: W < REG > { self . variant (Nostretch :: StretchingDisable) } } # [doc = "Разрешение адреса общего вызова\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gcen { # [doc = "0: Адрес 0b00000000 запрещен, формируется NACK"]
Disabled = 0 , # [doc = "1: Адрес 0b00000000 разрешен, формируется ACK"]
Enable = 1 , } impl From < Gcen > for bool { # [inline (always)]
fn from (variant : Gcen) -> Self { variant as u8 != 0 } } # [doc = "Field `GCEN` reader - Разрешение адреса общего вызова"]
pub type GcenR = crate :: BitReader < Gcen > ; impl GcenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Gcen { match self . bits { false => Gcen :: Disabled , true => Gcen :: Enable , } } # [doc = "Адрес 0b00000000 запрещен, формируется NACK"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == Gcen :: Disabled } # [doc = "Адрес 0b00000000 разрешен, формируется ACK"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Gcen :: Enable } } # [doc = "Field `GCEN` writer - Разрешение адреса общего вызова"]
pub type GcenW < 'a , REG > = crate :: BitWriter < 'a , REG , Gcen > ; impl < 'a , REG > GcenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Адрес 0b00000000 запрещен, формируется NACK"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Gcen :: Disabled) } # [doc = "Адрес 0b00000000 разрешен, формируется ACK"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Gcen :: Enable) } } impl R { # [doc = "Bit 0 - Управление интерфейсом. После очистки, бит должен оставаться в ‘0’ минимум три периода тактового сигнала APB"]
# [inline (always)]
pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Разрешение прерывания при передаче"]
# [inline (always)]
pub fn txie (& self) -> TxieR { TxieR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Разрешение прерывания при приеме"]
# [inline (always)]
pub fn rxie (& self) -> RxieR { RxieR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Разрешение прерывания соот-ветствия адреса в режиме «ведомый»"]
# [inline (always)]
pub fn addrie (& self) -> AddrieR { AddrieR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Разрешение прерывания прием NACK"]
# [inline (always)]
pub fn nackie (& self) -> NackieR { NackieR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Разрешение прерывания обнаружения STOP на линии"]
# [inline (always)]
pub fn stopie (& self) -> StopieR { StopieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Разрешение прерывания окончания передачи. События, вызывающие прерывание: - окончание передачи (TC); - окончание передачи при RELOAD=1 (TCR)."]
# [inline (always)]
pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Разрешение прерывания при ошибке. События, вызывающие прерывание: - потеря арбитража (ARLO); - ошибка шины (BERR); - переполне-ние/недозагрузка (OVR)."]
# [inline (always)]
pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:11 - Управление цифровым фильтром шумов. Изменение значения допускается только при выключенном блоке (PE=0)"]
# [inline (always)]
pub fn dnf (& self) -> DnfR { DnfR :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bit 12 - Управление аналоговым фильтром шумов"]
# [inline (always)]
pub fn anfoff (& self) -> AnfoffR { AnfoffR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 14 - Режим поддержки DMA при передаче данных"]
# [inline (always)]
pub fn txdmaen (& self) -> TxdmaenR { TxdmaenR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Режим поддержки DMA при приеме данных"]
# [inline (always)]
pub fn rxdmaen (& self) -> RxdmaenR { RxdmaenR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Режим аппаратного контроля передачи данных в режиме «ведомый»"]
# [inline (always)]
pub fn sbc (& self) -> SbcR { SbcR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Отключение растягивания тактового сигнала в режиме «ведомый». Изменение значения допуска-ется только при выключенном блоке (PE=0). В режиме «ве-дущий» бит должен быть установлен в ‘0’"]
# [inline (always)]
pub fn nostretch (& self) -> NostretchR { NostretchR :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 19 - Разрешение адреса общего вызова"]
# [inline (always)]
pub fn gcen (& self) -> GcenR { GcenR :: new (((self . bits >> 19) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление интерфейсом. После очистки, бит должен оставаться в ‘0’ минимум три периода тактового сигнала APB"]
# [inline (always)]
pub fn pe (& mut self) -> PeW < Cr1Spec > { PeW :: new (self , 0) } # [doc = "Bit 1 - Разрешение прерывания при передаче"]
# [inline (always)]
pub fn txie (& mut self) -> TxieW < Cr1Spec > { TxieW :: new (self , 1) } # [doc = "Bit 2 - Разрешение прерывания при приеме"]
# [inline (always)]
pub fn rxie (& mut self) -> RxieW < Cr1Spec > { RxieW :: new (self , 2) } # [doc = "Bit 3 - Разрешение прерывания соот-ветствия адреса в режиме «ведомый»"]
# [inline (always)]
pub fn addrie (& mut self) -> AddrieW < Cr1Spec > { AddrieW :: new (self , 3) } # [doc = "Bit 4 - Разрешение прерывания прием NACK"]
# [inline (always)]
pub fn nackie (& mut self) -> NackieW < Cr1Spec > { NackieW :: new (self , 4) } # [doc = "Bit 5 - Разрешение прерывания обнаружения STOP на линии"]
# [inline (always)]
pub fn stopie (& mut self) -> StopieW < Cr1Spec > { StopieW :: new (self , 5) } # [doc = "Bit 6 - Разрешение прерывания окончания передачи. События, вызывающие прерывание: - окончание передачи (TC); - окончание передачи при RELOAD=1 (TCR)."]
# [inline (always)]
pub fn tcie (& mut self) -> TcieW < Cr1Spec > { TcieW :: new (self , 6) } # [doc = "Bit 7 - Разрешение прерывания при ошибке. События, вызывающие прерывание: - потеря арбитража (ARLO); - ошибка шины (BERR); - переполне-ние/недозагрузка (OVR)."]
# [inline (always)]
pub fn errie (& mut self) -> ErrieW < Cr1Spec > { ErrieW :: new (self , 7) } # [doc = "Bits 8:11 - Управление цифровым фильтром шумов. Изменение значения допускается только при выключенном блоке (PE=0)"]
# [inline (always)]
pub fn dnf (& mut self) -> DnfW < Cr1Spec > { DnfW :: new (self , 8) } # [doc = "Bit 12 - Управление аналоговым фильтром шумов"]
# [inline (always)]
pub fn anfoff (& mut self) -> AnfoffW < Cr1Spec > { AnfoffW :: new (self , 12) } # [doc = "Bit 14 - Режим поддержки DMA при передаче данных"]
# [inline (always)]
pub fn txdmaen (& mut self) -> TxdmaenW < Cr1Spec > { TxdmaenW :: new (self , 14) } # [doc = "Bit 15 - Режим поддержки DMA при приеме данных"]
# [inline (always)]
pub fn rxdmaen (& mut self) -> RxdmaenW < Cr1Spec > { RxdmaenW :: new (self , 15) } # [doc = "Bit 16 - Режим аппаратного контроля передачи данных в режиме «ведомый»"]
# [inline (always)]
pub fn sbc (& mut self) -> SbcW < Cr1Spec > { SbcW :: new (self , 16) } # [doc = "Bit 17 - Отключение растягивания тактового сигнала в режиме «ведомый». Изменение значения допуска-ется только при выключенном блоке (PE=0). В режиме «ве-дущий» бит должен быть установлен в ‘0’"]
# [inline (always)]
pub fn nostretch (& mut self) -> NostretchW < Cr1Spec > { NostretchW :: new (self , 17) } # [doc = "Bit 19 - Разрешение адреса общего вызова"]
# [inline (always)]
pub fn gcen (& mut self) -> GcenW < Cr1Spec > { GcenW :: new (self , 19) } } # [doc = "Регистр управления 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr1::R`](R) reader structure"]
impl crate :: Readable for Cr1Spec { } # [doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"]
impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CR1 to value 0"]
impl crate :: Resettable for Cr1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CR2 (rw) register accessor: Регистр управления 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`]
module"]
# [doc (alias = "CR2")]
pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ; # [doc = "Регистр управления 2"]
pub mod cr2 { # [doc = "Register `CR2` reader"]
pub type R = crate :: R < Cr2Spec > ; # [doc = "Register `CR2` writer"]
pub type W = crate :: W < Cr2Spec > ; # [doc = "Field `SADD_10bit` reader - Адрес ведомого (режим «ведущий») в режиме 10-битного адреса (ADD10 = 1). Изменение этих битов при START=1 не допускается."]
pub type Sadd10bitR = crate :: FieldReader < u16 > ; # [doc = "Field `SADD_10bit` writer - Адрес ведомого (режим «ведущий») в режиме 10-битного адреса (ADD10 = 1). Изменение этих битов при START=1 не допускается."]
pub type Sadd10bitW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; # [doc = "Field `SADD_7bit` reader - Адрес ведомого (режим «ведущий») в режиме 7-битного адреса (ADD10 = 0). Изменение этих битов при START=1 не допускается."]
pub type Sadd7bitR = crate :: FieldReader ; # [doc = "Field `SADD_7bit` writer - Адрес ведомого (режим «ведущий») в режиме 7-битного адреса (ADD10 = 0). Изменение этих битов при START=1 не допускается."]
pub type Sadd7bitW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ; # [doc = "Направление передачи (режим «ведущий»). Изменение этого бита при START=1 не допускается.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RdWrn { # [doc = "0: Ведущий запрашивает транзакцию записи"]
Write = 0 , # [doc = "1: Ведущий запрашивает транзакцию чтения"]
Read = 1 , } impl From < RdWrn > for bool { # [inline (always)]
fn from (variant : RdWrn) -> Self { variant as u8 != 0 } } # [doc = "Field `RD_WRN` reader - Направление передачи (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
pub type RdWrnR = crate :: BitReader < RdWrn > ; impl RdWrnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RdWrn { match self . bits { false => RdWrn :: Write , true => RdWrn :: Read , } } # [doc = "Ведущий запрашивает транзакцию записи"]
# [inline (always)]
pub fn is_write (& self) -> bool { * self == RdWrn :: Write } # [doc = "Ведущий запрашивает транзакцию чтения"]
# [inline (always)]
pub fn is_read (& self) -> bool { * self == RdWrn :: Read } } # [doc = "Field `RD_WRN` writer - Направление передачи (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
pub type RdWrnW < 'a , REG > = crate :: BitWriter < 'a , REG , RdWrn > ; impl < 'a , REG > RdWrnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Ведущий запрашивает транзакцию записи"]
# [inline (always)]
pub fn write (self) -> & 'a mut crate :: W < REG > { self . variant (RdWrn :: Write) } # [doc = "Ведущий запрашивает транзакцию чтения"]
# [inline (always)]
pub fn read (self) -> & 'a mut crate :: W < REG > { self . variant (RdWrn :: Read) } } # [doc = "Режим 10-битного адреса (режим «ведущий»). Изменение этого бита при START=1 не допускается.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Add10 { # [doc = "0: Ведущий работает в режиме 7-битного адреса"]
_7bit = 0 , # [doc = "1: Ведущий работает в режиме 10-битного адреса"]
_10bit = 1 , } impl From < Add10 > for bool { # [inline (always)]
fn from (variant : Add10) -> Self { variant as u8 != 0 } } # [doc = "Field `ADD10` reader - Режим 10-битного адреса (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
pub type Add10R = crate :: BitReader < Add10 > ; impl Add10R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Add10 { match self . bits { false => Add10 :: _7bit , true => Add10 :: _10bit , } } # [doc = "Ведущий работает в режиме 7-битного адреса"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == Add10 :: _7bit } # [doc = "Ведущий работает в режиме 10-битного адреса"]
# [inline (always)]
pub fn is_10bit (& self) -> bool { * self == Add10 :: _10bit } } # [doc = "Field `ADD10` writer - Режим 10-битного адреса (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
pub type Add10W < 'a , REG > = crate :: BitWriter < 'a , REG , Add10 > ; impl < 'a , REG > Add10W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Ведущий работает в режиме 7-битного адреса"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut crate :: W < REG > { self . variant (Add10 :: _7bit) } # [doc = "Ведущий работает в режиме 10-битного адреса"]
# [inline (always)]
pub fn _10bit (self) -> & 'a mut crate :: W < REG > { self . variant (Add10 :: _10bit) } } # [doc = "Поддержка 10-битного адреса в режиме «ведущий», чтение Изменение этого бита при START=1 не допускается\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Head10r { # [doc = "0: Ведущий отправляет полную последовательность для чтения для 10 битного адреса: Start + 2 байта ад-реса (запись) + ReStart + заголовок 10-битного адреса (чтение)"]
Complete = 0 , # [doc = "1: Ведущий отправляет только заголовок 10-битного адреса (чтение)"]
Header = 1 , } impl From < Head10r > for bool { # [inline (always)]
fn from (variant : Head10r) -> Self { variant as u8 != 0 } } # [doc = "Field `HEAD10R` reader - Поддержка 10-битного адреса в режиме «ведущий», чтение Изменение этого бита при START=1 не допускается"]
pub type Head10rR = crate :: BitReader < Head10r > ; impl Head10rR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Head10r { match self . bits { false => Head10r :: Complete , true => Head10r :: Header , } } # [doc = "Ведущий отправляет полную последовательность для чтения для 10 битного адреса: Start + 2 байта ад-реса (запись) + ReStart + заголовок 10-битного адреса (чтение)"]
# [inline (always)]
pub fn is_complete (& self) -> bool { * self == Head10r :: Complete } # [doc = "Ведущий отправляет только заголовок 10-битного адреса (чтение)"]
# [inline (always)]
pub fn is_header (& self) -> bool { * self == Head10r :: Header } } # [doc = "Field `HEAD10R` writer - Поддержка 10-битного адреса в режиме «ведущий», чтение Изменение этого бита при START=1 не допускается"]
pub type Head10rW < 'a , REG > = crate :: BitWriter < 'a , REG , Head10r > ; impl < 'a , REG > Head10rW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Ведущий отправляет полную последовательность для чтения для 10 битного адреса: Start + 2 байта ад-реса (запись) + ReStart + заголовок 10-битного адреса (чтение)"]
# [inline (always)]
pub fn complete (self) -> & 'a mut crate :: W < REG > { self . variant (Head10r :: Complete) } # [doc = "Ведущий отправляет только заголовок 10-битного адреса (чтение)"]
# [inline (always)]
pub fn header (self) -> & 'a mut crate :: W < REG > { self . variant (Head10r :: Header) } } # [doc = "Формирование START. Устанавливается программно, сбрасывается аппаратно после отправки адреса, потере арбитража или PE=0. Запись ‘0’ в этот бит не имеет эффекта. В режиме «ведущий» отправка первой части 10-битного адреса повторяется при получении NACK до получения ACK или до очистки бита START записью в бит ADDRCF\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Start { # [doc = "0: START не формируется"]
_0 = 0 , # [doc = "1: формирование START после передачи текущего байта"]
Start = 1 , } impl From < Start > for bool { # [inline (always)]
fn from (variant : Start) -> Self { variant as u8 != 0 } } # [doc = "Field `START` reader - Формирование START. Устанавливается программно, сбрасывается аппаратно после отправки адреса, потере арбитража или PE=0. Запись ‘0’ в этот бит не имеет эффекта. В режиме «ведущий» отправка первой части 10-битного адреса повторяется при получении NACK до получения ACK или до очистки бита START записью в бит ADDRCF"]
pub type StartR = crate :: BitReader < Start > ; impl StartR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Start { match self . bits { false => Start :: _0 , true => Start :: Start , } } # [doc = "START не формируется"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Start :: _0 } # [doc = "формирование START после передачи текущего байта"]
# [inline (always)]
pub fn is_start (& self) -> bool { * self == Start :: Start } } # [doc = "Field `START` writer - Формирование START. Устанавливается программно, сбрасывается аппаратно после отправки адреса, потере арбитража или PE=0. Запись ‘0’ в этот бит не имеет эффекта. В режиме «ведущий» отправка первой части 10-битного адреса повторяется при получении NACK до получения ACK или до очистки бита START записью в бит ADDRCF"]
pub type StartW < 'a , REG > = crate :: BitWriter < 'a , REG , Start > ; impl < 'a , REG > StartW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "START не формируется"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Start :: _0) } # [doc = "формирование START после передачи текущего байта"]
# [inline (always)]
pub fn start (self) -> & 'a mut crate :: W < REG > { self . variant (Start :: Start) } } # [doc = "Формирование STOP в режиме «ведущий». Устанавливается программно, сбрасывается аппаратно по событию STOP на шине или при PE=0. Запись ‘0’ в этот бит не имеет эффекта.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Stop { # [doc = "0: STOP не формируется"]
_0 = 0 , # [doc = "1: Формирование STOP после передачи текущего байта"]
Stop = 1 , } impl From < Stop > for bool { # [inline (always)]
fn from (variant : Stop) -> Self { variant as u8 != 0 } } # [doc = "Field `STOP` reader - Формирование STOP в режиме «ведущий». Устанавливается программно, сбрасывается аппаратно по событию STOP на шине или при PE=0. Запись ‘0’ в этот бит не имеет эффекта."]
pub type StopR = crate :: BitReader < Stop > ; impl StopR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Stop { match self . bits { false => Stop :: _0 , true => Stop :: Stop , } } # [doc = "STOP не формируется"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Stop :: _0 } # [doc = "Формирование STOP после передачи текущего байта"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == Stop :: Stop } } # [doc = "Field `STOP` writer - Формирование STOP в режиме «ведущий». Устанавливается программно, сбрасывается аппаратно по событию STOP на шине или при PE=0. Запись ‘0’ в этот бит не имеет эффекта."]
pub type StopW < 'a , REG > = crate :: BitWriter < 'a , REG , Stop > ; impl < 'a , REG > StopW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "STOP не формируется"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Stop :: _0) } # [doc = "Формирование STOP после передачи текущего байта"]
# [inline (always)]
pub fn stop (self) -> & 'a mut crate :: W < REG > { self . variant (Stop :: Stop) } } # [doc = "Формирование NACK в режиме «ведомый». Устанавливается программно, сбрасывается аппаратно: • после отправки NACK; • по событию STOP на шине; • при получении свое-го адреса ведомого; • PE=0.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nack { # [doc = "0: Отправка ACK после приёма текущего байта"]
Ask = 0 , # [doc = "1: Отправка NACK после приёма текущего байта"]
Nack = 1 , } impl From < Nack > for bool { # [inline (always)]
fn from (variant : Nack) -> Self { variant as u8 != 0 } } # [doc = "Field `NACK` reader - Формирование NACK в режиме «ведомый». Устанавливается программно, сбрасывается аппаратно: • после отправки NACK; • по событию STOP на шине; • при получении свое-го адреса ведомого; • PE=0."]
pub type NackR = crate :: BitReader < Nack > ; impl NackR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nack { match self . bits { false => Nack :: Ask , true => Nack :: Nack , } } # [doc = "Отправка ACK после приёма текущего байта"]
# [inline (always)]
pub fn is_ask (& self) -> bool { * self == Nack :: Ask } # [doc = "Отправка NACK после приёма текущего байта"]
# [inline (always)]
pub fn is_nack (& self) -> bool { * self == Nack :: Nack } } # [doc = "Field `NACK` writer - Формирование NACK в режиме «ведомый». Устанавливается программно, сбрасывается аппаратно: • после отправки NACK; • по событию STOP на шине; • при получении свое-го адреса ведомого; • PE=0."]
pub type NackW < 'a , REG > = crate :: BitWriter < 'a , REG , Nack > ; impl < 'a , REG > NackW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Отправка ACK после приёма текущего байта"]
# [inline (always)]
pub fn ask (self) -> & 'a mut crate :: W < REG > { self . variant (Nack :: Ask) } # [doc = "Отправка NACK после приёма текущего байта"]
# [inline (always)]
pub fn nack (self) -> & 'a mut crate :: W < REG > { self . variant (Nack :: Nack) } } # [doc = "Field `NBYTES` reader - Количество байт для приема / передачи Не имеет значения в режиме «ведомый» при SBC=0 Не допускается изменение при установленном бите START"]
pub type NbytesR = crate :: FieldReader ; # [doc = "Field `NBYTES` writer - Количество байт для приема / передачи Не имеет значения в режиме «ведомый» при SBC=0 Не допускается изменение при установленном бите START"]
pub type NbytesW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Управление режимом перезаписи NBYTES. Бит устанавливается и очищается программой.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Reload { # [doc = "0: Транзакция завершена после пересылки NBYTES байт данных (на шине ожидаются STOP или RESTART)"]
Disable = 0 , # [doc = "1: Транзакция не завершена после пересылки NBYTES байт данных (значение NBYTES будет перезаписано)"]
Enable = 1 , } impl From < Reload > for bool { # [inline (always)]
fn from (variant : Reload) -> Self { variant as u8 != 0 } } # [doc = "Field `RELOAD` reader - Управление режимом перезаписи NBYTES. Бит устанавливается и очищается программой."]
pub type ReloadR = crate :: BitReader < Reload > ; impl ReloadR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Reload { match self . bits { false => Reload :: Disable , true => Reload :: Enable , } } # [doc = "Транзакция завершена после пересылки NBYTES байт данных (на шине ожидаются STOP или RESTART)"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Reload :: Disable } # [doc = "Транзакция не завершена после пересылки NBYTES байт данных (значение NBYTES будет перезаписано)"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Reload :: Enable } } # [doc = "Field `RELOAD` writer - Управление режимом перезаписи NBYTES. Бит устанавливается и очищается программой."]
pub type ReloadW < 'a , REG > = crate :: BitWriter < 'a , REG , Reload > ; impl < 'a , REG > ReloadW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Транзакция завершена после пересылки NBYTES байт данных (на шине ожидаются STOP или RESTART)"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Reload :: Disable) } # [doc = "Транзакция не завершена после пересылки NBYTES байт данных (значение NBYTES будет перезаписано)"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Reload :: Enable) } } # [doc = "Управление режимом автоматического окончания в режиме «ведущий». Бит устанавливается и очищается программой. Не имеет значения при установленном бите RE-LOAD и в режиме «ведомый»\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Autoend { # [doc = "0: Режим автоматического окончания отключен"]
Disable = 0 , # [doc = "1: Режим автоматического окончания включен"]
Enable = 1 , } impl From < Autoend > for bool { # [inline (always)]
fn from (variant : Autoend) -> Self { variant as u8 != 0 } } # [doc = "Field `AUTOEND` reader - Управление режимом автоматического окончания в режиме «ведущий». Бит устанавливается и очищается программой. Не имеет значения при установленном бите RE-LOAD и в режиме «ведомый»"]
pub type AutoendR = crate :: BitReader < Autoend > ; impl AutoendR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Autoend { match self . bits { false => Autoend :: Disable , true => Autoend :: Enable , } } # [doc = "Режим автоматического окончания отключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Autoend :: Disable } # [doc = "Режим автоматического окончания включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Autoend :: Enable } } # [doc = "Field `AUTOEND` writer - Управление режимом автоматического окончания в режиме «ведущий». Бит устанавливается и очищается программой. Не имеет значения при установленном бите RE-LOAD и в режиме «ведомый»"]
pub type AutoendW < 'a , REG > = crate :: BitWriter < 'a , REG , Autoend > ; impl < 'a , REG > AutoendW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Режим автоматического окончания отключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Autoend :: Disable) } # [doc = "Режим автоматического окончания включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Autoend :: Enable) } } impl R { # [doc = "Bits 0:9 - Адрес ведомого (режим «ведущий») в режиме 10-битного адреса (ADD10 = 1). Изменение этих битов при START=1 не допускается."]
# [inline (always)]
pub fn sadd_10bit (& self) -> Sadd10bitR { Sadd10bitR :: new ((self . bits & 0x03ff) as u16) } # [doc = "Bits 1:7 - Адрес ведомого (режим «ведущий») в режиме 7-битного адреса (ADD10 = 0). Изменение этих битов при START=1 не допускается."]
# [inline (always)]
pub fn sadd_7bit (& self) -> Sadd7bitR { Sadd7bitR :: new (((self . bits >> 1) & 0x7f) as u8) } # [doc = "Bit 10 - Направление передачи (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
# [inline (always)]
pub fn rd_wrn (& self) -> RdWrnR { RdWrnR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Режим 10-битного адреса (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
# [inline (always)]
pub fn add10 (& self) -> Add10R { Add10R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Поддержка 10-битного адреса в режиме «ведущий», чтение Изменение этого бита при START=1 не допускается"]
# [inline (always)]
pub fn head10r (& self) -> Head10rR { Head10rR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Формирование START. Устанавливается программно, сбрасывается аппаратно после отправки адреса, потере арбитража или PE=0. Запись ‘0’ в этот бит не имеет эффекта. В режиме «ведущий» отправка первой части 10-битного адреса повторяется при получении NACK до получения ACK или до очистки бита START записью в бит ADDRCF"]
# [inline (always)]
pub fn start (& self) -> StartR { StartR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Формирование STOP в режиме «ведущий». Устанавливается программно, сбрасывается аппаратно по событию STOP на шине или при PE=0. Запись ‘0’ в этот бит не имеет эффекта."]
# [inline (always)]
pub fn stop (& self) -> StopR { StopR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Формирование NACK в режиме «ведомый». Устанавливается программно, сбрасывается аппаратно: • после отправки NACK; • по событию STOP на шине; • при получении свое-го адреса ведомого; • PE=0."]
# [inline (always)]
pub fn nack (& self) -> NackR { NackR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:23 - Количество байт для приема / передачи Не имеет значения в режиме «ведомый» при SBC=0 Не допускается изменение при установленном бите START"]
# [inline (always)]
pub fn nbytes (& self) -> NbytesR { NbytesR :: new (((self . bits >> 16) & 0xff) as u8) } # [doc = "Bit 24 - Управление режимом перезаписи NBYTES. Бит устанавливается и очищается программой."]
# [inline (always)]
pub fn reload (& self) -> ReloadR { ReloadR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Управление режимом автоматического окончания в режиме «ведущий». Бит устанавливается и очищается программой. Не имеет значения при установленном бите RE-LOAD и в режиме «ведомый»"]
# [inline (always)]
pub fn autoend (& self) -> AutoendR { AutoendR :: new (((self . bits >> 25) & 1) != 0) } } impl W { # [doc = "Bits 0:9 - Адрес ведомого (режим «ведущий») в режиме 10-битного адреса (ADD10 = 1). Изменение этих битов при START=1 не допускается."]
# [inline (always)]
pub fn sadd_10bit (& mut self) -> Sadd10bitW < Cr2Spec > { Sadd10bitW :: new (self , 0) } # [doc = "Bits 1:7 - Адрес ведомого (режим «ведущий») в режиме 7-битного адреса (ADD10 = 0). Изменение этих битов при START=1 не допускается."]
# [inline (always)]
pub fn sadd_7bit (& mut self) -> Sadd7bitW < Cr2Spec > { Sadd7bitW :: new (self , 1) } # [doc = "Bit 10 - Направление передачи (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
# [inline (always)]
pub fn rd_wrn (& mut self) -> RdWrnW < Cr2Spec > { RdWrnW :: new (self , 10) } # [doc = "Bit 11 - Режим 10-битного адреса (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
# [inline (always)]
pub fn add10 (& mut self) -> Add10W < Cr2Spec > { Add10W :: new (self , 11) } # [doc = "Bit 12 - Поддержка 10-битного адреса в режиме «ведущий», чтение Изменение этого бита при START=1 не допускается"]
# [inline (always)]
pub fn head10r (& mut self) -> Head10rW < Cr2Spec > { Head10rW :: new (self , 12) } # [doc = "Bit 13 - Формирование START. Устанавливается программно, сбрасывается аппаратно после отправки адреса, потере арбитража или PE=0. Запись ‘0’ в этот бит не имеет эффекта. В режиме «ведущий» отправка первой части 10-битного адреса повторяется при получении NACK до получения ACK или до очистки бита START записью в бит ADDRCF"]
# [inline (always)]
pub fn start (& mut self) -> StartW < Cr2Spec > { StartW :: new (self , 13) } # [doc = "Bit 14 - Формирование STOP в режиме «ведущий». Устанавливается программно, сбрасывается аппаратно по событию STOP на шине или при PE=0. Запись ‘0’ в этот бит не имеет эффекта."]
# [inline (always)]
pub fn stop (& mut self) -> StopW < Cr2Spec > { StopW :: new (self , 14) } # [doc = "Bit 15 - Формирование NACK в режиме «ведомый». Устанавливается программно, сбрасывается аппаратно: • после отправки NACK; • по событию STOP на шине; • при получении свое-го адреса ведомого; • PE=0."]
# [inline (always)]
pub fn nack (& mut self) -> NackW < Cr2Spec > { NackW :: new (self , 15) } # [doc = "Bits 16:23 - Количество байт для приема / передачи Не имеет значения в режиме «ведомый» при SBC=0 Не допускается изменение при установленном бите START"]
# [inline (always)]
pub fn nbytes (& mut self) -> NbytesW < Cr2Spec > { NbytesW :: new (self , 16) } # [doc = "Bit 24 - Управление режимом перезаписи NBYTES. Бит устанавливается и очищается программой."]
# [inline (always)]
pub fn reload (& mut self) -> ReloadW < Cr2Spec > { ReloadW :: new (self , 24) } # [doc = "Bit 25 - Управление режимом автоматического окончания в режиме «ведущий». Бит устанавливается и очищается программой. Не имеет значения при установленном бите RE-LOAD и в режиме «ведомый»"]
# [inline (always)]
pub fn autoend (& mut self) -> AutoendW < Cr2Spec > { AutoendW :: new (self , 25) } } # [doc = "Регистр управления 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr2::R`](R) reader structure"]
impl crate :: Readable for Cr2Spec { } # [doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"]
impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CR2 to value 0"]
impl crate :: Resettable for Cr2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "OAR1 (rw) register accessor: Регистр адреса 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oar1`]
module"]
# [doc (alias = "OAR1")]
pub type Oar1 = crate :: Reg < oar1 :: Oar1Spec > ; # [doc = "Регистр адреса 1"]
pub mod oar1 { # [doc = "Register `OAR1` reader"]
pub type R = crate :: R < Oar1Spec > ; # [doc = "Register `OAR1` writer"]
pub type W = crate :: W < Oar1Spec > ; # [doc = "Field `OA1_10bit` reader - Собственный адрес 1 (10-битный режим). Изменение бита допускается при OA1EN=0."]
pub type Oa1_10bitR = crate :: FieldReader < u16 > ; # [doc = "Field `OA1_10bit` writer - Собственный адрес 1 (10-битный режим). Изменение бита допускается при OA1EN=0."]
pub type Oa1_10bitW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; # [doc = "Field `OA1_7bit` reader - Собственный адрес 1 (7-битный режим). Изменение бита допускается при OA1EN=0."]
pub type Oa1_7bitR = crate :: FieldReader ; # [doc = "Field `OA1_7bit` writer - Собственный адрес 1 (7-битный режим). Изменение бита допускается при OA1EN=0."]
pub type Oa1_7bitW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ; # [doc = "Режим 10-битного адреса OA1. Изменение бита допускается при OA1EN=0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Oa1mode { # [doc = "0: OA1 – 7-битный адрес"]
_7bit = 0 , # [doc = "1: OA1 – 10-битный адрес"]
_10bit = 1 , } impl From < Oa1mode > for bool { # [inline (always)]
fn from (variant : Oa1mode) -> Self { variant as u8 != 0 } } # [doc = "Field `OA1MODE` reader - Режим 10-битного адреса OA1. Изменение бита допускается при OA1EN=0"]
pub type Oa1modeR = crate :: BitReader < Oa1mode > ; impl Oa1modeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Oa1mode { match self . bits { false => Oa1mode :: _7bit , true => Oa1mode :: _10bit , } } # [doc = "OA1 – 7-битный адрес"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == Oa1mode :: _7bit } # [doc = "OA1 – 10-битный адрес"]
# [inline (always)]
pub fn is_10bit (& self) -> bool { * self == Oa1mode :: _10bit } } # [doc = "Field `OA1MODE` writer - Режим 10-битного адреса OA1. Изменение бита допускается при OA1EN=0"]
pub type Oa1modeW < 'a , REG > = crate :: BitWriter < 'a , REG , Oa1mode > ; impl < 'a , REG > Oa1modeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "OA1 – 7-битный адрес"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut crate :: W < REG > { self . variant (Oa1mode :: _7bit) } # [doc = "OA1 – 10-битный адрес"]
# [inline (always)]
pub fn _10bit (self) -> & 'a mut crate :: W < REG > { self . variant (Oa1mode :: _10bit) } } # [doc = "Использование собственно-го адреса OA1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Oa1en { # [doc = "0: При получении адреса OA1 формируется NACK"]
Nack = 0 , # [doc = "1: При получении адреса OA1 формируется ACK"]
Ack = 1 , } impl From < Oa1en > for bool { # [inline (always)]
fn from (variant : Oa1en) -> Self { variant as u8 != 0 } } # [doc = "Field `OA1EN` reader - Использование собственно-го адреса OA1"]
pub type Oa1enR = crate :: BitReader < Oa1en > ; impl Oa1enR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Oa1en { match self . bits { false => Oa1en :: Nack , true => Oa1en :: Ack , } } # [doc = "При получении адреса OA1 формируется NACK"]
# [inline (always)]
pub fn is_nack (& self) -> bool { * self == Oa1en :: Nack } # [doc = "При получении адреса OA1 формируется ACK"]
# [inline (always)]
pub fn is_ack (& self) -> bool { * self == Oa1en :: Ack } } # [doc = "Field `OA1EN` writer - Использование собственно-го адреса OA1"]
pub type Oa1enW < 'a , REG > = crate :: BitWriter < 'a , REG , Oa1en > ; impl < 'a , REG > Oa1enW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "При получении адреса OA1 формируется NACK"]
# [inline (always)]
pub fn nack (self) -> & 'a mut crate :: W < REG > { self . variant (Oa1en :: Nack) } # [doc = "При получении адреса OA1 формируется ACK"]
# [inline (always)]
pub fn ack (self) -> & 'a mut crate :: W < REG > { self . variant (Oa1en :: Ack) } } impl R { # [doc = "Bits 0:9 - Собственный адрес 1 (10-битный режим). Изменение бита допускается при OA1EN=0."]
# [inline (always)]
pub fn oa1_10bit (& self) -> Oa1_10bitR { Oa1_10bitR :: new ((self . bits & 0x03ff) as u16) } # [doc = "Bits 1:7 - Собственный адрес 1 (7-битный режим). Изменение бита допускается при OA1EN=0."]
# [inline (always)]
pub fn oa1_7bit (& self) -> Oa1_7bitR { Oa1_7bitR :: new (((self . bits >> 1) & 0x7f) as u8) } # [doc = "Bit 10 - Режим 10-битного адреса OA1. Изменение бита допускается при OA1EN=0"]
# [inline (always)]
pub fn oa1mode (& self) -> Oa1modeR { Oa1modeR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 15 - Использование собственно-го адреса OA1"]
# [inline (always)]
pub fn oa1en (& self) -> Oa1enR { Oa1enR :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bits 0:9 - Собственный адрес 1 (10-битный режим). Изменение бита допускается при OA1EN=0."]
# [inline (always)]
pub fn oa1_10bit (& mut self) -> Oa1_10bitW < Oar1Spec > { Oa1_10bitW :: new (self , 0) } # [doc = "Bits 1:7 - Собственный адрес 1 (7-битный режим). Изменение бита допускается при OA1EN=0."]
# [inline (always)]
pub fn oa1_7bit (& mut self) -> Oa1_7bitW < Oar1Spec > { Oa1_7bitW :: new (self , 1) } # [doc = "Bit 10 - Режим 10-битного адреса OA1. Изменение бита допускается при OA1EN=0"]
# [inline (always)]
pub fn oa1mode (& mut self) -> Oa1modeW < Oar1Spec > { Oa1modeW :: new (self , 10) } # [doc = "Bit 15 - Использование собственно-го адреса OA1"]
# [inline (always)]
pub fn oa1en (& mut self) -> Oa1enW < Oar1Spec > { Oa1enW :: new (self , 15) } } # [doc = "Регистр адреса 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Oar1Spec ; impl crate :: RegisterSpec for Oar1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`oar1::R`](R) reader structure"]
impl crate :: Readable for Oar1Spec { } # [doc = "`write(|w| ..)` method takes [`oar1::W`](W) writer structure"]
impl crate :: Writable for Oar1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OAR1 to value 0"]
impl crate :: Resettable for Oar1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "OAR2 (rw) register accessor: Регистр адреса 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oar2`]
module"]
# [doc (alias = "OAR2")]
pub type Oar2 = crate :: Reg < oar2 :: Oar2Spec > ; # [doc = "Регистр адреса 2"]
pub mod oar2 { # [doc = "Register `OAR2` reader"]
pub type R = crate :: R < Oar2Spec > ; # [doc = "Register `OAR2` writer"]
pub type W = crate :: W < Oar2Spec > ; # [doc = "Field `OA2` reader - Собственный 7-битный адрес 2 Изменение битов допускается при OA2EN=0"]
pub type Oa2R = crate :: FieldReader ; # [doc = "Field `OA2` writer - Собственный 7-битный адрес 2 Изменение битов допускается при OA2EN=0"]
pub type Oa2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ; # [doc = "Маска адреса OA2. Если OA2MSK ≠ 0, зарезервированные адреса I2C (0b0000xxx, 0b1111xxx) не подтверждаются, даже если адреса совпадают. Изменение битов допускается при OA2EN=0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Oa2msk { # [doc = "0: Нет маски"]
NoMask = 0 , # [doc = "1: Сравниваются только OA2\\[7:2\\]"]
_1_1Masked = 1 , # [doc = "2: Сравниваются только OA2\\[7:3\\]"]
_2_1Masked = 2 , # [doc = "3: Сравниваются только OA2\\[7:4\\]"]
_3_1Masked = 3 , # [doc = "4: Сравниваются только OA2\\[7:5\\]"]
_4_1Masked = 4 , # [doc = "5: Сравниваются только OA2\\[7:6\\]"]
_5_1Masked = 5 , # [doc = "6: Сравниваются только OA2\\[7\\]"]
_6_1Masked = 6 , # [doc = "7: OA2\\[7:1\\]
маскируются, подтверждаются (ACK) все 7-битные ад-реса (кроме зарезервированных)"]
_7_1Masked = 7 , } impl From < Oa2msk > for u8 { # [inline (always)]
fn from (variant : Oa2msk) -> Self { variant as _ } } impl crate :: FieldSpec for Oa2msk { type Ux = u8 ; } impl crate :: IsEnum for Oa2msk { } # [doc = "Field `OA2MSK` reader - Маска адреса OA2. Если OA2MSK ≠ 0, зарезервированные адреса I2C (0b0000xxx, 0b1111xxx) не подтверждаются, даже если адреса совпадают. Изменение битов допускается при OA2EN=0"]
pub type Oa2mskR = crate :: FieldReader < Oa2msk > ; impl Oa2mskR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Oa2msk { match self . bits { 0 => Oa2msk :: NoMask , 1 => Oa2msk :: _1_1Masked , 2 => Oa2msk :: _2_1Masked , 3 => Oa2msk :: _3_1Masked , 4 => Oa2msk :: _4_1Masked , 5 => Oa2msk :: _5_1Masked , 6 => Oa2msk :: _6_1Masked , 7 => Oa2msk :: _7_1Masked , _ => unreachable ! () , } } # [doc = "Нет маски"]
# [inline (always)]
pub fn is_no_mask (& self) -> bool { * self == Oa2msk :: NoMask } # [doc = "Сравниваются только OA2\\[7:2\\]"]
# [inline (always)]
pub fn is_1_1_masked (& self) -> bool { * self == Oa2msk :: _1_1Masked } # [doc = "Сравниваются только OA2\\[7:3\\]"]
# [inline (always)]
pub fn is_2_1_masked (& self) -> bool { * self == Oa2msk :: _2_1Masked } # [doc = "Сравниваются только OA2\\[7:4\\]"]
# [inline (always)]
pub fn is_3_1_masked (& self) -> bool { * self == Oa2msk :: _3_1Masked } # [doc = "Сравниваются только OA2\\[7:5\\]"]
# [inline (always)]
pub fn is_4_1_masked (& self) -> bool { * self == Oa2msk :: _4_1Masked } # [doc = "Сравниваются только OA2\\[7:6\\]"]
# [inline (always)]
pub fn is_5_1_masked (& self) -> bool { * self == Oa2msk :: _5_1Masked } # [doc = "Сравниваются только OA2\\[7\\]"]
# [inline (always)]
pub fn is_6_1_masked (& self) -> bool { * self == Oa2msk :: _6_1Masked } # [doc = "OA2\\[7:1\\]
маскируются, подтверждаются (ACK) все 7-битные ад-реса (кроме зарезервированных)"]
# [inline (always)]
pub fn is_7_1_masked (& self) -> bool { * self == Oa2msk :: _7_1Masked } } # [doc = "Field `OA2MSK` writer - Маска адреса OA2. Если OA2MSK ≠ 0, зарезервированные адреса I2C (0b0000xxx, 0b1111xxx) не подтверждаются, даже если адреса совпадают. Изменение битов допускается при OA2EN=0"]
pub type Oa2mskW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Oa2msk , crate :: Safe > ; impl < 'a , REG > Oa2mskW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нет маски"]
# [inline (always)]
pub fn no_mask (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: NoMask) } # [doc = "Сравниваются только OA2\\[7:2\\]"]
# [inline (always)]
pub fn _1_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _1_1Masked) } # [doc = "Сравниваются только OA2\\[7:3\\]"]
# [inline (always)]
pub fn _2_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _2_1Masked) } # [doc = "Сравниваются только OA2\\[7:4\\]"]
# [inline (always)]
pub fn _3_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _3_1Masked) } # [doc = "Сравниваются только OA2\\[7:5\\]"]
# [inline (always)]
pub fn _4_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _4_1Masked) } # [doc = "Сравниваются только OA2\\[7:6\\]"]
# [inline (always)]
pub fn _5_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _5_1Masked) } # [doc = "Сравниваются только OA2\\[7\\]"]
# [inline (always)]
pub fn _6_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _6_1Masked) } # [doc = "OA2\\[7:1\\]
маскируются, подтверждаются (ACK) все 7-битные ад-реса (кроме зарезервированных)"]
# [inline (always)]
pub fn _7_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _7_1Masked) } } # [doc = "Использование собственно-го адреса OA2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Oa2en { # [doc = "0: При получении адреса OA2 формируется NACK"]
Nack = 0 , # [doc = "1: При получении адреса OA2 формируется ACK"]
Ack = 1 , } impl From < Oa2en > for bool { # [inline (always)]
fn from (variant : Oa2en) -> Self { variant as u8 != 0 } } # [doc = "Field `OA2EN` reader - Использование собственно-го адреса OA2"]
pub type Oa2enR = crate :: BitReader < Oa2en > ; impl Oa2enR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Oa2en { match self . bits { false => Oa2en :: Nack , true => Oa2en :: Ack , } } # [doc = "При получении адреса OA2 формируется NACK"]
# [inline (always)]
pub fn is_nack (& self) -> bool { * self == Oa2en :: Nack } # [doc = "При получении адреса OA2 формируется ACK"]
# [inline (always)]
pub fn is_ack (& self) -> bool { * self == Oa2en :: Ack } } # [doc = "Field `OA2EN` writer - Использование собственно-го адреса OA2"]
pub type Oa2enW < 'a , REG > = crate :: BitWriter < 'a , REG , Oa2en > ; impl < 'a , REG > Oa2enW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "При получении адреса OA2 формируется NACK"]
# [inline (always)]
pub fn nack (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2en :: Nack) } # [doc = "При получении адреса OA2 формируется ACK"]
# [inline (always)]
pub fn ack (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2en :: Ack) } } impl R { # [doc = "Bits 1:7 - Собственный 7-битный адрес 2 Изменение битов допускается при OA2EN=0"]
# [inline (always)]
pub fn oa2 (& self) -> Oa2R { Oa2R :: new (((self . bits >> 1) & 0x7f) as u8) } # [doc = "Bits 8:10 - Маска адреса OA2. Если OA2MSK ≠ 0, зарезервированные адреса I2C (0b0000xxx, 0b1111xxx) не подтверждаются, даже если адреса совпадают. Изменение битов допускается при OA2EN=0"]
# [inline (always)]
pub fn oa2msk (& self) -> Oa2mskR { Oa2mskR :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 15 - Использование собственно-го адреса OA2"]
# [inline (always)]
pub fn oa2en (& self) -> Oa2enR { Oa2enR :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bits 1:7 - Собственный 7-битный адрес 2 Изменение битов допускается при OA2EN=0"]
# [inline (always)]
pub fn oa2 (& mut self) -> Oa2W < Oar2Spec > { Oa2W :: new (self , 1) } # [doc = "Bits 8:10 - Маска адреса OA2. Если OA2MSK ≠ 0, зарезервированные адреса I2C (0b0000xxx, 0b1111xxx) не подтверждаются, даже если адреса совпадают. Изменение битов допускается при OA2EN=0"]
# [inline (always)]
pub fn oa2msk (& mut self) -> Oa2mskW < Oar2Spec > { Oa2mskW :: new (self , 8) } # [doc = "Bit 15 - Использование собственно-го адреса OA2"]
# [inline (always)]
pub fn oa2en (& mut self) -> Oa2enW < Oar2Spec > { Oa2enW :: new (self , 15) } } # [doc = "Регистр адреса 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Oar2Spec ; impl crate :: RegisterSpec for Oar2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`oar2::R`](R) reader structure"]
impl crate :: Readable for Oar2Spec { } # [doc = "`write(|w| ..)` method takes [`oar2::W`](W) writer structure"]
impl crate :: Writable for Oar2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OAR2 to value 0"]
impl crate :: Resettable for Oar2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TIMINGR (rw) register accessor: Регистр настройки временных ограничений. Регистр должен конфигурироваться, пока интерфейс заблокирован (PE=0).\n\nYou can [`read`](crate::Reg::read) this register and get [`timingr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timingr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@timingr`]
module"]
# [doc (alias = "TIMINGR")]
pub type Timingr = crate :: Reg < timingr :: TimingrSpec > ; # [doc = "Регистр настройки временных ограничений. Регистр должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub mod timingr { # [doc = "Register `TIMINGR` reader"]
pub type R = crate :: R < TimingrSpec > ; # [doc = "Register `TIMINGR` writer"]
pub type W = crate :: W < TimingrSpec > ; # [doc = "Field `SCLL` reader - Длительность удержания SCL в состоянии логиче-ского «0» в режиме «ведущий» t_SCLL = (SCLL+1) x t_PRESC Также используется для генерации задержек t_BUF и t_SU:STA. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type ScllR = crate :: FieldReader ; # [doc = "Field `SCLL` writer - Длительность удержания SCL в состоянии логиче-ского «0» в режиме «ведущий» t_SCLL = (SCLL+1) x t_PRESC Также используется для генерации задержек t_BUF и t_SU:STA. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type ScllW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `SCLH` reader - Длительность удержания SCL в состоянии логической «1» в режиме «ведущий» t_SCLH = (SCLH+1) x t_PRESC Также используется для генерации задержек t_HD:STA и t_SU:STO. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type SclhR = crate :: FieldReader ; # [doc = "Field `SCLH` writer - Длительность удержания SCL в состоянии логической «1» в режиме «ведущий» t_SCLH = (SCLH+1) x t_PRESC Также используется для генерации задержек t_HD:STA и t_SU:STO. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type SclhW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `SDADEL` reader - Длительность предустановки данных t_HD:DAT. Задержка между спадом SCL и изменением SDA в режиме ведущего и ведомого при NOSTRETCH = 0 t_SCADEL = (SCADEL+1) x t_PRESC Используется для генера-ции задержек t_HD:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type SdadelR = crate :: FieldReader ; # [doc = "Field `SDADEL` writer - Длительность предустановки данных t_HD:DAT. Задержка между спадом SCL и изменением SDA в режиме ведущего и ведомого при NOSTRETCH = 0 t_SCADEL = (SCADEL+1) x t_PRESC Используется для генера-ции задержек t_HD:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type SdadelW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `SCLDEL` reader - Длительность предустанов-ки данных t_SU:DAT. Задержка между изменени-ем SDA и фронтом SCL. t_SCLDEL = (SCLDEL+1) x t_PRESC Используется для генерации задержек t_SU:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type ScldelR = crate :: FieldReader ; # [doc = "Field `SCLDEL` writer - Длительность предустанов-ки данных t_SU:DAT. Задержка между изменени-ем SDA и фронтом SCL. t_SCLDEL = (SCLDEL+1) x t_PRESC Используется для генерации задержек t_SU:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type ScldelW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `PRESC` reader - Предварительный делитель частоты I2CCLK. Использу-ется для вычисления значения t_PRESC используемого счетчиками предустановки, удержания, низкого и вы-сокого уровней. t_PRESC = (PRESC+1) x t_I2CCLK. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type PrescR = crate :: FieldReader ; # [doc = "Field `PRESC` writer - Предварительный делитель частоты I2CCLK. Использу-ется для вычисления значения t_PRESC используемого счетчиками предустановки, удержания, низкого и вы-сокого уровней. t_PRESC = (PRESC+1) x t_I2CCLK. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type PrescW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R { # [doc = "Bits 0:7 - Длительность удержания SCL в состоянии логиче-ского «0» в режиме «ведущий» t_SCLL = (SCLL+1) x t_PRESC Также используется для генерации задержек t_BUF и t_SU:STA. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn scll (& self) -> ScllR { ScllR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - Длительность удержания SCL в состоянии логической «1» в режиме «ведущий» t_SCLH = (SCLH+1) x t_PRESC Также используется для генерации задержек t_HD:STA и t_SU:STO. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn sclh (& self) -> SclhR { SclhR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:19 - Длительность предустановки данных t_HD:DAT. Задержка между спадом SCL и изменением SDA в режиме ведущего и ведомого при NOSTRETCH = 0 t_SCADEL = (SCADEL+1) x t_PRESC Используется для генера-ции задержек t_HD:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn sdadel (& self) -> SdadelR { SdadelR :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 20:23 - Длительность предустанов-ки данных t_SU:DAT. Задержка между изменени-ем SDA и фронтом SCL. t_SCLDEL = (SCLDEL+1) x t_PRESC Используется для генерации задержек t_SU:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn scldel (& self) -> ScldelR { ScldelR :: new (((self . bits >> 20) & 0x0f) as u8) } # [doc = "Bits 28:31 - Предварительный делитель частоты I2CCLK. Использу-ется для вычисления значения t_PRESC используемого счетчиками предустановки, удержания, низкого и вы-сокого уровней. t_PRESC = (PRESC+1) x t_I2CCLK. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn presc (& self) -> PrescR { PrescR :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W { # [doc = "Bits 0:7 - Длительность удержания SCL в состоянии логиче-ского «0» в режиме «ведущий» t_SCLL = (SCLL+1) x t_PRESC Также используется для генерации задержек t_BUF и t_SU:STA. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn scll (& mut self) -> ScllW < TimingrSpec > { ScllW :: new (self , 0) } # [doc = "Bits 8:15 - Длительность удержания SCL в состоянии логической «1» в режиме «ведущий» t_SCLH = (SCLH+1) x t_PRESC Также используется для генерации задержек t_HD:STA и t_SU:STO. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn sclh (& mut self) -> SclhW < TimingrSpec > { SclhW :: new (self , 8) } # [doc = "Bits 16:19 - Длительность предустановки данных t_HD:DAT. Задержка между спадом SCL и изменением SDA в режиме ведущего и ведомого при NOSTRETCH = 0 t_SCADEL = (SCADEL+1) x t_PRESC Используется для генера-ции задержек t_HD:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn sdadel (& mut self) -> SdadelW < TimingrSpec > { SdadelW :: new (self , 16) } # [doc = "Bits 20:23 - Длительность предустанов-ки данных t_SU:DAT. Задержка между изменени-ем SDA и фронтом SCL. t_SCLDEL = (SCLDEL+1) x t_PRESC Используется для генерации задержек t_SU:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn scldel (& mut self) -> ScldelW < TimingrSpec > { ScldelW :: new (self , 20) } # [doc = "Bits 28:31 - Предварительный делитель частоты I2CCLK. Использу-ется для вычисления значения t_PRESC используемого счетчиками предустановки, удержания, низкого и вы-сокого уровней. t_PRESC = (PRESC+1) x t_I2CCLK. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn presc (& mut self) -> PrescW < TimingrSpec > { PrescW :: new (self , 28) } } # [doc = "Регистр настройки временных ограничений. Регистр должен конфигурироваться, пока интерфейс заблокирован (PE=0).\n\nYou can [`read`](crate::Reg::read) this register and get [`timingr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timingr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TimingrSpec ; impl crate :: RegisterSpec for TimingrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`timingr::R`](R) reader structure"]
impl crate :: Readable for TimingrSpec { } # [doc = "`write(|w| ..)` method takes [`timingr::W`](W) writer structure"]
impl crate :: Writable for TimingrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TIMINGR to value 0"]
impl crate :: Resettable for TimingrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ISR (rw) register accessor: Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`]
module"]
# [doc (alias = "ISR")]
pub type Isr = crate :: Reg < isr :: IsrSpec > ; # [doc = "Регистр флагов прерываний"]
pub mod isr { # [doc = "Register `ISR` reader"]
pub type R = crate :: R < IsrSpec > ; # [doc = "Register `ISR` writer"]
pub type W = crate :: W < IsrSpec > ; # [doc = "Field `TXE` reader - Флаг «буфер передаваемых данных» TXDR пуст (режимы отправки). Устанавливается аппаратно, если буфер пуст; при PE=0 или программно, чтобы сбросить содержимое регистра TXDR. Сбрасывается записью следующего байта данных в регистр TXDR."]
pub type TxeR = crate :: BitReader ; # [doc = "Field `TXIS` reader - Состояние прерывания передатчика. Устанавливается аппаратно, когда регистр TXDR пуст и следующий байт данных должен быть в него записан. Сбрасывается записью следующего байта данных в регистр TXDR или аппаратно при PE=0. Этот бит может быть установлен программой только при NOSTRETCH=1 для выработки события TXIS (в результате: прерывание, при TXIE=1 или DMA запрос, при TXDMAEN=1)"]
pub type TxisR = crate :: BitReader ; # [doc = "Field `RXNE` reader - Флаг «буфер принятых данных заполнен» (режимы приёма). Устанавливается аппарат-но, после записи принятых данных в регистр RXDR. Сбрасывается при чтении RXDR или аппаратно при PE=0."]
pub type RxneR = crate :: BitReader ; # [doc = "Field `RXNE` writer - Флаг «буфер принятых данных заполнен» (режимы приёма). Устанавливается аппарат-но, после записи принятых данных в регистр RXDR. Сбрасывается при чтении RXDR или аппаратно при PE=0."]
pub type RxneW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `ADDR` reader - Флаг соответствия адреса (режим «ведомый»). Устанавливается аппаратно, если полученный адрес совпадает с одним из разрешенных в OAR1, OAR2. Сбрасывается программной установкой бита ADDRCF или аппаратно при PE=0."]
pub type AddrR = crate :: BitReader ; # [doc = "Field `NACKF` reader - Флаг «не получено под-тверждение» (NACK). Устанавливается аппарат-но, после передачи байта. Сбрасывается программной установкой бита NACKCF или аппаратно при PE=0."]
pub type NackfR = crate :: BitReader ; # [doc = "Field `STOPF` reader - Флаг детектирования STOP на шине. Устанавливается аппарат-но, если интерфейс участ-вует в передаче. Сбрасывается программной установкой бита STOPCF или аппаратно при PE=0."]
pub type StopfR = crate :: BitReader ; # [doc = "Field `TC` reader - Флаг окончания передачи (режим «ведущий»). Уста-навливается аппаратно при RELOAD=0, AUTOEND=0, после передачи NBYTES байт. Сбрасывается программной установкой бита START или STOP или аппаратно при PE=0."]
pub type TcR = crate :: BitReader ; # [doc = "Field `TCR` reader - Флаг окончания передачи (режим «ведущий» или «ведомый» с установлен-ным битом SBC). Устанав-ливается аппаратно при RELOAD=1, после переда-чи NBYTES байт. Сбрасывается записью в NBYTES ненулевого значе-ния или аппаратно при PE=0."]
pub type TcrR = crate :: BitReader ; # [doc = "Field `BERR` reader - Флаг ошибки шины Устанавливается аппаратно при детектировании не-уместного события START или STOP на шине, если интерфейс участвует в пе-редаче. Не устанавливается в фазе адреса в режиме «ведомый». Сбрасывается программной установкой бита BERRCF или аппарат-но при PE=0."]
pub type BerrR = crate :: BitReader ; # [doc = "Field `ARLO` reader - Флаг проигрыша арбитража. Устанавливается аппаратно, сбрасывается программной установкой бита ARLOCF или аппаратно при PE=0."]
pub type ArloR = crate :: BitReader ; # [doc = "Field `OVR` reader - Флаг переполнения/недозагрузки (режим «ведомый» при NOSTRETCH=1) Устанавливается аппаратно, сбрасывается программной установкой бита OVRCF или аппаратно при PE=0."]
pub type OvrR = crate :: BitReader ; # [doc = "Field `BUSY` reader - Флаг индикации занятой шины. Устанавливается по-сле события START на шине и сбрасывается после события STOP на шине"]
pub type BusyR = crate :: BitReader ; # [doc = "Направление передачи (режим «ведомый»). Обновляется при совпадении адреса (ADDR=1)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dir { # [doc = "0: Тип передачи «запись», ведомый переходит в режим приемника"]
Write = 0 , # [doc = "1: Тип передачи «чтение», ведомый переходит в режим передатчика"]
Read = 1 , } impl From < Dir > for bool { # [inline (always)]
fn from (variant : Dir) -> Self { variant as u8 != 0 } } # [doc = "Field `DIR` reader - Направление передачи (режим «ведомый»). Обновляется при совпадении адреса (ADDR=1)"]
pub type DirR = crate :: BitReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dir { match self . bits { false => Dir :: Write , true => Dir :: Read , } } # [doc = "Тип передачи «запись», ведомый переходит в режим приемника"]
# [inline (always)]
pub fn is_write (& self) -> bool { * self == Dir :: Write } # [doc = "Тип передачи «чтение», ведомый переходит в режим передатчика"]
# [inline (always)]
pub fn is_read (& self) -> bool { * self == Dir :: Read } } # [doc = "Field `ADDCODE` reader - Код совпавшего адреса. Обновляется в режиме «ве-домый» при совпадении адреса (ADDR=1). В режиме 10-битного адре-са содержит заголовок (5b11110) и два старших бита адреса."]
pub type AddcodeR = crate :: FieldReader ; impl R { # [doc = "Bit 0 - Флаг «буфер передаваемых данных» TXDR пуст (режимы отправки). Устанавливается аппаратно, если буфер пуст; при PE=0 или программно, чтобы сбросить содержимое регистра TXDR. Сбрасывается записью следующего байта данных в регистр TXDR."]
# [inline (always)]
pub fn txe (& self) -> TxeR { TxeR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Состояние прерывания передатчика. Устанавливается аппаратно, когда регистр TXDR пуст и следующий байт данных должен быть в него записан. Сбрасывается записью следующего байта данных в регистр TXDR или аппаратно при PE=0. Этот бит может быть установлен программой только при NOSTRETCH=1 для выработки события TXIS (в результате: прерывание, при TXIE=1 или DMA запрос, при TXDMAEN=1)"]
# [inline (always)]
pub fn txis (& self) -> TxisR { TxisR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Флаг «буфер принятых данных заполнен» (режимы приёма). Устанавливается аппарат-но, после записи принятых данных в регистр RXDR. Сбрасывается при чтении RXDR или аппаратно при PE=0."]
# [inline (always)]
pub fn rxne (& self) -> RxneR { RxneR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Флаг соответствия адреса (режим «ведомый»). Устанавливается аппаратно, если полученный адрес совпадает с одним из разрешенных в OAR1, OAR2. Сбрасывается программной установкой бита ADDRCF или аппаратно при PE=0."]
# [inline (always)]
pub fn addr (& self) -> AddrR { AddrR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Флаг «не получено под-тверждение» (NACK). Устанавливается аппарат-но, после передачи байта. Сбрасывается программной установкой бита NACKCF или аппаратно при PE=0."]
# [inline (always)]
pub fn nackf (& self) -> NackfR { NackfR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Флаг детектирования STOP на шине. Устанавливается аппарат-но, если интерфейс участ-вует в передаче. Сбрасывается программной установкой бита STOPCF или аппаратно при PE=0."]
# [inline (always)]
pub fn stopf (& self) -> StopfR { StopfR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Флаг окончания передачи (режим «ведущий»). Уста-навливается аппаратно при RELOAD=0, AUTOEND=0, после передачи NBYTES байт. Сбрасывается программной установкой бита START или STOP или аппаратно при PE=0."]
# [inline (always)]
pub fn tc (& self) -> TcR { TcR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Флаг окончания передачи (режим «ведущий» или «ведомый» с установлен-ным битом SBC). Устанав-ливается аппаратно при RELOAD=1, после переда-чи NBYTES байт. Сбрасывается записью в NBYTES ненулевого значе-ния или аппаратно при PE=0."]
# [inline (always)]
pub fn tcr (& self) -> TcrR { TcrR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Флаг ошибки шины Устанавливается аппаратно при детектировании не-уместного события START или STOP на шине, если интерфейс участвует в пе-редаче. Не устанавливается в фазе адреса в режиме «ведомый». Сбрасывается программной установкой бита BERRCF или аппарат-но при PE=0."]
# [inline (always)]
pub fn berr (& self) -> BerrR { BerrR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Флаг проигрыша арбитража. Устанавливается аппаратно, сбрасывается программной установкой бита ARLOCF или аппаратно при PE=0."]
# [inline (always)]
pub fn arlo (& self) -> ArloR { ArloR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Флаг переполнения/недозагрузки (режим «ведомый» при NOSTRETCH=1) Устанавливается аппаратно, сбрасывается программной установкой бита OVRCF или аппаратно при PE=0."]
# [inline (always)]
pub fn ovr (& self) -> OvrR { OvrR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 15 - Флаг индикации занятой шины. Устанавливается по-сле события START на шине и сбрасывается после события STOP на шине"]
# [inline (always)]
pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Направление передачи (режим «ведомый»). Обновляется при совпадении адреса (ADDR=1)"]
# [inline (always)]
pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bits 17:23 - Код совпавшего адреса. Обновляется в режиме «ве-домый» при совпадении адреса (ADDR=1). В режиме 10-битного адре-са содержит заголовок (5b11110) и два старших бита адреса."]
# [inline (always)]
pub fn addcode (& self) -> AddcodeR { AddcodeR :: new (((self . bits >> 17) & 0x7f) as u8) } } impl W { # [doc = "Bit 2 - Флаг «буфер принятых данных заполнен» (режимы приёма). Устанавливается аппарат-но, после записи принятых данных в регистр RXDR. Сбрасывается при чтении RXDR или аппаратно при PE=0."]
# [inline (always)]
pub fn rxne (& mut self) -> RxneW < IsrSpec > { RxneW :: new (self , 2) } } # [doc = "Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`isr::R`](R) reader structure"]
impl crate :: Readable for IsrSpec { } # [doc = "`write(|w| ..)` method takes [`isr::W`](W) writer structure"]
impl crate :: Writable for IsrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ISR to value 0"]
impl crate :: Resettable for IsrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ICR (w) register accessor: Регистр сроса флагов прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`]
module"]
# [doc (alias = "ICR")]
pub type Icr = crate :: Reg < icr :: IcrSpec > ; # [doc = "Регистр сроса флагов прерываний"]
pub mod icr { # [doc = "Register `ICR` writer"]
pub type W = crate :: W < IcrSpec > ; # [doc = "Field `ADDRCF` writer - Сброс флага соответствия адреса"]
pub type AddrcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `NACKCF` writer - Сброс флага «не получено подтверждение» (NACK)"]
pub type NackcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `STOPCF` writer - Сброс флага детектирования STOP на шине"]
pub type StopcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `BERRCF` writer - Сброс флага ошибки шины"]
pub type BerrcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `ARLOCF` writer - Сброс флага проигрыша арбитража"]
pub type ArlocfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OVRCF` writer - Сброс флага прерывания переполнения/недозагрузки"]
pub type OvrcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W { # [doc = "Bit 3 - Сброс флага соответствия адреса"]
# [inline (always)]
pub fn addrcf (& mut self) -> AddrcfW < IcrSpec > { AddrcfW :: new (self , 3) } # [doc = "Bit 4 - Сброс флага «не получено подтверждение» (NACK)"]
# [inline (always)]
pub fn nackcf (& mut self) -> NackcfW < IcrSpec > { NackcfW :: new (self , 4) } # [doc = "Bit 5 - Сброс флага детектирования STOP на шине"]
# [inline (always)]
pub fn stopcf (& mut self) -> StopcfW < IcrSpec > { StopcfW :: new (self , 5) } # [doc = "Bit 8 - Сброс флага ошибки шины"]
# [inline (always)]
pub fn berrcf (& mut self) -> BerrcfW < IcrSpec > { BerrcfW :: new (self , 8) } # [doc = "Bit 9 - Сброс флага проигрыша арбитража"]
# [inline (always)]
pub fn arlocf (& mut self) -> ArlocfW < IcrSpec > { ArlocfW :: new (self , 9) } # [doc = "Bit 10 - Сброс флага прерывания переполнения/недозагрузки"]
# [inline (always)]
pub fn ovrcf (& mut self) -> OvrcfW < IcrSpec > { OvrcfW :: new (self , 10) } } # [doc = "Регистр сроса флагов прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"]
impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ICR to value 0"]
impl crate :: Resettable for IcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RXDR (r) register accessor: Регистр принятых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxdr`]
module"]
# [doc (alias = "RXDR")]
pub type Rxdr = crate :: Reg < rxdr :: RxdrSpec > ; # [doc = "Регистр принятых данных"]
pub mod rxdr { # [doc = "Register `RXDR` reader"]
pub type R = crate :: R < RxdrSpec > ; # [doc = "Field `TXDATA` reader - Буфер принятых данных"]
pub type TxdataR = crate :: FieldReader ; impl R { # [doc = "Bits 0:7 - Буфер принятых данных"]
# [inline (always)]
pub fn txdata (& self) -> TxdataR { TxdataR :: new ((self . bits & 0xff) as u8) } } # [doc = "Регистр принятых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxdrSpec ; impl crate :: RegisterSpec for RxdrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rxdr::R`](R) reader structure"]
impl crate :: Readable for RxdrSpec { } # [doc = "`reset()` method sets RXDR to value 0"]
impl crate :: Resettable for RxdrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TXDR (rw) register accessor: Регистр передаваемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`txdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txdr`]
module"]
# [doc (alias = "TXDR")]
pub type Txdr = crate :: Reg < txdr :: TxdrSpec > ; # [doc = "Регистр передаваемых данных"]
pub mod txdr { # [doc = "Register `TXDR` reader"]
pub type R = crate :: R < TxdrSpec > ; # [doc = "Register `TXDR` writer"]
pub type W = crate :: W < TxdrSpec > ; # [doc = "Field `TXDATA` reader - Буфер передаваемых данных"]
pub type TxdataR = crate :: FieldReader ; # [doc = "Field `TXDATA` writer - Буфер передаваемых данных"]
pub type TxdataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7 - Буфер передаваемых данных"]
# [inline (always)]
pub fn txdata (& self) -> TxdataR { TxdataR :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - Буфер передаваемых данных"]
# [inline (always)]
pub fn txdata (& mut self) -> TxdataW < TxdrSpec > { TxdataW :: new (self , 0) } } # [doc = "Регистр передаваемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`txdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxdrSpec ; impl crate :: RegisterSpec for TxdrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`txdr::R`](R) reader structure"]
impl crate :: Readable for TxdrSpec { } # [doc = "`write(|w| ..)` method takes [`txdr::W`](W) writer structure"]
impl crate :: Writable for TxdrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TXDR to value 0"]
impl crate :: Resettable for TxdrSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Модуль обеспечивает интерфейс для связи контроллера и последовательной шины I2C"]
pub struct I2c1 { _marker : PhantomData < * const () > } unsafe impl Send for I2c1 { } impl I2c1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const i2c_1 :: RegisterBlock = 0x0008_3c00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const i2c_1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for I2c1 { type Target = i2c_1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for I2c1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("I2c1") . finish () } } # [doc = "Модуль обеспечивает интерфейс для связи контроллера и последовательной шины I2C"]
pub mod i2c_1 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { cr1 : Cr1 , cr2 : Cr2 , oar1 : Oar1 , oar2 : Oar2 , timingr : Timingr , _reserved5 : [u8 ; 0x04]
, isr : Isr , icr : Icr , rxdr : Rxdr , txdr : Txdr , } impl RegisterBlock { # [doc = "0x00 - Регистр управления 1"]
# [inline (always)]
pub const fn cr1 (& self) -> & Cr1 { & self . cr1 } # [doc = "0x04 - Регистр управления 2"]
# [inline (always)]
pub const fn cr2 (& self) -> & Cr2 { & self . cr2 } # [doc = "0x08 - Регистр адреса 1"]
# [inline (always)]
pub const fn oar1 (& self) -> & Oar1 { & self . oar1 } # [doc = "0x0c - Регистр адреса 2"]
# [inline (always)]
pub const fn oar2 (& self) -> & Oar2 { & self . oar2 } # [doc = "0x10 - Регистр настройки временных ограничений. Регистр должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub const fn timingr (& self) -> & Timingr { & self . timingr } # [doc = "0x18 - Регистр флагов прерываний"]
# [inline (always)]
pub const fn isr (& self) -> & Isr { & self . isr } # [doc = "0x1c - Регистр сроса флагов прерываний"]
# [inline (always)]
pub const fn icr (& self) -> & Icr { & self . icr } # [doc = "0x20 - Регистр принятых данных"]
# [inline (always)]
pub const fn rxdr (& self) -> & Rxdr { & self . rxdr } # [doc = "0x24 - Регистр передаваемых данных"]
# [inline (always)]
pub const fn txdr (& self) -> & Txdr { & self . txdr } } # [doc = "CR1 (rw) register accessor: Регистр управления 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr1`]
module"]
# [doc (alias = "CR1")]
pub type Cr1 = crate :: Reg < cr1 :: Cr1Spec > ; # [doc = "Регистр управления 1"]
pub mod cr1 { # [doc = "Register `CR1` reader"]
pub type R = crate :: R < Cr1Spec > ; # [doc = "Register `CR1` writer"]
pub type W = crate :: W < Cr1Spec > ; # [doc = "Управление интерфейсом. После очистки, бит должен оставаться в ‘0’ минимум три периода тактового сигнала APB\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pe { # [doc = "0: Интерфейс выключен"]
Disable = 0 , # [doc = "1: Интерфейс включен"]
Enable = 1 , } impl From < Pe > for bool { # [inline (always)]
fn from (variant : Pe) -> Self { variant as u8 != 0 } } # [doc = "Field `PE` reader - Управление интерфейсом. После очистки, бит должен оставаться в ‘0’ минимум три периода тактового сигнала APB"]
pub type PeR = crate :: BitReader < Pe > ; impl PeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pe { match self . bits { false => Pe :: Disable , true => Pe :: Enable , } } # [doc = "Интерфейс выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Pe :: Disable } # [doc = "Интерфейс включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Pe :: Enable } } # [doc = "Field `PE` writer - Управление интерфейсом. После очистки, бит должен оставаться в ‘0’ минимум три периода тактового сигнала APB"]
pub type PeW < 'a , REG > = crate :: BitWriter < 'a , REG , Pe > ; impl < 'a , REG > PeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Интерфейс выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Pe :: Disable) } # [doc = "Интерфейс включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Pe :: Enable) } } # [doc = "Разрешение прерывания при передаче\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Txie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Txie > for bool { # [inline (always)]
fn from (variant : Txie) -> Self { variant as u8 != 0 } } # [doc = "Field `TXIE` reader - Разрешение прерывания при передаче"]
pub type TxieR = crate :: BitReader < Txie > ; impl TxieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Txie { match self . bits { false => Txie :: Disable , true => Txie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Txie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Txie :: Enable } } # [doc = "Field `TXIE` writer - Разрешение прерывания при передаче"]
pub type TxieW < 'a , REG > = crate :: BitWriter < 'a , REG , Txie > ; impl < 'a , REG > TxieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Txie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Txie :: Enable) } } # [doc = "Разрешение прерывания при приеме\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rxie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Rxie > for bool { # [inline (always)]
fn from (variant : Rxie) -> Self { variant as u8 != 0 } } # [doc = "Field `RXIE` reader - Разрешение прерывания при приеме"]
pub type RxieR = crate :: BitReader < Rxie > ; impl RxieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rxie { match self . bits { false => Rxie :: Disable , true => Rxie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Rxie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Rxie :: Enable } } # [doc = "Field `RXIE` writer - Разрешение прерывания при приеме"]
pub type RxieW < 'a , REG > = crate :: BitWriter < 'a , REG , Rxie > ; impl < 'a , REG > RxieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxie :: Enable) } } # [doc = "Разрешение прерывания соот-ветствия адреса в режиме «ведомый»\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Addrie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Addrie > for bool { # [inline (always)]
fn from (variant : Addrie) -> Self { variant as u8 != 0 } } # [doc = "Field `ADDRIE` reader - Разрешение прерывания соот-ветствия адреса в режиме «ведомый»"]
pub type AddrieR = crate :: BitReader < Addrie > ; impl AddrieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Addrie { match self . bits { false => Addrie :: Disable , true => Addrie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Addrie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Addrie :: Enable } } # [doc = "Field `ADDRIE` writer - Разрешение прерывания соот-ветствия адреса в режиме «ведомый»"]
pub type AddrieW < 'a , REG > = crate :: BitWriter < 'a , REG , Addrie > ; impl < 'a , REG > AddrieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Addrie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Addrie :: Enable) } } # [doc = "Разрешение прерывания прием NACK\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nackie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Nackie > for bool { # [inline (always)]
fn from (variant : Nackie) -> Self { variant as u8 != 0 } } # [doc = "Field `NACKIE` reader - Разрешение прерывания прием NACK"]
pub type NackieR = crate :: BitReader < Nackie > ; impl NackieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nackie { match self . bits { false => Nackie :: Disable , true => Nackie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Nackie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Nackie :: Enable } } # [doc = "Field `NACKIE` writer - Разрешение прерывания прием NACK"]
pub type NackieW < 'a , REG > = crate :: BitWriter < 'a , REG , Nackie > ; impl < 'a , REG > NackieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Nackie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Nackie :: Enable) } } # [doc = "Разрешение прерывания обнаружения STOP на линии\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Stopie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Stopie > for bool { # [inline (always)]
fn from (variant : Stopie) -> Self { variant as u8 != 0 } } # [doc = "Field `STOPIE` reader - Разрешение прерывания обнаружения STOP на линии"]
pub type StopieR = crate :: BitReader < Stopie > ; impl StopieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Stopie { match self . bits { false => Stopie :: Disable , true => Stopie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Stopie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Stopie :: Enable } } # [doc = "Field `STOPIE` writer - Разрешение прерывания обнаружения STOP на линии"]
pub type StopieW < 'a , REG > = crate :: BitWriter < 'a , REG , Stopie > ; impl < 'a , REG > StopieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Stopie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Stopie :: Enable) } } # [doc = "Разрешение прерывания окончания передачи. События, вызывающие прерывание: - окончание передачи (TC); - окончание передачи при RELOAD=1 (TCR).\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Tcie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Tcie > for bool { # [inline (always)]
fn from (variant : Tcie) -> Self { variant as u8 != 0 } } # [doc = "Field `TCIE` reader - Разрешение прерывания окончания передачи. События, вызывающие прерывание: - окончание передачи (TC); - окончание передачи при RELOAD=1 (TCR)."]
pub type TcieR = crate :: BitReader < Tcie > ; impl TcieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Tcie { match self . bits { false => Tcie :: Disable , true => Tcie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Tcie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Tcie :: Enable } } # [doc = "Field `TCIE` writer - Разрешение прерывания окончания передачи. События, вызывающие прерывание: - окончание передачи (TC); - окончание передачи при RELOAD=1 (TCR)."]
pub type TcieW < 'a , REG > = crate :: BitWriter < 'a , REG , Tcie > ; impl < 'a , REG > TcieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Tcie :: Enable) } } # [doc = "Разрешение прерывания при ошибке. События, вызывающие прерывание: - потеря арбитража (ARLO); - ошибка шины (BERR); - переполне-ние/недозагрузка (OVR).\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Errie { # [doc = "0: Прерывание запрещено"]
Disable = 0 , # [doc = "1: Прерывание разрешено"]
Enable = 1 , } impl From < Errie > for bool { # [inline (always)]
fn from (variant : Errie) -> Self { variant as u8 != 0 } } # [doc = "Field `ERRIE` reader - Разрешение прерывания при ошибке. События, вызывающие прерывание: - потеря арбитража (ARLO); - ошибка шины (BERR); - переполне-ние/недозагрузка (OVR)."]
pub type ErrieR = crate :: BitReader < Errie > ; impl ErrieR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Errie { match self . bits { false => Errie :: Disable , true => Errie :: Enable , } } # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Errie :: Disable } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Errie :: Enable } } # [doc = "Field `ERRIE` writer - Разрешение прерывания при ошибке. События, вызывающие прерывание: - потеря арбитража (ARLO); - ошибка шины (BERR); - переполне-ние/недозагрузка (OVR)."]
pub type ErrieW < 'a , REG > = crate :: BitWriter < 'a , REG , Errie > ; impl < 'a , REG > ErrieW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Прерывание запрещено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Errie :: Disable) } # [doc = "Прерывание разрешено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Errie :: Enable) } } # [doc = "Управление цифровым фильтром шумов. Изменение значения допускается только при выключенном блоке (PE=0)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Dnf { # [doc = "0: Цифровой фильтр выключен"]
Disable = 0 , # [doc = "1: Цифровой фильтр установлен на 1 такт I2CCLK"]
_1 = 1 , # [doc = "2: Цифровой фильтр установлен на 2 такта I2CCLK"]
_2 = 2 , # [doc = "3: Цифровой фильтр установлен на 3 такта I2CCLK"]
_3 = 3 , # [doc = "4: Цифровой фильтр установлен на 4 такта I2CCLK"]
_4 = 4 , # [doc = "5: Цифровой фильтр установлен на 5 тактов I2CCLK"]
_5 = 5 , # [doc = "6: Цифровой фильтр установлен на 6 тактов I2CCLK"]
_6 = 6 , # [doc = "7: Цифровой фильтр установлен на 7 тактов I2CCLK"]
_7 = 7 , # [doc = "8: Цифровой фильтр установлен на 8 тактов I2CCLK"]
_8 = 8 , # [doc = "9: Цифровой фильтр установлен на 9 тактов I2CCLK"]
_9 = 9 , # [doc = "10: Цифровой фильтр установлен на 10 тактов I2CCLK"]
_10 = 10 , # [doc = "11: Цифровой фильтр установлен на 11 тактов I2CCLK"]
_11 = 11 , # [doc = "12: Цифровой фильтр установлен на 12 тактов I2CCLK"]
_12 = 12 , # [doc = "13: Цифровой фильтр установлен на 13 тактов I2CCLK"]
_13 = 13 , # [doc = "14: цифровой фильтр установлен на 14 тактов I2CCLK"]
_14 = 14 , # [doc = "15: Цифровой фильтр установлен на 15 тактов I2CCLK"]
_15 = 15 , } impl From < Dnf > for u8 { # [inline (always)]
fn from (variant : Dnf) -> Self { variant as _ } } impl crate :: FieldSpec for Dnf { type Ux = u8 ; } impl crate :: IsEnum for Dnf { } # [doc = "Field `DNF` reader - Управление цифровым фильтром шумов. Изменение значения допускается только при выключенном блоке (PE=0)"]
pub type DnfR = crate :: FieldReader < Dnf > ; impl DnfR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dnf { match self . bits { 0 => Dnf :: Disable , 1 => Dnf :: _1 , 2 => Dnf :: _2 , 3 => Dnf :: _3 , 4 => Dnf :: _4 , 5 => Dnf :: _5 , 6 => Dnf :: _6 , 7 => Dnf :: _7 , 8 => Dnf :: _8 , 9 => Dnf :: _9 , 10 => Dnf :: _10 , 11 => Dnf :: _11 , 12 => Dnf :: _12 , 13 => Dnf :: _13 , 14 => Dnf :: _14 , 15 => Dnf :: _15 , _ => unreachable ! () , } } # [doc = "Цифровой фильтр выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Dnf :: Disable } # [doc = "Цифровой фильтр установлен на 1 такт I2CCLK"]
# [inline (always)]
pub fn is_1 (& self) -> bool { * self == Dnf :: _1 } # [doc = "Цифровой фильтр установлен на 2 такта I2CCLK"]
# [inline (always)]
pub fn is_2 (& self) -> bool { * self == Dnf :: _2 } # [doc = "Цифровой фильтр установлен на 3 такта I2CCLK"]
# [inline (always)]
pub fn is_3 (& self) -> bool { * self == Dnf :: _3 } # [doc = "Цифровой фильтр установлен на 4 такта I2CCLK"]
# [inline (always)]
pub fn is_4 (& self) -> bool { * self == Dnf :: _4 } # [doc = "Цифровой фильтр установлен на 5 тактов I2CCLK"]
# [inline (always)]
pub fn is_5 (& self) -> bool { * self == Dnf :: _5 } # [doc = "Цифровой фильтр установлен на 6 тактов I2CCLK"]
# [inline (always)]
pub fn is_6 (& self) -> bool { * self == Dnf :: _6 } # [doc = "Цифровой фильтр установлен на 7 тактов I2CCLK"]
# [inline (always)]
pub fn is_7 (& self) -> bool { * self == Dnf :: _7 } # [doc = "Цифровой фильтр установлен на 8 тактов I2CCLK"]
# [inline (always)]
pub fn is_8 (& self) -> bool { * self == Dnf :: _8 } # [doc = "Цифровой фильтр установлен на 9 тактов I2CCLK"]
# [inline (always)]
pub fn is_9 (& self) -> bool { * self == Dnf :: _9 } # [doc = "Цифровой фильтр установлен на 10 тактов I2CCLK"]
# [inline (always)]
pub fn is_10 (& self) -> bool { * self == Dnf :: _10 } # [doc = "Цифровой фильтр установлен на 11 тактов I2CCLK"]
# [inline (always)]
pub fn is_11 (& self) -> bool { * self == Dnf :: _11 } # [doc = "Цифровой фильтр установлен на 12 тактов I2CCLK"]
# [inline (always)]
pub fn is_12 (& self) -> bool { * self == Dnf :: _12 } # [doc = "Цифровой фильтр установлен на 13 тактов I2CCLK"]
# [inline (always)]
pub fn is_13 (& self) -> bool { * self == Dnf :: _13 } # [doc = "цифровой фильтр установлен на 14 тактов I2CCLK"]
# [inline (always)]
pub fn is_14 (& self) -> bool { * self == Dnf :: _14 } # [doc = "Цифровой фильтр установлен на 15 тактов I2CCLK"]
# [inline (always)]
pub fn is_15 (& self) -> bool { * self == Dnf :: _15 } } # [doc = "Field `DNF` writer - Управление цифровым фильтром шумов. Изменение значения допускается только при выключенном блоке (PE=0)"]
pub type DnfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 , Dnf , crate :: Safe > ; impl < 'a , REG > DnfW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Цифровой фильтр выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: Disable) } # [doc = "Цифровой фильтр установлен на 1 такт I2CCLK"]
# [inline (always)]
pub fn _1 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _1) } # [doc = "Цифровой фильтр установлен на 2 такта I2CCLK"]
# [inline (always)]
pub fn _2 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _2) } # [doc = "Цифровой фильтр установлен на 3 такта I2CCLK"]
# [inline (always)]
pub fn _3 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _3) } # [doc = "Цифровой фильтр установлен на 4 такта I2CCLK"]
# [inline (always)]
pub fn _4 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _4) } # [doc = "Цифровой фильтр установлен на 5 тактов I2CCLK"]
# [inline (always)]
pub fn _5 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _5) } # [doc = "Цифровой фильтр установлен на 6 тактов I2CCLK"]
# [inline (always)]
pub fn _6 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _6) } # [doc = "Цифровой фильтр установлен на 7 тактов I2CCLK"]
# [inline (always)]
pub fn _7 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _7) } # [doc = "Цифровой фильтр установлен на 8 тактов I2CCLK"]
# [inline (always)]
pub fn _8 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _8) } # [doc = "Цифровой фильтр установлен на 9 тактов I2CCLK"]
# [inline (always)]
pub fn _9 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _9) } # [doc = "Цифровой фильтр установлен на 10 тактов I2CCLK"]
# [inline (always)]
pub fn _10 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _10) } # [doc = "Цифровой фильтр установлен на 11 тактов I2CCLK"]
# [inline (always)]
pub fn _11 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _11) } # [doc = "Цифровой фильтр установлен на 12 тактов I2CCLK"]
# [inline (always)]
pub fn _12 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _12) } # [doc = "Цифровой фильтр установлен на 13 тактов I2CCLK"]
# [inline (always)]
pub fn _13 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _13) } # [doc = "цифровой фильтр установлен на 14 тактов I2CCLK"]
# [inline (always)]
pub fn _14 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _14) } # [doc = "Цифровой фильтр установлен на 15 тактов I2CCLK"]
# [inline (always)]
pub fn _15 (self) -> & 'a mut crate :: W < REG > { self . variant (Dnf :: _15) } } # [doc = "Управление аналоговым фильтром шумов\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Anfoff { # [doc = "0: Фильтр выключен"]
Disable = 0 , # [doc = "1: Фильтр включен"]
Enable = 1 , } impl From < Anfoff > for bool { # [inline (always)]
fn from (variant : Anfoff) -> Self { variant as u8 != 0 } } # [doc = "Field `ANFOFF` reader - Управление аналоговым фильтром шумов"]
pub type AnfoffR = crate :: BitReader < Anfoff > ; impl AnfoffR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Anfoff { match self . bits { false => Anfoff :: Disable , true => Anfoff :: Enable , } } # [doc = "Фильтр выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Anfoff :: Disable } # [doc = "Фильтр включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Anfoff :: Enable } } # [doc = "Field `ANFOFF` writer - Управление аналоговым фильтром шумов"]
pub type AnfoffW < 'a , REG > = crate :: BitWriter < 'a , REG , Anfoff > ; impl < 'a , REG > AnfoffW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Фильтр выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Anfoff :: Disable) } # [doc = "Фильтр включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Anfoff :: Enable) } } # [doc = "Режим поддержки DMA при передаче данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Txdmaen { # [doc = "0: Поддержка DMA выключена"]
Disable = 0 , # [doc = "1: Поддержка DMA включена"]
Enable = 1 , } impl From < Txdmaen > for bool { # [inline (always)]
fn from (variant : Txdmaen) -> Self { variant as u8 != 0 } } # [doc = "Field `TXDMAEN` reader - Режим поддержки DMA при передаче данных"]
pub type TxdmaenR = crate :: BitReader < Txdmaen > ; impl TxdmaenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Txdmaen { match self . bits { false => Txdmaen :: Disable , true => Txdmaen :: Enable , } } # [doc = "Поддержка DMA выключена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Txdmaen :: Disable } # [doc = "Поддержка DMA включена"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Txdmaen :: Enable } } # [doc = "Field `TXDMAEN` writer - Режим поддержки DMA при передаче данных"]
pub type TxdmaenW < 'a , REG > = crate :: BitWriter < 'a , REG , Txdmaen > ; impl < 'a , REG > TxdmaenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Поддержка DMA выключена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Txdmaen :: Disable) } # [doc = "Поддержка DMA включена"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Txdmaen :: Enable) } } # [doc = "Режим поддержки DMA при приеме данных\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Rxdmaen { # [doc = "0: Поддержка DMA выключена"]
Disable = 0 , # [doc = "1: Поддержка DMA включенa"]
Enable = 1 , } impl From < Rxdmaen > for bool { # [inline (always)]
fn from (variant : Rxdmaen) -> Self { variant as u8 != 0 } } # [doc = "Field `RXDMAEN` reader - Режим поддержки DMA при приеме данных"]
pub type RxdmaenR = crate :: BitReader < Rxdmaen > ; impl RxdmaenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Rxdmaen { match self . bits { false => Rxdmaen :: Disable , true => Rxdmaen :: Enable , } } # [doc = "Поддержка DMA выключена"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Rxdmaen :: Disable } # [doc = "Поддержка DMA включенa"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Rxdmaen :: Enable } } # [doc = "Field `RXDMAEN` writer - Режим поддержки DMA при приеме данных"]
pub type RxdmaenW < 'a , REG > = crate :: BitWriter < 'a , REG , Rxdmaen > ; impl < 'a , REG > RxdmaenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Поддержка DMA выключена"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxdmaen :: Disable) } # [doc = "Поддержка DMA включенa"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Rxdmaen :: Enable) } } # [doc = "Режим аппаратного контроля передачи данных в режиме «ведомый»\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Sbc { # [doc = "0: Контроль выключен"]
Disable = 0 , # [doc = "1: Контроль включен"]
Enable = 1 , } impl From < Sbc > for bool { # [inline (always)]
fn from (variant : Sbc) -> Self { variant as u8 != 0 } } # [doc = "Field `SBC` reader - Режим аппаратного контроля передачи данных в режиме «ведомый»"]
pub type SbcR = crate :: BitReader < Sbc > ; impl SbcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Sbc { match self . bits { false => Sbc :: Disable , true => Sbc :: Enable , } } # [doc = "Контроль выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Sbc :: Disable } # [doc = "Контроль включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Sbc :: Enable } } # [doc = "Field `SBC` writer - Режим аппаратного контроля передачи данных в режиме «ведомый»"]
pub type SbcW < 'a , REG > = crate :: BitWriter < 'a , REG , Sbc > ; impl < 'a , REG > SbcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Контроль выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Sbc :: Disable) } # [doc = "Контроль включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Sbc :: Enable) } } # [doc = "Отключение растягивания тактового сигнала в режиме «ведомый». Изменение значения допуска-ется только при выключенном блоке (PE=0). В режиме «ве-дущий» бит должен быть установлен в ‘0’\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nostretch { # [doc = "0: Растягивание активно"]
StretchingEnabled = 0 , # [doc = "1: Растягивание выключено"]
StretchingDisable = 1 , } impl From < Nostretch > for bool { # [inline (always)]
fn from (variant : Nostretch) -> Self { variant as u8 != 0 } } # [doc = "Field `NOSTRETCH` reader - Отключение растягивания тактового сигнала в режиме «ведомый». Изменение значения допуска-ется только при выключенном блоке (PE=0). В режиме «ве-дущий» бит должен быть установлен в ‘0’"]
pub type NostretchR = crate :: BitReader < Nostretch > ; impl NostretchR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nostretch { match self . bits { false => Nostretch :: StretchingEnabled , true => Nostretch :: StretchingDisable , } } # [doc = "Растягивание активно"]
# [inline (always)]
pub fn is_stretching_enabled (& self) -> bool { * self == Nostretch :: StretchingEnabled } # [doc = "Растягивание выключено"]
# [inline (always)]
pub fn is_stretching_disable (& self) -> bool { * self == Nostretch :: StretchingDisable } } # [doc = "Field `NOSTRETCH` writer - Отключение растягивания тактового сигнала в режиме «ведомый». Изменение значения допуска-ется только при выключенном блоке (PE=0). В режиме «ве-дущий» бит должен быть установлен в ‘0’"]
pub type NostretchW < 'a , REG > = crate :: BitWriter < 'a , REG , Nostretch > ; impl < 'a , REG > NostretchW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Растягивание активно"]
# [inline (always)]
pub fn stretching_enabled (self) -> & 'a mut crate :: W < REG > { self . variant (Nostretch :: StretchingEnabled) } # [doc = "Растягивание выключено"]
# [inline (always)]
pub fn stretching_disable (self) -> & 'a mut crate :: W < REG > { self . variant (Nostretch :: StretchingDisable) } } # [doc = "Разрешение адреса общего вызова\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Gcen { # [doc = "0: Адрес 0b00000000 запрещен, формируется NACK"]
Disabled = 0 , # [doc = "1: Адрес 0b00000000 разрешен, формируется ACK"]
Enable = 1 , } impl From < Gcen > for bool { # [inline (always)]
fn from (variant : Gcen) -> Self { variant as u8 != 0 } } # [doc = "Field `GCEN` reader - Разрешение адреса общего вызова"]
pub type GcenR = crate :: BitReader < Gcen > ; impl GcenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Gcen { match self . bits { false => Gcen :: Disabled , true => Gcen :: Enable , } } # [doc = "Адрес 0b00000000 запрещен, формируется NACK"]
# [inline (always)]
pub fn is_disabled (& self) -> bool { * self == Gcen :: Disabled } # [doc = "Адрес 0b00000000 разрешен, формируется ACK"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Gcen :: Enable } } # [doc = "Field `GCEN` writer - Разрешение адреса общего вызова"]
pub type GcenW < 'a , REG > = crate :: BitWriter < 'a , REG , Gcen > ; impl < 'a , REG > GcenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Адрес 0b00000000 запрещен, формируется NACK"]
# [inline (always)]
pub fn disabled (self) -> & 'a mut crate :: W < REG > { self . variant (Gcen :: Disabled) } # [doc = "Адрес 0b00000000 разрешен, формируется ACK"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Gcen :: Enable) } } impl R { # [doc = "Bit 0 - Управление интерфейсом. После очистки, бит должен оставаться в ‘0’ минимум три периода тактового сигнала APB"]
# [inline (always)]
pub fn pe (& self) -> PeR { PeR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Разрешение прерывания при передаче"]
# [inline (always)]
pub fn txie (& self) -> TxieR { TxieR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Разрешение прерывания при приеме"]
# [inline (always)]
pub fn rxie (& self) -> RxieR { RxieR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Разрешение прерывания соот-ветствия адреса в режиме «ведомый»"]
# [inline (always)]
pub fn addrie (& self) -> AddrieR { AddrieR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Разрешение прерывания прием NACK"]
# [inline (always)]
pub fn nackie (& self) -> NackieR { NackieR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Разрешение прерывания обнаружения STOP на линии"]
# [inline (always)]
pub fn stopie (& self) -> StopieR { StopieR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Разрешение прерывания окончания передачи. События, вызывающие прерывание: - окончание передачи (TC); - окончание передачи при RELOAD=1 (TCR)."]
# [inline (always)]
pub fn tcie (& self) -> TcieR { TcieR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Разрешение прерывания при ошибке. События, вызывающие прерывание: - потеря арбитража (ARLO); - ошибка шины (BERR); - переполне-ние/недозагрузка (OVR)."]
# [inline (always)]
pub fn errie (& self) -> ErrieR { ErrieR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bits 8:11 - Управление цифровым фильтром шумов. Изменение значения допускается только при выключенном блоке (PE=0)"]
# [inline (always)]
pub fn dnf (& self) -> DnfR { DnfR :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bit 12 - Управление аналоговым фильтром шумов"]
# [inline (always)]
pub fn anfoff (& self) -> AnfoffR { AnfoffR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 14 - Режим поддержки DMA при передаче данных"]
# [inline (always)]
pub fn txdmaen (& self) -> TxdmaenR { TxdmaenR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Режим поддержки DMA при приеме данных"]
# [inline (always)]
pub fn rxdmaen (& self) -> RxdmaenR { RxdmaenR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Режим аппаратного контроля передачи данных в режиме «ведомый»"]
# [inline (always)]
pub fn sbc (& self) -> SbcR { SbcR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bit 17 - Отключение растягивания тактового сигнала в режиме «ведомый». Изменение значения допуска-ется только при выключенном блоке (PE=0). В режиме «ве-дущий» бит должен быть установлен в ‘0’"]
# [inline (always)]
pub fn nostretch (& self) -> NostretchR { NostretchR :: new (((self . bits >> 17) & 1) != 0) } # [doc = "Bit 19 - Разрешение адреса общего вызова"]
# [inline (always)]
pub fn gcen (& self) -> GcenR { GcenR :: new (((self . bits >> 19) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление интерфейсом. После очистки, бит должен оставаться в ‘0’ минимум три периода тактового сигнала APB"]
# [inline (always)]
pub fn pe (& mut self) -> PeW < Cr1Spec > { PeW :: new (self , 0) } # [doc = "Bit 1 - Разрешение прерывания при передаче"]
# [inline (always)]
pub fn txie (& mut self) -> TxieW < Cr1Spec > { TxieW :: new (self , 1) } # [doc = "Bit 2 - Разрешение прерывания при приеме"]
# [inline (always)]
pub fn rxie (& mut self) -> RxieW < Cr1Spec > { RxieW :: new (self , 2) } # [doc = "Bit 3 - Разрешение прерывания соот-ветствия адреса в режиме «ведомый»"]
# [inline (always)]
pub fn addrie (& mut self) -> AddrieW < Cr1Spec > { AddrieW :: new (self , 3) } # [doc = "Bit 4 - Разрешение прерывания прием NACK"]
# [inline (always)]
pub fn nackie (& mut self) -> NackieW < Cr1Spec > { NackieW :: new (self , 4) } # [doc = "Bit 5 - Разрешение прерывания обнаружения STOP на линии"]
# [inline (always)]
pub fn stopie (& mut self) -> StopieW < Cr1Spec > { StopieW :: new (self , 5) } # [doc = "Bit 6 - Разрешение прерывания окончания передачи. События, вызывающие прерывание: - окончание передачи (TC); - окончание передачи при RELOAD=1 (TCR)."]
# [inline (always)]
pub fn tcie (& mut self) -> TcieW < Cr1Spec > { TcieW :: new (self , 6) } # [doc = "Bit 7 - Разрешение прерывания при ошибке. События, вызывающие прерывание: - потеря арбитража (ARLO); - ошибка шины (BERR); - переполне-ние/недозагрузка (OVR)."]
# [inline (always)]
pub fn errie (& mut self) -> ErrieW < Cr1Spec > { ErrieW :: new (self , 7) } # [doc = "Bits 8:11 - Управление цифровым фильтром шумов. Изменение значения допускается только при выключенном блоке (PE=0)"]
# [inline (always)]
pub fn dnf (& mut self) -> DnfW < Cr1Spec > { DnfW :: new (self , 8) } # [doc = "Bit 12 - Управление аналоговым фильтром шумов"]
# [inline (always)]
pub fn anfoff (& mut self) -> AnfoffW < Cr1Spec > { AnfoffW :: new (self , 12) } # [doc = "Bit 14 - Режим поддержки DMA при передаче данных"]
# [inline (always)]
pub fn txdmaen (& mut self) -> TxdmaenW < Cr1Spec > { TxdmaenW :: new (self , 14) } # [doc = "Bit 15 - Режим поддержки DMA при приеме данных"]
# [inline (always)]
pub fn rxdmaen (& mut self) -> RxdmaenW < Cr1Spec > { RxdmaenW :: new (self , 15) } # [doc = "Bit 16 - Режим аппаратного контроля передачи данных в режиме «ведомый»"]
# [inline (always)]
pub fn sbc (& mut self) -> SbcW < Cr1Spec > { SbcW :: new (self , 16) } # [doc = "Bit 17 - Отключение растягивания тактового сигнала в режиме «ведомый». Изменение значения допуска-ется только при выключенном блоке (PE=0). В режиме «ве-дущий» бит должен быть установлен в ‘0’"]
# [inline (always)]
pub fn nostretch (& mut self) -> NostretchW < Cr1Spec > { NostretchW :: new (self , 17) } # [doc = "Bit 19 - Разрешение адреса общего вызова"]
# [inline (always)]
pub fn gcen (& mut self) -> GcenW < Cr1Spec > { GcenW :: new (self , 19) } } # [doc = "Регистр управления 1\n\nYou can [`read`](crate::Reg::read) this register and get [`cr1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Cr1Spec ; impl crate :: RegisterSpec for Cr1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr1::R`](R) reader structure"]
impl crate :: Readable for Cr1Spec { } # [doc = "`write(|w| ..)` method takes [`cr1::W`](W) writer structure"]
impl crate :: Writable for Cr1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CR1 to value 0"]
impl crate :: Resettable for Cr1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CR2 (rw) register accessor: Регистр управления 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@cr2`]
module"]
# [doc (alias = "CR2")]
pub type Cr2 = crate :: Reg < cr2 :: Cr2Spec > ; # [doc = "Регистр управления 2"]
pub mod cr2 { # [doc = "Register `CR2` reader"]
pub type R = crate :: R < Cr2Spec > ; # [doc = "Register `CR2` writer"]
pub type W = crate :: W < Cr2Spec > ; # [doc = "Field `SADD_10bit` reader - Адрес ведомого (режим «ведущий») в режиме 10-битного адреса (ADD10 = 1). Изменение этих битов при START=1 не допускается."]
pub type Sadd10bitR = crate :: FieldReader < u16 > ; # [doc = "Field `SADD_10bit` writer - Адрес ведомого (режим «ведущий») в режиме 10-битного адреса (ADD10 = 1). Изменение этих битов при START=1 не допускается."]
pub type Sadd10bitW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; # [doc = "Field `SADD_7bit` reader - Адрес ведомого (режим «ведущий») в режиме 7-битного адреса (ADD10 = 0). Изменение этих битов при START=1 не допускается."]
pub type Sadd7bitR = crate :: FieldReader ; # [doc = "Field `SADD_7bit` writer - Адрес ведомого (режим «ведущий») в режиме 7-битного адреса (ADD10 = 0). Изменение этих битов при START=1 не допускается."]
pub type Sadd7bitW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ; # [doc = "Направление передачи (режим «ведущий»). Изменение этого бита при START=1 не допускается.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum RdWrn { # [doc = "0: Ведущий запрашивает транзакцию записи"]
Write = 0 , # [doc = "1: Ведущий запрашивает транзакцию чтения"]
Read = 1 , } impl From < RdWrn > for bool { # [inline (always)]
fn from (variant : RdWrn) -> Self { variant as u8 != 0 } } # [doc = "Field `RD_WRN` reader - Направление передачи (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
pub type RdWrnR = crate :: BitReader < RdWrn > ; impl RdWrnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> RdWrn { match self . bits { false => RdWrn :: Write , true => RdWrn :: Read , } } # [doc = "Ведущий запрашивает транзакцию записи"]
# [inline (always)]
pub fn is_write (& self) -> bool { * self == RdWrn :: Write } # [doc = "Ведущий запрашивает транзакцию чтения"]
# [inline (always)]
pub fn is_read (& self) -> bool { * self == RdWrn :: Read } } # [doc = "Field `RD_WRN` writer - Направление передачи (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
pub type RdWrnW < 'a , REG > = crate :: BitWriter < 'a , REG , RdWrn > ; impl < 'a , REG > RdWrnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Ведущий запрашивает транзакцию записи"]
# [inline (always)]
pub fn write (self) -> & 'a mut crate :: W < REG > { self . variant (RdWrn :: Write) } # [doc = "Ведущий запрашивает транзакцию чтения"]
# [inline (always)]
pub fn read (self) -> & 'a mut crate :: W < REG > { self . variant (RdWrn :: Read) } } # [doc = "Режим 10-битного адреса (режим «ведущий»). Изменение этого бита при START=1 не допускается.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Add10 { # [doc = "0: Ведущий работает в режиме 7-битного адреса"]
_7bit = 0 , # [doc = "1: Ведущий работает в режиме 10-битного адреса"]
_10bit = 1 , } impl From < Add10 > for bool { # [inline (always)]
fn from (variant : Add10) -> Self { variant as u8 != 0 } } # [doc = "Field `ADD10` reader - Режим 10-битного адреса (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
pub type Add10R = crate :: BitReader < Add10 > ; impl Add10R { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Add10 { match self . bits { false => Add10 :: _7bit , true => Add10 :: _10bit , } } # [doc = "Ведущий работает в режиме 7-битного адреса"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == Add10 :: _7bit } # [doc = "Ведущий работает в режиме 10-битного адреса"]
# [inline (always)]
pub fn is_10bit (& self) -> bool { * self == Add10 :: _10bit } } # [doc = "Field `ADD10` writer - Режим 10-битного адреса (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
pub type Add10W < 'a , REG > = crate :: BitWriter < 'a , REG , Add10 > ; impl < 'a , REG > Add10W < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Ведущий работает в режиме 7-битного адреса"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut crate :: W < REG > { self . variant (Add10 :: _7bit) } # [doc = "Ведущий работает в режиме 10-битного адреса"]
# [inline (always)]
pub fn _10bit (self) -> & 'a mut crate :: W < REG > { self . variant (Add10 :: _10bit) } } # [doc = "Поддержка 10-битного адреса в режиме «ведущий», чтение Изменение этого бита при START=1 не допускается\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Head10r { # [doc = "0: Ведущий отправляет полную последовательность для чтения для 10 битного адреса: Start + 2 байта ад-реса (запись) + ReStart + заголовок 10-битного адреса (чтение)"]
Complete = 0 , # [doc = "1: Ведущий отправляет только заголовок 10-битного адреса (чтение)"]
Header = 1 , } impl From < Head10r > for bool { # [inline (always)]
fn from (variant : Head10r) -> Self { variant as u8 != 0 } } # [doc = "Field `HEAD10R` reader - Поддержка 10-битного адреса в режиме «ведущий», чтение Изменение этого бита при START=1 не допускается"]
pub type Head10rR = crate :: BitReader < Head10r > ; impl Head10rR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Head10r { match self . bits { false => Head10r :: Complete , true => Head10r :: Header , } } # [doc = "Ведущий отправляет полную последовательность для чтения для 10 битного адреса: Start + 2 байта ад-реса (запись) + ReStart + заголовок 10-битного адреса (чтение)"]
# [inline (always)]
pub fn is_complete (& self) -> bool { * self == Head10r :: Complete } # [doc = "Ведущий отправляет только заголовок 10-битного адреса (чтение)"]
# [inline (always)]
pub fn is_header (& self) -> bool { * self == Head10r :: Header } } # [doc = "Field `HEAD10R` writer - Поддержка 10-битного адреса в режиме «ведущий», чтение Изменение этого бита при START=1 не допускается"]
pub type Head10rW < 'a , REG > = crate :: BitWriter < 'a , REG , Head10r > ; impl < 'a , REG > Head10rW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Ведущий отправляет полную последовательность для чтения для 10 битного адреса: Start + 2 байта ад-реса (запись) + ReStart + заголовок 10-битного адреса (чтение)"]
# [inline (always)]
pub fn complete (self) -> & 'a mut crate :: W < REG > { self . variant (Head10r :: Complete) } # [doc = "Ведущий отправляет только заголовок 10-битного адреса (чтение)"]
# [inline (always)]
pub fn header (self) -> & 'a mut crate :: W < REG > { self . variant (Head10r :: Header) } } # [doc = "Формирование START. Устанавливается программно, сбрасывается аппаратно после отправки адреса, потере арбитража или PE=0. Запись ‘0’ в этот бит не имеет эффекта. В режиме «ведущий» отправка первой части 10-битного адреса повторяется при получении NACK до получения ACK или до очистки бита START записью в бит ADDRCF\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Start { # [doc = "0: START не формируется"]
_0 = 0 , # [doc = "1: формирование START после передачи текущего байта"]
Start = 1 , } impl From < Start > for bool { # [inline (always)]
fn from (variant : Start) -> Self { variant as u8 != 0 } } # [doc = "Field `START` reader - Формирование START. Устанавливается программно, сбрасывается аппаратно после отправки адреса, потере арбитража или PE=0. Запись ‘0’ в этот бит не имеет эффекта. В режиме «ведущий» отправка первой части 10-битного адреса повторяется при получении NACK до получения ACK или до очистки бита START записью в бит ADDRCF"]
pub type StartR = crate :: BitReader < Start > ; impl StartR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Start { match self . bits { false => Start :: _0 , true => Start :: Start , } } # [doc = "START не формируется"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Start :: _0 } # [doc = "формирование START после передачи текущего байта"]
# [inline (always)]
pub fn is_start (& self) -> bool { * self == Start :: Start } } # [doc = "Field `START` writer - Формирование START. Устанавливается программно, сбрасывается аппаратно после отправки адреса, потере арбитража или PE=0. Запись ‘0’ в этот бит не имеет эффекта. В режиме «ведущий» отправка первой части 10-битного адреса повторяется при получении NACK до получения ACK или до очистки бита START записью в бит ADDRCF"]
pub type StartW < 'a , REG > = crate :: BitWriter < 'a , REG , Start > ; impl < 'a , REG > StartW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "START не формируется"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Start :: _0) } # [doc = "формирование START после передачи текущего байта"]
# [inline (always)]
pub fn start (self) -> & 'a mut crate :: W < REG > { self . variant (Start :: Start) } } # [doc = "Формирование STOP в режиме «ведущий». Устанавливается программно, сбрасывается аппаратно по событию STOP на шине или при PE=0. Запись ‘0’ в этот бит не имеет эффекта.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Stop { # [doc = "0: STOP не формируется"]
_0 = 0 , # [doc = "1: Формирование STOP после передачи текущего байта"]
Stop = 1 , } impl From < Stop > for bool { # [inline (always)]
fn from (variant : Stop) -> Self { variant as u8 != 0 } } # [doc = "Field `STOP` reader - Формирование STOP в режиме «ведущий». Устанавливается программно, сбрасывается аппаратно по событию STOP на шине или при PE=0. Запись ‘0’ в этот бит не имеет эффекта."]
pub type StopR = crate :: BitReader < Stop > ; impl StopR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Stop { match self . bits { false => Stop :: _0 , true => Stop :: Stop , } } # [doc = "STOP не формируется"]
# [inline (always)]
pub fn is_0 (& self) -> bool { * self == Stop :: _0 } # [doc = "Формирование STOP после передачи текущего байта"]
# [inline (always)]
pub fn is_stop (& self) -> bool { * self == Stop :: Stop } } # [doc = "Field `STOP` writer - Формирование STOP в режиме «ведущий». Устанавливается программно, сбрасывается аппаратно по событию STOP на шине или при PE=0. Запись ‘0’ в этот бит не имеет эффекта."]
pub type StopW < 'a , REG > = crate :: BitWriter < 'a , REG , Stop > ; impl < 'a , REG > StopW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "STOP не формируется"]
# [inline (always)]
pub fn _0 (self) -> & 'a mut crate :: W < REG > { self . variant (Stop :: _0) } # [doc = "Формирование STOP после передачи текущего байта"]
# [inline (always)]
pub fn stop (self) -> & 'a mut crate :: W < REG > { self . variant (Stop :: Stop) } } # [doc = "Формирование NACK в режиме «ведомый». Устанавливается программно, сбрасывается аппаратно: • после отправки NACK; • по событию STOP на шине; • при получении свое-го адреса ведомого; • PE=0.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nack { # [doc = "0: Отправка ACK после приёма текущего байта"]
Ask = 0 , # [doc = "1: Отправка NACK после приёма текущего байта"]
Nack = 1 , } impl From < Nack > for bool { # [inline (always)]
fn from (variant : Nack) -> Self { variant as u8 != 0 } } # [doc = "Field `NACK` reader - Формирование NACK в режиме «ведомый». Устанавливается программно, сбрасывается аппаратно: • после отправки NACK; • по событию STOP на шине; • при получении свое-го адреса ведомого; • PE=0."]
pub type NackR = crate :: BitReader < Nack > ; impl NackR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nack { match self . bits { false => Nack :: Ask , true => Nack :: Nack , } } # [doc = "Отправка ACK после приёма текущего байта"]
# [inline (always)]
pub fn is_ask (& self) -> bool { * self == Nack :: Ask } # [doc = "Отправка NACK после приёма текущего байта"]
# [inline (always)]
pub fn is_nack (& self) -> bool { * self == Nack :: Nack } } # [doc = "Field `NACK` writer - Формирование NACK в режиме «ведомый». Устанавливается программно, сбрасывается аппаратно: • после отправки NACK; • по событию STOP на шине; • при получении свое-го адреса ведомого; • PE=0."]
pub type NackW < 'a , REG > = crate :: BitWriter < 'a , REG , Nack > ; impl < 'a , REG > NackW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Отправка ACK после приёма текущего байта"]
# [inline (always)]
pub fn ask (self) -> & 'a mut crate :: W < REG > { self . variant (Nack :: Ask) } # [doc = "Отправка NACK после приёма текущего байта"]
# [inline (always)]
pub fn nack (self) -> & 'a mut crate :: W < REG > { self . variant (Nack :: Nack) } } # [doc = "Field `NBYTES` reader - Количество байт для приема / передачи Не имеет значения в режиме «ведомый» при SBC=0 Не допускается изменение при установленном бите START"]
pub type NbytesR = crate :: FieldReader ; # [doc = "Field `NBYTES` writer - Количество байт для приема / передачи Не имеет значения в режиме «ведомый» при SBC=0 Не допускается изменение при установленном бите START"]
pub type NbytesW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Управление режимом перезаписи NBYTES. Бит устанавливается и очищается программой.\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Reload { # [doc = "0: Транзакция завершена после пересылки NBYTES байт данных (на шине ожидаются STOP или RESTART)"]
Disable = 0 , # [doc = "1: Транзакция не завершена после пересылки NBYTES байт данных (значение NBYTES будет перезаписано)"]
Enable = 1 , } impl From < Reload > for bool { # [inline (always)]
fn from (variant : Reload) -> Self { variant as u8 != 0 } } # [doc = "Field `RELOAD` reader - Управление режимом перезаписи NBYTES. Бит устанавливается и очищается программой."]
pub type ReloadR = crate :: BitReader < Reload > ; impl ReloadR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Reload { match self . bits { false => Reload :: Disable , true => Reload :: Enable , } } # [doc = "Транзакция завершена после пересылки NBYTES байт данных (на шине ожидаются STOP или RESTART)"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Reload :: Disable } # [doc = "Транзакция не завершена после пересылки NBYTES байт данных (значение NBYTES будет перезаписано)"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Reload :: Enable } } # [doc = "Field `RELOAD` writer - Управление режимом перезаписи NBYTES. Бит устанавливается и очищается программой."]
pub type ReloadW < 'a , REG > = crate :: BitWriter < 'a , REG , Reload > ; impl < 'a , REG > ReloadW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Транзакция завершена после пересылки NBYTES байт данных (на шине ожидаются STOP или RESTART)"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Reload :: Disable) } # [doc = "Транзакция не завершена после пересылки NBYTES байт данных (значение NBYTES будет перезаписано)"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Reload :: Enable) } } # [doc = "Управление режимом автоматического окончания в режиме «ведущий». Бит устанавливается и очищается программой. Не имеет значения при установленном бите RE-LOAD и в режиме «ведомый»\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Autoend { # [doc = "0: Режим автоматического окончания отключен"]
Disable = 0 , # [doc = "1: Режим автоматического окончания включен"]
Enable = 1 , } impl From < Autoend > for bool { # [inline (always)]
fn from (variant : Autoend) -> Self { variant as u8 != 0 } } # [doc = "Field `AUTOEND` reader - Управление режимом автоматического окончания в режиме «ведущий». Бит устанавливается и очищается программой. Не имеет значения при установленном бите RE-LOAD и в режиме «ведомый»"]
pub type AutoendR = crate :: BitReader < Autoend > ; impl AutoendR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Autoend { match self . bits { false => Autoend :: Disable , true => Autoend :: Enable , } } # [doc = "Режим автоматического окончания отключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Autoend :: Disable } # [doc = "Режим автоматического окончания включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Autoend :: Enable } } # [doc = "Field `AUTOEND` writer - Управление режимом автоматического окончания в режиме «ведущий». Бит устанавливается и очищается программой. Не имеет значения при установленном бите RE-LOAD и в режиме «ведомый»"]
pub type AutoendW < 'a , REG > = crate :: BitWriter < 'a , REG , Autoend > ; impl < 'a , REG > AutoendW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Режим автоматического окончания отключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Autoend :: Disable) } # [doc = "Режим автоматического окончания включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Autoend :: Enable) } } impl R { # [doc = "Bits 0:9 - Адрес ведомого (режим «ведущий») в режиме 10-битного адреса (ADD10 = 1). Изменение этих битов при START=1 не допускается."]
# [inline (always)]
pub fn sadd_10bit (& self) -> Sadd10bitR { Sadd10bitR :: new ((self . bits & 0x03ff) as u16) } # [doc = "Bits 1:7 - Адрес ведомого (режим «ведущий») в режиме 7-битного адреса (ADD10 = 0). Изменение этих битов при START=1 не допускается."]
# [inline (always)]
pub fn sadd_7bit (& self) -> Sadd7bitR { Sadd7bitR :: new (((self . bits >> 1) & 0x7f) as u8) } # [doc = "Bit 10 - Направление передачи (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
# [inline (always)]
pub fn rd_wrn (& self) -> RdWrnR { RdWrnR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Режим 10-битного адреса (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
# [inline (always)]
pub fn add10 (& self) -> Add10R { Add10R :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 12 - Поддержка 10-битного адреса в режиме «ведущий», чтение Изменение этого бита при START=1 не допускается"]
# [inline (always)]
pub fn head10r (& self) -> Head10rR { Head10rR :: new (((self . bits >> 12) & 1) != 0) } # [doc = "Bit 13 - Формирование START. Устанавливается программно, сбрасывается аппаратно после отправки адреса, потере арбитража или PE=0. Запись ‘0’ в этот бит не имеет эффекта. В режиме «ведущий» отправка первой части 10-битного адреса повторяется при получении NACK до получения ACK или до очистки бита START записью в бит ADDRCF"]
# [inline (always)]
pub fn start (& self) -> StartR { StartR :: new (((self . bits >> 13) & 1) != 0) } # [doc = "Bit 14 - Формирование STOP в режиме «ведущий». Устанавливается программно, сбрасывается аппаратно по событию STOP на шине или при PE=0. Запись ‘0’ в этот бит не имеет эффекта."]
# [inline (always)]
pub fn stop (& self) -> StopR { StopR :: new (((self . bits >> 14) & 1) != 0) } # [doc = "Bit 15 - Формирование NACK в режиме «ведомый». Устанавливается программно, сбрасывается аппаратно: • после отправки NACK; • по событию STOP на шине; • при получении свое-го адреса ведомого; • PE=0."]
# [inline (always)]
pub fn nack (& self) -> NackR { NackR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bits 16:23 - Количество байт для приема / передачи Не имеет значения в режиме «ведомый» при SBC=0 Не допускается изменение при установленном бите START"]
# [inline (always)]
pub fn nbytes (& self) -> NbytesR { NbytesR :: new (((self . bits >> 16) & 0xff) as u8) } # [doc = "Bit 24 - Управление режимом перезаписи NBYTES. Бит устанавливается и очищается программой."]
# [inline (always)]
pub fn reload (& self) -> ReloadR { ReloadR :: new (((self . bits >> 24) & 1) != 0) } # [doc = "Bit 25 - Управление режимом автоматического окончания в режиме «ведущий». Бит устанавливается и очищается программой. Не имеет значения при установленном бите RE-LOAD и в режиме «ведомый»"]
# [inline (always)]
pub fn autoend (& self) -> AutoendR { AutoendR :: new (((self . bits >> 25) & 1) != 0) } } impl W { # [doc = "Bits 0:9 - Адрес ведомого (режим «ведущий») в режиме 10-битного адреса (ADD10 = 1). Изменение этих битов при START=1 не допускается."]
# [inline (always)]
pub fn sadd_10bit (& mut self) -> Sadd10bitW < Cr2Spec > { Sadd10bitW :: new (self , 0) } # [doc = "Bits 1:7 - Адрес ведомого (режим «ведущий») в режиме 7-битного адреса (ADD10 = 0). Изменение этих битов при START=1 не допускается."]
# [inline (always)]
pub fn sadd_7bit (& mut self) -> Sadd7bitW < Cr2Spec > { Sadd7bitW :: new (self , 1) } # [doc = "Bit 10 - Направление передачи (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
# [inline (always)]
pub fn rd_wrn (& mut self) -> RdWrnW < Cr2Spec > { RdWrnW :: new (self , 10) } # [doc = "Bit 11 - Режим 10-битного адреса (режим «ведущий»). Изменение этого бита при START=1 не допускается."]
# [inline (always)]
pub fn add10 (& mut self) -> Add10W < Cr2Spec > { Add10W :: new (self , 11) } # [doc = "Bit 12 - Поддержка 10-битного адреса в режиме «ведущий», чтение Изменение этого бита при START=1 не допускается"]
# [inline (always)]
pub fn head10r (& mut self) -> Head10rW < Cr2Spec > { Head10rW :: new (self , 12) } # [doc = "Bit 13 - Формирование START. Устанавливается программно, сбрасывается аппаратно после отправки адреса, потере арбитража или PE=0. Запись ‘0’ в этот бит не имеет эффекта. В режиме «ведущий» отправка первой части 10-битного адреса повторяется при получении NACK до получения ACK или до очистки бита START записью в бит ADDRCF"]
# [inline (always)]
pub fn start (& mut self) -> StartW < Cr2Spec > { StartW :: new (self , 13) } # [doc = "Bit 14 - Формирование STOP в режиме «ведущий». Устанавливается программно, сбрасывается аппаратно по событию STOP на шине или при PE=0. Запись ‘0’ в этот бит не имеет эффекта."]
# [inline (always)]
pub fn stop (& mut self) -> StopW < Cr2Spec > { StopW :: new (self , 14) } # [doc = "Bit 15 - Формирование NACK в режиме «ведомый». Устанавливается программно, сбрасывается аппаратно: • после отправки NACK; • по событию STOP на шине; • при получении свое-го адреса ведомого; • PE=0."]
# [inline (always)]
pub fn nack (& mut self) -> NackW < Cr2Spec > { NackW :: new (self , 15) } # [doc = "Bits 16:23 - Количество байт для приема / передачи Не имеет значения в режиме «ведомый» при SBC=0 Не допускается изменение при установленном бите START"]
# [inline (always)]
pub fn nbytes (& mut self) -> NbytesW < Cr2Spec > { NbytesW :: new (self , 16) } # [doc = "Bit 24 - Управление режимом перезаписи NBYTES. Бит устанавливается и очищается программой."]
# [inline (always)]
pub fn reload (& mut self) -> ReloadW < Cr2Spec > { ReloadW :: new (self , 24) } # [doc = "Bit 25 - Управление режимом автоматического окончания в режиме «ведущий». Бит устанавливается и очищается программой. Не имеет значения при установленном бите RE-LOAD и в режиме «ведомый»"]
# [inline (always)]
pub fn autoend (& mut self) -> AutoendW < Cr2Spec > { AutoendW :: new (self , 25) } } # [doc = "Регистр управления 2\n\nYou can [`read`](crate::Reg::read) this register and get [`cr2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`cr2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Cr2Spec ; impl crate :: RegisterSpec for Cr2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`cr2::R`](R) reader structure"]
impl crate :: Readable for Cr2Spec { } # [doc = "`write(|w| ..)` method takes [`cr2::W`](W) writer structure"]
impl crate :: Writable for Cr2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CR2 to value 0"]
impl crate :: Resettable for Cr2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "OAR1 (rw) register accessor: Регистр адреса 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oar1::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar1::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oar1`]
module"]
# [doc (alias = "OAR1")]
pub type Oar1 = crate :: Reg < oar1 :: Oar1Spec > ; # [doc = "Регистр адреса 1"]
pub mod oar1 { # [doc = "Register `OAR1` reader"]
pub type R = crate :: R < Oar1Spec > ; # [doc = "Register `OAR1` writer"]
pub type W = crate :: W < Oar1Spec > ; # [doc = "Field `OA1_10bit` reader - Собственный адрес 1 (10-битный режим). Изменение бита допускается при OA1EN=0."]
pub type Oa1_10bitR = crate :: FieldReader < u16 > ; # [doc = "Field `OA1_10bit` writer - Собственный адрес 1 (10-битный режим). Изменение бита допускается при OA1EN=0."]
pub type Oa1_10bitW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; # [doc = "Field `OA1_7bit` reader - Собственный адрес 1 (7-битный режим). Изменение бита допускается при OA1EN=0."]
pub type Oa1_7bitR = crate :: FieldReader ; # [doc = "Field `OA1_7bit` writer - Собственный адрес 1 (7-битный режим). Изменение бита допускается при OA1EN=0."]
pub type Oa1_7bitW < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ; # [doc = "Режим 10-битного адреса OA1. Изменение бита допускается при OA1EN=0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Oa1mode { # [doc = "0: OA1 – 7-битный адрес"]
_7bit = 0 , # [doc = "1: OA1 – 10-битный адрес"]
_10bit = 1 , } impl From < Oa1mode > for bool { # [inline (always)]
fn from (variant : Oa1mode) -> Self { variant as u8 != 0 } } # [doc = "Field `OA1MODE` reader - Режим 10-битного адреса OA1. Изменение бита допускается при OA1EN=0"]
pub type Oa1modeR = crate :: BitReader < Oa1mode > ; impl Oa1modeR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Oa1mode { match self . bits { false => Oa1mode :: _7bit , true => Oa1mode :: _10bit , } } # [doc = "OA1 – 7-битный адрес"]
# [inline (always)]
pub fn is_7bit (& self) -> bool { * self == Oa1mode :: _7bit } # [doc = "OA1 – 10-битный адрес"]
# [inline (always)]
pub fn is_10bit (& self) -> bool { * self == Oa1mode :: _10bit } } # [doc = "Field `OA1MODE` writer - Режим 10-битного адреса OA1. Изменение бита допускается при OA1EN=0"]
pub type Oa1modeW < 'a , REG > = crate :: BitWriter < 'a , REG , Oa1mode > ; impl < 'a , REG > Oa1modeW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "OA1 – 7-битный адрес"]
# [inline (always)]
pub fn _7bit (self) -> & 'a mut crate :: W < REG > { self . variant (Oa1mode :: _7bit) } # [doc = "OA1 – 10-битный адрес"]
# [inline (always)]
pub fn _10bit (self) -> & 'a mut crate :: W < REG > { self . variant (Oa1mode :: _10bit) } } # [doc = "Использование собственно-го адреса OA1\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Oa1en { # [doc = "0: При получении адреса OA1 формируется NACK"]
Nack = 0 , # [doc = "1: При получении адреса OA1 формируется ACK"]
Ack = 1 , } impl From < Oa1en > for bool { # [inline (always)]
fn from (variant : Oa1en) -> Self { variant as u8 != 0 } } # [doc = "Field `OA1EN` reader - Использование собственно-го адреса OA1"]
pub type Oa1enR = crate :: BitReader < Oa1en > ; impl Oa1enR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Oa1en { match self . bits { false => Oa1en :: Nack , true => Oa1en :: Ack , } } # [doc = "При получении адреса OA1 формируется NACK"]
# [inline (always)]
pub fn is_nack (& self) -> bool { * self == Oa1en :: Nack } # [doc = "При получении адреса OA1 формируется ACK"]
# [inline (always)]
pub fn is_ack (& self) -> bool { * self == Oa1en :: Ack } } # [doc = "Field `OA1EN` writer - Использование собственно-го адреса OA1"]
pub type Oa1enW < 'a , REG > = crate :: BitWriter < 'a , REG , Oa1en > ; impl < 'a , REG > Oa1enW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "При получении адреса OA1 формируется NACK"]
# [inline (always)]
pub fn nack (self) -> & 'a mut crate :: W < REG > { self . variant (Oa1en :: Nack) } # [doc = "При получении адреса OA1 формируется ACK"]
# [inline (always)]
pub fn ack (self) -> & 'a mut crate :: W < REG > { self . variant (Oa1en :: Ack) } } impl R { # [doc = "Bits 0:9 - Собственный адрес 1 (10-битный режим). Изменение бита допускается при OA1EN=0."]
# [inline (always)]
pub fn oa1_10bit (& self) -> Oa1_10bitR { Oa1_10bitR :: new ((self . bits & 0x03ff) as u16) } # [doc = "Bits 1:7 - Собственный адрес 1 (7-битный режим). Изменение бита допускается при OA1EN=0."]
# [inline (always)]
pub fn oa1_7bit (& self) -> Oa1_7bitR { Oa1_7bitR :: new (((self . bits >> 1) & 0x7f) as u8) } # [doc = "Bit 10 - Режим 10-битного адреса OA1. Изменение бита допускается при OA1EN=0"]
# [inline (always)]
pub fn oa1mode (& self) -> Oa1modeR { Oa1modeR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 15 - Использование собственно-го адреса OA1"]
# [inline (always)]
pub fn oa1en (& self) -> Oa1enR { Oa1enR :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bits 0:9 - Собственный адрес 1 (10-битный режим). Изменение бита допускается при OA1EN=0."]
# [inline (always)]
pub fn oa1_10bit (& mut self) -> Oa1_10bitW < Oar1Spec > { Oa1_10bitW :: new (self , 0) } # [doc = "Bits 1:7 - Собственный адрес 1 (7-битный режим). Изменение бита допускается при OA1EN=0."]
# [inline (always)]
pub fn oa1_7bit (& mut self) -> Oa1_7bitW < Oar1Spec > { Oa1_7bitW :: new (self , 1) } # [doc = "Bit 10 - Режим 10-битного адреса OA1. Изменение бита допускается при OA1EN=0"]
# [inline (always)]
pub fn oa1mode (& mut self) -> Oa1modeW < Oar1Spec > { Oa1modeW :: new (self , 10) } # [doc = "Bit 15 - Использование собственно-го адреса OA1"]
# [inline (always)]
pub fn oa1en (& mut self) -> Oa1enW < Oar1Spec > { Oa1enW :: new (self , 15) } } # [doc = "Регистр адреса 1\n\nYou can [`read`](crate::Reg::read) this register and get [`oar1::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar1::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Oar1Spec ; impl crate :: RegisterSpec for Oar1Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`oar1::R`](R) reader structure"]
impl crate :: Readable for Oar1Spec { } # [doc = "`write(|w| ..)` method takes [`oar1::W`](W) writer structure"]
impl crate :: Writable for Oar1Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OAR1 to value 0"]
impl crate :: Resettable for Oar1Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "OAR2 (rw) register accessor: Регистр адреса 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oar2::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar2::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@oar2`]
module"]
# [doc (alias = "OAR2")]
pub type Oar2 = crate :: Reg < oar2 :: Oar2Spec > ; # [doc = "Регистр адреса 2"]
pub mod oar2 { # [doc = "Register `OAR2` reader"]
pub type R = crate :: R < Oar2Spec > ; # [doc = "Register `OAR2` writer"]
pub type W = crate :: W < Oar2Spec > ; # [doc = "Field `OA2` reader - Собственный 7-битный адрес 2 Изменение битов допускается при OA2EN=0"]
pub type Oa2R = crate :: FieldReader ; # [doc = "Field `OA2` writer - Собственный 7-битный адрес 2 Изменение битов допускается при OA2EN=0"]
pub type Oa2W < 'a , REG > = crate :: FieldWriter < 'a , REG , 7 > ; # [doc = "Маска адреса OA2. Если OA2MSK ≠ 0, зарезервированные адреса I2C (0b0000xxx, 0b1111xxx) не подтверждаются, даже если адреса совпадают. Изменение битов допускается при OA2EN=0\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum Oa2msk { # [doc = "0: Нет маски"]
NoMask = 0 , # [doc = "1: Сравниваются только OA2\\[7:2\\]"]
_1_1Masked = 1 , # [doc = "2: Сравниваются только OA2\\[7:3\\]"]
_2_1Masked = 2 , # [doc = "3: Сравниваются только OA2\\[7:4\\]"]
_3_1Masked = 3 , # [doc = "4: Сравниваются только OA2\\[7:5\\]"]
_4_1Masked = 4 , # [doc = "5: Сравниваются только OA2\\[7:6\\]"]
_5_1Masked = 5 , # [doc = "6: Сравниваются только OA2\\[7\\]"]
_6_1Masked = 6 , # [doc = "7: OA2\\[7:1\\]
маскируются, подтверждаются (ACK) все 7-битные ад-реса (кроме зарезервированных)"]
_7_1Masked = 7 , } impl From < Oa2msk > for u8 { # [inline (always)]
fn from (variant : Oa2msk) -> Self { variant as _ } } impl crate :: FieldSpec for Oa2msk { type Ux = u8 ; } impl crate :: IsEnum for Oa2msk { } # [doc = "Field `OA2MSK` reader - Маска адреса OA2. Если OA2MSK ≠ 0, зарезервированные адреса I2C (0b0000xxx, 0b1111xxx) не подтверждаются, даже если адреса совпадают. Изменение битов допускается при OA2EN=0"]
pub type Oa2mskR = crate :: FieldReader < Oa2msk > ; impl Oa2mskR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Oa2msk { match self . bits { 0 => Oa2msk :: NoMask , 1 => Oa2msk :: _1_1Masked , 2 => Oa2msk :: _2_1Masked , 3 => Oa2msk :: _3_1Masked , 4 => Oa2msk :: _4_1Masked , 5 => Oa2msk :: _5_1Masked , 6 => Oa2msk :: _6_1Masked , 7 => Oa2msk :: _7_1Masked , _ => unreachable ! () , } } # [doc = "Нет маски"]
# [inline (always)]
pub fn is_no_mask (& self) -> bool { * self == Oa2msk :: NoMask } # [doc = "Сравниваются только OA2\\[7:2\\]"]
# [inline (always)]
pub fn is_1_1_masked (& self) -> bool { * self == Oa2msk :: _1_1Masked } # [doc = "Сравниваются только OA2\\[7:3\\]"]
# [inline (always)]
pub fn is_2_1_masked (& self) -> bool { * self == Oa2msk :: _2_1Masked } # [doc = "Сравниваются только OA2\\[7:4\\]"]
# [inline (always)]
pub fn is_3_1_masked (& self) -> bool { * self == Oa2msk :: _3_1Masked } # [doc = "Сравниваются только OA2\\[7:5\\]"]
# [inline (always)]
pub fn is_4_1_masked (& self) -> bool { * self == Oa2msk :: _4_1Masked } # [doc = "Сравниваются только OA2\\[7:6\\]"]
# [inline (always)]
pub fn is_5_1_masked (& self) -> bool { * self == Oa2msk :: _5_1Masked } # [doc = "Сравниваются только OA2\\[7\\]"]
# [inline (always)]
pub fn is_6_1_masked (& self) -> bool { * self == Oa2msk :: _6_1Masked } # [doc = "OA2\\[7:1\\]
маскируются, подтверждаются (ACK) все 7-битные ад-реса (кроме зарезервированных)"]
# [inline (always)]
pub fn is_7_1_masked (& self) -> bool { * self == Oa2msk :: _7_1Masked } } # [doc = "Field `OA2MSK` writer - Маска адреса OA2. Если OA2MSK ≠ 0, зарезервированные адреса I2C (0b0000xxx, 0b1111xxx) не подтверждаются, даже если адреса совпадают. Изменение битов допускается при OA2EN=0"]
pub type Oa2mskW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , Oa2msk , crate :: Safe > ; impl < 'a , REG > Oa2mskW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "Нет маски"]
# [inline (always)]
pub fn no_mask (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: NoMask) } # [doc = "Сравниваются только OA2\\[7:2\\]"]
# [inline (always)]
pub fn _1_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _1_1Masked) } # [doc = "Сравниваются только OA2\\[7:3\\]"]
# [inline (always)]
pub fn _2_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _2_1Masked) } # [doc = "Сравниваются только OA2\\[7:4\\]"]
# [inline (always)]
pub fn _3_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _3_1Masked) } # [doc = "Сравниваются только OA2\\[7:5\\]"]
# [inline (always)]
pub fn _4_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _4_1Masked) } # [doc = "Сравниваются только OA2\\[7:6\\]"]
# [inline (always)]
pub fn _5_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _5_1Masked) } # [doc = "Сравниваются только OA2\\[7\\]"]
# [inline (always)]
pub fn _6_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _6_1Masked) } # [doc = "OA2\\[7:1\\]
маскируются, подтверждаются (ACK) все 7-битные ад-реса (кроме зарезервированных)"]
# [inline (always)]
pub fn _7_1_masked (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2msk :: _7_1Masked) } } # [doc = "Использование собственно-го адреса OA2\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Oa2en { # [doc = "0: При получении адреса OA2 формируется NACK"]
Nack = 0 , # [doc = "1: При получении адреса OA2 формируется ACK"]
Ack = 1 , } impl From < Oa2en > for bool { # [inline (always)]
fn from (variant : Oa2en) -> Self { variant as u8 != 0 } } # [doc = "Field `OA2EN` reader - Использование собственно-го адреса OA2"]
pub type Oa2enR = crate :: BitReader < Oa2en > ; impl Oa2enR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Oa2en { match self . bits { false => Oa2en :: Nack , true => Oa2en :: Ack , } } # [doc = "При получении адреса OA2 формируется NACK"]
# [inline (always)]
pub fn is_nack (& self) -> bool { * self == Oa2en :: Nack } # [doc = "При получении адреса OA2 формируется ACK"]
# [inline (always)]
pub fn is_ack (& self) -> bool { * self == Oa2en :: Ack } } # [doc = "Field `OA2EN` writer - Использование собственно-го адреса OA2"]
pub type Oa2enW < 'a , REG > = crate :: BitWriter < 'a , REG , Oa2en > ; impl < 'a , REG > Oa2enW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "При получении адреса OA2 формируется NACK"]
# [inline (always)]
pub fn nack (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2en :: Nack) } # [doc = "При получении адреса OA2 формируется ACK"]
# [inline (always)]
pub fn ack (self) -> & 'a mut crate :: W < REG > { self . variant (Oa2en :: Ack) } } impl R { # [doc = "Bits 1:7 - Собственный 7-битный адрес 2 Изменение битов допускается при OA2EN=0"]
# [inline (always)]
pub fn oa2 (& self) -> Oa2R { Oa2R :: new (((self . bits >> 1) & 0x7f) as u8) } # [doc = "Bits 8:10 - Маска адреса OA2. Если OA2MSK ≠ 0, зарезервированные адреса I2C (0b0000xxx, 0b1111xxx) не подтверждаются, даже если адреса совпадают. Изменение битов допускается при OA2EN=0"]
# [inline (always)]
pub fn oa2msk (& self) -> Oa2mskR { Oa2mskR :: new (((self . bits >> 8) & 7) as u8) } # [doc = "Bit 15 - Использование собственно-го адреса OA2"]
# [inline (always)]
pub fn oa2en (& self) -> Oa2enR { Oa2enR :: new (((self . bits >> 15) & 1) != 0) } } impl W { # [doc = "Bits 1:7 - Собственный 7-битный адрес 2 Изменение битов допускается при OA2EN=0"]
# [inline (always)]
pub fn oa2 (& mut self) -> Oa2W < Oar2Spec > { Oa2W :: new (self , 1) } # [doc = "Bits 8:10 - Маска адреса OA2. Если OA2MSK ≠ 0, зарезервированные адреса I2C (0b0000xxx, 0b1111xxx) не подтверждаются, даже если адреса совпадают. Изменение битов допускается при OA2EN=0"]
# [inline (always)]
pub fn oa2msk (& mut self) -> Oa2mskW < Oar2Spec > { Oa2mskW :: new (self , 8) } # [doc = "Bit 15 - Использование собственно-го адреса OA2"]
# [inline (always)]
pub fn oa2en (& mut self) -> Oa2enW < Oar2Spec > { Oa2enW :: new (self , 15) } } # [doc = "Регистр адреса 2\n\nYou can [`read`](crate::Reg::read) this register and get [`oar2::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`oar2::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Oar2Spec ; impl crate :: RegisterSpec for Oar2Spec { type Ux = u32 ; } # [doc = "`read()` method returns [`oar2::R`](R) reader structure"]
impl crate :: Readable for Oar2Spec { } # [doc = "`write(|w| ..)` method takes [`oar2::W`](W) writer structure"]
impl crate :: Writable for Oar2Spec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OAR2 to value 0"]
impl crate :: Resettable for Oar2Spec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TIMINGR (rw) register accessor: Регистр настройки временных ограничений. Регистр должен конфигурироваться, пока интерфейс заблокирован (PE=0).\n\nYou can [`read`](crate::Reg::read) this register and get [`timingr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timingr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@timingr`]
module"]
# [doc (alias = "TIMINGR")]
pub type Timingr = crate :: Reg < timingr :: TimingrSpec > ; # [doc = "Регистр настройки временных ограничений. Регистр должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub mod timingr { # [doc = "Register `TIMINGR` reader"]
pub type R = crate :: R < TimingrSpec > ; # [doc = "Register `TIMINGR` writer"]
pub type W = crate :: W < TimingrSpec > ; # [doc = "Field `SCLL` reader - Длительность удержания SCL в состоянии логиче-ского «0» в режиме «ведущий» t_SCLL = (SCLL+1) x t_PRESC Также используется для генерации задержек t_BUF и t_SU:STA. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type ScllR = crate :: FieldReader ; # [doc = "Field `SCLL` writer - Длительность удержания SCL в состоянии логиче-ского «0» в режиме «ведущий» t_SCLL = (SCLL+1) x t_PRESC Также используется для генерации задержек t_BUF и t_SU:STA. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type ScllW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `SCLH` reader - Длительность удержания SCL в состоянии логической «1» в режиме «ведущий» t_SCLH = (SCLH+1) x t_PRESC Также используется для генерации задержек t_HD:STA и t_SU:STO. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type SclhR = crate :: FieldReader ; # [doc = "Field `SCLH` writer - Длительность удержания SCL в состоянии логической «1» в режиме «ведущий» t_SCLH = (SCLH+1) x t_PRESC Также используется для генерации задержек t_HD:STA и t_SU:STO. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type SclhW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Field `SDADEL` reader - Длительность предустановки данных t_HD:DAT. Задержка между спадом SCL и изменением SDA в режиме ведущего и ведомого при NOSTRETCH = 0 t_SCADEL = (SCADEL+1) x t_PRESC Используется для генера-ции задержек t_HD:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type SdadelR = crate :: FieldReader ; # [doc = "Field `SDADEL` writer - Длительность предустановки данных t_HD:DAT. Задержка между спадом SCL и изменением SDA в режиме ведущего и ведомого при NOSTRETCH = 0 t_SCADEL = (SCADEL+1) x t_PRESC Используется для генера-ции задержек t_HD:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type SdadelW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `SCLDEL` reader - Длительность предустанов-ки данных t_SU:DAT. Задержка между изменени-ем SDA и фронтом SCL. t_SCLDEL = (SCLDEL+1) x t_PRESC Используется для генерации задержек t_SU:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type ScldelR = crate :: FieldReader ; # [doc = "Field `SCLDEL` writer - Длительность предустанов-ки данных t_SU:DAT. Задержка между изменени-ем SDA и фронтом SCL. t_SCLDEL = (SCLDEL+1) x t_PRESC Используется для генерации задержек t_SU:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type ScldelW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `PRESC` reader - Предварительный делитель частоты I2CCLK. Использу-ется для вычисления значения t_PRESC используемого счетчиками предустановки, удержания, низкого и вы-сокого уровней. t_PRESC = (PRESC+1) x t_I2CCLK. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type PrescR = crate :: FieldReader ; # [doc = "Field `PRESC` writer - Предварительный делитель частоты I2CCLK. Использу-ется для вычисления значения t_PRESC используемого счетчиками предустановки, удержания, низкого и вы-сокого уровней. t_PRESC = (PRESC+1) x t_I2CCLK. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
pub type PrescW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; impl R { # [doc = "Bits 0:7 - Длительность удержания SCL в состоянии логиче-ского «0» в режиме «ведущий» t_SCLL = (SCLL+1) x t_PRESC Также используется для генерации задержек t_BUF и t_SU:STA. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn scll (& self) -> ScllR { ScllR :: new ((self . bits & 0xff) as u8) } # [doc = "Bits 8:15 - Длительность удержания SCL в состоянии логической «1» в режиме «ведущий» t_SCLH = (SCLH+1) x t_PRESC Также используется для генерации задержек t_HD:STA и t_SU:STO. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn sclh (& self) -> SclhR { SclhR :: new (((self . bits >> 8) & 0xff) as u8) } # [doc = "Bits 16:19 - Длительность предустановки данных t_HD:DAT. Задержка между спадом SCL и изменением SDA в режиме ведущего и ведомого при NOSTRETCH = 0 t_SCADEL = (SCADEL+1) x t_PRESC Используется для генера-ции задержек t_HD:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn sdadel (& self) -> SdadelR { SdadelR :: new (((self . bits >> 16) & 0x0f) as u8) } # [doc = "Bits 20:23 - Длительность предустанов-ки данных t_SU:DAT. Задержка между изменени-ем SDA и фронтом SCL. t_SCLDEL = (SCLDEL+1) x t_PRESC Используется для генерации задержек t_SU:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn scldel (& self) -> ScldelR { ScldelR :: new (((self . bits >> 20) & 0x0f) as u8) } # [doc = "Bits 28:31 - Предварительный делитель частоты I2CCLK. Использу-ется для вычисления значения t_PRESC используемого счетчиками предустановки, удержания, низкого и вы-сокого уровней. t_PRESC = (PRESC+1) x t_I2CCLK. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn presc (& self) -> PrescR { PrescR :: new (((self . bits >> 28) & 0x0f) as u8) } } impl W { # [doc = "Bits 0:7 - Длительность удержания SCL в состоянии логиче-ского «0» в режиме «ведущий» t_SCLL = (SCLL+1) x t_PRESC Также используется для генерации задержек t_BUF и t_SU:STA. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn scll (& mut self) -> ScllW < TimingrSpec > { ScllW :: new (self , 0) } # [doc = "Bits 8:15 - Длительность удержания SCL в состоянии логической «1» в режиме «ведущий» t_SCLH = (SCLH+1) x t_PRESC Также используется для генерации задержек t_HD:STA и t_SU:STO. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn sclh (& mut self) -> SclhW < TimingrSpec > { SclhW :: new (self , 8) } # [doc = "Bits 16:19 - Длительность предустановки данных t_HD:DAT. Задержка между спадом SCL и изменением SDA в режиме ведущего и ведомого при NOSTRETCH = 0 t_SCADEL = (SCADEL+1) x t_PRESC Используется для генера-ции задержек t_HD:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn sdadel (& mut self) -> SdadelW < TimingrSpec > { SdadelW :: new (self , 16) } # [doc = "Bits 20:23 - Длительность предустанов-ки данных t_SU:DAT. Задержка между изменени-ем SDA и фронтом SCL. t_SCLDEL = (SCLDEL+1) x t_PRESC Используется для генерации задержек t_SU:DAT. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn scldel (& mut self) -> ScldelW < TimingrSpec > { ScldelW :: new (self , 20) } # [doc = "Bits 28:31 - Предварительный делитель частоты I2CCLK. Использу-ется для вычисления значения t_PRESC используемого счетчиками предустановки, удержания, низкого и вы-сокого уровней. t_PRESC = (PRESC+1) x t_I2CCLK. Примечание: Регистр TIMING должен конфигурироваться, пока интерфейс заблокирован (PE=0)."]
# [inline (always)]
pub fn presc (& mut self) -> PrescW < TimingrSpec > { PrescW :: new (self , 28) } } # [doc = "Регистр настройки временных ограничений. Регистр должен конфигурироваться, пока интерфейс заблокирован (PE=0).\n\nYou can [`read`](crate::Reg::read) this register and get [`timingr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timingr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TimingrSpec ; impl crate :: RegisterSpec for TimingrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`timingr::R`](R) reader structure"]
impl crate :: Readable for TimingrSpec { } # [doc = "`write(|w| ..)` method takes [`timingr::W`](W) writer structure"]
impl crate :: Writable for TimingrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TIMINGR to value 0"]
impl crate :: Resettable for TimingrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ISR (rw) register accessor: Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@isr`]
module"]
# [doc (alias = "ISR")]
pub type Isr = crate :: Reg < isr :: IsrSpec > ; # [doc = "Регистр флагов прерываний"]
pub mod isr { # [doc = "Register `ISR` reader"]
pub type R = crate :: R < IsrSpec > ; # [doc = "Register `ISR` writer"]
pub type W = crate :: W < IsrSpec > ; # [doc = "Field `TXE` reader - Флаг «буфер передаваемых данных» TXDR пуст (режимы отправки). Устанавливается аппаратно, если буфер пуст; при PE=0 или программно, чтобы сбросить содержимое регистра TXDR. Сбрасывается записью следующего байта данных в регистр TXDR."]
pub type TxeR = crate :: BitReader ; # [doc = "Field `TXIS` reader - Состояние прерывания передатчика. Устанавливается аппаратно, когда регистр TXDR пуст и следующий байт данных должен быть в него записан. Сбрасывается записью следующего байта данных в регистр TXDR или аппаратно при PE=0. Этот бит может быть установлен программой только при NOSTRETCH=1 для выработки события TXIS (в результате: прерывание, при TXIE=1 или DMA запрос, при TXDMAEN=1)"]
pub type TxisR = crate :: BitReader ; # [doc = "Field `RXNE` reader - Флаг «буфер принятых данных заполнен» (режимы приёма). Устанавливается аппарат-но, после записи принятых данных в регистр RXDR. Сбрасывается при чтении RXDR или аппаратно при PE=0."]
pub type RxneR = crate :: BitReader ; # [doc = "Field `RXNE` writer - Флаг «буфер принятых данных заполнен» (режимы приёма). Устанавливается аппарат-но, после записи принятых данных в регистр RXDR. Сбрасывается при чтении RXDR или аппаратно при PE=0."]
pub type RxneW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `ADDR` reader - Флаг соответствия адреса (режим «ведомый»). Устанавливается аппаратно, если полученный адрес совпадает с одним из разрешенных в OAR1, OAR2. Сбрасывается программной установкой бита ADDRCF или аппаратно при PE=0."]
pub type AddrR = crate :: BitReader ; # [doc = "Field `NACKF` reader - Флаг «не получено под-тверждение» (NACK). Устанавливается аппарат-но, после передачи байта. Сбрасывается программной установкой бита NACKCF или аппаратно при PE=0."]
pub type NackfR = crate :: BitReader ; # [doc = "Field `STOPF` reader - Флаг детектирования STOP на шине. Устанавливается аппарат-но, если интерфейс участ-вует в передаче. Сбрасывается программной установкой бита STOPCF или аппаратно при PE=0."]
pub type StopfR = crate :: BitReader ; # [doc = "Field `TC` reader - Флаг окончания передачи (режим «ведущий»). Уста-навливается аппаратно при RELOAD=0, AUTOEND=0, после передачи NBYTES байт. Сбрасывается программной установкой бита START или STOP или аппаратно при PE=0."]
pub type TcR = crate :: BitReader ; # [doc = "Field `TCR` reader - Флаг окончания передачи (режим «ведущий» или «ведомый» с установлен-ным битом SBC). Устанав-ливается аппаратно при RELOAD=1, после переда-чи NBYTES байт. Сбрасывается записью в NBYTES ненулевого значе-ния или аппаратно при PE=0."]
pub type TcrR = crate :: BitReader ; # [doc = "Field `BERR` reader - Флаг ошибки шины Устанавливается аппаратно при детектировании не-уместного события START или STOP на шине, если интерфейс участвует в пе-редаче. Не устанавливается в фазе адреса в режиме «ведомый». Сбрасывается программной установкой бита BERRCF или аппарат-но при PE=0."]
pub type BerrR = crate :: BitReader ; # [doc = "Field `ARLO` reader - Флаг проигрыша арбитража. Устанавливается аппаратно, сбрасывается программной установкой бита ARLOCF или аппаратно при PE=0."]
pub type ArloR = crate :: BitReader ; # [doc = "Field `OVR` reader - Флаг переполнения/недозагрузки (режим «ведомый» при NOSTRETCH=1) Устанавливается аппаратно, сбрасывается программной установкой бита OVRCF или аппаратно при PE=0."]
pub type OvrR = crate :: BitReader ; # [doc = "Field `BUSY` reader - Флаг индикации занятой шины. Устанавливается по-сле события START на шине и сбрасывается после события STOP на шине"]
pub type BusyR = crate :: BitReader ; # [doc = "Направление передачи (режим «ведомый»). Обновляется при совпадении адреса (ADDR=1)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Dir { # [doc = "0: Тип передачи «запись», ведомый переходит в режим приемника"]
Write = 0 , # [doc = "1: Тип передачи «чтение», ведомый переходит в режим передатчика"]
Read = 1 , } impl From < Dir > for bool { # [inline (always)]
fn from (variant : Dir) -> Self { variant as u8 != 0 } } # [doc = "Field `DIR` reader - Направление передачи (режим «ведомый»). Обновляется при совпадении адреса (ADDR=1)"]
pub type DirR = crate :: BitReader < Dir > ; impl DirR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Dir { match self . bits { false => Dir :: Write , true => Dir :: Read , } } # [doc = "Тип передачи «запись», ведомый переходит в режим приемника"]
# [inline (always)]
pub fn is_write (& self) -> bool { * self == Dir :: Write } # [doc = "Тип передачи «чтение», ведомый переходит в режим передатчика"]
# [inline (always)]
pub fn is_read (& self) -> bool { * self == Dir :: Read } } # [doc = "Field `ADDCODE` reader - Код совпавшего адреса. Обновляется в режиме «ве-домый» при совпадении адреса (ADDR=1). В режиме 10-битного адре-са содержит заголовок (5b11110) и два старших бита адреса."]
pub type AddcodeR = crate :: FieldReader ; impl R { # [doc = "Bit 0 - Флаг «буфер передаваемых данных» TXDR пуст (режимы отправки). Устанавливается аппаратно, если буфер пуст; при PE=0 или программно, чтобы сбросить содержимое регистра TXDR. Сбрасывается записью следующего байта данных в регистр TXDR."]
# [inline (always)]
pub fn txe (& self) -> TxeR { TxeR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Состояние прерывания передатчика. Устанавливается аппаратно, когда регистр TXDR пуст и следующий байт данных должен быть в него записан. Сбрасывается записью следующего байта данных в регистр TXDR или аппаратно при PE=0. Этот бит может быть установлен программой только при NOSTRETCH=1 для выработки события TXIS (в результате: прерывание, при TXIE=1 или DMA запрос, при TXDMAEN=1)"]
# [inline (always)]
pub fn txis (& self) -> TxisR { TxisR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Флаг «буфер принятых данных заполнен» (режимы приёма). Устанавливается аппарат-но, после записи принятых данных в регистр RXDR. Сбрасывается при чтении RXDR или аппаратно при PE=0."]
# [inline (always)]
pub fn rxne (& self) -> RxneR { RxneR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Флаг соответствия адреса (режим «ведомый»). Устанавливается аппаратно, если полученный адрес совпадает с одним из разрешенных в OAR1, OAR2. Сбрасывается программной установкой бита ADDRCF или аппаратно при PE=0."]
# [inline (always)]
pub fn addr (& self) -> AddrR { AddrR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Флаг «не получено под-тверждение» (NACK). Устанавливается аппарат-но, после передачи байта. Сбрасывается программной установкой бита NACKCF или аппаратно при PE=0."]
# [inline (always)]
pub fn nackf (& self) -> NackfR { NackfR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Флаг детектирования STOP на шине. Устанавливается аппарат-но, если интерфейс участ-вует в передаче. Сбрасывается программной установкой бита STOPCF или аппаратно при PE=0."]
# [inline (always)]
pub fn stopf (& self) -> StopfR { StopfR :: new (((self . bits >> 5) & 1) != 0) } # [doc = "Bit 6 - Флаг окончания передачи (режим «ведущий»). Уста-навливается аппаратно при RELOAD=0, AUTOEND=0, после передачи NBYTES байт. Сбрасывается программной установкой бита START или STOP или аппаратно при PE=0."]
# [inline (always)]
pub fn tc (& self) -> TcR { TcR :: new (((self . bits >> 6) & 1) != 0) } # [doc = "Bit 7 - Флаг окончания передачи (режим «ведущий» или «ведомый» с установлен-ным битом SBC). Устанав-ливается аппаратно при RELOAD=1, после переда-чи NBYTES байт. Сбрасывается записью в NBYTES ненулевого значе-ния или аппаратно при PE=0."]
# [inline (always)]
pub fn tcr (& self) -> TcrR { TcrR :: new (((self . bits >> 7) & 1) != 0) } # [doc = "Bit 8 - Флаг ошибки шины Устанавливается аппаратно при детектировании не-уместного события START или STOP на шине, если интерфейс участвует в пе-редаче. Не устанавливается в фазе адреса в режиме «ведомый». Сбрасывается программной установкой бита BERRCF или аппарат-но при PE=0."]
# [inline (always)]
pub fn berr (& self) -> BerrR { BerrR :: new (((self . bits >> 8) & 1) != 0) } # [doc = "Bit 9 - Флаг проигрыша арбитража. Устанавливается аппаратно, сбрасывается программной установкой бита ARLOCF или аппаратно при PE=0."]
# [inline (always)]
pub fn arlo (& self) -> ArloR { ArloR :: new (((self . bits >> 9) & 1) != 0) } # [doc = "Bit 10 - Флаг переполнения/недозагрузки (режим «ведомый» при NOSTRETCH=1) Устанавливается аппаратно, сбрасывается программной установкой бита OVRCF или аппаратно при PE=0."]
# [inline (always)]
pub fn ovr (& self) -> OvrR { OvrR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 15 - Флаг индикации занятой шины. Устанавливается по-сле события START на шине и сбрасывается после события STOP на шине"]
# [inline (always)]
pub fn busy (& self) -> BusyR { BusyR :: new (((self . bits >> 15) & 1) != 0) } # [doc = "Bit 16 - Направление передачи (режим «ведомый»). Обновляется при совпадении адреса (ADDR=1)"]
# [inline (always)]
pub fn dir (& self) -> DirR { DirR :: new (((self . bits >> 16) & 1) != 0) } # [doc = "Bits 17:23 - Код совпавшего адреса. Обновляется в режиме «ве-домый» при совпадении адреса (ADDR=1). В режиме 10-битного адре-са содержит заголовок (5b11110) и два старших бита адреса."]
# [inline (always)]
pub fn addcode (& self) -> AddcodeR { AddcodeR :: new (((self . bits >> 17) & 0x7f) as u8) } } impl W { # [doc = "Bit 2 - Флаг «буфер принятых данных заполнен» (режимы приёма). Устанавливается аппарат-но, после записи принятых данных в регистр RXDR. Сбрасывается при чтении RXDR или аппаратно при PE=0."]
# [inline (always)]
pub fn rxne (& mut self) -> RxneW < IsrSpec > { RxneW :: new (self , 2) } } # [doc = "Регистр флагов прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`isr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`isr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IsrSpec ; impl crate :: RegisterSpec for IsrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`isr::R`](R) reader structure"]
impl crate :: Readable for IsrSpec { } # [doc = "`write(|w| ..)` method takes [`isr::W`](W) writer structure"]
impl crate :: Writable for IsrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ISR to value 0"]
impl crate :: Resettable for IsrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ICR (w) register accessor: Регистр сроса флагов прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@icr`]
module"]
# [doc (alias = "ICR")]
pub type Icr = crate :: Reg < icr :: IcrSpec > ; # [doc = "Регистр сроса флагов прерываний"]
pub mod icr { # [doc = "Register `ICR` writer"]
pub type W = crate :: W < IcrSpec > ; # [doc = "Field `ADDRCF` writer - Сброс флага соответствия адреса"]
pub type AddrcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `NACKCF` writer - Сброс флага «не получено подтверждение» (NACK)"]
pub type NackcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `STOPCF` writer - Сброс флага детектирования STOP на шине"]
pub type StopcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `BERRCF` writer - Сброс флага ошибки шины"]
pub type BerrcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `ARLOCF` writer - Сброс флага проигрыша арбитража"]
pub type ArlocfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `OVRCF` writer - Сброс флага прерывания переполнения/недозагрузки"]
pub type OvrcfW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W { # [doc = "Bit 3 - Сброс флага соответствия адреса"]
# [inline (always)]
pub fn addrcf (& mut self) -> AddrcfW < IcrSpec > { AddrcfW :: new (self , 3) } # [doc = "Bit 4 - Сброс флага «не получено подтверждение» (NACK)"]
# [inline (always)]
pub fn nackcf (& mut self) -> NackcfW < IcrSpec > { NackcfW :: new (self , 4) } # [doc = "Bit 5 - Сброс флага детектирования STOP на шине"]
# [inline (always)]
pub fn stopcf (& mut self) -> StopcfW < IcrSpec > { StopcfW :: new (self , 5) } # [doc = "Bit 8 - Сброс флага ошибки шины"]
# [inline (always)]
pub fn berrcf (& mut self) -> BerrcfW < IcrSpec > { BerrcfW :: new (self , 8) } # [doc = "Bit 9 - Сброс флага проигрыша арбитража"]
# [inline (always)]
pub fn arlocf (& mut self) -> ArlocfW < IcrSpec > { ArlocfW :: new (self , 9) } # [doc = "Bit 10 - Сброс флага прерывания переполнения/недозагрузки"]
# [inline (always)]
pub fn ovrcf (& mut self) -> OvrcfW < IcrSpec > { OvrcfW :: new (self , 10) } } # [doc = "Регистр сроса флагов прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`icr::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct IcrSpec ; impl crate :: RegisterSpec for IcrSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`icr::W`](W) writer structure"]
impl crate :: Writable for IcrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ICR to value 0"]
impl crate :: Resettable for IcrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "RXDR (r) register accessor: Регистр принятых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdr::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@rxdr`]
module"]
# [doc (alias = "RXDR")]
pub type Rxdr = crate :: Reg < rxdr :: RxdrSpec > ; # [doc = "Регистр принятых данных"]
pub mod rxdr { # [doc = "Register `RXDR` reader"]
pub type R = crate :: R < RxdrSpec > ; # [doc = "Field `TXDATA` reader - Буфер принятых данных"]
pub type TxdataR = crate :: FieldReader ; impl R { # [doc = "Bits 0:7 - Буфер принятых данных"]
# [inline (always)]
pub fn txdata (& self) -> TxdataR { TxdataR :: new ((self . bits & 0xff) as u8) } } # [doc = "Регистр принятых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`rxdr::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RxdrSpec ; impl crate :: RegisterSpec for RxdrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`rxdr::R`](R) reader structure"]
impl crate :: Readable for RxdrSpec { } # [doc = "`reset()` method sets RXDR to value 0"]
impl crate :: Resettable for RxdrSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TXDR (rw) register accessor: Регистр передаваемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`txdr::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdr::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@txdr`]
module"]
# [doc (alias = "TXDR")]
pub type Txdr = crate :: Reg < txdr :: TxdrSpec > ; # [doc = "Регистр передаваемых данных"]
pub mod txdr { # [doc = "Register `TXDR` reader"]
pub type R = crate :: R < TxdrSpec > ; # [doc = "Register `TXDR` writer"]
pub type W = crate :: W < TxdrSpec > ; # [doc = "Field `TXDATA` reader - Буфер передаваемых данных"]
pub type TxdataR = crate :: FieldReader ; # [doc = "Field `TXDATA` writer - Буфер передаваемых данных"]
pub type TxdataW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; impl R { # [doc = "Bits 0:7 - Буфер передаваемых данных"]
# [inline (always)]
pub fn txdata (& self) -> TxdataR { TxdataR :: new ((self . bits & 0xff) as u8) } } impl W { # [doc = "Bits 0:7 - Буфер передаваемых данных"]
# [inline (always)]
pub fn txdata (& mut self) -> TxdataW < TxdrSpec > { TxdataW :: new (self , 0) } } # [doc = "Регистр передаваемых данных\n\nYou can [`read`](crate::Reg::read) this register and get [`txdr::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`txdr::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TxdrSpec ; impl crate :: RegisterSpec for TxdrSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`txdr::R`](R) reader structure"]
impl crate :: Readable for TxdrSpec { } # [doc = "`write(|w| ..)` method takes [`txdr::W`](W) writer structure"]
impl crate :: Writable for TxdrSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TXDR to value 0"]
impl crate :: Resettable for TxdrSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Модуль ввода/вывода"]
pub struct Gpio16_0 { _marker : PhantomData < * const () > } unsafe impl Send for Gpio16_0 { } impl Gpio16_0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const gpio16_0 :: RegisterBlock = 0x0008_4000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const gpio16_0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Gpio16_0 { type Target = gpio16_0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Gpio16_0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpio16_0") . finish () } } # [doc = "Модуль ввода/вывода"]
pub mod gpio16_0 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { _reserved_0_set : [u8 ; 0x04]
, clear : Clear , direction_out : DirectionOut , direction_in : DirectionIn , output : Output , control : Control , } impl RegisterBlock { # [doc = "0x00 - Текущее состояние выводов"]
# [inline (always)]
pub const fn state (& self) -> & State { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . cast () } } # [doc = "0x00 - Установка выводов в «1»"]
# [inline (always)]
pub const fn set (& self) -> & Set { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . cast () } } # [doc = "0x04 - Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»"]
# [inline (always)]
pub const fn clear (& self) -> & Clear { & self . clear } # [doc = "0x08 - Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»"]
# [inline (always)]
pub const fn direction_out (& self) -> & DirectionOut { & self . direction_out } # [doc = "0x0c - Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»"]
# [inline (always)]
pub const fn direction_in (& self) -> & DirectionIn { & self . direction_in } # [doc = "0x10 - Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра"]
# [inline (always)]
pub const fn output (& self) -> & Output { & self . output } # [doc = "0x14 - Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим"]
# [inline (always)]
pub const fn control (& self) -> & Control { & self . control } } # [doc = "SET (w) register accessor: Установка выводов в «1»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`set::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@set`]
module"]
# [doc (alias = "SET")]
pub type Set = crate :: Reg < set :: SetSpec > ; # [doc = "Установка выводов в «1»"]
pub mod set { # [doc = "Register `SET` writer"]
pub type W = crate :: W < SetSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < SetSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Установка выводов в «1»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`set::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SetSpec ; impl crate :: RegisterSpec for SetSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`set::W`](W) writer structure"]
impl crate :: Writable for SetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SET to value 0"]
impl crate :: Resettable for SetSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "STATE (r) register accessor: Текущее состояние выводов\n\nYou can [`read`](crate::Reg::read) this register and get [`state::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@state`]
module"]
# [doc (alias = "STATE")]
pub type State = crate :: Reg < state :: StateSpec > ; # [doc = "Текущее состояние выводов"]
pub mod state { # [doc = "Register `STATE` reader"]
pub type R = crate :: R < StateSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } # [doc = "Текущее состояние выводов\n\nYou can [`read`](crate::Reg::read) this register and get [`state::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StateSpec ; impl crate :: RegisterSpec for StateSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`state::R`](R) reader structure"]
impl crate :: Readable for StateSpec { } # [doc = "`reset()` method sets STATE to value 0"]
impl crate :: Resettable for StateSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CLEAR (w) register accessor: Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clear::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clear`]
module"]
# [doc (alias = "CLEAR")]
pub type Clear = crate :: Reg < clear :: ClearSpec > ; # [doc = "Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»"]
pub mod clear { # [doc = "Register `CLEAR` writer"]
pub type W = crate :: W < ClearSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < ClearSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clear::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClearSpec ; impl crate :: RegisterSpec for ClearSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`clear::W`](W) writer structure"]
impl crate :: Writable for ClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLEAR to value 0"]
impl crate :: Resettable for ClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DIRECTION_OUT (rw) register accessor: Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@direction_out`]
module"]
# [doc (alias = "DIRECTION_OUT")]
pub type DirectionOut = crate :: Reg < direction_out :: DirectionOutSpec > ; # [doc = "Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»"]
pub mod direction_out { # [doc = "Register `DIRECTION_OUT` reader"]
pub type R = crate :: R < DirectionOutSpec > ; # [doc = "Register `DIRECTION_OUT` writer"]
pub type W = crate :: W < DirectionOutSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DirectionOutSpec ; impl crate :: RegisterSpec for DirectionOutSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`direction_out::R`](R) reader structure"]
impl crate :: Readable for DirectionOutSpec { } # [doc = "`write(|w| ..)` method takes [`direction_out::W`](W) writer structure"]
impl crate :: Writable for DirectionOutSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DIRECTION_OUT to value 0xffff"]
impl crate :: Resettable for DirectionOutSpec { const RESET_VALUE : u32 = 0xffff ; } } # [doc = "DIRECTION_IN (rw) register accessor: Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_in::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_in::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@direction_in`]
module"]
# [doc (alias = "DIRECTION_IN")]
pub type DirectionIn = crate :: Reg < direction_in :: DirectionInSpec > ; # [doc = "Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»"]
pub mod direction_in { # [doc = "Register `DIRECTION_IN` reader"]
pub type R = crate :: R < DirectionInSpec > ; # [doc = "Register `DIRECTION_IN` writer"]
pub type W = crate :: W < DirectionInSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_in::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_in::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DirectionInSpec ; impl crate :: RegisterSpec for DirectionInSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`direction_in::R`](R) reader structure"]
impl crate :: Readable for DirectionInSpec { } # [doc = "`write(|w| ..)` method takes [`direction_in::W`](W) writer structure"]
impl crate :: Writable for DirectionInSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DIRECTION_IN to value 0xffff"]
impl crate :: Resettable for DirectionInSpec { const RESET_VALUE : u32 = 0xffff ; } } # [doc = "OUTPUT (rw) register accessor: Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра\n\nYou can [`read`](crate::Reg::read) this register and get [`output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@output`]
module"]
# [doc (alias = "OUTPUT")]
pub type Output = crate :: Reg < output :: OutputSpec > ; # [doc = "Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра"]
pub mod output { # [doc = "Register `OUTPUT` reader"]
pub type R = crate :: R < OutputSpec > ; # [doc = "Register `OUTPUT` writer"]
pub type W = crate :: W < OutputSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра\n\nYou can [`read`](crate::Reg::read) this register and get [`output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OutputSpec ; impl crate :: RegisterSpec for OutputSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`output::R`](R) reader structure"]
impl crate :: Readable for OutputSpec { } # [doc = "`write(|w| ..)` method takes [`output::W`](W) writer structure"]
impl crate :: Writable for OutputSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OUTPUT to value 0"]
impl crate :: Resettable for OutputSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONTROL (rw) register accessor: Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control`]
module"]
# [doc (alias = "CONTROL")]
pub type Control = crate :: Reg < control :: ControlSpec > ; # [doc = "Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим"]
pub mod control { # [doc = "Register `CONTROL` reader"]
pub type R = crate :: R < ControlSpec > ; # [doc = "Register `CONTROL` writer"]
pub type W = crate :: W < ControlSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ControlSpec ; impl crate :: RegisterSpec for ControlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`control::R`](R) reader structure"]
impl crate :: Readable for ControlSpec { } # [doc = "`write(|w| ..)` method takes [`control::W`](W) writer structure"]
impl crate :: Writable for ControlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL to value 0"]
impl crate :: Resettable for ControlSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Модуль ввода/вывода"]
pub struct Gpio16_1 { _marker : PhantomData < * const () > } unsafe impl Send for Gpio16_1 { } impl Gpio16_1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const gpio16_1 :: RegisterBlock = 0x0008_4400 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const gpio16_1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Gpio16_1 { type Target = gpio16_1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Gpio16_1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpio16_1") . finish () } } # [doc = "Модуль ввода/вывода"]
pub mod gpio16_1 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { _reserved_0_set : [u8 ; 0x04]
, clear : Clear , direction_out : DirectionOut , direction_in : DirectionIn , output : Output , control : Control , } impl RegisterBlock { # [doc = "0x00 - Текущее состояние выводов"]
# [inline (always)]
pub const fn state (& self) -> & State { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . cast () } } # [doc = "0x00 - Установка выводов в «1»"]
# [inline (always)]
pub const fn set (& self) -> & Set { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . cast () } } # [doc = "0x04 - Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»"]
# [inline (always)]
pub const fn clear (& self) -> & Clear { & self . clear } # [doc = "0x08 - Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»"]
# [inline (always)]
pub const fn direction_out (& self) -> & DirectionOut { & self . direction_out } # [doc = "0x0c - Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»"]
# [inline (always)]
pub const fn direction_in (& self) -> & DirectionIn { & self . direction_in } # [doc = "0x10 - Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра"]
# [inline (always)]
pub const fn output (& self) -> & Output { & self . output } # [doc = "0x14 - Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим"]
# [inline (always)]
pub const fn control (& self) -> & Control { & self . control } } # [doc = "SET (w) register accessor: Установка выводов в «1»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`set::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@set`]
module"]
# [doc (alias = "SET")]
pub type Set = crate :: Reg < set :: SetSpec > ; # [doc = "Установка выводов в «1»"]
pub mod set { # [doc = "Register `SET` writer"]
pub type W = crate :: W < SetSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < SetSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Установка выводов в «1»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`set::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SetSpec ; impl crate :: RegisterSpec for SetSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`set::W`](W) writer structure"]
impl crate :: Writable for SetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SET to value 0"]
impl crate :: Resettable for SetSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "STATE (r) register accessor: Текущее состояние выводов\n\nYou can [`read`](crate::Reg::read) this register and get [`state::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@state`]
module"]
# [doc (alias = "STATE")]
pub type State = crate :: Reg < state :: StateSpec > ; # [doc = "Текущее состояние выводов"]
pub mod state { # [doc = "Register `STATE` reader"]
pub type R = crate :: R < StateSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } # [doc = "Текущее состояние выводов\n\nYou can [`read`](crate::Reg::read) this register and get [`state::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StateSpec ; impl crate :: RegisterSpec for StateSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`state::R`](R) reader structure"]
impl crate :: Readable for StateSpec { } # [doc = "`reset()` method sets STATE to value 0"]
impl crate :: Resettable for StateSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CLEAR (w) register accessor: Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clear::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clear`]
module"]
# [doc (alias = "CLEAR")]
pub type Clear = crate :: Reg < clear :: ClearSpec > ; # [doc = "Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»"]
pub mod clear { # [doc = "Register `CLEAR` writer"]
pub type W = crate :: W < ClearSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < ClearSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clear::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClearSpec ; impl crate :: RegisterSpec for ClearSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`clear::W`](W) writer structure"]
impl crate :: Writable for ClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLEAR to value 0"]
impl crate :: Resettable for ClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DIRECTION_OUT (rw) register accessor: Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@direction_out`]
module"]
# [doc (alias = "DIRECTION_OUT")]
pub type DirectionOut = crate :: Reg < direction_out :: DirectionOutSpec > ; # [doc = "Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»"]
pub mod direction_out { # [doc = "Register `DIRECTION_OUT` reader"]
pub type R = crate :: R < DirectionOutSpec > ; # [doc = "Register `DIRECTION_OUT` writer"]
pub type W = crate :: W < DirectionOutSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DirectionOutSpec ; impl crate :: RegisterSpec for DirectionOutSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`direction_out::R`](R) reader structure"]
impl crate :: Readable for DirectionOutSpec { } # [doc = "`write(|w| ..)` method takes [`direction_out::W`](W) writer structure"]
impl crate :: Writable for DirectionOutSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DIRECTION_OUT to value 0xffff"]
impl crate :: Resettable for DirectionOutSpec { const RESET_VALUE : u32 = 0xffff ; } } # [doc = "DIRECTION_IN (rw) register accessor: Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_in::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_in::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@direction_in`]
module"]
# [doc (alias = "DIRECTION_IN")]
pub type DirectionIn = crate :: Reg < direction_in :: DirectionInSpec > ; # [doc = "Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»"]
pub mod direction_in { # [doc = "Register `DIRECTION_IN` reader"]
pub type R = crate :: R < DirectionInSpec > ; # [doc = "Register `DIRECTION_IN` writer"]
pub type W = crate :: W < DirectionInSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_in::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_in::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DirectionInSpec ; impl crate :: RegisterSpec for DirectionInSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`direction_in::R`](R) reader structure"]
impl crate :: Readable for DirectionInSpec { } # [doc = "`write(|w| ..)` method takes [`direction_in::W`](W) writer structure"]
impl crate :: Writable for DirectionInSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DIRECTION_IN to value 0xffff"]
impl crate :: Resettable for DirectionInSpec { const RESET_VALUE : u32 = 0xffff ; } } # [doc = "OUTPUT (rw) register accessor: Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра\n\nYou can [`read`](crate::Reg::read) this register and get [`output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@output`]
module"]
# [doc (alias = "OUTPUT")]
pub type Output = crate :: Reg < output :: OutputSpec > ; # [doc = "Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра"]
pub mod output { # [doc = "Register `OUTPUT` reader"]
pub type R = crate :: R < OutputSpec > ; # [doc = "Register `OUTPUT` writer"]
pub type W = crate :: W < OutputSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра\n\nYou can [`read`](crate::Reg::read) this register and get [`output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OutputSpec ; impl crate :: RegisterSpec for OutputSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`output::R`](R) reader structure"]
impl crate :: Readable for OutputSpec { } # [doc = "`write(|w| ..)` method takes [`output::W`](W) writer structure"]
impl crate :: Writable for OutputSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OUTPUT to value 0"]
impl crate :: Resettable for OutputSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONTROL (rw) register accessor: Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control`]
module"]
# [doc (alias = "CONTROL")]
pub type Control = crate :: Reg < control :: ControlSpec > ; # [doc = "Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим"]
pub mod control { # [doc = "Register `CONTROL` reader"]
pub type R = crate :: R < ControlSpec > ; # [doc = "Register `CONTROL` writer"]
pub type W = crate :: W < ControlSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ControlSpec ; impl crate :: RegisterSpec for ControlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`control::R`](R) reader structure"]
impl crate :: Readable for ControlSpec { } # [doc = "`write(|w| ..)` method takes [`control::W`](W) writer structure"]
impl crate :: Writable for ControlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL to value 0"]
impl crate :: Resettable for ControlSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Модуль ввода/вывода"]
pub struct Gpio8_2 { _marker : PhantomData < * const () > } unsafe impl Send for Gpio8_2 { } impl Gpio8_2 { # [doc = r"Pointer to the register block"]
pub const PTR : * const gpio8_2 :: RegisterBlock = 0x0008_4800 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const gpio8_2 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Gpio8_2 { type Target = gpio8_2 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Gpio8_2 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Gpio8_2") . finish () } } # [doc = "Модуль ввода/вывода"]
pub mod gpio8_2 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { _reserved_0_set : [u8 ; 0x04]
, clear : Clear , direction_out : DirectionOut , direction_in : DirectionIn , output : Output , control : Control , } impl RegisterBlock { # [doc = "0x00 - Текущее состояние выводов"]
# [inline (always)]
pub const fn state (& self) -> & State { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . cast () } } # [doc = "0x00 - Установка выводов в «1»"]
# [inline (always)]
pub const fn set (& self) -> & Set { unsafe { & * core :: ptr :: from_ref (self) . cast :: < u8 > () . cast () } } # [doc = "0x04 - Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»"]
# [inline (always)]
pub const fn clear (& self) -> & Clear { & self . clear } # [doc = "0x08 - Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»"]
# [inline (always)]
pub const fn direction_out (& self) -> & DirectionOut { & self . direction_out } # [doc = "0x0c - Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»"]
# [inline (always)]
pub const fn direction_in (& self) -> & DirectionIn { & self . direction_in } # [doc = "0x10 - Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра"]
# [inline (always)]
pub const fn output (& self) -> & Output { & self . output } # [doc = "0x14 - Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим"]
# [inline (always)]
pub const fn control (& self) -> & Control { & self . control } } # [doc = "SET (w) register accessor: Установка выводов в «1»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`set::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@set`]
module"]
# [doc (alias = "SET")]
pub type Set = crate :: Reg < set :: SetSpec > ; # [doc = "Установка выводов в «1»"]
pub mod set { # [doc = "Register `SET` writer"]
pub type W = crate :: W < SetSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < SetSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Установка выводов в «1»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`set::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct SetSpec ; impl crate :: RegisterSpec for SetSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`set::W`](W) writer structure"]
impl crate :: Writable for SetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets SET to value 0"]
impl crate :: Resettable for SetSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "STATE (r) register accessor: Текущее состояние выводов\n\nYou can [`read`](crate::Reg::read) this register and get [`state::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@state`]
module"]
# [doc (alias = "STATE")]
pub type State = crate :: Reg < state :: StateSpec > ; # [doc = "Текущее состояние выводов"]
pub mod state { # [doc = "Register `STATE` reader"]
pub type R = crate :: R < StateSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } # [doc = "Текущее состояние выводов\n\nYou can [`read`](crate::Reg::read) this register and get [`state::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StateSpec ; impl crate :: RegisterSpec for StateSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`state::R`](R) reader structure"]
impl crate :: Readable for StateSpec { } # [doc = "`reset()` method sets STATE to value 0"]
impl crate :: Resettable for StateSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CLEAR (w) register accessor: Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clear::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clear`]
module"]
# [doc (alias = "CLEAR")]
pub type Clear = crate :: Reg < clear :: ClearSpec > ; # [doc = "Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»"]
pub mod clear { # [doc = "Register `CLEAR` writer"]
pub type W = crate :: W < ClearSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < ClearSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Текущее состояние прерываний / Установка «0» При чтении – текущее состояние запросов прерываний. При записи бита «1» соответствующий биту вывод устанавливается в «0»\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clear::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClearSpec ; impl crate :: RegisterSpec for ClearSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`clear::W`](W) writer structure"]
impl crate :: Writable for ClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLEAR to value 0"]
impl crate :: Resettable for ClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DIRECTION_OUT (rw) register accessor: Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_out::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_out::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@direction_out`]
module"]
# [doc (alias = "DIRECTION_OUT")]
pub type DirectionOut = crate :: Reg < direction_out :: DirectionOutSpec > ; # [doc = "Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»"]
pub mod direction_out { # [doc = "Register `DIRECTION_OUT` reader"]
pub type R = crate :: R < DirectionOutSpec > ; # [doc = "Register `DIRECTION_OUT` writer"]
pub type W = crate :: W < DirectionOutSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Установка направления выводов как выход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «выход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_out::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_out::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DirectionOutSpec ; impl crate :: RegisterSpec for DirectionOutSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`direction_out::R`](R) reader structure"]
impl crate :: Readable for DirectionOutSpec { } # [doc = "`write(|w| ..)` method takes [`direction_out::W`](W) writer structure"]
impl crate :: Writable for DirectionOutSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DIRECTION_OUT to value 0xff"]
impl crate :: Resettable for DirectionOutSpec { const RESET_VALUE : u32 = 0xff ; } } # [doc = "DIRECTION_IN (rw) register accessor: Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_in::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_in::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@direction_in`]
module"]
# [doc (alias = "DIRECTION_IN")]
pub type DirectionIn = crate :: Reg < direction_in :: DirectionInSpec > ; # [doc = "Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»"]
pub mod direction_in { # [doc = "Register `DIRECTION_IN` reader"]
pub type R = crate :: R < DirectionInSpec > ; # [doc = "Register `DIRECTION_IN` writer"]
pub type W = crate :: W < DirectionInSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Установка направления выводов как вход При чтении – текущее направление выводов: 0 – выход; 1 – вход. Запись «1» устанавливает соответствующий вывод как «вход»\n\nYou can [`read`](crate::Reg::read) this register and get [`direction_in::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`direction_in::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DirectionInSpec ; impl crate :: RegisterSpec for DirectionInSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`direction_in::R`](R) reader structure"]
impl crate :: Readable for DirectionInSpec { } # [doc = "`write(|w| ..)` method takes [`direction_in::W`](W) writer structure"]
impl crate :: Writable for DirectionInSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DIRECTION_IN to value 0xff"]
impl crate :: Resettable for DirectionInSpec { const RESET_VALUE : u32 = 0xff ; } } # [doc = "OUTPUT (rw) register accessor: Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра\n\nYou can [`read`](crate::Reg::read) this register and get [`output::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`output::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@output`]
module"]
# [doc (alias = "OUTPUT")]
pub type Output = crate :: Reg < output :: OutputSpec > ; # [doc = "Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра"]
pub mod output { # [doc = "Register `OUTPUT` reader"]
pub type R = crate :: R < OutputSpec > ; # [doc = "Register `OUTPUT` writer"]
pub type W = crate :: W < OutputSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Выходной регистр Чтение возвращает содержимое выходного регистра независимо от текущего направления выводов Запись устанавливает значения всех битов выходного регистра\n\nYou can [`read`](crate::Reg::read) this register and get [`output::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`output::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct OutputSpec ; impl crate :: RegisterSpec for OutputSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`output::R`](R) reader structure"]
impl crate :: Readable for OutputSpec { } # [doc = "`write(|w| ..)` method takes [`output::W`](W) writer structure"]
impl crate :: Writable for OutputSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets OUTPUT to value 0"]
impl crate :: Resettable for OutputSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CONTROL (rw) register accessor: Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@control`]
module"]
# [doc (alias = "CONTROL")]
pub type Control = crate :: Reg < control :: ControlSpec > ; # [doc = "Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим"]
pub mod control { # [doc = "Register `CONTROL` reader"]
pub type R = crate :: R < ControlSpec > ; # [doc = "Register `CONTROL` writer"]
pub type W = crate :: W < ControlSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Тестовый режим Запись «1» в \\[0:0\\]
разряд – включение тестового режима (выходы замкнуты на входы внутри модуля) Запись «0» в \\[0:0\\]
разряд – нормальный режим\n\nYou can [`read`](crate::Reg::read) this register and get [`control::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`control::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ControlSpec ; impl crate :: RegisterSpec for ControlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`control::R`](R) reader structure"]
impl crate :: Readable for ControlSpec { } # [doc = "`write(|w| ..)` method takes [`control::W`](W) writer structure"]
impl crate :: Writable for ControlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONTROL to value 0"]
impl crate :: Resettable for ControlSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Модуль формирования прерываний"]
pub struct GpioIrq { _marker : PhantomData < * const () > } unsafe impl Send for GpioIrq { } impl GpioIrq { # [doc = r"Pointer to the register block"]
pub const PTR : * const gpio_irq :: RegisterBlock = 0x0008_4c00 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const gpio_irq :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for GpioIrq { type Target = gpio_irq :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for GpioIrq { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("GpioIrq") . finish () } } # [doc = "Модуль формирования прерываний"]
pub mod gpio_irq { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { state : State , line_mux : LineMux , interrupt : Interrupt , enable_set : EnableSet , enable_clear : EnableClear , edge : Edge , level : Level , level_set : LevelSet , level_clear : LevelClear , any_edge_set : AnyEdgeSet , any_edge_clear : AnyEdgeClear , clear : Clear , } impl RegisterBlock { # [doc = "0x00 - Текущее состояние выводов линий после мультисплексоров. Номер бита соответсвует номеру канала."]
# [inline (always)]
pub const fn state (& self) -> & State { & self . state } # [doc = "0x04 - Управление мультиплексорами. Каждый мультиплесор управляется своими 4 битами: Mux_0 – \\[3:0\\]; Mux_1 – \\[7:4\\]; Mux_2 – \\[11:8\\]; Mux_3 – \\[15:12\\]; Mux_4 – \\[19:16\\]; Mux_5– \\[23:20\\]; Mux_6 – \\[27:24\\]; Mux_7 – \\[31:28\\]"]
# [inline (always)]
pub const fn line_mux (& self) -> & LineMux { & self . line_mux } # [doc = "0x08 - Текущее состояние прерываний. Номер бита соответсвует номеру канала."]
# [inline (always)]
pub const fn interrupt (& self) -> & Interrupt { & self . interrupt } # [doc = "0x0c - Регистр разрешения прерываний При чтении – текущее состояние разрешений прерываний. При записи «1» разрешает прерывание от соответствующего канала."]
# [inline (always)]
pub const fn enable_set (& self) -> & EnableSet { & self . enable_set } # [doc = "0x10 - Регистр запрета прерываний При чтении – текущее состояние разрешений прерываний. При записи «1» запрещает прерывание от соответствующего канала"]
# [inline (always)]
pub const fn enable_clear (& self) -> & EnableClear { & self . enable_clear } # [doc = "0x14 - Регистр типа прерываний. При чтении – текущий тип прерывания: «1» – по событию (фронт или спад), «0» – по уровню. Запись «1» – прерывание формируется по событию для соответствующего канала Запись «0» - не влияет"]
# [inline (always)]
pub const fn edge (& self) -> & Edge { & self . edge } # [doc = "0x18 - Регистр типа прерываний. При чтении – текущий тип прерывания (инвертированный): «0» – по событию; «1» – по уровню. Запись «1» – прерывание формируется по уровню для соответствующего канала Запись «0» - не влияет"]
# [inline (always)]
pub const fn level (& self) -> & Level { & self . level } # [doc = "0x1c - Регистр выбора уровня / события прерываний. При чтении: «0» – прерывания формируются по спаду или уровню логического «0»; «1» – прерывания формируются по нарастающему фронту или уровню логической «1» Запись «1» – прерывание формируется по нарастающему фронту или уровню логической «1» для соответствующего канала"]
# [inline (always)]
pub const fn level_set (& self) -> & LevelSet { & self . level_set } # [doc = "0x20 - Регистр уровня / со-бытия прерываний. При чтении: «0» – прерывания формируются по спаду или уровню логического «0»; «1» – прерывания формируются по нарастающему фронту или уровню логической «1» Запись «1»– прерывание формируется по спаду или уровню логического «0» для соответствующего канала"]
# [inline (always)]
pub const fn level_clear (& self) -> & LevelClear { & self . level_clear } # [doc = "0x24 - Регистр прерываний по любому событию. Запись «1» – прерывание формируется по любому изменению соответствующего канала"]
# [inline (always)]
pub const fn any_edge_set (& self) -> & AnyEdgeSet { & self . any_edge_set } # [doc = "0x28 - Регистр прерываний по любому событию. Запись «1» – прерывание не формируется по любому изменению соответствующего канала"]
# [inline (always)]
pub const fn any_edge_clear (& self) -> & AnyEdgeClear { & self . any_edge_clear } # [doc = "0x2c - Регистр сброса флагов прерываний по событию. Запись «1» – очищает флаг прерывания соответствующего канала"]
# [inline (always)]
pub const fn clear (& self) -> & Clear { & self . clear } } # [doc = "STATE (r) register accessor: Текущее состояние выводов линий после мультисплексоров. Номер бита соответсвует номеру канала.\n\nYou can [`read`](crate::Reg::read) this register and get [`state::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@state`]
module"]
# [doc (alias = "STATE")]
pub type State = crate :: Reg < state :: StateSpec > ; # [doc = "Текущее состояние выводов линий после мультисплексоров. Номер бита соответсвует номеру канала."]
pub mod state { # [doc = "Register `STATE` reader"]
pub type R = crate :: R < StateSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } # [doc = "Текущее состояние выводов линий после мультисплексоров. Номер бита соответсвует номеру канала.\n\nYou can [`read`](crate::Reg::read) this register and get [`state::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StateSpec ; impl crate :: RegisterSpec for StateSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`state::R`](R) reader structure"]
impl crate :: Readable for StateSpec { } # [doc = "`reset()` method sets STATE to value 0"]
impl crate :: Resettable for StateSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "LINE_MUX (rw) register accessor: Управление мультиплексорами. Каждый мультиплесор управляется своими 4 битами: Mux_0 – \\[3:0\\]; Mux_1 – \\[7:4\\]; Mux_2 – \\[11:8\\]; Mux_3 – \\[15:12\\]; Mux_4 – \\[19:16\\]; Mux_5– \\[23:20\\]; Mux_6 – \\[27:24\\]; Mux_7 – \\[31:28\\]\n\nYou can [`read`](crate::Reg::read) this register and get [`line_mux::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`line_mux::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@line_mux`]
module"]
# [doc (alias = "LINE_MUX")]
pub type LineMux = crate :: Reg < line_mux :: LineMuxSpec > ; # [doc = "Управление мультиплексорами. Каждый мультиплесор управляется своими 4 битами: Mux_0 – \\[3:0\\]; Mux_1 – \\[7:4\\]; Mux_2 – \\[11:8\\]; Mux_3 – \\[15:12\\]; Mux_4 – \\[19:16\\]; Mux_5– \\[23:20\\]; Mux_6 – \\[27:24\\]; Mux_7 – \\[31:28\\]"]
pub mod line_mux { # [doc = "Register `LINE_MUX` reader"]
pub type R = crate :: R < LineMuxSpec > ; # [doc = "Register `LINE_MUX` writer"]
pub type W = crate :: W < LineMuxSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Управление мультиплексорами. Каждый мультиплесор управляется своими 4 битами: Mux_0 – \\[3:0\\]; Mux_1 – \\[7:4\\]; Mux_2 – \\[11:8\\]; Mux_3 – \\[15:12\\]; Mux_4 – \\[19:16\\]; Mux_5– \\[23:20\\]; Mux_6 – \\[27:24\\]; Mux_7 – \\[31:28\\]\n\nYou can [`read`](crate::Reg::read) this register and get [`line_mux::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`line_mux::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct LineMuxSpec ; impl crate :: RegisterSpec for LineMuxSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`line_mux::R`](R) reader structure"]
impl crate :: Readable for LineMuxSpec { } # [doc = "`write(|w| ..)` method takes [`line_mux::W`](W) writer structure"]
impl crate :: Writable for LineMuxSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets LINE_MUX to value 0"]
impl crate :: Resettable for LineMuxSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "INTERRUPT (rw) register accessor: Текущее состояние прерываний. Номер бита соответсвует номеру канала.\n\nYou can [`read`](crate::Reg::read) this register and get [`interrupt::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`interrupt::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@interrupt`]
module"]
# [doc (alias = "INTERRUPT")]
pub type Interrupt = crate :: Reg < interrupt :: InterruptSpec > ; # [doc = "Текущее состояние прерываний. Номер бита соответсвует номеру канала."]
pub mod interrupt { # [doc = "Register `INTERRUPT` reader"]
pub type R = crate :: R < InterruptSpec > ; # [doc = "Register `INTERRUPT` writer"]
pub type W = crate :: W < InterruptSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Текущее состояние прерываний. Номер бита соответсвует номеру канала.\n\nYou can [`read`](crate::Reg::read) this register and get [`interrupt::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`interrupt::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct InterruptSpec ; impl crate :: RegisterSpec for InterruptSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`interrupt::R`](R) reader structure"]
impl crate :: Readable for InterruptSpec { } # [doc = "`write(|w| ..)` method takes [`interrupt::W`](W) writer structure"]
impl crate :: Writable for InterruptSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets INTERRUPT to value 0"]
impl crate :: Resettable for InterruptSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ENABLE_SET (rw) register accessor: Регистр разрешения прерываний При чтении – текущее состояние разрешений прерываний. При записи «1» разрешает прерывание от соответствующего канала.\n\nYou can [`read`](crate::Reg::read) this register and get [`enable_set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable_set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable_set`]
module"]
# [doc (alias = "ENABLE_SET")]
pub type EnableSet = crate :: Reg < enable_set :: EnableSetSpec > ; # [doc = "Регистр разрешения прерываний При чтении – текущее состояние разрешений прерываний. При записи «1» разрешает прерывание от соответствующего канала."]
pub mod enable_set { # [doc = "Register `ENABLE_SET` reader"]
pub type R = crate :: R < EnableSetSpec > ; # [doc = "Register `ENABLE_SET` writer"]
pub type W = crate :: W < EnableSetSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр разрешения прерываний При чтении – текущее состояние разрешений прерываний. При записи «1» разрешает прерывание от соответствующего канала.\n\nYou can [`read`](crate::Reg::read) this register and get [`enable_set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable_set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EnableSetSpec ; impl crate :: RegisterSpec for EnableSetSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`enable_set::R`](R) reader structure"]
impl crate :: Readable for EnableSetSpec { } # [doc = "`write(|w| ..)` method takes [`enable_set::W`](W) writer structure"]
impl crate :: Writable for EnableSetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ENABLE_SET to value 0"]
impl crate :: Resettable for EnableSetSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ENABLE_CLEAR (rw) register accessor: Регистр запрета прерываний При чтении – текущее состояние разрешений прерываний. При записи «1» запрещает прерывание от соответствующего канала\n\nYou can [`read`](crate::Reg::read) this register and get [`enable_clear::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable_clear::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@enable_clear`]
module"]
# [doc (alias = "ENABLE_CLEAR")]
pub type EnableClear = crate :: Reg < enable_clear :: EnableClearSpec > ; # [doc = "Регистр запрета прерываний При чтении – текущее состояние разрешений прерываний. При записи «1» запрещает прерывание от соответствующего канала"]
pub mod enable_clear { # [doc = "Register `ENABLE_CLEAR` reader"]
pub type R = crate :: R < EnableClearSpec > ; # [doc = "Register `ENABLE_CLEAR` writer"]
pub type W = crate :: W < EnableClearSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр запрета прерываний При чтении – текущее состояние разрешений прерываний. При записи «1» запрещает прерывание от соответствующего канала\n\nYou can [`read`](crate::Reg::read) this register and get [`enable_clear::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`enable_clear::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EnableClearSpec ; impl crate :: RegisterSpec for EnableClearSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`enable_clear::R`](R) reader structure"]
impl crate :: Readable for EnableClearSpec { } # [doc = "`write(|w| ..)` method takes [`enable_clear::W`](W) writer structure"]
impl crate :: Writable for EnableClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ENABLE_CLEAR to value 0"]
impl crate :: Resettable for EnableClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "EDGE (rw) register accessor: Регистр типа прерываний. При чтении – текущий тип прерывания: «1» – по событию (фронт или спад), «0» – по уровню. Запись «1» – прерывание формируется по событию для соответствующего канала Запись «0» - не влияет\n\nYou can [`read`](crate::Reg::read) this register and get [`edge::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`edge::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@edge`]
module"]
# [doc (alias = "EDGE")]
pub type Edge = crate :: Reg < edge :: EdgeSpec > ; # [doc = "Регистр типа прерываний. При чтении – текущий тип прерывания: «1» – по событию (фронт или спад), «0» – по уровню. Запись «1» – прерывание формируется по событию для соответствующего канала Запись «0» - не влияет"]
pub mod edge { # [doc = "Register `EDGE` reader"]
pub type R = crate :: R < EdgeSpec > ; # [doc = "Register `EDGE` writer"]
pub type W = crate :: W < EdgeSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр типа прерываний. При чтении – текущий тип прерывания: «1» – по событию (фронт или спад), «0» – по уровню. Запись «1» – прерывание формируется по событию для соответствующего канала Запись «0» - не влияет\n\nYou can [`read`](crate::Reg::read) this register and get [`edge::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`edge::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct EdgeSpec ; impl crate :: RegisterSpec for EdgeSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`edge::R`](R) reader structure"]
impl crate :: Readable for EdgeSpec { } # [doc = "`write(|w| ..)` method takes [`edge::W`](W) writer structure"]
impl crate :: Writable for EdgeSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets EDGE to value 0"]
impl crate :: Resettable for EdgeSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "LEVEL (rw) register accessor: Регистр типа прерываний. При чтении – текущий тип прерывания (инвертированный): «0» – по событию; «1» – по уровню. Запись «1» – прерывание формируется по уровню для соответствующего канала Запись «0» - не влияет\n\nYou can [`read`](crate::Reg::read) this register and get [`level::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`level::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@level`]
module"]
# [doc (alias = "LEVEL")]
pub type Level = crate :: Reg < level :: LevelSpec > ; # [doc = "Регистр типа прерываний. При чтении – текущий тип прерывания (инвертированный): «0» – по событию; «1» – по уровню. Запись «1» – прерывание формируется по уровню для соответствующего канала Запись «0» - не влияет"]
pub mod level { # [doc = "Register `LEVEL` reader"]
pub type R = crate :: R < LevelSpec > ; # [doc = "Register `LEVEL` writer"]
pub type W = crate :: W < LevelSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр типа прерываний. При чтении – текущий тип прерывания (инвертированный): «0» – по событию; «1» – по уровню. Запись «1» – прерывание формируется по уровню для соответствующего канала Запись «0» - не влияет\n\nYou can [`read`](crate::Reg::read) this register and get [`level::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`level::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct LevelSpec ; impl crate :: RegisterSpec for LevelSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`level::R`](R) reader structure"]
impl crate :: Readable for LevelSpec { } # [doc = "`write(|w| ..)` method takes [`level::W`](W) writer structure"]
impl crate :: Writable for LevelSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets LEVEL to value 0xff"]
impl crate :: Resettable for LevelSpec { const RESET_VALUE : u32 = 0xff ; } } # [doc = "LEVEL_SET (rw) register accessor: Регистр выбора уровня / события прерываний. При чтении: «0» – прерывания формируются по спаду или уровню логического «0»; «1» – прерывания формируются по нарастающему фронту или уровню логической «1» Запись «1» – прерывание формируется по нарастающему фронту или уровню логической «1» для соответствующего канала\n\nYou can [`read`](crate::Reg::read) this register and get [`level_set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`level_set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@level_set`]
module"]
# [doc (alias = "LEVEL_SET")]
pub type LevelSet = crate :: Reg < level_set :: LevelSetSpec > ; # [doc = "Регистр выбора уровня / события прерываний. При чтении: «0» – прерывания формируются по спаду или уровню логического «0»; «1» – прерывания формируются по нарастающему фронту или уровню логической «1» Запись «1» – прерывание формируется по нарастающему фронту или уровню логической «1» для соответствующего канала"]
pub mod level_set { # [doc = "Register `LEVEL_SET` reader"]
pub type R = crate :: R < LevelSetSpec > ; # [doc = "Register `LEVEL_SET` writer"]
pub type W = crate :: W < LevelSetSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр выбора уровня / события прерываний. При чтении: «0» – прерывания формируются по спаду или уровню логического «0»; «1» – прерывания формируются по нарастающему фронту или уровню логической «1» Запись «1» – прерывание формируется по нарастающему фронту или уровню логической «1» для соответствующего канала\n\nYou can [`read`](crate::Reg::read) this register and get [`level_set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`level_set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct LevelSetSpec ; impl crate :: RegisterSpec for LevelSetSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`level_set::R`](R) reader structure"]
impl crate :: Readable for LevelSetSpec { } # [doc = "`write(|w| ..)` method takes [`level_set::W`](W) writer structure"]
impl crate :: Writable for LevelSetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets LEVEL_SET to value 0"]
impl crate :: Resettable for LevelSetSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "LEVEL_CLEAR (rw) register accessor: Регистр уровня / со-бытия прерываний. При чтении: «0» – прерывания формируются по спаду или уровню логического «0»; «1» – прерывания формируются по нарастающему фронту или уровню логической «1» Запись «1»– прерывание формируется по спаду или уровню логического «0» для соответствующего канала\n\nYou can [`read`](crate::Reg::read) this register and get [`level_clear::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`level_clear::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@level_clear`]
module"]
# [doc (alias = "LEVEL_CLEAR")]
pub type LevelClear = crate :: Reg < level_clear :: LevelClearSpec > ; # [doc = "Регистр уровня / со-бытия прерываний. При чтении: «0» – прерывания формируются по спаду или уровню логического «0»; «1» – прерывания формируются по нарастающему фронту или уровню логической «1» Запись «1»– прерывание формируется по спаду или уровню логического «0» для соответствующего канала"]
pub mod level_clear { # [doc = "Register `LEVEL_CLEAR` reader"]
pub type R = crate :: R < LevelClearSpec > ; # [doc = "Register `LEVEL_CLEAR` writer"]
pub type W = crate :: W < LevelClearSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр уровня / со-бытия прерываний. При чтении: «0» – прерывания формируются по спаду или уровню логического «0»; «1» – прерывания формируются по нарастающему фронту или уровню логической «1» Запись «1»– прерывание формируется по спаду или уровню логического «0» для соответствующего канала\n\nYou can [`read`](crate::Reg::read) this register and get [`level_clear::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`level_clear::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct LevelClearSpec ; impl crate :: RegisterSpec for LevelClearSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`level_clear::R`](R) reader structure"]
impl crate :: Readable for LevelClearSpec { } # [doc = "`write(|w| ..)` method takes [`level_clear::W`](W) writer structure"]
impl crate :: Writable for LevelClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets LEVEL_CLEAR to value 0"]
impl crate :: Resettable for LevelClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ANY_EDGE_SET (rw) register accessor: Регистр прерываний по любому событию. Запись «1» – прерывание формируется по любому изменению соответствующего канала\n\nYou can [`read`](crate::Reg::read) this register and get [`any_edge_set::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`any_edge_set::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@any_edge_set`]
module"]
# [doc (alias = "ANY_EDGE_SET")]
pub type AnyEdgeSet = crate :: Reg < any_edge_set :: AnyEdgeSetSpec > ; # [doc = "Регистр прерываний по любому событию. Запись «1» – прерывание формируется по любому изменению соответствующего канала"]
pub mod any_edge_set { # [doc = "Register `ANY_EDGE_SET` reader"]
pub type R = crate :: R < AnyEdgeSetSpec > ; # [doc = "Register `ANY_EDGE_SET` writer"]
pub type W = crate :: W < AnyEdgeSetSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр прерываний по любому событию. Запись «1» – прерывание формируется по любому изменению соответствующего канала\n\nYou can [`read`](crate::Reg::read) this register and get [`any_edge_set::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`any_edge_set::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AnyEdgeSetSpec ; impl crate :: RegisterSpec for AnyEdgeSetSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`any_edge_set::R`](R) reader structure"]
impl crate :: Readable for AnyEdgeSetSpec { } # [doc = "`write(|w| ..)` method takes [`any_edge_set::W`](W) writer structure"]
impl crate :: Writable for AnyEdgeSetSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ANY_EDGE_SET to value 0"]
impl crate :: Resettable for AnyEdgeSetSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ANY_EDGE_CLEAR (rw) register accessor: Регистр прерываний по любому событию. Запись «1» – прерывание не формируется по любому изменению соответствующего канала\n\nYou can [`read`](crate::Reg::read) this register and get [`any_edge_clear::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`any_edge_clear::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@any_edge_clear`]
module"]
# [doc (alias = "ANY_EDGE_CLEAR")]
pub type AnyEdgeClear = crate :: Reg < any_edge_clear :: AnyEdgeClearSpec > ; # [doc = "Регистр прерываний по любому событию. Запись «1» – прерывание не формируется по любому изменению соответствующего канала"]
pub mod any_edge_clear { # [doc = "Register `ANY_EDGE_CLEAR` reader"]
pub type R = crate :: R < AnyEdgeClearSpec > ; # [doc = "Register `ANY_EDGE_CLEAR` writer"]
pub type W = crate :: W < AnyEdgeClearSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр прерываний по любому событию. Запись «1» – прерывание не формируется по любому изменению соответствующего канала\n\nYou can [`read`](crate::Reg::read) this register and get [`any_edge_clear::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`any_edge_clear::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AnyEdgeClearSpec ; impl crate :: RegisterSpec for AnyEdgeClearSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`any_edge_clear::R`](R) reader structure"]
impl crate :: Readable for AnyEdgeClearSpec { } # [doc = "`write(|w| ..)` method takes [`any_edge_clear::W`](W) writer structure"]
impl crate :: Writable for AnyEdgeClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ANY_EDGE_CLEAR to value 0"]
impl crate :: Resettable for AnyEdgeClearSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "CLEAR (w) register accessor: Регистр сброса флагов прерываний по событию. Запись «1» – очищает флаг прерывания соответствующего канала\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clear::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@clear`]
module"]
# [doc (alias = "CLEAR")]
pub type Clear = crate :: Reg < clear :: ClearSpec > ; # [doc = "Регистр сброса флагов прерываний по событию. Запись «1» – очищает флаг прерывания соответствующего канала"]
pub mod clear { # [doc = "Register `CLEAR` writer"]
pub type W = crate :: W < ClearSpec > ; impl core :: fmt :: Debug for crate :: generic :: Reg < ClearSpec > { fn fmt (& self , f : & mut core :: fmt :: Formatter < '_ >) -> core :: fmt :: Result { write ! (f , "(not readable)") } } impl W { } # [doc = "Регистр сброса флагов прерываний по событию. Запись «1» – очищает флаг прерывания соответствующего канала\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`clear::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ClearSpec ; impl crate :: RegisterSpec for ClearSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`clear::W`](W) writer structure"]
impl crate :: Writable for ClearSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CLEAR to value 0"]
impl crate :: Resettable for ClearSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Управление ЦАП"]
pub struct Dac0 { _marker : PhantomData < * const () > } unsafe impl Send for Dac0 { } impl Dac0 { # [doc = r"Pointer to the register block"]
pub const PTR : * const dac0 :: RegisterBlock = 0x0008_5000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const dac0 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Dac0 { type Target = dac0 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Dac0 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dac0") . finish () } } # [doc = "Управление ЦАП"]
pub mod dac0 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { dac0_cfg : Dac0Cfg , dac0_value : Dac0Value , } impl RegisterBlock { # [doc = "0x00 - Регистр настойки ЦАП0"]
# [inline (always)]
pub const fn dac0_cfg (& self) -> & Dac0Cfg { & self . dac0_cfg } # [doc = "0x04 - Входные данные для ЦАП0"]
# [inline (always)]
pub const fn dac0_value (& self) -> & Dac0Value { & self . dac0_value } } # [doc = "DAC0_CFG (rw) register accessor: Регистр настойки ЦАП0\n\nYou can [`read`](crate::Reg::read) this register and get [`dac0_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dac0_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dac0_cfg`]
module"]
# [doc (alias = "DAC0_CFG")]
pub type Dac0Cfg = crate :: Reg < dac0_cfg :: Dac0CfgSpec > ; # [doc = "Регистр настойки ЦАП0"]
pub mod dac0_cfg { # [doc = "Register `DAC0_CFG` reader"]
pub type R = crate :: R < Dac0CfgSpec > ; # [doc = "Register `DAC0_CFG` writer"]
pub type W = crate :: W < Dac0CfgSpec > ; # [doc = "Управление питанием ЦАП\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum En { # [doc = "0: Выключен"]
Disable = 0 , # [doc = "1: Включен"]
Enable = 1 , } impl From < En > for bool { # [inline (always)]
fn from (variant : En) -> Self { variant as u8 != 0 } } # [doc = "Field `EN` reader - Управление питанием ЦАП"]
pub type EnR = crate :: BitReader < En > ; impl EnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> En { match self . bits { false => En :: Disable , true => En :: Enable , } } # [doc = "Выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == En :: Disable } # [doc = "Включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == En :: Enable } } # [doc = "Field `EN` writer - Управление питанием ЦАП"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG , En > ; impl < 'a , REG > EnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Disable) } # [doc = "Включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Enable) } } # [doc = "Field `RN` reader - Управление сбросом ЦАП, активный уровень «0»"]
pub type RnR = crate :: BitReader ; # [doc = "Field `RN` writer - Управление сбросом ЦАП, активный уровень «0»"]
pub type RnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `DIV` reader - Значение делителя тактового сигнала. Частота определяется как FЦАП=FIN/(DIV+1)"]
pub type DivR = crate :: FieldReader ; # [doc = "Field `DIV` writer - Значение делителя тактового сигнала. Частота определяется как FЦАП=FIN/(DIV+1)"]
pub type DivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Выбор источника опорного напряжения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Exten { # [doc = "0: Встроенный"]
Internal = 0 , # [doc = "1: Внешний"]
External = 1 , } impl From < Exten > for bool { # [inline (always)]
fn from (variant : Exten) -> Self { variant as u8 != 0 } } # [doc = "Field `EXTEN` reader - Выбор источника опорного напряжения"]
pub type ExtenR = crate :: BitReader < Exten > ; impl ExtenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Exten { match self . bits { false => Exten :: Internal , true => Exten :: External , } } # [doc = "Встроенный"]
# [inline (always)]
pub fn is_internal (& self) -> bool { * self == Exten :: Internal } # [doc = "Внешний"]
# [inline (always)]
pub fn is_external (& self) -> bool { * self == Exten :: External } } # [doc = "Field `EXTEN` writer - Выбор источника опорного напряжения"]
pub type ExtenW < 'a , REG > = crate :: BitWriter < 'a , REG , Exten > ; impl < 'a , REG > ExtenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Встроенный"]
# [inline (always)]
pub fn internal (self) -> & 'a mut crate :: W < REG > { self . variant (Exten :: Internal) } # [doc = "Внешний"]
# [inline (always)]
pub fn external (self) -> & 'a mut crate :: W < REG > { self . variant (Exten :: External) } } # [doc = "Выбор источника внешнего опорного напряжения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Extpad { # [doc = "0: Настраиваемый ИОН"]
CalibratedVoltageReference = 0 , # [doc = "1: Внешний вывод REF_ADC_DAC (PORT1_11)"]
RefDacPin = 1 , } impl From < Extpad > for bool { # [inline (always)]
fn from (variant : Extpad) -> Self { variant as u8 != 0 } } # [doc = "Field `EXTPAD` reader - Выбор источника внешнего опорного напряжения"]
pub type ExtpadR = crate :: BitReader < Extpad > ; impl ExtpadR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Extpad { match self . bits { false => Extpad :: CalibratedVoltageReference , true => Extpad :: RefDacPin , } } # [doc = "Настраиваемый ИОН"]
# [inline (always)]
pub fn is_calibrated_voltage_reference (& self) -> bool { * self == Extpad :: CalibratedVoltageReference } # [doc = "Внешний вывод REF_ADC_DAC (PORT1_11)"]
# [inline (always)]
pub fn is_ref_dac_pin (& self) -> bool { * self == Extpad :: RefDacPin } } # [doc = "Field `EXTPAD` writer - Выбор источника внешнего опорного напряжения"]
pub type ExtpadW < 'a , REG > = crate :: BitWriter < 'a , REG , Extpad > ; impl < 'a , REG > ExtpadW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Настраиваемый ИОН"]
# [inline (always)]
pub fn calibrated_voltage_reference (self) -> & 'a mut crate :: W < REG > { self . variant (Extpad :: CalibratedVoltageReference) } # [doc = "Внешний вывод REF_ADC_DAC (PORT1_11)"]
# [inline (always)]
pub fn ref_dac_pin (self) -> & 'a mut crate :: W < REG > { self . variant (Extpad :: RefDacPin) } } # [doc = "Признак заполненности регистра DAC_VALUE\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EmptyRead { # [doc = "0: Значение, хранящееся в DAC_VALUE было сдвинуто в ЦАП, возможна запись следующего значения"]
Full = 0 , # [doc = "1: В регистре DAC_Value находится необработанное значение. Автоматически сбрасывается при записи в DAC_Value"]
Empty = 1 , } impl From < EmptyRead > for bool { # [inline (always)]
fn from (variant : EmptyRead) -> Self { variant as u8 != 0 } } # [doc = "Field `EMPTY_READ` reader - Признак заполненности регистра DAC_VALUE"]
pub type EmptyReadR = crate :: BitReader < EmptyRead > ; impl EmptyReadR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> EmptyRead { match self . bits { false => EmptyRead :: Full , true => EmptyRead :: Empty , } } # [doc = "Значение, хранящееся в DAC_VALUE было сдвинуто в ЦАП, возможна запись следующего значения"]
# [inline (always)]
pub fn is_full (& self) -> bool { * self == EmptyRead :: Full } # [doc = "В регистре DAC_Value находится необработанное значение. Автоматически сбрасывается при записи в DAC_Value"]
# [inline (always)]
pub fn is_empty (& self) -> bool { * self == EmptyRead :: Empty } } impl R { # [doc = "Bit 0 - Управление питанием ЦАП"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Управление сбросом ЦАП, активный уровень «0»"]
# [inline (always)]
pub fn rn (& self) -> RnR { RnR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:9 - Значение делителя тактового сигнала. Частота определяется как FЦАП=FIN/(DIV+1)"]
# [inline (always)]
pub fn div (& self) -> DivR { DivR :: new (((self . bits >> 2) & 0xff) as u8) } # [doc = "Bit 10 - Выбор источника опорного напряжения"]
# [inline (always)]
pub fn exten (& self) -> ExtenR { ExtenR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Выбор источника внешнего опорного напряжения"]
# [inline (always)]
pub fn extpad (& self) -> ExtpadR { ExtpadR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 13 - Признак заполненности регистра DAC_VALUE"]
# [inline (always)]
pub fn empty_read (& self) -> EmptyReadR { EmptyReadR :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление питанием ЦАП"]
# [inline (always)]
pub fn en (& mut self) -> EnW < Dac0CfgSpec > { EnW :: new (self , 0) } # [doc = "Bit 1 - Управление сбросом ЦАП, активный уровень «0»"]
# [inline (always)]
pub fn rn (& mut self) -> RnW < Dac0CfgSpec > { RnW :: new (self , 1) } # [doc = "Bits 2:9 - Значение делителя тактового сигнала. Частота определяется как FЦАП=FIN/(DIV+1)"]
# [inline (always)]
pub fn div (& mut self) -> DivW < Dac0CfgSpec > { DivW :: new (self , 2) } # [doc = "Bit 10 - Выбор источника опорного напряжения"]
# [inline (always)]
pub fn exten (& mut self) -> ExtenW < Dac0CfgSpec > { ExtenW :: new (self , 10) } # [doc = "Bit 11 - Выбор источника внешнего опорного напряжения"]
# [inline (always)]
pub fn extpad (& mut self) -> ExtpadW < Dac0CfgSpec > { ExtpadW :: new (self , 11) } } # [doc = "Регистр настойки ЦАП0\n\nYou can [`read`](crate::Reg::read) this register and get [`dac0_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dac0_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Dac0CfgSpec ; impl crate :: RegisterSpec for Dac0CfgSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dac0_cfg::R`](R) reader structure"]
impl crate :: Readable for Dac0CfgSpec { } # [doc = "`write(|w| ..)` method takes [`dac0_cfg::W`](W) writer structure"]
impl crate :: Writable for Dac0CfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DAC0_CFG to value 0"]
impl crate :: Resettable for Dac0CfgSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DAC0_VALUE (rw) register accessor: Входные данные для ЦАП0\n\nYou can [`read`](crate::Reg::read) this register and get [`dac0_value::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dac0_value::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dac0_value`]
module"]
# [doc (alias = "DAC0_VALUE")]
pub type Dac0Value = crate :: Reg < dac0_value :: Dac0ValueSpec > ; # [doc = "Входные данные для ЦАП0"]
pub mod dac0_value { # [doc = "Register `DAC0_VALUE` reader"]
pub type R = crate :: R < Dac0ValueSpec > ; # [doc = "Register `DAC0_VALUE` writer"]
pub type W = crate :: W < Dac0ValueSpec > ; # [doc = "Field `VALUE` reader - Входные данные для прерывания"]
pub type ValueR = crate :: FieldReader < u16 > ; # [doc = "Field `VALUE` writer - Входные данные для прерывания"]
pub type ValueW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R { # [doc = "Bits 0:11 - Входные данные для прерывания"]
# [inline (always)]
pub fn value (& self) -> ValueR { ValueR :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11 - Входные данные для прерывания"]
# [inline (always)]
pub fn value (& mut self) -> ValueW < Dac0ValueSpec > { ValueW :: new (self , 0) } } # [doc = "Входные данные для ЦАП0\n\nYou can [`read`](crate::Reg::read) this register and get [`dac0_value::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dac0_value::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Dac0ValueSpec ; impl crate :: RegisterSpec for Dac0ValueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dac0_value::R`](R) reader structure"]
impl crate :: Readable for Dac0ValueSpec { } # [doc = "`write(|w| ..)` method takes [`dac0_value::W`](W) writer structure"]
impl crate :: Writable for Dac0ValueSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DAC0_VALUE to value 0"]
impl crate :: Resettable for Dac0ValueSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Управление ЦАП"]
pub struct Dac1 { _marker : PhantomData < * const () > } unsafe impl Send for Dac1 { } impl Dac1 { # [doc = r"Pointer to the register block"]
pub const PTR : * const dac1 :: RegisterBlock = 0x0008_5008 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const dac1 :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Dac1 { type Target = dac1 :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Dac1 { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Dac1") . finish () } } # [doc = "Управление ЦАП"]
pub mod dac1 { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { dac1_cfg : Dac1Cfg , dac1_value : Dac1Value , } impl RegisterBlock { # [doc = "0x00 - Регистр настойки ЦАП1"]
# [inline (always)]
pub const fn dac1_cfg (& self) -> & Dac1Cfg { & self . dac1_cfg } # [doc = "0x04 - Входные данные для ЦАП1"]
# [inline (always)]
pub const fn dac1_value (& self) -> & Dac1Value { & self . dac1_value } } # [doc = "DAC1_CFG (rw) register accessor: Регистр настойки ЦАП1\n\nYou can [`read`](crate::Reg::read) this register and get [`dac1_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dac1_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dac1_cfg`]
module"]
# [doc (alias = "DAC1_CFG")]
pub type Dac1Cfg = crate :: Reg < dac1_cfg :: Dac1CfgSpec > ; # [doc = "Регистр настойки ЦАП1"]
pub mod dac1_cfg { # [doc = "Register `DAC1_CFG` reader"]
pub type R = crate :: R < Dac1CfgSpec > ; # [doc = "Register `DAC1_CFG` writer"]
pub type W = crate :: W < Dac1CfgSpec > ; # [doc = "Управление питанием ЦАП\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum En { # [doc = "0: Выключен"]
Disable = 0 , # [doc = "1: Включен"]
Enable = 1 , } impl From < En > for bool { # [inline (always)]
fn from (variant : En) -> Self { variant as u8 != 0 } } # [doc = "Field `EN` reader - Управление питанием ЦАП"]
pub type EnR = crate :: BitReader < En > ; impl EnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> En { match self . bits { false => En :: Disable , true => En :: Enable , } } # [doc = "Выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == En :: Disable } # [doc = "Включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == En :: Enable } } # [doc = "Field `EN` writer - Управление питанием ЦАП"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG , En > ; impl < 'a , REG > EnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Disable) } # [doc = "Включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Enable) } } # [doc = "Field `RN` reader - Управление сбросом ЦАП, активный уровень «0»"]
pub type RnR = crate :: BitReader ; # [doc = "Field `RN` writer - Управление сбросом ЦАП, активный уровень «0»"]
pub type RnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `DIV` reader - Значение делителя тактового сигнала. Частота определяется как FЦАП=FIN/(DIV+1)"]
pub type DivR = crate :: FieldReader ; # [doc = "Field `DIV` writer - Значение делителя тактового сигнала. Частота определяется как FЦАП=FIN/(DIV+1)"]
pub type DivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 8 > ; # [doc = "Выбор источника опорного напряжения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Exten { # [doc = "0: Встроенный"]
Internal = 0 , # [doc = "1: Внешний"]
External = 1 , } impl From < Exten > for bool { # [inline (always)]
fn from (variant : Exten) -> Self { variant as u8 != 0 } } # [doc = "Field `EXTEN` reader - Выбор источника опорного напряжения"]
pub type ExtenR = crate :: BitReader < Exten > ; impl ExtenR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Exten { match self . bits { false => Exten :: Internal , true => Exten :: External , } } # [doc = "Встроенный"]
# [inline (always)]
pub fn is_internal (& self) -> bool { * self == Exten :: Internal } # [doc = "Внешний"]
# [inline (always)]
pub fn is_external (& self) -> bool { * self == Exten :: External } } # [doc = "Field `EXTEN` writer - Выбор источника опорного напряжения"]
pub type ExtenW < 'a , REG > = crate :: BitWriter < 'a , REG , Exten > ; impl < 'a , REG > ExtenW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Встроенный"]
# [inline (always)]
pub fn internal (self) -> & 'a mut crate :: W < REG > { self . variant (Exten :: Internal) } # [doc = "Внешний"]
# [inline (always)]
pub fn external (self) -> & 'a mut crate :: W < REG > { self . variant (Exten :: External) } } # [doc = "Выбор источника внешнего опорного напряжения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Extpad { # [doc = "0: Настраиваемый ИОН"]
CalibratedVoltageReference = 0 , # [doc = "1: Внешний вывод REF_ADC_DAC (PORT1_11)"]
RefDacPin = 1 , } impl From < Extpad > for bool { # [inline (always)]
fn from (variant : Extpad) -> Self { variant as u8 != 0 } } # [doc = "Field `EXTPAD` reader - Выбор источника внешнего опорного напряжения"]
pub type ExtpadR = crate :: BitReader < Extpad > ; impl ExtpadR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Extpad { match self . bits { false => Extpad :: CalibratedVoltageReference , true => Extpad :: RefDacPin , } } # [doc = "Настраиваемый ИОН"]
# [inline (always)]
pub fn is_calibrated_voltage_reference (& self) -> bool { * self == Extpad :: CalibratedVoltageReference } # [doc = "Внешний вывод REF_ADC_DAC (PORT1_11)"]
# [inline (always)]
pub fn is_ref_dac_pin (& self) -> bool { * self == Extpad :: RefDacPin } } # [doc = "Field `EXTPAD` writer - Выбор источника внешнего опорного напряжения"]
pub type ExtpadW < 'a , REG > = crate :: BitWriter < 'a , REG , Extpad > ; impl < 'a , REG > ExtpadW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Настраиваемый ИОН"]
# [inline (always)]
pub fn calibrated_voltage_reference (self) -> & 'a mut crate :: W < REG > { self . variant (Extpad :: CalibratedVoltageReference) } # [doc = "Внешний вывод REF_ADC_DAC (PORT1_11)"]
# [inline (always)]
pub fn ref_dac_pin (self) -> & 'a mut crate :: W < REG > { self . variant (Extpad :: RefDacPin) } } # [doc = "Признак заполненности регистра DAC_VALUE\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum EmptyRead { # [doc = "0: Значение, хранящееся в DAC_VALUE было сдвинуто в ЦАП, возможна запись следующего значения"]
Full = 0 , # [doc = "1: В регистре DAC_Value находится необработанное значение. Автоматически сбрасывается при записи в DAC_Value"]
Empty = 1 , } impl From < EmptyRead > for bool { # [inline (always)]
fn from (variant : EmptyRead) -> Self { variant as u8 != 0 } } # [doc = "Field `EMPTY_READ` reader - Признак заполненности регистра DAC_VALUE"]
pub type EmptyReadR = crate :: BitReader < EmptyRead > ; impl EmptyReadR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> EmptyRead { match self . bits { false => EmptyRead :: Full , true => EmptyRead :: Empty , } } # [doc = "Значение, хранящееся в DAC_VALUE было сдвинуто в ЦАП, возможна запись следующего значения"]
# [inline (always)]
pub fn is_full (& self) -> bool { * self == EmptyRead :: Full } # [doc = "В регистре DAC_Value находится необработанное значение. Автоматически сбрасывается при записи в DAC_Value"]
# [inline (always)]
pub fn is_empty (& self) -> bool { * self == EmptyRead :: Empty } } impl R { # [doc = "Bit 0 - Управление питанием ЦАП"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Управление сбросом ЦАП, активный уровень «0»"]
# [inline (always)]
pub fn rn (& self) -> RnR { RnR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bits 2:9 - Значение делителя тактового сигнала. Частота определяется как FЦАП=FIN/(DIV+1)"]
# [inline (always)]
pub fn div (& self) -> DivR { DivR :: new (((self . bits >> 2) & 0xff) as u8) } # [doc = "Bit 10 - Выбор источника опорного напряжения"]
# [inline (always)]
pub fn exten (& self) -> ExtenR { ExtenR :: new (((self . bits >> 10) & 1) != 0) } # [doc = "Bit 11 - Выбор источника внешнего опорного напряжения"]
# [inline (always)]
pub fn extpad (& self) -> ExtpadR { ExtpadR :: new (((self . bits >> 11) & 1) != 0) } # [doc = "Bit 13 - Признак заполненности регистра DAC_VALUE"]
# [inline (always)]
pub fn empty_read (& self) -> EmptyReadR { EmptyReadR :: new (((self . bits >> 13) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление питанием ЦАП"]
# [inline (always)]
pub fn en (& mut self) -> EnW < Dac1CfgSpec > { EnW :: new (self , 0) } # [doc = "Bit 1 - Управление сбросом ЦАП, активный уровень «0»"]
# [inline (always)]
pub fn rn (& mut self) -> RnW < Dac1CfgSpec > { RnW :: new (self , 1) } # [doc = "Bits 2:9 - Значение делителя тактового сигнала. Частота определяется как FЦАП=FIN/(DIV+1)"]
# [inline (always)]
pub fn div (& mut self) -> DivW < Dac1CfgSpec > { DivW :: new (self , 2) } # [doc = "Bit 10 - Выбор источника опорного напряжения"]
# [inline (always)]
pub fn exten (& mut self) -> ExtenW < Dac1CfgSpec > { ExtenW :: new (self , 10) } # [doc = "Bit 11 - Выбор источника внешнего опорного напряжения"]
# [inline (always)]
pub fn extpad (& mut self) -> ExtpadW < Dac1CfgSpec > { ExtpadW :: new (self , 11) } } # [doc = "Регистр настойки ЦАП1\n\nYou can [`read`](crate::Reg::read) this register and get [`dac1_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dac1_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Dac1CfgSpec ; impl crate :: RegisterSpec for Dac1CfgSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dac1_cfg::R`](R) reader structure"]
impl crate :: Readable for Dac1CfgSpec { } # [doc = "`write(|w| ..)` method takes [`dac1_cfg::W`](W) writer structure"]
impl crate :: Writable for Dac1CfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DAC1_CFG to value 0"]
impl crate :: Resettable for Dac1CfgSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "DAC1_VALUE (rw) register accessor: Входные данные для ЦАП1\n\nYou can [`read`](crate::Reg::read) this register and get [`dac1_value::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dac1_value::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dac1_value`]
module"]
# [doc (alias = "DAC1_VALUE")]
pub type Dac1Value = crate :: Reg < dac1_value :: Dac1ValueSpec > ; # [doc = "Входные данные для ЦАП1"]
pub mod dac1_value { # [doc = "Register `DAC1_VALUE` reader"]
pub type R = crate :: R < Dac1ValueSpec > ; # [doc = "Register `DAC1_VALUE` writer"]
pub type W = crate :: W < Dac1ValueSpec > ; # [doc = "Field `VALUE` reader - Входные данные для прерывания"]
pub type ValueR = crate :: FieldReader < u16 > ; # [doc = "Field `VALUE` writer - Входные данные для прерывания"]
pub type ValueW < 'a , REG > = crate :: FieldWriter < 'a , REG , 12 , u16 > ; impl R { # [doc = "Bits 0:11 - Входные данные для прерывания"]
# [inline (always)]
pub fn value (& self) -> ValueR { ValueR :: new ((self . bits & 0x0fff) as u16) } } impl W { # [doc = "Bits 0:11 - Входные данные для прерывания"]
# [inline (always)]
pub fn value (& mut self) -> ValueW < Dac1ValueSpec > { ValueW :: new (self , 0) } } # [doc = "Входные данные для ЦАП1\n\nYou can [`read`](crate::Reg::read) this register and get [`dac1_value::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dac1_value::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct Dac1ValueSpec ; impl crate :: RegisterSpec for Dac1ValueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dac1_value::R`](R) reader structure"]
impl crate :: Readable for Dac1ValueSpec { } # [doc = "`write(|w| ..)` method takes [`dac1_value::W`](W) writer structure"]
impl crate :: Writable for Dac1ValueSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DAC1_VALUE to value 0"]
impl crate :: Resettable for Dac1ValueSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Управление монитором напряжения AVCC"]
pub struct PvdAvcc { _marker : PhantomData < * const () > } unsafe impl Send for PvdAvcc { } impl PvdAvcc { # [doc = r"Pointer to the register block"]
pub const PTR : * const pvd_avcc :: RegisterBlock = 0x0008_5010 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const pvd_avcc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for PvdAvcc { type Target = pvd_avcc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for PvdAvcc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("PvdAvcc") . finish () } } # [doc = "Управление монитором напряжения AVCC"]
pub mod pvd_avcc { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { dpf_value : DpfValue , config : Config , status : Status , } impl RegisterBlock { # [doc = "0x00 - Настройка цифрового фильтра"]
# [inline (always)]
pub const fn dpf_value (& self) -> & DpfValue { & self . dpf_value } # [doc = "0x04 - Регистр настроек"]
# [inline (always)]
pub const fn config (& self) -> & Config { & self . config } # [doc = "0x08 - Регистр статуса"]
# [inline (always)]
pub const fn status (& self) -> & Status { & self . status } } # [doc = "DPF_VALUE (rw) register accessor: Настройка цифрового фильтра\n\nYou can [`read`](crate::Reg::read) this register and get [`dpf_value::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dpf_value::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@dpf_value`]
module"]
# [doc (alias = "DPF_VALUE")]
pub type DpfValue = crate :: Reg < dpf_value :: DpfValueSpec > ; # [doc = "Настройка цифрового фильтра"]
pub mod dpf_value { # [doc = "Register `DPF_VALUE` reader"]
pub type R = crate :: R < DpfValueSpec > ; # [doc = "Register `DPF_VALUE` writer"]
pub type W = crate :: W < DpfValueSpec > ; # [doc = "Field `DPF` reader - Коэффициент, определяющий длительность отфильтровываемых импульсов (на системной частоте)"]
pub type DpfR = crate :: FieldReader < u16 > ; # [doc = "Field `DPF` writer - Коэффициент, определяющий длительность отфильтровываемых импульсов (на системной частоте)"]
pub type DpfW < 'a , REG > = crate :: FieldWriter < 'a , REG , 16 , u16 > ; impl R { # [doc = "Bits 0:15 - Коэффициент, определяющий длительность отфильтровываемых импульсов (на системной частоте)"]
# [inline (always)]
pub fn dpf (& self) -> DpfR { DpfR :: new ((self . bits & 0xffff) as u16) } } impl W { # [doc = "Bits 0:15 - Коэффициент, определяющий длительность отфильтровываемых импульсов (на системной частоте)"]
# [inline (always)]
pub fn dpf (& mut self) -> DpfW < DpfValueSpec > { DpfW :: new (self , 0) } } # [doc = "Настройка цифрового фильтра\n\nYou can [`read`](crate::Reg::read) this register and get [`dpf_value::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`dpf_value::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct DpfValueSpec ; impl crate :: RegisterSpec for DpfValueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`dpf_value::R`](R) reader structure"]
impl crate :: Readable for DpfValueSpec { } # [doc = "`write(|w| ..)` method takes [`dpf_value::W`](W) writer structure"]
impl crate :: Writable for DpfValueSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets DPF_VALUE to value 0x05dc"]
impl crate :: Resettable for DpfValueSpec { const RESET_VALUE : u32 = 0x05dc ; } } # [doc = "CONFIG (rw) register accessor: Регистр настроек\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@config`]
module"]
# [doc (alias = "CONFIG")]
pub type Config = crate :: Reg < config :: ConfigSpec > ; # [doc = "Регистр настроек"]
pub mod config { # [doc = "Register `CONFIG` reader"]
pub type R = crate :: R < ConfigSpec > ; # [doc = "Register `CONFIG` writer"]
pub type W = crate :: W < ConfigSpec > ; # [doc = "Управление питанием монитора\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Pd { # [doc = "0: Монитор включен"]
Enable = 0 , # [doc = "1: Монитор выключен"]
Disable = 1 , } impl From < Pd > for bool { # [inline (always)]
fn from (variant : Pd) -> Self { variant as u8 != 0 } } # [doc = "Field `PD` reader - Управление питанием монитора"]
pub type PdR = crate :: BitReader < Pd > ; impl PdR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Pd { match self . bits { false => Pd :: Enable , true => Pd :: Disable , } } # [doc = "Монитор включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Pd :: Enable } # [doc = "Монитор выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Pd :: Disable } } # [doc = "Field `PD` writer - Управление питанием монитора"]
pub type PdW < 'a , REG > = crate :: BitWriter < 'a , REG , Pd > ; impl < 'a , REG > PdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Монитор включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Pd :: Enable) } # [doc = "Монитор выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Pd :: Disable) } } # [doc = "Отключение (сброс) детектирования нижнего порога\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nresetu { # [doc = "0: Детектирование не выполняется, схема в состоянии сброса"]
Reset = 0 , # [doc = "1: Нормальная работа"]
Normal = 1 , } impl From < Nresetu > for bool { # [inline (always)]
fn from (variant : Nresetu) -> Self { variant as u8 != 0 } } # [doc = "Field `NRESETU` reader - Отключение (сброс) детектирования нижнего порога"]
pub type NresetuR = crate :: BitReader < Nresetu > ; impl NresetuR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nresetu { match self . bits { false => Nresetu :: Reset , true => Nresetu :: Normal , } } # [doc = "Детектирование не выполняется, схема в состоянии сброса"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == Nresetu :: Reset } # [doc = "Нормальная работа"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == Nresetu :: Normal } } # [doc = "Field `NRESETU` writer - Отключение (сброс) детектирования нижнего порога"]
pub type NresetuW < 'a , REG > = crate :: BitWriter < 'a , REG , Nresetu > ; impl < 'a , REG > NresetuW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Детектирование не выполняется, схема в состоянии сброса"]
# [inline (always)]
pub fn reset (self) -> & 'a mut crate :: W < REG > { self . variant (Nresetu :: Reset) } # [doc = "Нормальная работа"]
# [inline (always)]
pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Nresetu :: Normal) } } # [doc = "Отключение (сброс) детектирования вехнего порога\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Nreseto { # [doc = "0: Детектирование не выполняется, схема в состоянии сброса"]
Reset = 0 , # [doc = "1: Нормальная работа"]
Normal = 1 , } impl From < Nreseto > for bool { # [inline (always)]
fn from (variant : Nreseto) -> Self { variant as u8 != 0 } } # [doc = "Field `NRESETO` reader - Отключение (сброс) детектирования вехнего порога"]
pub type NresetoR = crate :: BitReader < Nreseto > ; impl NresetoR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Nreseto { match self . bits { false => Nreseto :: Reset , true => Nreseto :: Normal , } } # [doc = "Детектирование не выполняется, схема в состоянии сброса"]
# [inline (always)]
pub fn is_reset (& self) -> bool { * self == Nreseto :: Reset } # [doc = "Нормальная работа"]
# [inline (always)]
pub fn is_normal (& self) -> bool { * self == Nreseto :: Normal } } # [doc = "Field `NRESETO` writer - Отключение (сброс) детектирования вехнего порога"]
pub type NresetoW < 'a , REG > = crate :: BitWriter < 'a , REG , Nreseto > ; impl < 'a , REG > NresetoW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Детектирование не выполняется, схема в состоянии сброса"]
# [inline (always)]
pub fn reset (self) -> & 'a mut crate :: W < REG > { self . variant (Nreseto :: Reset) } # [doc = "Нормальная работа"]
# [inline (always)]
pub fn normal (self) -> & 'a mut crate :: W < REG > { self . variant (Nreseto :: Normal) } } # [doc = "Field `TESTMODE` reader - Переход в тестовый режим"]
pub type TestmodeR = crate :: BitReader ; # [doc = "Field `TESTMODE` writer - Переход в тестовый режим"]
pub type TestmodeW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `UNDER_THRESH` reader - Нижний порог срабатывания монитора"]
pub type UnderThreshR = crate :: FieldReader ; # [doc = "Field `UNDER_THRESH` writer - Нижний порог срабатывания монитора"]
pub type UnderThreshW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `OVER_THRESH` reader - Верхний порог срабатывания монитора"]
pub type OverThreshR = crate :: FieldReader ; # [doc = "Field `OVER_THRESH` writer - Верхний порог срабатывания монитора"]
pub type OverThreshW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `EN_VREFCLB` reader - Использование в качестве опорного источника напряжения каллибруемый ОИН"]
pub type EnVrefclbR = crate :: BitReader ; # [doc = "Field `EN_VREFCLB` writer - Использование в качестве опорного источника напряжения каллибруемый ОИН"]
pub type EnVrefclbW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Управление питанием монитора"]
# [inline (always)]
pub fn pd (& self) -> PdR { PdR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Отключение (сброс) детектирования нижнего порога"]
# [inline (always)]
pub fn nresetu (& self) -> NresetuR { NresetuR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Отключение (сброс) детектирования вехнего порога"]
# [inline (always)]
pub fn nreseto (& self) -> NresetoR { NresetoR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Переход в тестовый режим"]
# [inline (always)]
pub fn testmode (& self) -> TestmodeR { TestmodeR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:7 - Нижний порог срабатывания монитора"]
# [inline (always)]
pub fn under_thresh (& self) -> UnderThreshR { UnderThreshR :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bits 8:11 - Верхний порог срабатывания монитора"]
# [inline (always)]
pub fn over_thresh (& self) -> OverThreshR { OverThreshR :: new (((self . bits >> 8) & 0x0f) as u8) } # [doc = "Bit 12 - Использование в качестве опорного источника напряжения каллибруемый ОИН"]
# [inline (always)]
pub fn en_vrefclb (& self) -> EnVrefclbR { EnVrefclbR :: new (((self . bits >> 12) & 1) != 0) } } impl W { # [doc = "Bit 0 - Управление питанием монитора"]
# [inline (always)]
pub fn pd (& mut self) -> PdW < ConfigSpec > { PdW :: new (self , 0) } # [doc = "Bit 1 - Отключение (сброс) детектирования нижнего порога"]
# [inline (always)]
pub fn nresetu (& mut self) -> NresetuW < ConfigSpec > { NresetuW :: new (self , 1) } # [doc = "Bit 2 - Отключение (сброс) детектирования вехнего порога"]
# [inline (always)]
pub fn nreseto (& mut self) -> NresetoW < ConfigSpec > { NresetoW :: new (self , 2) } # [doc = "Bit 3 - Переход в тестовый режим"]
# [inline (always)]
pub fn testmode (& mut self) -> TestmodeW < ConfigSpec > { TestmodeW :: new (self , 3) } # [doc = "Bits 4:7 - Нижний порог срабатывания монитора"]
# [inline (always)]
pub fn under_thresh (& mut self) -> UnderThreshW < ConfigSpec > { UnderThreshW :: new (self , 4) } # [doc = "Bits 8:11 - Верхний порог срабатывания монитора"]
# [inline (always)]
pub fn over_thresh (& mut self) -> OverThreshW < ConfigSpec > { OverThreshW :: new (self , 8) } # [doc = "Bit 12 - Использование в качестве опорного источника напряжения каллибруемый ОИН"]
# [inline (always)]
pub fn en_vrefclb (& mut self) -> EnVrefclbW < ConfigSpec > { EnVrefclbW :: new (self , 12) } } # [doc = "Регистр настроек\n\nYou can [`read`](crate::Reg::read) this register and get [`config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct ConfigSpec ; impl crate :: RegisterSpec for ConfigSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`config::R`](R) reader structure"]
impl crate :: Readable for ConfigSpec { } # [doc = "`write(|w| ..)` method takes [`config::W`](W) writer structure"]
impl crate :: Writable for ConfigSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets CONFIG to value 0x01"]
impl crate :: Resettable for ConfigSpec { const RESET_VALUE : u32 = 0x01 ; } } # [doc = "STATUS (r) register accessor: Регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@status`]
module"]
# [doc (alias = "STATUS")]
pub type Status = crate :: Reg < status :: StatusSpec > ; # [doc = "Регистр статуса"]
pub mod status { # [doc = "Register `STATUS` reader"]
pub type R = crate :: R < StatusSpec > ; # [doc = "Field `OUT_UNDER_VALUE` reader - Текущее состояние линии монитора нижнего порога без цифровой фильтрации"]
pub type OutUnderValueR = crate :: BitReader ; # [doc = "Field `OUT_OVER_VALUE` reader - Текущее состояние линии монитора верхнего порога без цифровой фильтрации"]
pub type OutOverValueR = crate :: BitReader ; # [doc = "Field `OUT_UNDER_FLAG` reader - Текущее состояние линии монитора нижнего порога с учетом цифровой фильтрации"]
pub type OutUnderFlagR = crate :: BitReader ; # [doc = "Field `OUT_OVER_FLAG` reader - Текущее состояние линии монитора верхнего порога с учетом цифровой фильтрации"]
pub type OutOverFlagR = crate :: BitReader ; impl R { # [doc = "Bit 0 - Текущее состояние линии монитора нижнего порога без цифровой фильтрации"]
# [inline (always)]
pub fn out_under_value (& self) -> OutUnderValueR { OutUnderValueR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Текущее состояние линии монитора верхнего порога без цифровой фильтрации"]
# [inline (always)]
pub fn out_over_value (& self) -> OutOverValueR { OutOverValueR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Текущее состояние линии монитора нижнего порога с учетом цифровой фильтрации"]
# [inline (always)]
pub fn out_under_flag (& self) -> OutUnderFlagR { OutUnderFlagR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Текущее состояние линии монитора верхнего порога с учетом цифровой фильтрации"]
# [inline (always)]
pub fn out_over_flag (& self) -> OutOverFlagR { OutOverFlagR :: new (((self . bits >> 3) & 1) != 0) } } # [doc = "Регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`status::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct StatusSpec ; impl crate :: RegisterSpec for StatusSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`status::R`](R) reader structure"]
impl crate :: Readable for StatusSpec { } # [doc = "`reset()` method sets STATUS to value 0"]
impl crate :: Resettable for StatusSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Управление температурным сенсором"]
pub struct Tsens { _marker : PhantomData < * const () > } unsafe impl Send for Tsens { } impl Tsens { # [doc = r"Pointer to the register block"]
pub const PTR : * const tsens :: RegisterBlock = 0x0008_501c as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const tsens :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Tsens { type Target = tsens :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Tsens { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Tsens") . finish () } } # [doc = "Управление температурным сенсором"]
pub mod tsens { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { tsens_cfg : TsensCfg , tsens_treshold : TsensTreshold , tsens_irq : TsensIrq , tsens_clear_irq : TsensClearIrq , tsens_value : TsensValue , tsens_single : TsensSingle , _reserved6 : [u8 ; 0x1c]
, tsens_continuous : TsensContinuous , } impl RegisterBlock { # [doc = "0x00 - Регистр настроек"]
# [inline (always)]
pub const fn tsens_cfg (& self) -> & TsensCfg { & self . tsens_cfg } # [doc = "0x04 - Регистр пороговых значений"]
# [inline (always)]
pub const fn tsens_treshold (& self) -> & TsensTreshold { & self . tsens_treshold } # [doc = "0x08 - Регистр прерываний"]
# [inline (always)]
pub const fn tsens_irq (& self) -> & TsensIrq { & self . tsens_irq } # [doc = "0x0c - Регистр сброса прерываний"]
# [inline (always)]
pub const fn tsens_clear_irq (& self) -> & TsensClearIrq { & self . tsens_clear_irq } # [doc = "0x10 - Регистр данных"]
# [inline (always)]
pub const fn tsens_value (& self) -> & TsensValue { & self . tsens_value } # [doc = "0x14 - Регистр запуска однократного измерения"]
# [inline (always)]
pub const fn tsens_single (& self) -> & TsensSingle { & self . tsens_single } # [doc = "0x34 - Регистр запуска непрерываного измерения"]
# [inline (always)]
pub const fn tsens_continuous (& self) -> & TsensContinuous { & self . tsens_continuous } } # [doc = "TSENS_CFG (rw) register accessor: Регистр настроек\n\nYou can [`read`](crate::Reg::read) this register and get [`tsens_cfg::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_cfg::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tsens_cfg`]
module"]
# [doc (alias = "TSENS_CFG")]
pub type TsensCfg = crate :: Reg < tsens_cfg :: TsensCfgSpec > ; # [doc = "Регистр настроек"]
pub mod tsens_cfg { # [doc = "Register `TSENS_CFG` reader"]
pub type R = crate :: R < TsensCfgSpec > ; # [doc = "Register `TSENS_CFG` writer"]
pub type W = crate :: W < TsensCfgSpec > ; # [doc = "Управление питанием сенсора\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Npd { # [doc = "0: Сенсор выключен"]
Disable = 0 , # [doc = "1: Сенсор включен"]
Enable = 1 , } impl From < Npd > for bool { # [inline (always)]
fn from (variant : Npd) -> Self { variant as u8 != 0 } } # [doc = "Field `NPD` reader - Управление питанием сенсора"]
pub type NpdR = crate :: BitReader < Npd > ; impl NpdR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Npd { match self . bits { false => Npd :: Disable , true => Npd :: Enable , } } # [doc = "Сенсор выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == Npd :: Disable } # [doc = "Сенсор включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Npd :: Enable } } # [doc = "Field `NPD` writer - Управление питанием сенсора"]
pub type NpdW < 'a , REG > = crate :: BitWriter < 'a , REG , Npd > ; impl < 'a , REG > NpdW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Сенсор выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (Npd :: Disable) } # [doc = "Сенсор включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Npd :: Enable) } } # [doc = "Управление тактированием сенсора\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum NpdClk { # [doc = "0: Тактирование сенсора выключено"]
Disable = 0 , # [doc = "1: Тактирование сенсора включено"]
Enable = 1 , } impl From < NpdClk > for bool { # [inline (always)]
fn from (variant : NpdClk) -> Self { variant as u8 != 0 } } # [doc = "Field `NPD_CLK` reader - Управление тактированием сенсора"]
pub type NpdClkR = crate :: BitReader < NpdClk > ; impl NpdClkR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> NpdClk { match self . bits { false => NpdClk :: Disable , true => NpdClk :: Enable , } } # [doc = "Тактирование сенсора выключено"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == NpdClk :: Disable } # [doc = "Тактирование сенсора включено"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == NpdClk :: Enable } } # [doc = "Field `NPD_CLK` writer - Управление тактированием сенсора"]
pub type NpdClkW < 'a , REG > = crate :: BitWriter < 'a , REG , NpdClk > ; impl < 'a , REG > NpdClkW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование сенсора выключено"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (NpdClk :: Disable) } # [doc = "Тактирование сенсора включено"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (NpdClk :: Enable) } } # [doc = "Field `NRST` reader - Управление сбросом сенсора, активный уровень «0»"]
pub type NrstR = crate :: BitReader ; # [doc = "Field `NRST` writer - Управление сбросом сенсора, активный уровень «0»"]
pub type NrstW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Выбор источника тактирования сенсора (Fin)\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
# [repr (u8)]
pub enum ClkMux { # [doc = "0: системная частота (sys_clk)"]
SysClk = 0 , # [doc = "1: Частота шины AHB (hclk)"]
Hclk = 1 , # [doc = "2: Частота внешнего осциллятора 32 МГц"]
Osc32m = 2 , # [doc = "3: Частота HSI32M"]
Hsi32m = 3 , # [doc = "4: Частота внешнего осциллятора 32 кГц"]
Osc32k = 4 , # [doc = "5: Частота LSI32K"]
Lsi32k = 5 , } impl From < ClkMux > for u8 { # [inline (always)]
fn from (variant : ClkMux) -> Self { variant as _ } } impl crate :: FieldSpec for ClkMux { type Ux = u8 ; } impl crate :: IsEnum for ClkMux { } # [doc = "Field `CLK_MUX` reader - Выбор источника тактирования сенсора (Fin)"]
pub type ClkMuxR = crate :: FieldReader < ClkMux > ; impl ClkMuxR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Option < ClkMux > { match self . bits { 0 => Some (ClkMux :: SysClk) , 1 => Some (ClkMux :: Hclk) , 2 => Some (ClkMux :: Osc32m) , 3 => Some (ClkMux :: Hsi32m) , 4 => Some (ClkMux :: Osc32k) , 5 => Some (ClkMux :: Lsi32k) , _ => None , } } # [doc = "системная частота (sys_clk)"]
# [inline (always)]
pub fn is_sys_clk (& self) -> bool { * self == ClkMux :: SysClk } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn is_hclk (& self) -> bool { * self == ClkMux :: Hclk } # [doc = "Частота внешнего осциллятора 32 МГц"]
# [inline (always)]
pub fn is_osc32m (& self) -> bool { * self == ClkMux :: Osc32m } # [doc = "Частота HSI32M"]
# [inline (always)]
pub fn is_hsi32m (& self) -> bool { * self == ClkMux :: Hsi32m } # [doc = "Частота внешнего осциллятора 32 кГц"]
# [inline (always)]
pub fn is_osc32k (& self) -> bool { * self == ClkMux :: Osc32k } # [doc = "Частота LSI32K"]
# [inline (always)]
pub fn is_lsi32k (& self) -> bool { * self == ClkMux :: Lsi32k } } # [doc = "Field `CLK_MUX` writer - Выбор источника тактирования сенсора (Fin)"]
pub type ClkMuxW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 , ClkMux > ; impl < 'a , REG > ClkMuxW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , REG :: Ux : From < u8 > { # [doc = "системная частота (sys_clk)"]
# [inline (always)]
pub fn sys_clk (self) -> & 'a mut crate :: W < REG > { self . variant (ClkMux :: SysClk) } # [doc = "Частота шины AHB (hclk)"]
# [inline (always)]
pub fn hclk (self) -> & 'a mut crate :: W < REG > { self . variant (ClkMux :: Hclk) } # [doc = "Частота внешнего осциллятора 32 МГц"]
# [inline (always)]
pub fn osc32m (self) -> & 'a mut crate :: W < REG > { self . variant (ClkMux :: Osc32m) } # [doc = "Частота HSI32M"]
# [inline (always)]
pub fn hsi32m (self) -> & 'a mut crate :: W < REG > { self . variant (ClkMux :: Hsi32m) } # [doc = "Частота внешнего осциллятора 32 кГц"]
# [inline (always)]
pub fn osc32k (self) -> & 'a mut crate :: W < REG > { self . variant (ClkMux :: Osc32k) } # [doc = "Частота LSI32K"]
# [inline (always)]
pub fn lsi32k (self) -> & 'a mut crate :: W < REG > { self . variant (ClkMux :: Lsi32k) } } # [doc = "Field `DIV` reader - Значение делителя тактового сигнала. Частота сенсора определяется как Tsens = Fin/(2*(Div + 1))"]
pub type DivR = crate :: FieldReader < u16 > ; # [doc = "Field `DIV` writer - Значение делителя тактового сигнала. Частота сенсора определяется как Tsens = Fin/(2*(Div + 1))"]
pub type DivW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; impl R { # [doc = "Bit 0 - Управление питанием сенсора"]
# [inline (always)]
pub fn npd (& self) -> NpdR { NpdR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Управление тактированием сенсора"]
# [inline (always)]
pub fn npd_clk (& self) -> NpdClkR { NpdClkR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Управление сбросом сенсора, активный уровень «0»"]
# [inline (always)]
pub fn nrst (& self) -> NrstR { NrstR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bits 3:5 - Выбор источника тактирования сенсора (Fin)"]
# [inline (always)]
pub fn clk_mux (& self) -> ClkMuxR { ClkMuxR :: new (((self . bits >> 3) & 7) as u8) } # [doc = "Bits 6:15 - Значение делителя тактового сигнала. Частота сенсора определяется как Tsens = Fin/(2*(Div + 1))"]
# [inline (always)]
pub fn div (& self) -> DivR { DivR :: new (((self . bits >> 6) & 0x03ff) as u16) } } impl W { # [doc = "Bit 0 - Управление питанием сенсора"]
# [inline (always)]
pub fn npd (& mut self) -> NpdW < TsensCfgSpec > { NpdW :: new (self , 0) } # [doc = "Bit 1 - Управление тактированием сенсора"]
# [inline (always)]
pub fn npd_clk (& mut self) -> NpdClkW < TsensCfgSpec > { NpdClkW :: new (self , 1) } # [doc = "Bit 2 - Управление сбросом сенсора, активный уровень «0»"]
# [inline (always)]
pub fn nrst (& mut self) -> NrstW < TsensCfgSpec > { NrstW :: new (self , 2) } # [doc = "Bits 3:5 - Выбор источника тактирования сенсора (Fin)"]
# [inline (always)]
pub fn clk_mux (& mut self) -> ClkMuxW < TsensCfgSpec > { ClkMuxW :: new (self , 3) } # [doc = "Bits 6:15 - Значение делителя тактового сигнала. Частота сенсора определяется как Tsens = Fin/(2*(Div + 1))"]
# [inline (always)]
pub fn div (& mut self) -> DivW < TsensCfgSpec > { DivW :: new (self , 6) } } # [doc = "Регистр настроек\n\nYou can [`read`](crate::Reg::read) this register and get [`tsens_cfg::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_cfg::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TsensCfgSpec ; impl crate :: RegisterSpec for TsensCfgSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`tsens_cfg::R`](R) reader structure"]
impl crate :: Readable for TsensCfgSpec { } # [doc = "`write(|w| ..)` method takes [`tsens_cfg::W`](W) writer structure"]
impl crate :: Writable for TsensCfgSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TSENS_CFG to value 0"]
impl crate :: Resettable for TsensCfgSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TSENS_TRESHOLD (rw) register accessor: Регистр пороговых значений\n\nYou can [`read`](crate::Reg::read) this register and get [`tsens_treshold::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_treshold::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tsens_treshold`]
module"]
# [doc (alias = "TSENS_TRESHOLD")]
pub type TsensTreshold = crate :: Reg < tsens_treshold :: TsensTresholdSpec > ; # [doc = "Регистр пороговых значений"]
pub mod tsens_treshold { # [doc = "Register `TSENS_TRESHOLD` reader"]
pub type R = crate :: R < TsensTresholdSpec > ; # [doc = "Register `TSENS_TRESHOLD` writer"]
pub type W = crate :: W < TsensTresholdSpec > ; # [doc = "Field `TRESHOLD_HI` reader - При значении выхода сенсора больше HI_THRESHOLD будет формироваться прерывание. Значение по умолчанию соот-ветсвует температуре 125 оС"]
pub type TresholdHiR = crate :: FieldReader < u16 > ; # [doc = "Field `TRESHOLD_HI` writer - При значении выхода сенсора больше HI_THRESHOLD будет формироваться прерывание. Значение по умолчанию соот-ветсвует температуре 125 оС"]
pub type TresholdHiW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; # [doc = "Field `TRESHOLD_LOW` reader - При значении выхода сенсора менее LOW_THRESHOLD будет формироваться прерывание. Значение по умолчанию соответсвует температуре -40 оС"]
pub type TresholdLowR = crate :: FieldReader < u16 > ; # [doc = "Field `TRESHOLD_LOW` writer - При значении выхода сенсора менее LOW_THRESHOLD будет формироваться прерывание. Значение по умолчанию соответсвует температуре -40 оС"]
pub type TresholdLowW < 'a , REG > = crate :: FieldWriter < 'a , REG , 10 , u16 > ; impl R { # [doc = "Bits 0:9 - При значении выхода сенсора больше HI_THRESHOLD будет формироваться прерывание. Значение по умолчанию соот-ветсвует температуре 125 оС"]
# [inline (always)]
pub fn treshold_hi (& self) -> TresholdHiR { TresholdHiR :: new ((self . bits & 0x03ff) as u16) } # [doc = "Bits 10:19 - При значении выхода сенсора менее LOW_THRESHOLD будет формироваться прерывание. Значение по умолчанию соответсвует температуре -40 оС"]
# [inline (always)]
pub fn treshold_low (& self) -> TresholdLowR { TresholdLowR :: new (((self . bits >> 10) & 0x03ff) as u16) } } impl W { # [doc = "Bits 0:9 - При значении выхода сенсора больше HI_THRESHOLD будет формироваться прерывание. Значение по умолчанию соот-ветсвует температуре 125 оС"]
# [inline (always)]
pub fn treshold_hi (& mut self) -> TresholdHiW < TsensTresholdSpec > { TresholdHiW :: new (self , 0) } # [doc = "Bits 10:19 - При значении выхода сенсора менее LOW_THRESHOLD будет формироваться прерывание. Значение по умолчанию соответсвует температуре -40 оС"]
# [inline (always)]
pub fn treshold_low (& mut self) -> TresholdLowW < TsensTresholdSpec > { TresholdLowW :: new (self , 10) } } # [doc = "Регистр пороговых значений\n\nYou can [`read`](crate::Reg::read) this register and get [`tsens_treshold::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_treshold::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TsensTresholdSpec ; impl crate :: RegisterSpec for TsensTresholdSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`tsens_treshold::R`](R) reader structure"]
impl crate :: Readable for TsensTresholdSpec { } # [doc = "`write(|w| ..)` method takes [`tsens_treshold::W`](W) writer structure"]
impl crate :: Writable for TsensTresholdSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TSENS_TRESHOLD to value 0x0003_865b"]
impl crate :: Resettable for TsensTresholdSpec { const RESET_VALUE : u32 = 0x0003_865b ; } } # [doc = "TSENS_IRQ (rw) register accessor: Регистр прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`tsens_irq::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_irq::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tsens_irq`]
module"]
# [doc (alias = "TSENS_IRQ")]
pub type TsensIrq = crate :: Reg < tsens_irq :: TsensIrqSpec > ; # [doc = "Регистр прерываний"]
pub mod tsens_irq { # [doc = "Register `TSENS_IRQ` reader"]
pub type R = crate :: R < TsensIrqSpec > ; # [doc = "Register `TSENS_IRQ` writer"]
pub type W = crate :: W < TsensIrqSpec > ; # [doc = "Field `EOC_MASK` reader - Маска прерывания по окончанию преобразования"]
pub type EocMaskR = crate :: BitReader ; # [doc = "Field `EOC_MASK` writer - Маска прерывания по окончанию преобразования"]
pub type EocMaskW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `HI_MASK` reader - Маска прерывания события «выход сенсора больше порогового значения HI_THRESHOLD»"]
pub type HiMaskR = crate :: BitReader ; # [doc = "Field `HI_MASK` writer - Маска прерывания события «выход сенсора больше порогового значения HI_THRESHOLD»"]
pub type HiMaskW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `LOW_MASK` reader - Маска прерывания события «выход сенсора меньше порогового значения LOW_ THRESHOLD»"]
pub type LowMaskR = crate :: BitReader ; # [doc = "Field `LOW_MASK` writer - Маска прерывания события «выход сенсора меньше порогового значения LOW_ THRESHOLD»"]
pub type LowMaskW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Field `EOC_IRQ` reader - Статус прерывания по окончанию преобразования"]
pub type EocIrqR = crate :: BitReader ; # [doc = "Field `HI_IRQ` reader - Статус прерывания события «выход сенсора больше порогового значения HI_THRESHOLD»"]
pub type HiIrqR = crate :: BitReader ; # [doc = "Field `LOW_IRQ` reader - Статус прерывания события «выход сенсора меньше порогового значения LOW_ THRESHOLD»"]
pub type LowIrqR = crate :: BitReader ; impl R { # [doc = "Bit 0 - Маска прерывания по окончанию преобразования"]
# [inline (always)]
pub fn eoc_mask (& self) -> EocMaskR { EocMaskR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Маска прерывания события «выход сенсора больше порогового значения HI_THRESHOLD»"]
# [inline (always)]
pub fn hi_mask (& self) -> HiMaskR { HiMaskR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Маска прерывания события «выход сенсора меньше порогового значения LOW_ THRESHOLD»"]
# [inline (always)]
pub fn low_mask (& self) -> LowMaskR { LowMaskR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Статус прерывания по окончанию преобразования"]
# [inline (always)]
pub fn eoc_irq (& self) -> EocIrqR { EocIrqR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bit 4 - Статус прерывания события «выход сенсора больше порогового значения HI_THRESHOLD»"]
# [inline (always)]
pub fn hi_irq (& self) -> HiIrqR { HiIrqR :: new (((self . bits >> 4) & 1) != 0) } # [doc = "Bit 5 - Статус прерывания события «выход сенсора меньше порогового значения LOW_ THRESHOLD»"]
# [inline (always)]
pub fn low_irq (& self) -> LowIrqR { LowIrqR :: new (((self . bits >> 5) & 1) != 0) } } impl W { # [doc = "Bit 0 - Маска прерывания по окончанию преобразования"]
# [inline (always)]
pub fn eoc_mask (& mut self) -> EocMaskW < TsensIrqSpec > { EocMaskW :: new (self , 0) } # [doc = "Bit 1 - Маска прерывания события «выход сенсора больше порогового значения HI_THRESHOLD»"]
# [inline (always)]
pub fn hi_mask (& mut self) -> HiMaskW < TsensIrqSpec > { HiMaskW :: new (self , 1) } # [doc = "Bit 2 - Маска прерывания события «выход сенсора меньше порогового значения LOW_ THRESHOLD»"]
# [inline (always)]
pub fn low_mask (& mut self) -> LowMaskW < TsensIrqSpec > { LowMaskW :: new (self , 2) } } # [doc = "Регистр прерываний\n\nYou can [`read`](crate::Reg::read) this register and get [`tsens_irq::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_irq::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TsensIrqSpec ; impl crate :: RegisterSpec for TsensIrqSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`tsens_irq::R`](R) reader structure"]
impl crate :: Readable for TsensIrqSpec { } # [doc = "`write(|w| ..)` method takes [`tsens_irq::W`](W) writer structure"]
impl crate :: Writable for TsensIrqSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TSENS_IRQ to value 0"]
impl crate :: Resettable for TsensIrqSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TSENS_CLEAR_IRQ (w) register accessor: Регистр сброса прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_clear_irq::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tsens_clear_irq`]
module"]
# [doc (alias = "TSENS_CLEAR_IRQ")]
pub type TsensClearIrq = crate :: Reg < tsens_clear_irq :: TsensClearIrqSpec > ; # [doc = "Регистр сброса прерываний"]
pub mod tsens_clear_irq { # [doc = "Register `TSENS_CLEAR_IRQ` writer"]
pub type W = crate :: W < TsensClearIrqSpec > ; # [doc = "Field `EOC_CLEAR` writer - Сброс прерывания по окончанию преобразования"]
pub type EocClearW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `HI_CLEAR` writer - Сброс прерывания события «выход сенсора больше порогового значения HI_THRESHOLD»"]
pub type HiClearW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; # [doc = "Field `LOW_CLEAR` writer - Сброс прерывания события «выход сенсора меньше порогового значения LOW_ THRESHOLD»"]
pub type LowClearW < 'a , REG > = crate :: BitWriter1C < 'a , REG > ; impl W { # [doc = "Bit 0 - Сброс прерывания по окончанию преобразования"]
# [inline (always)]
pub fn eoc_clear (& mut self) -> EocClearW < TsensClearIrqSpec > { EocClearW :: new (self , 0) } # [doc = "Bit 1 - Сброс прерывания события «выход сенсора больше порогового значения HI_THRESHOLD»"]
# [inline (always)]
pub fn hi_clear (& mut self) -> HiClearW < TsensClearIrqSpec > { HiClearW :: new (self , 1) } # [doc = "Bit 2 - Сброс прерывания события «выход сенсора меньше порогового значения LOW_ THRESHOLD»"]
# [inline (always)]
pub fn low_clear (& mut self) -> LowClearW < TsensClearIrqSpec > { LowClearW :: new (self , 2) } } # [doc = "Регистр сброса прерываний\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_clear_irq::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TsensClearIrqSpec ; impl crate :: RegisterSpec for TsensClearIrqSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`tsens_clear_irq::W`](W) writer structure"]
impl crate :: Writable for TsensClearIrqSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0x07 ; } # [doc = "`reset()` method sets TSENS_CLEAR_IRQ to value 0"]
impl crate :: Resettable for TsensClearIrqSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TSENS_VALUE (r) register accessor: Регистр данных\n\nYou can [`read`](crate::Reg::read) this register and get [`tsens_value::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tsens_value`]
module"]
# [doc (alias = "TSENS_VALUE")]
pub type TsensValue = crate :: Reg < tsens_value :: TsensValueSpec > ; # [doc = "Регистр данных"]
pub mod tsens_value { # [doc = "Register `TSENS_VALUE` reader"]
pub type R = crate :: R < TsensValueSpec > ; # [doc = "Field `VALUE` reader - Последнее измереннное значение сенсором"]
pub type ValueR = crate :: FieldReader < u16 > ; # [doc = "Field `EOC` reader - Текущее значение выхода окончания преобразования"]
pub type EocR = crate :: BitReader ; impl R { # [doc = "Bits 0:9 - Последнее измереннное значение сенсором"]
# [inline (always)]
pub fn value (& self) -> ValueR { ValueR :: new ((self . bits & 0x03ff) as u16) } # [doc = "Bit 10 - Текущее значение выхода окончания преобразования"]
# [inline (always)]
pub fn eoc (& self) -> EocR { EocR :: new (((self . bits >> 10) & 1) != 0) } } # [doc = "Регистр данных\n\nYou can [`read`](crate::Reg::read) this register and get [`tsens_value::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TsensValueSpec ; impl crate :: RegisterSpec for TsensValueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`tsens_value::R`](R) reader structure"]
impl crate :: Readable for TsensValueSpec { } # [doc = "`reset()` method sets TSENS_VALUE to value 0"]
impl crate :: Resettable for TsensValueSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TSENS_SINGLE (w) register accessor: Регистр запуска однократного измерения\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_single::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tsens_single`]
module"]
# [doc (alias = "TSENS_SINGLE")]
pub type TsensSingle = crate :: Reg < tsens_single :: TsensSingleSpec > ; # [doc = "Регистр запуска однократного измерения"]
pub mod tsens_single { # [doc = "Register `TSENS_SINGLE` writer"]
pub type W = crate :: W < TsensSingleSpec > ; # [doc = "Field `SINGLE` writer - Запуск одного измерения"]
pub type SingleW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W { # [doc = "Bit 0 - Запуск одного измерения"]
# [inline (always)]
pub fn single (& mut self) -> SingleW < TsensSingleSpec > { SingleW :: new (self , 0) } } # [doc = "Регистр запуска однократного измерения\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_single::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TsensSingleSpec ; impl crate :: RegisterSpec for TsensSingleSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`tsens_single::W`](W) writer structure"]
impl crate :: Writable for TsensSingleSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TSENS_SINGLE to value 0"]
impl crate :: Resettable for TsensSingleSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "TSENS_CONTINUOUS (w) register accessor: Регистр запуска непрерываного измерения\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_continuous::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@tsens_continuous`]
module"]
# [doc (alias = "TSENS_CONTINUOUS")]
pub type TsensContinuous = crate :: Reg < tsens_continuous :: TsensContinuousSpec > ; # [doc = "Регистр запуска непрерываного измерения"]
pub mod tsens_continuous { # [doc = "Register `TSENS_CONTINUOUS` writer"]
pub type W = crate :: W < TsensContinuousSpec > ; # [doc = "Field `CONTINUOUS` writer - Запуск / остановка непрерывного измерения температуры"]
pub type ContinuousW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W { # [doc = "Bit 0 - Запуск / остановка непрерывного измерения температуры"]
# [inline (always)]
pub fn continuous (& mut self) -> ContinuousW < TsensContinuousSpec > { ContinuousW :: new (self , 0) } } # [doc = "Регистр запуска непрерываного измерения\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`tsens_continuous::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TsensContinuousSpec ; impl crate :: RegisterSpec for TsensContinuousSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`tsens_continuous::W`](W) writer structure"]
impl crate :: Writable for TsensContinuousSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TSENS_CONTINUOUS to value 0"]
impl crate :: Resettable for TsensContinuousSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Управление калибруемыми источниками напряжения и тока"]
pub struct RefvConfig { _marker : PhantomData < * const () > } unsafe impl Send for RefvConfig { } impl RefvConfig { # [doc = r"Pointer to the register block"]
pub const PTR : * const refv_config :: RegisterBlock = 0x0008_5038 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const refv_config :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for RefvConfig { type Target = refv_config :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for RefvConfig { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("RefvConfig") . finish () } } # [doc = "Управление калибруемыми источниками напряжения и тока"]
pub mod refv_config { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { ref_clb : RefClb , } impl RegisterBlock { # [doc = "0x00 - Управление калибруемыми источниками тока и напряжения"]
# [inline (always)]
pub const fn ref_clb (& self) -> & RefClb { & self . ref_clb } } # [doc = "REF_CLB (rw) register accessor: Управление калибруемыми источниками тока и напряжения\n\nYou can [`read`](crate::Reg::read) this register and get [`ref_clb::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ref_clb::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@ref_clb`]
module"]
# [doc (alias = "REF_CLB")]
pub type RefClb = crate :: Reg < ref_clb :: RefClbSpec > ; # [doc = "Управление калибруемыми источниками тока и напряжения"]
pub mod ref_clb { # [doc = "Register `REF_CLB` reader"]
pub type R = crate :: R < RefClbSpec > ; # [doc = "Register `REF_CLB` writer"]
pub type W = crate :: W < RefClbSpec > ; # [doc = "Field `COEF_REFVCLB` reader - Коэфициент настройки опорного источника напряжения"]
pub type CoefRefvclbR = crate :: FieldReader ; # [doc = "Field `COEF_REFVCLB` writer - Коэфициент настройки опорного источника напряжения"]
pub type CoefRefvclbW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Field `COEF_REFICLB` reader - Коэфициент настройки опорного источника тока"]
pub type CoefReficlbR = crate :: FieldReader ; # [doc = "Field `COEF_REFICLB` writer - Коэфициент настройки опорного источника тока"]
pub type CoefReficlbW < 'a , REG > = crate :: FieldWriter < 'a , REG , 4 > ; # [doc = "Разрешение работы калибруемых источников\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ClbEn { # [doc = "0: Включить"]
Disable = 0 , # [doc = "1: Выключить"]
Enable = 1 , } impl From < ClbEn > for bool { # [inline (always)]
fn from (variant : ClbEn) -> Self { variant as u8 != 0 } } # [doc = "Field `CLB_EN` reader - Разрешение работы калибруемых источников"]
pub type ClbEnR = crate :: BitReader < ClbEn > ; impl ClbEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ClbEn { match self . bits { false => ClbEn :: Disable , true => ClbEn :: Enable , } } # [doc = "Включить"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == ClbEn :: Disable } # [doc = "Выключить"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == ClbEn :: Enable } } # [doc = "Field `CLB_EN` writer - Разрешение работы калибруемых источников"]
pub type ClbEnW < 'a , REG > = crate :: BitWriter < 'a , REG , ClbEn > ; impl < 'a , REG > ClbEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Включить"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (ClbEn :: Disable) } # [doc = "Выключить"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (ClbEn :: Enable) } } impl R { # [doc = "Bits 0:3 - Коэфициент настройки опорного источника напряжения"]
# [inline (always)]
pub fn coef_refvclb (& self) -> CoefRefvclbR { CoefRefvclbR :: new ((self . bits & 0x0f) as u8) } # [doc = "Bits 4:7 - Коэфициент настройки опорного источника тока"]
# [inline (always)]
pub fn coef_reficlb (& self) -> CoefReficlbR { CoefReficlbR :: new (((self . bits >> 4) & 0x0f) as u8) } # [doc = "Bit 8 - Разрешение работы калибруемых источников"]
# [inline (always)]
pub fn clb_en (& self) -> ClbEnR { ClbEnR :: new (((self . bits >> 8) & 1) != 0) } } impl W { # [doc = "Bits 0:3 - Коэфициент настройки опорного источника напряжения"]
# [inline (always)]
pub fn coef_refvclb (& mut self) -> CoefRefvclbW < RefClbSpec > { CoefRefvclbW :: new (self , 0) } # [doc = "Bits 4:7 - Коэфициент настройки опорного источника тока"]
# [inline (always)]
pub fn coef_reficlb (& mut self) -> CoefReficlbW < RefClbSpec > { CoefReficlbW :: new (self , 4) } # [doc = "Bit 8 - Разрешение работы калибруемых источников"]
# [inline (always)]
pub fn clb_en (& mut self) -> ClbEnW < RefClbSpec > { ClbEnW :: new (self , 8) } } # [doc = "Управление калибруемыми источниками тока и напряжения\n\nYou can [`read`](crate::Reg::read) this register and get [`ref_clb::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`ref_clb::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct RefClbSpec ; impl crate :: RegisterSpec for RefClbSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`ref_clb::R`](R) reader structure"]
impl crate :: Readable for RefClbSpec { } # [doc = "`write(|w| ..)` method takes [`ref_clb::W`](W) writer structure"]
impl crate :: Writable for RefClbSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets REF_CLB to value 0x0188"]
impl crate :: Resettable for RefClbSpec { const RESET_VALUE : u32 = 0x0188 ; } } } # [doc = "Управление АЦП"]
pub struct Adc { _marker : PhantomData < * const () > } unsafe impl Send for Adc { } impl Adc { # [doc = r"Pointer to the register block"]
pub const PTR : * const adc :: RegisterBlock = 0x0008_503c as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const adc :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Adc { type Target = adc :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Adc { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Adc") . finish () } } # [doc = "Управление АЦП"]
pub mod adc { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { adc_config : AdcConfig , adc_continuous : AdcContinuous , adc_single : AdcSingle , adc_valid : AdcValid , adc_value : AdcValue , } impl RegisterBlock { # [doc = "0x00 - Регистр настойки"]
# [inline (always)]
pub const fn adc_config (& self) -> & AdcConfig { & self . adc_config } # [doc = "0x04 - Управление непрерывным измерением"]
# [inline (always)]
pub const fn adc_continuous (& self) -> & AdcContinuous { & self . adc_continuous } # [doc = "0x08 - Управление однократным измерением"]
# [inline (always)]
pub const fn adc_single (& self) -> & AdcSingle { & self . adc_single } # [doc = "0x0c - Регистр статуса"]
# [inline (always)]
pub const fn adc_valid (& self) -> & AdcValid { & self . adc_valid } # [doc = "0x10 - Регистр данных"]
# [inline (always)]
pub const fn adc_value (& self) -> & AdcValue { & self . adc_value } } # [doc = "ADC_CONFIG (rw) register accessor: Регистр настойки\n\nYou can [`read`](crate::Reg::read) this register and get [`adc_config::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc_config::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc_config`]
module"]
# [doc (alias = "ADC_CONFIG")]
pub type AdcConfig = crate :: Reg < adc_config :: AdcConfigSpec > ; # [doc = "Регистр настойки"]
pub mod adc_config { # [doc = "Register `ADC_CONFIG` reader"]
pub type R = crate :: R < AdcConfigSpec > ; # [doc = "Register `ADC_CONFIG` writer"]
pub type W = crate :: W < AdcConfigSpec > ; # [doc = "Управление питанием АЦП\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum En { # [doc = "0: Выключен"]
Disable = 0 , # [doc = "1: Включен"]
Enable = 1 , } impl From < En > for bool { # [inline (always)]
fn from (variant : En) -> Self { variant as u8 != 0 } } # [doc = "Field `EN` reader - Управление питанием АЦП"]
pub type EnR = crate :: BitReader < En > ; impl EnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> En { match self . bits { false => En :: Disable , true => En :: Enable , } } # [doc = "Выключен"]
# [inline (always)]
pub fn is_disable (& self) -> bool { * self == En :: Disable } # [doc = "Включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == En :: Enable } } # [doc = "Field `EN` writer - Управление питанием АЦП"]
pub type EnW < 'a , REG > = crate :: BitWriter < 'a , REG , En > ; impl < 'a , REG > EnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Выключен"]
# [inline (always)]
pub fn disable (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Disable) } # [doc = "Включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (En :: Enable) } } # [doc = "Field `RESETN` reader - Управление сбросом АЦП, активный уровень «0»"]
pub type ResetnR = crate :: BitReader ; # [doc = "Field `RESETN` writer - Управление сбросом АЦП, активный уровень «0»"]
pub type ResetnW < 'a , REG > = crate :: BitWriter < 'a , REG > ; # [doc = "Выбор источника опорного напряжения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Extref { # [doc = "0: Встроенный"]
Internal = 0 , # [doc = "1: Внешний"]
External = 1 , } impl From < Extref > for bool { # [inline (always)]
fn from (variant : Extref) -> Self { variant as u8 != 0 } } # [doc = "Field `EXTREF` reader - Выбор источника опорного напряжения"]
pub type ExtrefR = crate :: BitReader < Extref > ; impl ExtrefR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Extref { match self . bits { false => Extref :: Internal , true => Extref :: External , } } # [doc = "Встроенный"]
# [inline (always)]
pub fn is_internal (& self) -> bool { * self == Extref :: Internal } # [doc = "Внешний"]
# [inline (always)]
pub fn is_external (& self) -> bool { * self == Extref :: External } } # [doc = "Field `EXTREF` writer - Выбор источника опорного напряжения"]
pub type ExtrefW < 'a , REG > = crate :: BitWriter < 'a , REG , Extref > ; impl < 'a , REG > ExtrefW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Встроенный"]
# [inline (always)]
pub fn internal (self) -> & 'a mut crate :: W < REG > { self . variant (Extref :: Internal) } # [doc = "Внешний"]
# [inline (always)]
pub fn external (self) -> & 'a mut crate :: W < REG > { self . variant (Extref :: External) } } # [doc = "Выбор источника внешнего опорного напряжения\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum ExtpadEn { # [doc = "0: Настраиваемый ИОН"]
CalibratedVoltageReference = 0 , # [doc = "1: Внешний вывод REF_ADC_DAC (PORT1_11)"]
RefDacPin = 1 , } impl From < ExtpadEn > for bool { # [inline (always)]
fn from (variant : ExtpadEn) -> Self { variant as u8 != 0 } } # [doc = "Field `EXTPAD_EN` reader - Выбор источника внешнего опорного напряжения"]
pub type ExtpadEnR = crate :: BitReader < ExtpadEn > ; impl ExtpadEnR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> ExtpadEn { match self . bits { false => ExtpadEn :: CalibratedVoltageReference , true => ExtpadEn :: RefDacPin , } } # [doc = "Настраиваемый ИОН"]
# [inline (always)]
pub fn is_calibrated_voltage_reference (& self) -> bool { * self == ExtpadEn :: CalibratedVoltageReference } # [doc = "Внешний вывод REF_ADC_DAC (PORT1_11)"]
# [inline (always)]
pub fn is_ref_dac_pin (& self) -> bool { * self == ExtpadEn :: RefDacPin } } # [doc = "Field `EXTPAD_EN` writer - Выбор источника внешнего опорного напряжения"]
pub type ExtpadEnW < 'a , REG > = crate :: BitWriter < 'a , REG , ExtpadEn > ; impl < 'a , REG > ExtpadEnW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Настраиваемый ИОН"]
# [inline (always)]
pub fn calibrated_voltage_reference (self) -> & 'a mut crate :: W < REG > { self . variant (ExtpadEn :: CalibratedVoltageReference) } # [doc = "Внешний вывод REF_ADC_DAC (PORT1_11)"]
# [inline (always)]
pub fn ref_dac_pin (self) -> & 'a mut crate :: W < REG > { self . variant (ExtpadEn :: RefDacPin) } } # [doc = "Field `SEL` reader - Выбор канала АЦП"]
pub type SelR = crate :: FieldReader ; # [doc = "Field `SEL` writer - Выбор канала АЦП"]
pub type SelW < 'a , REG > = crate :: FieldWriter < 'a , REG , 3 > ; # [doc = "Field `SAH_TIME` reader - Время выборки очередного отсчета в тактах АЦП"]
pub type SahTimeR = crate :: FieldReader ; # [doc = "Field `SAH_TIME` writer - Время выборки очередного отсчета в тактах АЦП"]
pub type SahTimeW < 'a , REG > = crate :: FieldWriter < 'a , REG , 6 > ; impl R { # [doc = "Bit 0 - Управление питанием АЦП"]
# [inline (always)]
pub fn en (& self) -> EnR { EnR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Управление сбросом АЦП, активный уровень «0»"]
# [inline (always)]
pub fn resetn (& self) -> ResetnR { ResetnR :: new (((self . bits >> 1) & 1) != 0) } # [doc = "Bit 2 - Выбор источника опорного напряжения"]
# [inline (always)]
pub fn extref (& self) -> ExtrefR { ExtrefR :: new (((self . bits >> 2) & 1) != 0) } # [doc = "Bit 3 - Выбор источника внешнего опорного напряжения"]
# [inline (always)]
pub fn extpad_en (& self) -> ExtpadEnR { ExtpadEnR :: new (((self . bits >> 3) & 1) != 0) } # [doc = "Bits 4:6 - Выбор канала АЦП"]
# [inline (always)]
pub fn sel (& self) -> SelR { SelR :: new (((self . bits >> 4) & 7) as u8) } # [doc = "Bits 8:13 - Время выборки очередного отсчета в тактах АЦП"]
# [inline (always)]
pub fn sah_time (& self) -> SahTimeR { SahTimeR :: new (((self . bits >> 8) & 0x3f) as u8) } } impl W { # [doc = "Bit 0 - Управление питанием АЦП"]
# [inline (always)]
pub fn en (& mut self) -> EnW < AdcConfigSpec > { EnW :: new (self , 0) } # [doc = "Bit 1 - Управление сбросом АЦП, активный уровень «0»"]
# [inline (always)]
pub fn resetn (& mut self) -> ResetnW < AdcConfigSpec > { ResetnW :: new (self , 1) } # [doc = "Bit 2 - Выбор источника опорного напряжения"]
# [inline (always)]
pub fn extref (& mut self) -> ExtrefW < AdcConfigSpec > { ExtrefW :: new (self , 2) } # [doc = "Bit 3 - Выбор источника внешнего опорного напряжения"]
# [inline (always)]
pub fn extpad_en (& mut self) -> ExtpadEnW < AdcConfigSpec > { ExtpadEnW :: new (self , 3) } # [doc = "Bits 4:6 - Выбор канала АЦП"]
# [inline (always)]
pub fn sel (& mut self) -> SelW < AdcConfigSpec > { SelW :: new (self , 4) } # [doc = "Bits 8:13 - Время выборки очередного отсчета в тактах АЦП"]
# [inline (always)]
pub fn sah_time (& mut self) -> SahTimeW < AdcConfigSpec > { SahTimeW :: new (self , 8) } } # [doc = "Регистр настойки\n\nYou can [`read`](crate::Reg::read) this register and get [`adc_config::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc_config::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AdcConfigSpec ; impl crate :: RegisterSpec for AdcConfigSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`adc_config::R`](R) reader structure"]
impl crate :: Readable for AdcConfigSpec { } # [doc = "`write(|w| ..)` method takes [`adc_config::W`](W) writer structure"]
impl crate :: Writable for AdcConfigSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ADC_CONFIG to value 0"]
impl crate :: Resettable for AdcConfigSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ADC_CONTINUOUS (rw) register accessor: Управление непрерывным измерением\n\nYou can [`read`](crate::Reg::read) this register and get [`adc_continuous::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc_continuous::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc_continuous`]
module"]
# [doc (alias = "ADC_CONTINUOUS")]
pub type AdcContinuous = crate :: Reg < adc_continuous :: AdcContinuousSpec > ; # [doc = "Управление непрерывным измерением"]
pub mod adc_continuous { # [doc = "Register `ADC_CONTINUOUS` reader"]
pub type R = crate :: R < AdcContinuousSpec > ; # [doc = "Register `ADC_CONTINUOUS` writer"]
pub type W = crate :: W < AdcContinuousSpec > ; # [doc = "Field `CONTINUOUS` reader - Запуск / остановка непрерывного измерения"]
pub type ContinuousR = crate :: BitReader ; # [doc = "Field `CONTINUOUS` writer - Запуск / остановка непрерывного измерения"]
pub type ContinuousW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl R { # [doc = "Bit 0 - Запуск / остановка непрерывного измерения"]
# [inline (always)]
pub fn continuous (& self) -> ContinuousR { ContinuousR :: new ((self . bits & 1) != 0) } } impl W { # [doc = "Bit 0 - Запуск / остановка непрерывного измерения"]
# [inline (always)]
pub fn continuous (& mut self) -> ContinuousW < AdcContinuousSpec > { ContinuousW :: new (self , 0) } } # [doc = "Управление непрерывным измерением\n\nYou can [`read`](crate::Reg::read) this register and get [`adc_continuous::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc_continuous::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AdcContinuousSpec ; impl crate :: RegisterSpec for AdcContinuousSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`adc_continuous::R`](R) reader structure"]
impl crate :: Readable for AdcContinuousSpec { } # [doc = "`write(|w| ..)` method takes [`adc_continuous::W`](W) writer structure"]
impl crate :: Writable for AdcContinuousSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ADC_CONTINUOUS to value 0"]
impl crate :: Resettable for AdcContinuousSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ADC_SINGLE (w) register accessor: Управление однократным измерением\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc_single::W`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc_single`]
module"]
# [doc (alias = "ADC_SINGLE")]
pub type AdcSingle = crate :: Reg < adc_single :: AdcSingleSpec > ; # [doc = "Управление однократным измерением"]
pub mod adc_single { # [doc = "Register `ADC_SINGLE` writer"]
pub type W = crate :: W < AdcSingleSpec > ; # [doc = "Field `SINGLE` writer - Запуск однократного измерения"]
pub type SingleW < 'a , REG > = crate :: BitWriter < 'a , REG > ; impl W { # [doc = "Bit 0 - Запуск однократного измерения"]
# [inline (always)]
pub fn single (& mut self) -> SingleW < AdcSingleSpec > { SingleW :: new (self , 0) } } # [doc = "Управление однократным измерением\n\nYou can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`adc_single::W`](W). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AdcSingleSpec ; impl crate :: RegisterSpec for AdcSingleSpec { type Ux = u32 ; } # [doc = "`write(|w| ..)` method takes [`adc_single::W`](W) writer structure"]
impl crate :: Writable for AdcSingleSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets ADC_SINGLE to value 0"]
impl crate :: Resettable for AdcSingleSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ADC_VALID (r) register accessor: Регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`adc_valid::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc_valid`]
module"]
# [doc (alias = "ADC_VALID")]
pub type AdcValid = crate :: Reg < adc_valid :: AdcValidSpec > ; # [doc = "Регистр статуса"]
pub mod adc_valid { # [doc = "Register `ADC_VALID` reader"]
pub type R = crate :: R < AdcValidSpec > ; # [doc = "Field `VALID` reader - Признак наличия актуальных данных"]
pub type ValidR = crate :: BitReader ; impl R { # [doc = "Bit 0 - Признак наличия актуальных данных"]
# [inline (always)]
pub fn valid (& self) -> ValidR { ValidR :: new ((self . bits & 1) != 0) } } # [doc = "Регистр статуса\n\nYou can [`read`](crate::Reg::read) this register and get [`adc_valid::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AdcValidSpec ; impl crate :: RegisterSpec for AdcValidSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`adc_valid::R`](R) reader structure"]
impl crate :: Readable for AdcValidSpec { } # [doc = "`reset()` method sets ADC_VALID to value 0"]
impl crate :: Resettable for AdcValidSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "ADC_VALUE (r) register accessor: Регистр данных\n\nYou can [`read`](crate::Reg::read) this register and get [`adc_value::R`]. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@adc_value`]
module"]
# [doc (alias = "ADC_VALUE")]
pub type AdcValue = crate :: Reg < adc_value :: AdcValueSpec > ; # [doc = "Регистр данных"]
pub mod adc_value { # [doc = "Register `ADC_VALUE` reader"]
pub type R = crate :: R < AdcValueSpec > ; # [doc = "Field `VALUE` reader - Результат преобразования"]
pub type ValueR = crate :: FieldReader < u16 > ; impl R { # [doc = "Bits 0:11 - Результат преобразования"]
# [inline (always)]
pub fn value (& self) -> ValueR { ValueR :: new ((self . bits & 0x0fff) as u16) } } # [doc = "Регистр данных\n\nYou can [`read`](crate::Reg::read) this register and get [`adc_value::R`](R). See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct AdcValueSpec ; impl crate :: RegisterSpec for AdcValueSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`adc_value::R`](R) reader structure"]
impl crate :: Readable for AdcValueSpec { } # [doc = "`reset()` method sets ADC_VALUE to value 0"]
impl crate :: Resettable for AdcValueSpec { const RESET_VALUE : u32 = 0 ; } } } # [doc = "Регистры системного таймера"]
pub struct Scr1Timer { _marker : PhantomData < * const () > } unsafe impl Send for Scr1Timer { } impl Scr1Timer { # [doc = r"Pointer to the register block"]
pub const PTR : * const scr1_timer :: RegisterBlock = 0x0049_0000 as * const _ ; # [doc = r"Return the pointer to the register block"]
# [inline (always)]
pub const fn ptr () -> * const scr1_timer :: RegisterBlock { Self :: PTR } # [doc = r" Steal an instance of this peripheral"]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Ensure that the new instance of the peripheral cannot be used in a way"]
# [doc = r" that may race with any existing instances, for example by only"]
# [doc = r" accessing read-only or write-only registers, or by consuming the"]
# [doc = r" original peripheral and using critical sections to coordinate"]
# [doc = r" access between multiple new instances."]
# [doc = r""]
# [doc = r" Additionally, other software such as HALs may rely on only one"]
# [doc = r" peripheral instance existing to ensure memory safety; ensure"]
# [doc = r" no stolen instances are passed to such software."]
pub unsafe fn steal () -> Self { Self { _marker : PhantomData } } } impl Deref for Scr1Timer { type Target = scr1_timer :: RegisterBlock ; # [inline (always)]
fn deref (& self) -> & Self :: Target { unsafe { & * Self :: PTR } } } impl core :: fmt :: Debug for Scr1Timer { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { f . debug_struct ("Scr1Timer") . finish () } } # [doc = "Регистры системного таймера"]
pub mod scr1_timer { # [repr (C)]
# [doc = "Register block"]
pub struct RegisterBlock { timer_ctrl : TimerCtrl , timer_div : TimerDiv , mtime : Mtime , mtimeh : Mtimeh , mtimecmp : Mtimecmp , mtimecmph : Mtimecmph , } impl RegisterBlock { # [doc = "0x00 - Регистр конфигурации"]
# [inline (always)]
pub const fn timer_ctrl (& self) -> & TimerCtrl { & self . timer_ctrl } # [doc = "0x04 - Делитель частоты. Счет идет каждые DIV+1 такта частоты"]
# [inline (always)]
pub const fn timer_div (& self) -> & TimerDiv { & self . timer_div } # [doc = "0x08 - Счетчик таймера, младшее слово"]
# [inline (always)]
pub const fn mtime (& self) -> & Mtime { & self . mtime } # [doc = "0x0c - Счетчик таймера, старшее слово"]
# [inline (always)]
pub const fn mtimeh (& self) -> & Mtimeh { & self . mtimeh } # [doc = "0x10 - Регистр сравнения, младшее слово"]
# [inline (always)]
pub const fn mtimecmp (& self) -> & Mtimecmp { & self . mtimecmp } # [doc = "0x14 - Регистр сравнения, старшее слово"]
# [inline (always)]
pub const fn mtimecmph (& self) -> & Mtimecmph { & self . mtimecmph } } # [doc = "TIMER_CTRL (rw) register accessor: Регистр конфигурации\n\nYou can [`read`](crate::Reg::read) this register and get [`timer_ctrl::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timer_ctrl::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@timer_ctrl`]
module"]
# [doc (alias = "TIMER_CTRL")]
pub type TimerCtrl = crate :: Reg < timer_ctrl :: TimerCtrlSpec > ; # [doc = "Регистр конфигурации"]
pub mod timer_ctrl { # [doc = "Register `TIMER_CTRL` reader"]
pub type R = crate :: R < TimerCtrlSpec > ; # [doc = "Register `TIMER_CTRL` writer"]
pub type W = crate :: W < TimerCtrlSpec > ; # [doc = "Включение таймера\n\nValue on reset: 1"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Enable { # [doc = "0: Таймер выключен"]
Diasable = 0 , # [doc = "1: Таймер включен"]
Enable = 1 , } impl From < Enable > for bool { # [inline (always)]
fn from (variant : Enable) -> Self { variant as u8 != 0 } } # [doc = "Field `ENABLE` reader - Включение таймера"]
pub type EnableR = crate :: BitReader < Enable > ; impl EnableR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Enable { match self . bits { false => Enable :: Diasable , true => Enable :: Enable , } } # [doc = "Таймер выключен"]
# [inline (always)]
pub fn is_diasable (& self) -> bool { * self == Enable :: Diasable } # [doc = "Таймер включен"]
# [inline (always)]
pub fn is_enable (& self) -> bool { * self == Enable :: Enable } } # [doc = "Field `ENABLE` writer - Включение таймера"]
pub type EnableW < 'a , REG > = crate :: BitWriter < 'a , REG , Enable > ; impl < 'a , REG > EnableW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Таймер выключен"]
# [inline (always)]
pub fn diasable (self) -> & 'a mut crate :: W < REG > { self . variant (Enable :: Diasable) } # [doc = "Таймер включен"]
# [inline (always)]
pub fn enable (self) -> & 'a mut crate :: W < REG > { self . variant (Enable :: Enable) } } # [doc = "Источник тактрования системного таймера\n\nValue on reset: 0"]
# [derive (Clone , Copy , Debug , PartialEq , Eq)]
pub enum Clksrc { # [doc = "0: Тактирование ядра (частота шины AHB hclk)"]
Hclk = 0 , # [doc = "1: Внешний RTC (источник выбранный в PM.CPU_RTC_CLK_MUX)"]
ExternalClk = 1 , } impl From < Clksrc > for bool { # [inline (always)]
fn from (variant : Clksrc) -> Self { variant as u8 != 0 } } # [doc = "Field `CLKSRC` reader - Источник тактрования системного таймера"]
pub type ClksrcR = crate :: BitReader < Clksrc > ; impl ClksrcR { # [doc = "Get enumerated values variant"]
# [inline (always)]
pub const fn variant (& self) -> Clksrc { match self . bits { false => Clksrc :: Hclk , true => Clksrc :: ExternalClk , } } # [doc = "Тактирование ядра (частота шины AHB hclk)"]
# [inline (always)]
pub fn is_hclk (& self) -> bool { * self == Clksrc :: Hclk } # [doc = "Внешний RTC (источник выбранный в PM.CPU_RTC_CLK_MUX)"]
# [inline (always)]
pub fn is_external_clk (& self) -> bool { * self == Clksrc :: ExternalClk } } # [doc = "Field `CLKSRC` writer - Источник тактрования системного таймера"]
pub type ClksrcW < 'a , REG > = crate :: BitWriter < 'a , REG , Clksrc > ; impl < 'a , REG > ClksrcW < 'a , REG > where REG : crate :: Writable + crate :: RegisterSpec , { # [doc = "Тактирование ядра (частота шины AHB hclk)"]
# [inline (always)]
pub fn hclk (self) -> & 'a mut crate :: W < REG > { self . variant (Clksrc :: Hclk) } # [doc = "Внешний RTC (источник выбранный в PM.CPU_RTC_CLK_MUX)"]
# [inline (always)]
pub fn external_clk (self) -> & 'a mut crate :: W < REG > { self . variant (Clksrc :: ExternalClk) } } impl R { # [doc = "Bit 0 - Включение таймера"]
# [inline (always)]
pub fn enable (& self) -> EnableR { EnableR :: new ((self . bits & 1) != 0) } # [doc = "Bit 1 - Источник тактрования системного таймера"]
# [inline (always)]
pub fn clksrc (& self) -> ClksrcR { ClksrcR :: new (((self . bits >> 1) & 1) != 0) } } impl W { # [doc = "Bit 0 - Включение таймера"]
# [inline (always)]
pub fn enable (& mut self) -> EnableW < TimerCtrlSpec > { EnableW :: new (self , 0) } # [doc = "Bit 1 - Источник тактрования системного таймера"]
# [inline (always)]
pub fn clksrc (& mut self) -> ClksrcW < TimerCtrlSpec > { ClksrcW :: new (self , 1) } } # [doc = "Регистр конфигурации\n\nYou can [`read`](crate::Reg::read) this register and get [`timer_ctrl::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timer_ctrl::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TimerCtrlSpec ; impl crate :: RegisterSpec for TimerCtrlSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`timer_ctrl::R`](R) reader structure"]
impl crate :: Readable for TimerCtrlSpec { } # [doc = "`write(|w| ..)` method takes [`timer_ctrl::W`](W) writer structure"]
impl crate :: Writable for TimerCtrlSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TIMER_CTRL to value 0x01"]
impl crate :: Resettable for TimerCtrlSpec { const RESET_VALUE : u32 = 0x01 ; } } # [doc = "TIMER_DIV (rw) register accessor: Делитель частоты. Счет идет каждые DIV+1 такта частоты\n\nYou can [`read`](crate::Reg::read) this register and get [`timer_div::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timer_div::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@timer_div`]
module"]
# [doc (alias = "TIMER_DIV")]
pub type TimerDiv = crate :: Reg < timer_div :: TimerDivSpec > ; # [doc = "Делитель частоты. Счет идет каждые DIV+1 такта частоты"]
pub mod timer_div { # [doc = "Register `TIMER_DIV` reader"]
pub type R = crate :: R < TimerDivSpec > ; # [doc = "Register `TIMER_DIV` writer"]
pub type W = crate :: W < TimerDivSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Делитель частоты. Счет идет каждые DIV+1 такта частоты\n\nYou can [`read`](crate::Reg::read) this register and get [`timer_div::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`timer_div::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct TimerDivSpec ; impl crate :: RegisterSpec for TimerDivSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`timer_div::R`](R) reader structure"]
impl crate :: Readable for TimerDivSpec { } # [doc = "`write(|w| ..)` method takes [`timer_div::W`](W) writer structure"]
impl crate :: Writable for TimerDivSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets TIMER_DIV to value 0"]
impl crate :: Resettable for TimerDivSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MTIME (rw) register accessor: Счетчик таймера, младшее слово\n\nYou can [`read`](crate::Reg::read) this register and get [`mtime::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtime::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mtime`]
module"]
# [doc (alias = "MTIME")]
pub type Mtime = crate :: Reg < mtime :: MtimeSpec > ; # [doc = "Счетчик таймера, младшее слово"]
pub mod mtime { # [doc = "Register `MTIME` reader"]
pub type R = crate :: R < MtimeSpec > ; # [doc = "Register `MTIME` writer"]
pub type W = crate :: W < MtimeSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Счетчик таймера, младшее слово\n\nYou can [`read`](crate::Reg::read) this register and get [`mtime::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtime::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MtimeSpec ; impl crate :: RegisterSpec for MtimeSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mtime::R`](R) reader structure"]
impl crate :: Readable for MtimeSpec { } # [doc = "`write(|w| ..)` method takes [`mtime::W`](W) writer structure"]
impl crate :: Writable for MtimeSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MTIME to value 0"]
impl crate :: Resettable for MtimeSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MTIMEH (rw) register accessor: Счетчик таймера, старшее слово\n\nYou can [`read`](crate::Reg::read) this register and get [`mtimeh::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtimeh::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mtimeh`]
module"]
# [doc (alias = "MTIMEH")]
pub type Mtimeh = crate :: Reg < mtimeh :: MtimehSpec > ; # [doc = "Счетчик таймера, старшее слово"]
pub mod mtimeh { # [doc = "Register `MTIMEH` reader"]
pub type R = crate :: R < MtimehSpec > ; # [doc = "Register `MTIMEH` writer"]
pub type W = crate :: W < MtimehSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Счетчик таймера, старшее слово\n\nYou can [`read`](crate::Reg::read) this register and get [`mtimeh::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtimeh::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MtimehSpec ; impl crate :: RegisterSpec for MtimehSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mtimeh::R`](R) reader structure"]
impl crate :: Readable for MtimehSpec { } # [doc = "`write(|w| ..)` method takes [`mtimeh::W`](W) writer structure"]
impl crate :: Writable for MtimehSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MTIMEH to value 0"]
impl crate :: Resettable for MtimehSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MTIMECMP (rw) register accessor: Регистр сравнения, младшее слово\n\nYou can [`read`](crate::Reg::read) this register and get [`mtimecmp::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtimecmp::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mtimecmp`]
module"]
# [doc (alias = "MTIMECMP")]
pub type Mtimecmp = crate :: Reg < mtimecmp :: MtimecmpSpec > ; # [doc = "Регистр сравнения, младшее слово"]
pub mod mtimecmp { # [doc = "Register `MTIMECMP` reader"]
pub type R = crate :: R < MtimecmpSpec > ; # [doc = "Register `MTIMECMP` writer"]
pub type W = crate :: W < MtimecmpSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр сравнения, младшее слово\n\nYou can [`read`](crate::Reg::read) this register and get [`mtimecmp::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtimecmp::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MtimecmpSpec ; impl crate :: RegisterSpec for MtimecmpSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mtimecmp::R`](R) reader structure"]
impl crate :: Readable for MtimecmpSpec { } # [doc = "`write(|w| ..)` method takes [`mtimecmp::W`](W) writer structure"]
impl crate :: Writable for MtimecmpSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MTIMECMP to value 0"]
impl crate :: Resettable for MtimecmpSpec { const RESET_VALUE : u32 = 0 ; } } # [doc = "MTIMECMPH (rw) register accessor: Регистр сравнения, старшее слово\n\nYou can [`read`](crate::Reg::read) this register and get [`mtimecmph::R`]. You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtimecmph::W`]. You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api).\n\nFor information about available fields see [`mod@mtimecmph`]
module"]
# [doc (alias = "MTIMECMPH")]
pub type Mtimecmph = crate :: Reg < mtimecmph :: MtimecmphSpec > ; # [doc = "Регистр сравнения, старшее слово"]
pub mod mtimecmph { # [doc = "Register `MTIMECMPH` reader"]
pub type R = crate :: R < MtimecmphSpec > ; # [doc = "Register `MTIMECMPH` writer"]
pub type W = crate :: W < MtimecmphSpec > ; impl core :: fmt :: Debug for R { fn fmt (& self , f : & mut core :: fmt :: Formatter) -> core :: fmt :: Result { write ! (f , "{}" , self . bits ()) } } impl W { } # [doc = "Регистр сравнения, старшее слово\n\nYou can [`read`](crate::Reg::read) this register and get [`mtimecmph::R`](R). You can [`reset`](crate::Reg::reset), [`write`](crate::Reg::write), [`write_with_zero`](crate::Reg::write_with_zero) this register using [`mtimecmph::W`](W). You can also [`modify`](crate::Reg::modify) this register. See [API](https://docs.rs/svd2rust/#read--modify--write-api)."]
pub struct MtimecmphSpec ; impl crate :: RegisterSpec for MtimecmphSpec { type Ux = u32 ; } # [doc = "`read()` method returns [`mtimecmph::R`](R) reader structure"]
impl crate :: Readable for MtimecmphSpec { } # [doc = "`write(|w| ..)` method takes [`mtimecmph::W`](W) writer structure"]
impl crate :: Writable for MtimecmphSpec { type Safety = crate :: Unsafe ; const ZERO_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; const ONE_TO_MODIFY_FIELDS_BITMAP : u32 = 0 ; } # [doc = "`reset()` method sets MTIMECMPH to value 0"]
impl crate :: Resettable for MtimecmphSpec { const RESET_VALUE : u32 = 0 ; } } } # [no_mangle]
static mut DEVICE_PERIPHERALS : bool = false ; # [doc = r" All the peripherals."]
# [allow (non_snake_case)]
pub struct Peripherals { # [doc = "DMA"]
pub dma : Dma , # [doc = "PM"]
pub pm : Pm , # [doc = "EPIC"]
pub epic : Epic , # [doc = "TIMER32_0"]
pub timer32_0 : Timer32_0 , # [doc = "PVD_VCC"]
pub pvd_vcc : PvdVcc , # [doc = "PAD_CONFIG"]
pub pad_config : PadConfig , # [doc = "WDT_BUS"]
pub wdt_bus : WdtBus , # [doc = "OTP"]
pub otp : Otp , # [doc = "WakeUp"]
pub wake_up : WakeUp , # [doc = "RTC"]
pub rtc : Rtc , # [doc = "BOOT_MANAGER"]
pub boot_manager : BootManager , # [doc = "SPIFI_CONFIG"]
pub spifi_config : SpifiConfig , # [doc = "EEPROM_REGS"]
pub eeprom_regs : EepromRegs , # [doc = "CRYPTO"]
pub crypto : Crypto , # [doc = "CRC"]
pub crc : Crc , # [doc = "WDT"]
pub wdt : Wdt , # [doc = "USART_0"]
pub usart_0 : Usart0 , # [doc = "USART_1"]
pub usart_1 : Usart1 , # [doc = "TIMER16_0"]
pub timer16_0 : Timer16_0 , # [doc = "TIMER16_1"]
pub timer16_1 : Timer16_1 , # [doc = "TIMER16_2"]
pub timer16_2 : Timer16_2 , # [doc = "TIMER32_1"]
pub timer32_1 : Timer32_1 , # [doc = "TIMER32_2"]
pub timer32_2 : Timer32_2 , # [doc = "SPI_0"]
pub spi_0 : Spi0 , # [doc = "SPI_1"]
pub spi_1 : Spi1 , # [doc = "I2C_0"]
pub i2c_0 : I2c0 , # [doc = "I2C_1"]
pub i2c_1 : I2c1 , # [doc = "GPIO16_0"]
pub gpio16_0 : Gpio16_0 , # [doc = "GPIO16_1"]
pub gpio16_1 : Gpio16_1 , # [doc = "GPIO8_2"]
pub gpio8_2 : Gpio8_2 , # [doc = "GPIO_IRQ"]
pub gpio_irq : GpioIrq , # [doc = "DAC0"]
pub dac0 : Dac0 , # [doc = "DAC1"]
pub dac1 : Dac1 , # [doc = "PVD_AVCC"]
pub pvd_avcc : PvdAvcc , # [doc = "TSENS"]
pub tsens : Tsens , # [doc = "REFV_CONFIG"]
pub refv_config : RefvConfig , # [doc = "ADC"]
pub adc : Adc , # [doc = "SCR1_TIMER"]
pub scr1_timer : Scr1Timer , } impl Peripherals { # [doc = r" Returns all the peripherals *once*."]
# [cfg (feature = "critical-section")]
# [inline]
pub fn take () -> Option < Self > { critical_section :: with (| _ | { if unsafe { DEVICE_PERIPHERALS } { return None } Some (unsafe { Peripherals :: steal () }) }) } # [doc = r" Unchecked version of `Peripherals::take`."]
# [doc = r""]
# [doc = r" # Safety"]
# [doc = r""]
# [doc = r" Each of the returned peripherals must be used at most once."]
# [inline]
pub unsafe fn steal () -> Self { DEVICE_PERIPHERALS = true ; Peripherals { dma : Dma :: steal () , pm : Pm :: steal () , epic : Epic :: steal () , timer32_0 : Timer32_0 :: steal () , pvd_vcc : PvdVcc :: steal () , pad_config : PadConfig :: steal () , wdt_bus : WdtBus :: steal () , otp : Otp :: steal () , wake_up : WakeUp :: steal () , rtc : Rtc :: steal () , boot_manager : BootManager :: steal () , spifi_config : SpifiConfig :: steal () , eeprom_regs : EepromRegs :: steal () , crypto : Crypto :: steal () , crc : Crc :: steal () , wdt : Wdt :: steal () , usart_0 : Usart0 :: steal () , usart_1 : Usart1 :: steal () , timer16_0 : Timer16_0 :: steal () , timer16_1 : Timer16_1 :: steal () , timer16_2 : Timer16_2 :: steal () , timer32_1 : Timer32_1 :: steal () , timer32_2 : Timer32_2 :: steal () , spi_0 : Spi0 :: steal () , spi_1 : Spi1 :: steal () , i2c_0 : I2c0 :: steal () , i2c_1 : I2c1 :: steal () , gpio16_0 : Gpio16_0 :: steal () , gpio16_1 : Gpio16_1 :: steal () , gpio8_2 : Gpio8_2 :: steal () , gpio_irq : GpioIrq :: steal () , dac0 : Dac0 :: steal () , dac1 : Dac1 :: steal () , pvd_avcc : PvdAvcc :: steal () , tsens : Tsens :: steal () , refv_config : RefvConfig :: steal () , adc : Adc :: steal () , scr1_timer : Scr1Timer :: steal () , } } }